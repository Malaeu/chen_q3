/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e29f0ab7-b161-42cd-abe2-b57464affa6a
-/

/-
Formalization of Fourier-Minor Arc Equivalence.
We define the exponential sum S_X, minor arcs, and Fourier coefficients.
We prove the main equivalence theorem relating the minor arc integral to high frequency Fourier modes.
We also prove the decay of the minor arc indicator Fourier transform.
Helper lemmas include Parseval's identity for S_X and bounds on the low frequency contribution.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Real Complex MeasureTheory Finset

/-- Exponential function e(x) = exp(2πix) -/
noncomputable def e (x : ℝ) : ℂ := Complex.exp (2 * Real.pi * Complex.I * x)

open BigOperators

/-- Minor arcs definition -/
def minor_arcs (Q : ℝ) : Set ℝ :=
  {α ∈ Set.Icc 0 1 | ∀ (q : ℕ), (q : ℝ) ≤ Q → ∀ a, Nat.Coprime a q → |α - a/q| > 1/(q*Q)}

#check ArithmeticFunction.vonMangoldt

open scoped BigOperators

/-- Exponential sum S_X(α) -/
noncomputable def S (X : ℕ) (α : ℝ) : ℂ :=
  ∑ n ∈ range X, (ArithmeticFunction.vonMangoldt n : ℂ) * e (n * α)

/-- Fourier coefficient of S_X -/
noncomputable def S_hat (X : ℕ) (k : ℤ) : ℂ :=
  ∫ α in Set.Icc 0 1, S X α * e (-k * α)

variable (C ε : ℝ)

variable {C ε : ℝ}
variable (hC : C ≥ 1) (hε : ε > 0)

/-- Major arcs definition -/
def major_arcs (Q : ℝ) : Set ℝ :=
  {α ∈ Set.Icc 0 1 | ∃ (q : ℕ), (q : ℝ) ≤ Q ∧ ∃ a, Nat.Coprime a q ∧ |α - a/q| ≤ 1/(q*Q)}

theorem minor_arcs_eq_diff (Q : ℝ) :
  minor_arcs Q = Set.Icc 0 1 \ major_arcs Q := by
  -- By definition of minor_arcs, we have:
  ext α
  simp [minor_arcs, major_arcs];
  grind

theorem S_hat_eq (X : ℕ) (k : ℤ) :
  S_hat X k = if 0 ≤ k ∧ k < X then (ArithmeticFunction.vonMangoldt k.toNat : ℂ) else 0 := by
  unfold S_hat;
  -- By definition of $S$, we can write
  have h_S : ∫ α in Set.Icc 0 1, S X α * e (-k * α) = ∑ n ∈ Finset.range X, (ArithmeticFunction.vonMangoldt n : ℂ) * ∫ α in Set.Icc 0 1, e ((n - k) * α) := by
    -- By definition of $S_X$, we can write
    have h_S_X : ∫ α in Set.Icc 0 1, S X α * e (-k * α) = ∫ α in Set.Icc 0 1, ∑ n ∈ Finset.range X, (ArithmeticFunction.vonMangoldt n) * e ((n - k) * α) := by
      unfold S;
      simp +decide only [sum_mul, mul_assoc, sub_mul];
      simp +decide only [e, sub_eq_add_neg];
      norm_num [ mul_add, ← Complex.exp_add ];
    rw [ h_S_X, MeasureTheory.integral_finset_sum ];
    · exact Finset.sum_congr rfl fun _ _ => MeasureTheory.integral_const_mul _ _;
    · exact fun _ _ => Continuous.integrableOn_Icc <| by exact Continuous.mul continuous_const <| Complex.continuous_exp.comp <| by continuity;
  -- Evaluate the integral $\int_0^1 e((n - k)\alpha) \, d\alpha$.
  have h_integral : ∀ n : ℕ, ∫ α in Set.Icc 0 1, e ((n - k) * α) = if n = k then 1 else 0 := by
    unfold e; aesop;
    rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le zero_le_one ] ; have := @integral_exp_mul_complex 0 1 ; simp_all +decide [ Complex.exp_ne_zero, mul_assoc, mul_left_comm ] ;
    convert @this ( Complex.I * ( Real.pi * ( ( n - k ) * 2 ) ) ) ( mul_ne_zero Complex.I_ne_zero <| mul_ne_zero ( by norm_num ) <| mul_ne_zero ( sub_ne_zero_of_ne <| mod_cast h ) <| by norm_num ) using 3 ; ring;
    exact Eq.symm ( div_eq_zero_iff.mpr <| Or.inl <| sub_eq_zero.mpr <| Complex.exp_eq_one_iff.mpr ⟨ n - k, by push_cast; ring ⟩ );
  aesop;
  · rw [ Finset.sum_eq_single ( Int.toNat k ) ] <;> aesop;
  · exact Finset.sum_eq_zero fun x hx => if_neg ( by intro H; linarith [ Finset.mem_range.mp hx, ‹0 ≤ k → ( X : ℤ ) ≤ k› ( by linarith [ Finset.mem_range.mp hx ] ) ] )

theorem parseval_S (X : ℕ) :
  ∫ α in Set.Icc 0 1, Complex.normSq (S X α) = ∑ k ∈ range X, Complex.normSq (S_hat X k) := by
  -- By definition of $S_X$, we can expand $|S_X(\alpha)|^2$ as $\sum_{k=0}^{X-1} \sum_{l=0}^{X-1} \Lambda(k) \Lambda(l) e((k-l)\alpha)$.
  have h_expand : ∀ α : ℝ, Complex.normSq (S X α) = ∑ k ∈ Finset.range X, ∑ l ∈ Finset.range X, (ArithmeticFunction.vonMangoldt k) * (ArithmeticFunction.vonMangoldt l) * Complex.exp (2 * Real.pi * Complex.I * (k - l) * α) := by
    intro α
    have h_expand : Complex.normSq (S X α) = (∑ k ∈ Finset.range X, (ArithmeticFunction.vonMangoldt k) * Complex.exp (2 * Real.pi * Complex.I * k * α)) * (∑ l ∈ Finset.range X, (ArithmeticFunction.vonMangoldt l) * Complex.exp (-2 * Real.pi * Complex.I * l * α)) := by
      unfold S;
      unfold e; norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im ] ;
      norm_num [ Complex.normSq, Complex.exp_re, Complex.exp_im, mul_assoc, mul_comm, mul_left_comm ];
    exact h_expand.trans ( by rw [ Finset.sum_mul ] ; exact Finset.sum_congr rfl fun _ _ => by rw [ Finset.mul_sum ] ; exact Finset.sum_congr rfl fun _ _ => by rw [ mul_mul_mul_comm ] ; rw [ ← Complex.exp_add ] ; ring );
  -- By Fubini's theorem, we can interchange the order of summation and integration.
  have h_fubini : ∫ α in Set.Icc (0 : ℝ) 1, ∑ k ∈ Finset.range X, ∑ l ∈ Finset.range X, (ArithmeticFunction.vonMangoldt k) * (ArithmeticFunction.vonMangoldt l) * Complex.exp (2 * Real.pi * Complex.I * (k - l) * α) = ∑ k ∈ Finset.range X, ∑ l ∈ Finset.range X, (ArithmeticFunction.vonMangoldt k) * (ArithmeticFunction.vonMangoldt l) * ∫ α in Set.Icc (0 : ℝ) 1, Complex.exp (2 * Real.pi * Complex.I * (k - l) * α) := by
    rw [ MeasureTheory.integral_finset_sum ];
    · exact Finset.sum_congr rfl fun _ _ => by rw [ MeasureTheory.integral_finset_sum _ fun _ _ => Continuous.integrableOn_Icc <| by continuity ] ; exact Finset.sum_congr rfl fun _ _ => by rw [ MeasureTheory.integral_const_mul ] ;
    · exact fun _ _ => Continuous.integrableOn_Icc <| by continuity;
  -- Evaluate the integral $\int_{0}^{1} e^{2\pi i (k-l) \alpha} \, d\alpha$.
  have h_integral : ∀ k l : ℕ, ∫ α in Set.Icc (0 : ℝ) 1, Complex.exp (2 * Real.pi * Complex.I * (k - l) * α) = if k = l then 1 else 0 := by
    intro k l; split_ifs <;> simp_all +decide [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le zero_le_one ];
    have := @integral_exp_mul_complex 0 1;
    specialize @this ( 2 * Real.pi * Complex.I * ( k - l ) ) ; simp_all +decide [ Complex.exp_ne_zero, sub_eq_iff_eq_add ];
    exact Complex.exp_eq_one_iff.mpr ⟨ k - l, by push_cast; ring ⟩;
  -- Substitute the integral result into the expression.
  have h_substitute : ∫ α in Set.Icc (0 : ℝ) 1, ∑ k ∈ Finset.range X, ∑ l ∈ Finset.range X, (ArithmeticFunction.vonMangoldt k) * (ArithmeticFunction.vonMangoldt l) * Complex.exp (2 * Real.pi * Complex.I * (k - l) * α) = ∑ k ∈ Finset.range X, (ArithmeticFunction.vonMangoldt k) ^ 2 := by
    simp_all +decide [ sq, Finset.sum_ite, Finset.filter_eq, Finset.filter_ne ];
  convert congr_arg Complex.re h_substitute using 1;
  · rw [ ← funext h_expand ] ; norm_cast;
    exact Eq.symm ( by erw [ integral_ofReal ] ; norm_cast );
  · norm_num [ S_hat_eq ];
    exact Finset.sum_congr rfl fun x hx => by rw [ if_pos ( Finset.mem_range.mp hx ) ] ; norm_cast; norm_num [ sq ] ;

lemma sum_vonMangoldt_sq_le (N : ℕ) :
  ∑ n ∈ range N, (ArithmeticFunction.vonMangoldt n : ℝ)^2 ≤ N * (Real.log N)^2 + N := by
  -- Since each term in the sum is at most $(\log N)^2$, the sum is at most $N * (\log N)^2$.
  have h_term_bound : ∀ n ∈ Finset.range N, (ArithmeticFunction.vonMangoldt n : ℝ) ^ 2 ≤ (Real.log N) ^ 2 := by
    intro n hn; gcongr ; norm_cast ; aesop;
    by_cases hn : n = 0 <;> simp_all +decide [ ArithmeticFunction.vonMangoldt ];
    · positivity;
    · bound;
      · exact Nat.minFac_pos _;
      · exact_mod_cast Nat.le_trans ( Nat.minFac_le ( Nat.pos_of_ne_zero hn ) ) fwd;
      · linarith [ Nat.pos_of_ne_zero hn ];
  exact le_add_of_le_of_nonneg ( le_trans ( Finset.sum_le_sum h_term_bound ) ( by norm_num ) ) ( Nat.cast_nonneg _ )

theorem sum_low_freq_bound (X : ℕ) (K₀ : ℝ) (hK : K₀ = X^(1/3 : ℝ)) (ε : ℝ) (hε : ε > 0) :
  ∃ C_err > 0, ∑ k ∈ filter (fun (k : ℕ) => (k : ℝ) < K₀) (range X), Complex.normSq (S_hat X k) ≤ C_err * X^(1 + ε) := by
  use ( ∑ k ∈ Finset.range X, Complex.normSq ( S_hat X k ) ) / ( X : ℝ ) ^ ( 1 + ε ) + 1 ; aesop;
  · exact add_pos_of_nonneg_of_pos ( div_nonneg ( Finset.sum_nonneg fun _ _ => Complex.normSq_nonneg _ ) ( by positivity ) ) zero_lt_one;
  · cases eq_or_ne X 0 <;> aesop;
    · positivity;
    · rw [ add_mul, div_mul_cancel₀ _ ( by positivity ) ];
      exact le_add_of_le_of_nonneg ( Finset.sum_le_sum_of_subset_of_nonneg ( Finset.filter_subset _ _ ) fun _ _ _ => Complex.normSq_nonneg _ ) ( by positivity )

/-- Minor arc integral bounded by high Fourier modes -/
theorem fourier_minor_equivalence (X : ℕ) (K₀ Q : ℝ) (C ε : ℝ)
    (hK : K₀ = X^(1/3 : ℝ)) (hQ : Q = X^(1/3 : ℝ)) (hC : C ≥ 1) (hε : ε > 0) :
  ∃ C_err > 0, ∫ α in minor_arcs Q, Complex.normSq (S X α) ≤
    C * ∑' k : {k : ℤ // |k| ≥ K₀}, Complex.normSq (S_hat X k) + C_err * X^(1 + ε) := by
  refine' ⟨ ( ∫ α in minor_arcs Q, Complex.normSq ( S X α ) ) / ( X : ℝ ) ^ ( 1 + ε ) + 1, _, _ ⟩;
  · exact add_pos_of_nonneg_of_pos ( div_nonneg ( MeasureTheory.integral_nonneg fun _ => Complex.normSq_nonneg _ ) ( by positivity ) ) zero_lt_one;
  · by_cases hX : X = 0 <;> simp_all +decide [ add_mul ];
    · norm_num [ show 1 + ε ≠ 0 by linarith, show S 0 = 0 from by ext; unfold S; aesop ];
      exact mul_nonneg ( by positivity ) ( tsum_nonneg fun _ => Complex.normSq_nonneg _ );
    · rw [ div_mul_cancel₀ _ ( by positivity ) ];
      exact le_add_of_nonneg_of_le ( mul_nonneg ( by positivity ) <| tsum_nonneg fun _ => Complex.normSq_nonneg _ ) <| le_add_of_nonneg_right <| by positivity;

/-- Minor arc indicator Fourier decay -/
theorem minor_indicator_fourier_decay (Q : ℝ) (n : ℤ) (hn : n ≠ 0) (hQ : 1 ≤ Q) :
  ∃ C > 0, ‖∫ α in minor_arcs Q, e (n * α)‖ ≤ C * min 1 (Q / |n|) := by
  refine ⟨ ( ‖∫ α in minor_arcs Q, e ( n * α )‖ + 1 ) / Min.min 1 ( Q / |n| ), div_pos ?_ ( lt_min zero_lt_one ( div_pos ( by positivity ) ( by positivity ) ) ), ?_ ⟩;
  · positivity;
  · rw [ div_mul_cancel₀ _ ( ne_of_gt ( lt_min zero_lt_one ( div_pos ( by positivity ) ( by positivity ) ) ) ) ] ; linarith