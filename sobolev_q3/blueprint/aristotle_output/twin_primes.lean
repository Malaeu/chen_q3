/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 3c6efbd9-876c-4355-809f-67c7594e8d05
-/

/-
We have formalized the Master Inequality for the twin prime energy functional.
The main result is `master_inequality`, which establishes that the twin prime integral is bounded below by `(c - Îµ) * X` under the assumptions that the Drift dominates the Noise (`c > Îµ`), the Drift is at least `c * X`, and the Noise is at most `Îµ * X`.
Note: The proof requires the additional assumptions that the test function `Î¨` is supported on `[0,1]` (consistent with the Circle Method context) and that the relevant integral is well-defined. These were added as hypotheses to the theorem.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-- Character e(nÎ±) = exp(2Ï€inÎ±) -/
noncomputable def circleChar (n : â„¤) (Î± : â„) : â„‚ :=
  Complex.exp (2 * Real.pi * Complex.I * n * Î±)

/-- Exponential sum S(Î±) = Î£_{pâ‰¤X} Î›(p)Â·e(pÎ±) -/
noncomputable def primeExpSum (X : â„•) (Î± : â„) : â„‚ :=
  âˆ‘ p âˆˆ (Finset.range X).filter Nat.Prime,
    (Real.log p : â„‚) * circleChar p Î±

/-- Squared modulus |S(Î±)|Â² -/
noncomputable def primeExpSumSq (X : â„•) (Î± : â„) : â„ :=
  Complex.normSq (primeExpSum X Î±)

/-- Major Arcs ð”: neighborhoods of rationals a/q with small q -/
def MajorArcs (X Q : â„•) : Set â„ :=
  â‹ƒ (q : â„•) (hq : q â‰¤ Q) (a : â„•) (ha : Nat.Coprime a q),
    Set.Icc ((a : â„)/q - (Q : â„)/(q*X)) ((a : â„)/q + (Q : â„)/(q*X))

/-- Minor Arcs ð”ª: complement of Major Arcs -/
def MinorArcs (X Q : â„•) : Set â„ :=
  Set.Icc 0 1 \ MajorArcs X Q

/-- Twin prime integral: I(Î¨; X) = âˆ« Î¨(Î±)Â·|S(Î±)|Â² dÎ± -/
noncomputable def twinIntegral (Î¨ : â„ â†’ â„) (X : â„•) : â„ :=
  âˆ« Î± in Set.Icc 0 1, Î¨ Î± * primeExpSumSq X Î±

/-- Drift: Major Arc contribution -/
noncomputable def Drift (Î¨ : â„ â†’ â„) (X Q : â„•) : â„ :=
  âˆ« Î± in MajorArcs X Q, Î¨ Î± * primeExpSumSq X Î±

/-- Noise: Minor Arc contribution (absolute value) -/
noncomputable def Noise (Î¨ : â„ â†’ â„) (X Q : â„•) : â„ :=
  |âˆ« Î± in MinorArcs X Q, Î¨ Î± * primeExpSumSq X Î±|

/-- Twin prime singular series ð”–â‚‚ â‰ˆ 1.32 -/
noncomputable def singularSeries : â„ := 1.32

lemma singularSeries_pos : singularSeries > 0 := by
  -- The singular series is defined as 1.32, which is clearly positive.
  norm_num [singularSeries]

/-
The set of Major Arcs is measurable.
-/
lemma MajorArcs_measurable (X Q : â„•) : MeasurableSet (MajorArcs X Q) := by
  exact MeasurableSet.iUnion fun q => MeasurableSet.iUnion fun hq => MeasurableSet.iUnion fun a => MeasurableSet.iUnion fun ha => measurableSet_Icc

/-
The set of Minor Arcs is measurable.
-/
lemma MinorArcs_measurable (X Q : â„•) : MeasurableSet (MinorArcs X Q) := by
  exact MeasurableSet.diff ( measurableSet_Icc ) ( MajorArcs_measurable X Q )

/-
Minor Arcs are contained in the interval [0,1].
-/
lemma MinorArcs_subset (X Q : â„•) : MinorArcs X Q âŠ† Set.Icc 0 1 := by
  -- By definition of MinorArcs, it is a subset of Set.Icc 0 1.
  simp [MinorArcs];
  exact?

/-
The union of Major Arcs (restricted to [0,1]) and Minor Arcs is exactly [0,1].
-/
lemma union_arcs (X Q : â„•) : (MajorArcs X Q âˆ© Set.Icc 0 1) âˆª MinorArcs X Q = Set.Icc 0 1 := by
  ext Î± ; by_cases h : Î± âˆˆ MajorArcs X Q <;> aesop;
  Â· exact a.1.1;
  Â· exact a.1.2;
  Â· exact a.1.1;
  Â· exact a.1.2;
  Â· exact âŸ¨ âŸ¨ left, right âŸ©, h âŸ©

/-
Major Arcs (restricted to [0,1]) and Minor Arcs are disjoint.
-/
lemma disjoint_arcs (X Q : â„•) : Disjoint (MajorArcs X Q âˆ© Set.Icc 0 1) (MinorArcs X Q) := by
  exact Set.disjoint_left.mpr fun x hxâ‚ hxâ‚‚ => hxâ‚‚.2 hxâ‚.1

/-
The twin prime integral over [0,1] splits into the sum of the integral over Major Arcs (intersected with [0,1]) and the integral over Minor Arcs.
-/
lemma integral_split (Î¨ : â„ â†’ â„) (X Q : â„•) (h_int : MeasureTheory.IntegrableOn (fun Î± => Î¨ Î± * primeExpSumSq X Î±) (Set.Icc 0 1)) :
    twinIntegral Î¨ X = (âˆ« Î± in MajorArcs X Q âˆ© Set.Icc 0 1, Î¨ Î± * primeExpSumSq X Î±) + âˆ« Î± in MinorArcs X Q, Î¨ Î± * primeExpSumSq X Î± := by
  rw [ â† MeasureTheory.setIntegral_union ];
  Â· rw [ union_arcs ];
    rfl;
  Â· exact?;
  Â· exact?;
  Â· exact h_int.mono_set fun x hx => hx.2;
  Â· exact h_int.mono_set <| MinorArcs_subset X Q

/-
If Î¨ is supported on [0,1], Drift is the integral over Major Arcs intersected with [0,1].
-/
lemma Drift_eq_restricted (Î¨ : â„ â†’ â„) (X Q : â„•) (h_supp : Function.support Î¨ âŠ† Set.Icc 0 1) :
    Drift Î¨ X Q = âˆ« Î± in MajorArcs X Q âˆ© Set.Icc 0 1, Î¨ Î± * primeExpSumSq X Î± := by
  -- Since the support of Î¨ is contained in the interval [0,1], the integral over the major arcs is equal to the integral over the major arcs intersected with [0,1].
  have h_free_support : âˆ€ Î±, Î± âˆˆ MajorArcs X Q â†’ Î± âˆ‰ Set.Icc 0 1 â†’ Î¨ Î± = 0 := by
    exact fun Î± hÎ± hÎ±' => Classical.not_not.1 fun h => hÎ±' <| h_supp h;
  rw [ â† MeasureTheory.integral_indicator ];
  Â· rw [ Drift ];
    rw [ â† MeasureTheory.integral_indicator ] <;> norm_num [ Set.indicator ];
    Â· congr with x ; aesop;
    Â· exact?;
  Â· exact MeasurableSet.inter ( MajorArcs_measurable X Q ) measurableSet_Icc

/-
The Master Inequality holds under the additional assumptions that Î¨ is supported on [0,1] and the integral is well-defined.
-/
theorem master_inequality_corrected (Î¨ : â„ â†’ â„) (X Q : â„•) (c Îµ : â„)
    (hc : c > 0) (hÎµ : Îµ â‰¥ 0) (hcÎµ : c > Îµ)
    (hDrift : Drift Î¨ X Q â‰¥ c * X)
    (hNoise : Noise Î¨ X Q â‰¤ Îµ * X)
    (h_supp : Function.support Î¨ âŠ† Set.Icc 0 1)
    (h_int : MeasureTheory.IntegrableOn (fun Î± => Î¨ Î± * primeExpSumSq X Î±) (Set.Icc 0 1)) :
    twinIntegral Î¨ X â‰¥ (c - Îµ) * X := by
  rw [integral_split Î¨ X Q h_int]
  rw [â† Drift_eq_restricted Î¨ X Q h_supp]
  have h_noise_bound : âˆ« Î± in MinorArcs X Q, Î¨ Î± * primeExpSumSq X Î± â‰¥ - Noise Î¨ X Q := by
    rw [Noise]
    exact neg_le_of_abs_le (le_refl _)
  linarith [hDrift, hNoise, h_noise_bound]

/-
The Master Inequality (with necessary support and integrability assumptions).
-/
/-- THE MASTER INEQUALITY

If:
  (1) Drift â‰¥ cÂ·X  (Major Arc contribution is linear)
  (2) Noise â‰¤ ÎµÂ·X  (Minor Arc contribution is sublinear, via Sobolev)
  (3) Î¨ is supported on [0,1] (Implicit in Circle Method context)
  (4) Integrability holds

Then:
  Total = Drift - Noise â‰¥ (c - Îµ)Â·X

When c > Îµ (Drift dominates Noise), the integral grows linearly.
For twin primes with Î¨ = Î¨_drift: c = ð”–â‚‚ â‰ˆ 1.32, Îµ = o(1).
Result: I(Î¨; X) â‰¥ ð”–â‚‚/2 Â· X â†’ âˆž
-/
theorem master_inequality (Î¨ : â„ â†’ â„) (X Q : â„•) (c Îµ : â„)
    (hc : c > 0) (hÎµ : Îµ â‰¥ 0) (hcÎµ : c > Îµ)
    (hDrift : Drift Î¨ X Q â‰¥ c * X)
    (hNoise : Noise Î¨ X Q â‰¤ Îµ * X)
    (h_supp : Function.support Î¨ âŠ† Set.Icc 0 1)
    (h_int : MeasureTheory.IntegrableOn (fun Î± => Î¨ Î± * primeExpSumSq X Î±) (Set.Icc 0 1)) :
    twinIntegral Î¨ X â‰¥ (c - Îµ) * X := by
  exact master_inequality_corrected Î¨ X Q c Îµ hc hÎµ hcÎµ hDrift hNoise h_supp h_int