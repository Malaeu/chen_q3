/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 0177ab41-ad0c-400b-88cc-5db1f113bc96

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Checking if EuclideanSpace is available.
-/
#check EuclideanSpace

/-
Definitions for Navier-Stokes on the torus.
-/
open Real MeasureTheory Set Function

abbrev Point := Fin 3 → ℝ
abbrev Velocity := Fin 3 → ℝ

-- Helper for partial derivative
-- ∂f/∂x_i at x
noncomputable def partialDeriv (i : Fin 3) (f : Point → ℝ) (x : Point) : ℝ :=
  deriv (fun s => f (x + Pi.single i s)) 0

-- Helper for divergence
noncomputable def divergence (u : Point → Velocity) (x : Point) : ℝ :=
  ∑ i, partialDeriv i (fun y => u y i) x

-- Helper for Laplacian of scalar
noncomputable def laplacian_scalar (f : Point → ℝ) (x : Point) : ℝ :=
  ∑ i, partialDeriv i (fun y => partialDeriv i f y) x

-- Helper for Laplacian of vector
noncomputable def laplacian_vector (u : Point → Velocity) (x : Point) : Velocity :=
  fun k => laplacian_scalar (fun y => u y k) x

-- Helper for advection (u · ∇) u
noncomputable def advection (u : Point → Velocity) (x : Point) : Velocity :=
  fun k => ∑ j, (u x j) * partialDeriv j (fun y => u y k) x

-- Periodicity condition
def IsPeriodic (u : Point → Velocity) : Prop :=
  ∀ (x : Point) (i : Fin 3), u (x + Pi.single i 1) = u x

-- Integral over the torus [0,1]³
noncomputable def TorusIntegral (f : Point → ℝ) : ℝ :=
  ∫ x in Icc (0 : Point) (fun _ => 1), f x

-- Kinetic Energy
noncomputable def KineticEnergy (u : Point → Velocity) : ℝ :=
  (1/2) * TorusIntegral (fun x => ∑ i, (u x i)^2)

-- Enstrophy
-- ε(t) = ∫ |∇u|² dx = ∫ ∑_{i,j} |∂_j u_i|² dx
noncomputable def Enstrophy (u : Point → Velocity) : ℝ :=
  TorusIntegral (fun x => ∑ i : Fin 3, ∑ j : Fin 3, (partialDeriv j (fun y => u y i) x)^2)

structure IsNavierStokesSolution (u : ℝ → Point → Velocity) (ν : ℝ) : Prop where
  smooth : ContDiff ℝ ⊤ (uncurry u)
  periodic : ∀ t, IsPeriodic (u t)
  div_free : ∀ t x, divergence (u t) x = 0
  momentum : ∃ p : ℝ → Point → ℝ,
      (∀ t, IsPeriodic (fun x => (fun _ => p t x))) ∧
      ∀ t x,
        deriv (fun s => u s x) t =
          (fun i => - partialDeriv i (p t) x) +
          ν • laplacian_vector (u t) x -
          advection (u t) x

/-
The integral of the derivative of a periodic function on [0,1] is zero.
-/
lemma integral_deriv_periodic_zero (g : ℝ → ℝ) (h_diff : ContDiff ℝ 1 g) (h_per : g 1 = g 0) :
    ∫ x in (0 : ℝ)..1, deriv g x = 0 := by
  erw [ intervalIntegral.integral_deriv_eq_sub ] ; aesop;
  · exact fun x hx => ( h_diff.differentiable le_rfl ) x;
  · exact ( h_diff.continuous_deriv le_rfl |> Continuous.intervalIntegrable ) _ _

/-
The integral over the torus can be split into an integral over one coordinate and the rest.
-/
open Real MeasureTheory Set Function

lemma torus_integral_split_i (f : Point → ℝ) (i : Fin 3) (hf : IntegrableOn f (Icc 0 1)) :
    TorusIntegral f = ∫ t in (0:ℝ)..1, ∫ y in Icc (0 : Fin 2 → ℝ) 1, f (i.insertNth t y) := by
  -- By definition of the integral over the torus, we can write it as an iterated integral.
  have h_iterated : ∫ x in (Set.Icc 0 1 : Set (Fin 3 → ℝ)), f x = ∫ t in (Set.Icc (0 : ℝ) 1), ∫ y in (Set.Icc (0 : Fin 2 → ℝ) 1), f (Fin.insertNth i t y) := by
    have h_prod : ∫ x in (Set.Icc (0 : Fin 3 → ℝ) (fun _ => 1)), f x = ∫ t in (Set.Icc (0 : ℝ) 1), ∫ y in (Set.Icc (0 : Fin 2 → ℝ) (fun _ => 1)), f (i.insertNth t y) := by
      have h_measure : (MeasureTheory.volume : MeasureTheory.Measure (Fin 3 → ℝ)) = MeasureTheory.Measure.map (fun p : ℝ × (Fin 2 → ℝ) => i.insertNth p.1 p.2) (MeasureTheory.volume.prod MeasureTheory.volume) := by
        refine' MeasureTheory.Measure.pi_eq _;
        intro s hs; erw [ MeasureTheory.Measure.map_apply ];
        · fin_cases i <;> simp +decide [ Fin.prod_univ_three, Set.preimage ];
          · simp +decide [ Fin.forall_fin_succ, Set.setOf_and ];
            erw [ show { a : ℝ × ( Fin 2 → ℝ ) | a.1 ∈ s 0 } ∩ ( { a : ℝ × ( Fin 2 → ℝ ) | a.2 0 ∈ s 1 } ∩ { a : ℝ × ( Fin 2 → ℝ ) | a.2 1 ∈ s 2 } ) = ( s 0 ×ˢ { a : Fin 2 → ℝ | a 0 ∈ s 1 ∧ a 1 ∈ s 2 } ) by ext ; aesop ] ; erw [ MeasureTheory.Measure.prod_prod ] ; ring;
            erw [ show { a : Fin 2 → ℝ | a 0 ∈ s 1 ∧ a 1 ∈ s 2 } = ( Set.pi Set.univ fun i : Fin 2 => if i = 0 then s 1 else s 2 ) by ext; simp +decide [ Fin.forall_fin_two ] ] ; erw [ MeasureTheory.Measure.pi_pi ] ; simp +decide [ mul_assoc ];
          · simp +decide [ Fin.forall_fin_succ, Fin.insertNth ];
            erw [ show { x : ℝ × ( Fin 2 → ℝ ) | x.2 0 ∈ s 0 ∧ x.1 ∈ s 1 ∧ x.2 1 ∈ s 2 } = ( s 1 ) ×ˢ { x : Fin 2 → ℝ | x 0 ∈ s 0 ∧ x 1 ∈ s 2 } by ext ; aesop ] ; erw [ MeasureTheory.Measure.prod_prod ] ; ring;
            erw [ show { x : Fin 2 → ℝ | x 0 ∈ s 0 ∧ x 1 ∈ s 2 } = ( Set.pi Set.univ fun i : Fin 2 => if i = 0 then s 0 else s 2 ) by ext; simp +decide [ Fin.forall_fin_two ] ] ; erw [ MeasureTheory.Measure.pi_pi ] ; simp +decide [ mul_assoc ];
          · simp +decide [ Fin.forall_fin_succ, Fin.insertNth ];
            erw [ show { x : ℝ × ( Fin 2 → ℝ ) | x.2 0 ∈ s 0 ∧ x.2 1 ∈ s 1 ∧ x.1 ∈ s 2 } = ( s 2 ) ×ˢ ( { x : Fin 2 → ℝ | x 0 ∈ s 0 ∧ x 1 ∈ s 1 } ) by ext ; aesop ] ; erw [ MeasureTheory.Measure.prod_prod ] ; ring;
            erw [ show { x : Fin 2 → ℝ | x 0 ∈ s 0 ∧ x 1 ∈ s 1 } = ( Set.pi Set.univ fun i : Fin 2 => if i = 0 then s 0 else s 1 ) by ext; simp +decide [ Fin.forall_fin_two ] ] ; erw [ MeasureTheory.Measure.pi_pi ] ; simp +decide [ mul_assoc ];
        · refine' measurable_pi_iff.mpr _;
          intro a; fin_cases a <;> simp +decide [ Fin.insertNth ] ;
          · fin_cases i <;> simp +decide [ Fin.succAboveCases ] <;> measurability;
          · fin_cases i <;> simp +decide [ Fin.succAboveCases ];
            · exact measurable_pi_apply 0 |> Measurable.comp <| measurable_snd;
            · exact measurable_fst;
            · exact measurable_pi_apply _ |> Measurable.comp <| measurable_snd;
          · fin_cases i <;> simp +decide [ Fin.succAboveCases ];
            · exact measurable_pi_apply _ |> Measurable.comp <| measurable_snd;
            · exact measurable_pi_apply _ |> Measurable.comp <| measurable_snd;
            · exact measurable_fst;
        · exact MeasurableSet.univ_pi hs
      have h_integral_def : ∫ x in (Set.Icc (0 : Fin 3 → ℝ) (fun _ => 1)), f x = ∫ p in (Set.Icc (0 : ℝ) 1 ×ˢ Set.Icc (0 : Fin 2 → ℝ) (fun _ => 1)), f (i.insertNth p.1 p.2) := by
        rw [ ← MeasureTheory.integral_indicator, ← MeasureTheory.integral_indicator ];
        · rw [ h_measure, MeasureTheory.integral_map ];
          · norm_num [ Set.indicator ];
            congr with x ; simp +decide [ Pi.le_def, forall_and ];
            simp +decide [ Prod.le_def, Fin.forall_fin_succ ];
            fin_cases i <;> simp +decide [ Pi.le_def ];
            · rfl;
            · simp +decide [ Fin.insertNth ];
              simp +decide [ Fin.succAboveCases ];
              grind;
            · simp +decide [ Fin.insertNth ];
              simp +decide [ Fin.succAboveCases ];
              grind;
          · refine' Measurable.aemeasurable _;
            refine' measurable_pi_iff.mpr _;
            intro a; fin_cases a <;> simp +decide [ Fin.insertNth ] ;
            · fin_cases i <;> simp +decide [ Fin.succAboveCases ];
              · exact measurable_fst;
              · exact measurable_pi_apply 0 |> Measurable.comp <| measurable_snd;
              · exact measurable_pi_apply 0 |> Measurable.comp <| measurable_snd;
            · fin_cases i <;> simp +decide [ Fin.succAboveCases ];
              · exact measurable_pi_apply 0 |> Measurable.comp <| measurable_snd;
              · exact measurable_fst;
              · exact measurable_pi_apply _ |> Measurable.comp <| measurable_snd;
            · fin_cases i <;> simp +decide [ Fin.succAboveCases ] <;> measurability;
          · refine' MeasureTheory.Integrable.aestronglyMeasurable _;
            rw [ MeasureTheory.integrable_indicator_iff ] <;> aesop;
        · exact measurableSet_Icc.prod measurableSet_Icc;
        · exact measurableSet_Icc;
      erw [ h_integral_def, MeasureTheory.setIntegral_prod ];
      have h_integrable : MeasureTheory.IntegrableOn (fun p : ℝ × (Fin 2 → ℝ) => f (i.insertNth p.1 p.2)) (Set.Icc (0 : ℝ) 1 ×ˢ Set.Icc (0 : Fin 2 → ℝ) (fun _ => 1)) (MeasureTheory.Measure.prod MeasureTheory.volume MeasureTheory.volume) := by
        have h_integrable : MeasureTheory.IntegrableOn f (Set.Icc (0 : Fin 3 → ℝ) (fun _ => 1)) MeasureTheory.volume := by
          exact hf
        rw [ h_measure ] at h_integrable;
        rw [ MeasureTheory.IntegrableOn, MeasureTheory.Measure.restrict_map ] at *;
        · rw [ MeasureTheory.integrable_map_measure ] at h_integrable;
          · refine' h_integrable.mono_measure _;
            refine' MeasureTheory.Measure.restrict_mono _ le_rfl;
            intro p hp; simp +decide [ Fin.insertNth ] at hp ⊢; aesop;
            · intro j; fin_cases i <;> fin_cases j <;> simp +decide [ * ] <;> aesop
            · intro x; fin_cases i <;> fin_cases x <;> simp +decide [ * ] ;
              all_goals exact right _;
          · exact h_integrable.1;
          · refine' Measurable.aemeasurable _;
            refine' measurable_pi_iff.mpr _;
            intro a; fin_cases a <;> simp +decide [ Fin.insertNth ] ;
            · fin_cases i <;> simp +decide [ Fin.succAboveCases ];
              · exact measurable_fst;
              · exact measurable_pi_apply 0 |> Measurable.comp <| measurable_snd;
              · exact measurable_pi_apply 0 |> Measurable.comp <| measurable_snd;
            · fin_cases i <;> simp +decide [ Fin.succAboveCases ];
              · exact measurable_pi_apply 0 |> Measurable.comp <| measurable_snd;
              · exact measurable_fst;
              · exact measurable_pi_apply 1 |> Measurable.comp <| measurable_snd;
            · fin_cases i <;> simp +decide [ Fin.succAboveCases ];
              · exact measurable_pi_apply 1 |> Measurable.comp <| measurable_snd;
              · exact measurable_pi_apply 1 |> Measurable.comp <| measurable_snd;
              · exact measurable_fst;
        · refine' measurable_pi_iff.mpr _;
          intro a; fin_cases a <;> simp +decide [ Fin.insertNth ] ;
          · fin_cases i <;> simp +decide [ Fin.succAboveCases ];
            · exact measurable_fst;
            · exact measurable_pi_apply 0 |> Measurable.comp <| measurable_snd;
            · exact measurable_pi_apply 0 |> Measurable.comp <| measurable_snd;
          · fin_cases i <;> simp +decide [ Fin.succAboveCases ];
            · exact measurable_pi_apply 0 |> Measurable.comp <| measurable_snd;
            · exact measurable_fst;
            · exact measurable_pi_apply _ |> Measurable.comp <| measurable_snd;
          · fin_cases i <;> simp +decide [ Fin.succAboveCases ];
            · exact measurable_pi_apply _ |> Measurable.comp <| measurable_snd;
            · exact measurable_pi_apply _ |> Measurable.comp <| measurable_snd;
            · exact measurable_fst;
        · exact measurableSet_Icc;
      convert h_integrable using 1;
    convert h_prod using 1;
  simp_all +decide [ intervalIntegral.integral_of_le zero_le_one ];
  simpa only [ ← MeasureTheory.integral_Icc_eq_integral_Ioc ] using h_iterated

/-
Checking if torus_integral_split_i exists.
-/
#check torus_integral_split_i

/-
Checking the signature of LinearEquiv.toContinuousLinearEquivOfContinuous.
-/
#check LinearEquiv.toContinuousLinearEquivOfContinuous

/-
Define the linear equivalence between `Fin 3 → ℝ` and `ℝ × (Fin 2 → ℝ)` by splitting at index `i`.
-/
open Real MeasureTheory Set Function

noncomputable def split_i_linear (i : Fin 3) : (Fin 3 → ℝ) ≃ₗ[ℝ] ℝ × (Fin 2 → ℝ) :=
  { toFun := fun x => (x i, x ∘ i.succAbove)
    invFun := fun (t, y) => i.insertNth t y
    left_inv := fun x => by
      fin_cases i <;> ext j <;> fin_cases j <;> rfl
    right_inv := fun (t, y) => by
      fin_cases i <;> aesop
    map_add' := fun x y => by
      rfl
    map_smul' := fun r x => by
      aesop }

/-
Define the continuous linear equivalence `split_i_equiv` using `split_i_linear` and the Open Mapping Theorem (via `toContinuousLinearEquivOfContinuous`).
-/
open Real MeasureTheory Set Function

noncomputable def split_i_equiv (i : Fin 3) : (Fin 3 → ℝ) ≃L[ℝ] ℝ × (Fin 2 → ℝ) :=
  LinearEquiv.toContinuousLinearEquivOfContinuous (split_i_linear i)
    (Continuous.prodMk (continuous_apply i) (continuous_pi (fun j => continuous_apply _)))

/-
The integral of a partial derivative of a periodic function over the torus is zero.
-/
open Real MeasureTheory Set Function

def IsPeriodicScalar (f : Point → ℝ) : Prop :=
  ∀ (x : Point) (i : Fin 3), f (x + Pi.single i 1) = f x

lemma torus_integral_partial_deriv_zero (f : Point → ℝ) (i : Fin 3)
    (h_smooth : ContDiff ℝ 1 f) (h_per : IsPeriodicScalar f) :
    TorusIntegral (fun x => partialDeriv i f x) = 0 := by
  -- Use `torus_integral_split_i` to write the integral as $\int_0^1 \int_{Icc} \partial_i f(i.insertNth t y) dy dt$.
  have h_split : TorusIntegral (fun x => partialDeriv i f x) = ∫ t in (0 : ℝ)..1, ∫ y in Icc (0 : Fin 2 → ℝ) (fun _ => 1), (deriv (fun s => f (i.insertNth s y)) t) := by
    convert torus_integral_split_i ( fun x => partialDeriv i f x ) i _;
    · rw [ deriv ];
      erw [ fderiv_comp ] <;> norm_num [ h_smooth.contDiffAt.differentiableAt ];
      · unfold partialDeriv;
        rw [ deriv ];
        rw [ deriv ];
        erw [ fderiv_comp 0 ] <;> norm_num [ h_smooth.contDiffAt.differentiableAt ];
        · rw [ deriv_pi ] <;> norm_num [ Fin.forall_fin_succ ];
          · congr! 2;
            fin_cases i <;> simp +decide [ Fin.forall_fin_succ, deriv_pi ];
            · rename_i k; fin_cases k <;> norm_num [ Fin.cons, Pi.single_apply ] ;
              exact deriv_id _;
            · rename_i k; fin_cases k <;> simp +decide [ Fin.insertNth ] ;
              · simp +decide [ Fin.succAboveCases ];
              · simp +decide [ Fin.succAboveCases ];
            · rename_i i; fin_cases i <;> simp +decide [ Fin.insertNth ] ;
              · simp +decide [ Fin.succAboveCases ];
              · simp +decide [ Fin.succAboveCases ];
          · fin_cases i <;> simp +decide [ Fin.insertNth ];
            · exact differentiableAt_const _;
            · simp +decide [ Fin.succAboveCases ];
            · simp +decide [ Fin.succAboveCases ];
        · intro j; by_cases h : j = i <;> simp +decide [ h, Pi.single_apply ] ;
      · norm_num [ Fin.insertNth ];
        intro j; fin_cases i <;> fin_cases j <;> simp +decide [ Fin.succAboveCases ] ;
    · -- The partial derivative of a $C^1$ function is continuous.
      have h_cont : Continuous (fun x => partialDeriv i f x) := by
        unfold partialDeriv;
        have := h_smooth.continuous_fderiv;
        -- The derivative of $f$ at $x$ in the direction of $e_i$ is given by the chain rule.
        have h_chain : ∀ x : Point, deriv (fun s => f (x + Pi.single i s)) 0 = (fderiv ℝ f x) (Pi.single i 1) := by
          intro x; erw [ deriv ] ; erw [ fderiv_comp ] <;> aesop;
          · rw [ deriv_pi ] <;> norm_num [ Fin.forall_fin_succ ];
            · congr ; ext j ; fin_cases i <;> fin_cases j <;> norm_num [ Pi.single_apply ];
            · fin_cases i <;> simp +decide [ Pi.single_apply ];
          · exact h_smooth.contDiffAt.differentiableAt ( by norm_num );
          · fin_cases i <;> fin_cases i_1 <;> simp +decide [ Pi.single_apply ];
        continuity;
      exact h_cont.integrableOn_Icc;
  -- By Fubini's theorem, we can interchange the order of integration.
  have h_fubini : ∫ t in (0 : ℝ)..1, ∫ y in Icc (0 : Fin 2 → ℝ) (fun _ => 1), (deriv (fun s => f (i.insertNth s y)) t) = ∫ y in Icc (0 : Fin 2 → ℝ) (fun _ => 1), ∫ t in (0 : ℝ)..1, (deriv (fun s => f (i.insertNth s y)) t) := by
    rw [ intervalIntegral.integral_of_le zero_le_one, MeasureTheory.integral_integral_swap ];
    · norm_num [ intervalIntegral.integral_of_le zero_le_one ];
    · -- The function inside the integral is continuous, hence integrable.
      have h_cont : Continuous (fun p : ℝ × (Fin 2 → ℝ) => deriv (fun s => f (i.insertNth s p.2)) p.1) := by
        have h_cont : ContDiff ℝ 1 (fun p : ℝ × (Fin 2 → ℝ) => f (i.insertNth p.1 p.2)) := by
          refine' h_smooth.comp _;
          refine' contDiff_pi.2 fun j => _;
          fin_cases j <;> simp +decide [ Fin.insertNth ];
          · fin_cases i <;> simp +decide [ Fin.succAboveCases ];
            · exact contDiff_fst;
            · exact contDiff_pi.1 contDiff_snd 0;
            · exact contDiff_pi.1 contDiff_snd 0;
          · fin_cases i <;> simp +decide [ Fin.succAboveCases ];
            · exact contDiff_pi.1 contDiff_snd 0;
            · exact contDiff_fst;
            · exact contDiff_pi.1 contDiff_snd 1;
          · fin_cases i <;> simp +decide [ Fin.succAboveCases ];
            · exact contDiff_pi.1 contDiff_snd 1;
            · exact contDiff_pi.1 contDiff_snd 1;
            · exact contDiff_fst;
        have := h_cont.continuous_fderiv; aesop;
        have h_cont_deriv : ∀ p : ℝ × (Fin 2 → ℝ), deriv (fun s => f (i.insertNth s p.2)) p.1 = (fderiv ℝ (fun p : ℝ × (Fin 2 → ℝ) => f (i.insertNth p.1 p.2)) p) (1, 0) := by
          intro p; exact (by
          exact HasDerivAt.deriv ( by simpa using HasFDerivAt.hasDerivAt ( h_cont.differentiable le_rfl |> Differentiable.differentiableAt |> DifferentiableAt.hasFDerivAt |> HasFDerivAt.comp _ <| HasFDerivAt.prodMk ( hasFDerivAt_id _ ) <| hasFDerivAt_const _ _ ) ));
        simpa only [ h_cont_deriv ] using this.clm_apply ( continuous_const );
      rw [ MeasureTheory.Measure.prod_restrict ];
      exact ContinuousOn.integrableOn_compact ( isCompact_Icc.prod CompactIccSpace.isCompact_Icc ) ( h_cont.continuousOn ) |> fun h => h.mono_set <| Set.prod_mono ( Set.Ioc_subset_Icc_self ) le_rfl;
  -- By the fundamental theorem of calculus, the inner integral is $f(i.insertNth 1 y) - f(i.insertNth 0 y)$.
  have h_ftc : ∀ y : Fin 2 → ℝ, ∫ t in (0 : ℝ)..1, deriv (fun s => f (i.insertNth s y)) t = f (i.insertNth 1 y) - f (i.insertNth 0 y) := by
    intro y; rw [ intervalIntegral.integral_deriv_eq_sub ];
    · refine' fun x hx => DifferentiableAt.comp x ( h_smooth.contDiffAt.differentiableAt ( by norm_num ) ) _;
      simp +zetaDelta at *;
      intro j; fin_cases i <;> fin_cases j <;> norm_num [ Fin.insertNth ] ;
      all_goals simp +decide [ Fin.succAboveCases ];
    · -- The function $deriv (fun s => f (i.insertNth s y))$ is continuous since $f$ is continuously differentiable.
      have h_cont : ContDiff ℝ 1 (fun s => f (i.insertNth s y)) := by
        refine' h_smooth.comp _;
        fin_cases i <;> simp +decide [ contDiff_pi, contDiff_const ];
        · exact fun i => by fin_cases i <;> [ exact contDiff_id; exact contDiff_const; exact contDiff_const ] ;
        · intro i; fin_cases i <;> simp +decide [ contDiff_const, contDiff_id ] ;
          · exact contDiff_const;
          · exact contDiff_id;
          · exact contDiff_const;
        · exact fun i => by fin_cases i <;> [ exact contDiff_const; exact contDiff_const; exact contDiff_id ] ;
      exact ( h_cont.continuous_deriv le_rfl |> Continuous.intervalIntegrable ) _ _;
  -- By periodicity, $f(i.insertNth 1 y) = f(i.insertNth 0 y)$.
  have h_periodic : ∀ y : Fin 2 → ℝ, f (i.insertNth 1 y) = f (i.insertNth 0 y) := by
    intro y; specialize h_per ( i.insertNth 0 y ) i; aesop;
    convert h_per using 2 ; ext j ; by_cases hj : j = i <;> aesop;
    fin_cases i <;> fin_cases j <;> trivial;
  aesop

/-
The integral of the divergence of a periodic vector field over the torus is zero.
-/
lemma torus_integral_div_periodic_zero (u : Point → Velocity)
    (h_smooth : ContDiff ℝ 1 u) (h_per : IsPeriodic u) :
    TorusIntegral (divergence u) = 0 := by
      -- The integral of the divergence is the sum of integrals of partial derivatives.
      have h_integral_divergence : TorusIntegral (divergence u) = ∑ i, TorusIntegral (fun x => partialDeriv i (fun y => u y i) x) := by
        apply_rules [ MeasureTheory.integral_finset_sum ];
        -- Since `u` is continuously differentiable, its partial derivatives are continuous.
        have h_cont_diff : ∀ i, Continuous (fun y => partialDeriv i (fun y => u y i) y) := by
          -- Since `u` is continuously differentiable, its partial derivatives are continuous. This follows from the fact that the composition of ContDiff functions is also ContDiff.
          have h_cont_diff : ∀ i, ContDiff ℝ 1 (fun y => u y i) := by
            exact fun i => contDiff_pi.mp h_smooth i;
          intro i; specialize h_cont_diff i; rw [ contDiff_one_iff_fderiv ] at h_cont_diff; aesop;
          unfold partialDeriv;
          have h_cont_diff : ∀ y, deriv (fun s => u (y + Pi.single i s) i) 0 = (fderiv ℝ (fun y => u y i) y) (Pi.single i 1) := by
            intro y;
            rw [ deriv ];
            rw [ show ( fun s => u ( y + Pi.single i s ) i ) = ( fun y => u y i ) ∘ ( fun s => y + Pi.single i s ) by ext; rfl, fderiv_comp ] <;> norm_num;
            · rw [ deriv_pi ] <;> norm_num [ Fin.forall_fin_succ ];
              · congr ; ext j ; fin_cases i <;> fin_cases j <;> norm_num [ Pi.single_apply ];
              · fin_cases i <;> simp +decide [ Pi.single_apply ];
            · exact?;
            · intro j; by_cases h : i = j <;> aesop;
          aesop;
          fun_prop;
        exact fun i _ => Continuous.integrableOn_Icc ( h_cont_diff i );
      rw [ h_integral_divergence, Finset.sum_eq_zero ] ; aesop;
      apply torus_integral_partial_deriv_zero;
      · exact h_smooth.comp ( contDiff_id ) |> ContDiff.comp ( contDiff_pi.1 contDiff_id x );
      · intro y i; specialize h_per y i; aesop;