/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9a7e75dd-32a8-44d0-bd2e-024c8405f7cf

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Define e(x) = exp(2πix), the exponential sum S_N(α), and the Goldbach integral I(N).
-/
open Nat Real Complex MeasureTheory intervalIntegral ArithmeticFunction
open scoped BigOperators

-- Fix: Add notation for Möbius function and Euler's totient
local notation "μ" => ArithmeticFunction.moebius
local notation "φ" => Nat.totient

noncomputable def e (x : ℝ) : ℂ := Complex.exp (2 * Real.pi * Complex.I * x)

noncomputable def S (N : ℕ) (α : ℝ) : ℂ := ∑ k ∈ Finset.range (N + 1), (Λ k : ℂ) * e (k * α)

noncomputable def I_goldbach (N : ℕ) : ℂ := intervalIntegral (fun α => (S N α) ^ 2 * e (-N * α)) 0 1 volume

/-
Define MajorArcs, MinorArcs, Ramanujan's sum, and the Singular Series.
-/
noncomputable def MajorArcs (N : ℕ) (Q : ℝ) : Set ℝ :=
  ⋃ (q : ℕ) (_ : q ∈ Finset.range (⌊Q⌋.toNat + 1)) (_ : q ≥ 1),
    ⋃ (a : ℕ) (_ : a ∈ Finset.range q) (_ : a.Coprime q),
      {α | |α - (a : ℝ) / q| < 1 / (q * (N : ℝ) ^ (1/2 : ℝ))} ∩ Set.Icc 0 1

noncomputable def MinorArcs (N : ℕ) (Q : ℝ) : Set ℝ := (Set.Icc 0 1) \ (MajorArcs N Q)

noncomputable def ramanujanSum (q N : ℕ) : ℂ :=
  ∑ a ∈ (Finset.range q).filter (fun x => x.Coprime q), e (a * N / q)

noncomputable def singularSeriesTerm (q N : ℕ) : ℂ :=
  ((μ q : ℂ) ^ 2) / ((φ q : ℂ) ^ 2) * ramanujanSum q N

noncomputable def singularSeries (N : ℕ) : ℂ := ∑' q : ℕ, singularSeriesTerm q N

/-
Define the local factor of the singular series at prime p for integer N.
-/
noncomputable def localFactor (p N : ℕ) : ℝ :=
  if p.Prime then
    1 + (if p ∣ N then 1 / (p - 1 : ℝ) else -1 / ((p - 1 : ℝ) ^ 2))
  else 1

/-
The local factor at prime p is 1 plus the real part of the p-th term in the singular series.
-/
theorem local_factor_val (p N : ℕ) (hp : p.Prime) :
  localFactor p N = 1 + (singularSeriesTerm p N).re := by
    unfold singularSeriesTerm localFactor; aesop;
    · -- Since $p \mid N$, we have $c_p(N) = p - 1$.
      have h_cpn : ramanujanSum p N = p - 1 := by
        unfold ramanujanSum;
        -- Since $p \mid N$, we have $e(aN/p) = e(0) = 1$ for all $a$ coprime to $p$.
        have h_exp : ∀ a ∈ Finset.range p, a.Coprime p → e ((a * N) / p) = 1 := by
          intro a ha₁ ha₂; obtain ⟨ k, rfl ⟩ := h; norm_num [ mul_assoc, mul_div_assoc, hp.ne_zero ] ;
          exact Complex.exp_eq_one_iff.mpr ⟨ a * k, by push_cast; ring ⟩;
        rw [ Finset.sum_congr rfl fun x hx => h_exp x ( Finset.mem_filter.mp hx |>.1 ) ( Finset.mem_filter.mp hx |>.2 ) ] ; aesop;
        rw [ show Finset.filter ( fun x => Nat.Coprime x p ) ( Finset.range p ) = Finset.Ico 1 p from ?_ ];
        · norm_num [ hp.pos ];
        · ext ( _ | x ) <;> aesop;
          exact Nat.Coprime.symm ( hp.coprime_iff_not_dvd.mpr <| Nat.not_dvd_of_pos_of_lt ( Nat.succ_pos _ ) a );
      norm_cast ; aesop;
      norm_num [ hp, Nat.totient_prime hp, Rat.divInt_eq_div ];
      rw [ Nat.cast_sub hp.pos ] ; norm_num [ hp, ArithmeticFunction.moebius_apply_prime hp ] ; ring;
      rw [ inv_eq_of_mul_eq_one_right ] ; nlinarith [ show ( p : ℝ ) ≥ 2 by exact_mod_cast hp.two_le, mul_inv_cancel₀ ( by nlinarith [ show ( p : ℝ ) ≥ 2 by exact_mod_cast hp.two_le ] : ( 1 - p * 2 + p ^ 2 : ℝ ) ≠ 0 ) ];
    · -- Since $p$ is prime and does not divide $N$, we have $c_p(N) = -1$.
      have h_c_p_N : ramanujanSum p N = -1 := by
        -- Since $p$ is prime and does not divide $N$, we have $c_p(N) = \sum_{a=1}^{p-1} e^{2\pi i a N / p}$.
        have h_c_p_N : ramanujanSum p N = ∑ a ∈ Finset.Ico 1 p, Complex.exp (2 * Real.pi * Complex.I * a * N / p) := by
          refine' Finset.sum_bij ( fun x hx => x ) _ _ _ _ <;> aesop;
          · exact Nat.pos_of_ne_zero ( by aesop );
          · exact Nat.Coprime.symm ( hp.coprime_iff_not_dvd.mpr <| Nat.not_dvd_of_pos_of_lt left right );
          · unfold e; push_cast; ring;
        -- Since $p$ is prime and does not divide $N$, the sum $\sum_{a=1}^{p-1} e^{2\pi i a N / p}$ is a geometric series with common ratio $e^{2\pi i N / p}$.
        have h_geo_series : ∑ a ∈ Finset.Ico 1 p, Complex.exp (2 * Real.pi * Complex.I * a * N / p) = (∑ a ∈ Finset.range p, Complex.exp (2 * Real.pi * Complex.I * a * N / p)) - 1 := by
          rw [ Finset.sum_Ico_eq_sub _ hp.pos ] ; norm_num;
        -- Since $p$ is prime and does not divide $N$, the sum $\sum_{a=0}^{p-1} e^{2\pi i a N / p}$ is a geometric series with common ratio $e^{2\pi i N / p}$.
        have h_geo_series_sum : ∑ a ∈ Finset.range p, Complex.exp (2 * Real.pi * Complex.I * a * N / p) = 0 := by
          have h_geo_series_sum : ∑ a ∈ Finset.range p, (Complex.exp (2 * Real.pi * Complex.I * N / p)) ^ a = 0 := by
            rw [ geom_sum_eq ] <;> norm_num [ ← Complex.exp_nat_mul, mul_div_cancel₀, hp.ne_zero ];
            · exact Or.inl ( sub_eq_zero_of_eq <| Complex.exp_eq_one_iff.mpr ⟨ N, by push_cast; ring ⟩ );
            · rw [ Complex.exp_eq_one_iff ];
              field_simp;
              exact fun ⟨ n, hn ⟩ => h <| Int.natCast_dvd_natCast.mp <| ⟨ n, by rw [ div_eq_iff ( Nat.cast_ne_zero.mpr hp.ne_zero ) ] at hn; norm_cast at *; linarith ⟩;
          exact Eq.trans ( Finset.sum_congr rfl fun _ _ => by rw [ ← Complex.exp_nat_mul ] ; ring ) h_geo_series_sum;
        aesop;
      simp_all +decide [ Nat.totient_prime hp, ArithmeticFunction.moebius_apply_prime hp ];
      norm_cast ; simp +decide [ hp.pos, sq ] ; ring;
      norm_num [ Rat.divInt_eq_div ] ; ring

/-
Each local factor of the singular series is strictly positive for even N.
-/
theorem local_factor_pos (p N : ℕ) (hp : p.Prime) (hN : Even N) :
  localFactor p N > 0 := by
    unfold localFactor; aesop;
    · exact add_pos_of_pos_of_nonneg zero_lt_one ( inv_nonneg.2 ( sub_nonneg.2 ( Nat.one_le_cast.2 hp.pos ) ) );
    · rcases p with ( _ | _ | _ | p ) <;> norm_num at *;
      · simp_all +decide [ Nat.even_iff ];
      · rw [ add_div', lt_div_iff₀ ] <;> ring <;> norm_cast <;> nlinarith

/-
Define the singular series term as an ArithmeticFunction.
-/
noncomputable def singularSeriesTermFunc (N : ℕ) : ArithmeticFunction ℂ :=
  { toFun := fun q => singularSeriesTerm q N
    map_zero' := by simp [singularSeriesTerm, ramanujanSum] }

/-
The singular series term is a multiplicative arithmetic function.
-/
theorem singular_series_term_multiplicative (N : ℕ) :
  (singularSeriesTermFunc N).IsMultiplicative := by
    constructor;
    · unfold singularSeriesTermFunc; aesop;
      unfold singularSeriesTerm ramanujanSum; norm_num;
      unfold e; norm_num;
    · intro m n hmn;
      unfold singularSeriesTermFunc;
      unfold singularSeriesTerm; aesop;
      -- Apply the multiplicative property of the Möbius function and Euler's totient function.
      have h_mu : (μ (m * n) : ℂ) = (μ m : ℂ) * (μ n : ℂ) := by
        unfold ArithmeticFunction.moebius at * ; aesop;
        · rw [ ← pow_add, ArithmeticFunction.cardFactors_mul ] ; aesop;
          aesop;
        · exact h_2 <| h.squarefree_of_dvd <| dvd_mul_right _ _;
        · exact h_1 <| h.squarefree_of_dvd <| dvd_mul_left _ _;
        · rw [ Nat.squarefree_mul_iff ] at h ; aesop
      have h_phi : (φ (m * n) : ℂ) = (φ m : ℂ) * (φ n : ℂ) := by
        exact mod_cast Nat.totient_mul hmn
      have h_ramanujan : ramanujanSum (m * n) N = ramanujanSum m N * ramanujanSum n N := by
        -- By the properties of the Möbius function and the Euler's totient function, we can rewrite the sum.
        have h_sum : ∑ a ∈ Finset.filter (fun x => Nat.Coprime x (m * n)) (Finset.range (m * n)), Complex.exp (2 * Real.pi * Complex.I * (a * N) / (m * n)) = ∑ a ∈ Finset.filter (fun x => Nat.Coprime x m) (Finset.range m), ∑ b ∈ Finset.filter (fun x => Nat.Coprime x n) (Finset.range n), Complex.exp (2 * Real.pi * Complex.I * ((a * n + b * m) * N) / (m * n)) := by
          have h_sum : Finset.filter (fun x => Nat.Coprime x (m * n)) (Finset.range (m * n)) = Finset.image (fun (p : ℕ × ℕ) => (p.1 * n + p.2 * m) % (m * n)) (Finset.filter (fun x => Nat.Coprime x m) (Finset.range m) ×ˢ Finset.filter (fun x => Nat.Coprime x n) (Finset.range n)) := by
            ext ; aesop;
            · -- By the Chinese Remainder Theorem, there exist unique $a_1$ and $b$ such that $a_1 \equiv a \pmod{m}$ and $b \equiv a \pmod{n}$.
              obtain ⟨a1, b, ha1, hb⟩ : ∃ a1 b : ℕ, a1 < m ∧ b < n ∧ a1 * n + b * m ≡ a [MOD m * n] := by
                have h_crt : ∃ a1 b : ℕ, a1 * n + b * m ≡ a [MOD m * n] := by
                  have h_crt : ∃ a1 b : ℤ, a1 * n + b * m = a := by
                    have := Nat.gcd_eq_gcd_ab m n; aesop;
                    exact ⟨ a * Nat.gcdB m n, a * Nat.gcdA m n, by nlinarith ⟩;
                  obtain ⟨ a1, b, h ⟩ := h_crt;
                  exact ⟨ Int.toNat ( a1 % ( m * n ) ), Int.toNat ( b % ( m * n ) ), by rw [ ← Int.natCast_modEq_iff ] ; simpa [ Int.ModEq, Int.add_emod, Int.mul_emod, Int.emod_nonneg _ ( by nlinarith : ( m * n : ℤ ) ≠ 0 ) ] using congr_arg ( · % ( m * n : ℤ ) ) h ⟩;
                obtain ⟨ a1, b, h ⟩ := h_crt;
                refine' ⟨ a1 % m, b % n, Nat.mod_lt _ ( Nat.pos_of_ne_zero ( by aesop_cat ) ), Nat.mod_lt _ ( Nat.pos_of_ne_zero ( by aesop_cat ) ), _ ⟩;
                simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
                simp_all +decide [ ← h, Nat.mod_eq_of_lt ];
                simp +decide [ Nat.mod_def ];
                rw [ Nat.cast_sub ( Nat.mul_div_le _ _ ), Nat.cast_sub ( Nat.mul_div_le _ _ ) ] ; norm_num;
                ring;
                norm_cast ; simp +decide [ mul_assoc, mul_comm, mul_left_comm ];
                norm_cast ; simp +decide [ ← mul_assoc, ← ZMod.natCast_eq_zero_iff ];
              use a1, b;
              aesop;
              · have := right_1.gcd_eq ; aesop;
                by_contra h_contra;
                obtain ⟨ p, hp₁, hp₂ ⟩ := Nat.Prime.not_coprime_iff_dvd.mp h_contra;
                exact Nat.Prime.not_dvd_one hp₁ ( this ▸ Nat.dvd_gcd ( show p ∣ a1 * n + b * m from dvd_add ( dvd_mul_of_dvd_left hp₂.1 _ ) ( dvd_mul_of_dvd_right hp₂.2 _ ) ) ( show p ∣ m * n from dvd_mul_of_dvd_left hp₂.2 _ ) );
              · have := right_1.gcd_eq ; aesop;
                by_contra h_contra;
                obtain ⟨ p, hp₁, hp₂ ⟩ := Nat.Prime.not_coprime_iff_dvd.mp h_contra;
                exact Nat.Prime.not_dvd_one hp₁ ( this ▸ Nat.dvd_gcd ( show p ∣ a1 * n + b * m from dvd_add ( dvd_mul_of_dvd_right hp₂.2 _ ) ( dvd_mul_of_dvd_left hp₂.1 _ ) ) ( show p ∣ m * n from dvd_mul_of_dvd_right hp₂.2 _ ) );
              · exact right_1.symm ▸ Nat.mod_eq_of_lt left;
            · exact Nat.mod_lt _ ( Nat.mul_pos ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ( Nat.pos_of_ne_zero ( by aesop_cat ) ) );
            · -- By definition of coprimality, we need to show that $\gcd(w * n + w_1 * m, m * n) = 1$.
              have h_coprime : Nat.gcd (w * n + w_1 * m) (m * n) = 1 := by
                simp_all +decide [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right, Nat.Coprime, Nat.gcd_comm ];
              rwa [ Nat.gcd_comm, Nat.gcd_rec ] at h_coprime;
          rw [ h_sum, Finset.sum_image ];
          · rw [ Finset.sum_product ];
            refine' Finset.sum_congr rfl fun x hx => Finset.sum_congr rfl fun y hy => _;
            rw [ Complex.exp_eq_exp_iff_exists_int ];
            use -((x * n + y * m) / (m * n)) * N;
            rw [ Nat.mod_def ] ; ring;
            rw [ Nat.cast_sub ( show n * m * ( ( x * n + y * m ) / ( n * m ) ) ≤ x * n + y * m from Nat.mul_div_le _ _ ) ] ; push_cast ; ring;
            by_cases hm : m = 0 <;> by_cases hn : n = 0 <;> simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ] ; ring;
            norm_cast ; ring;
          · intros p hp q hq h_eq; simp_all +decide [ Nat.mod_eq_of_lt ] ;
            -- Since $p.1 * n + p.2 * m \equiv q.1 * n + q.2 * m \pmod{m * n}$, we have $p.1 * n \equiv q.1 * n \pmod{m}$ and $p.2 * m \equiv q.2 * m \pmod{n}$.
            have h_mod_m : p.1 * n ≡ q.1 * n [MOD m] := by
              have := congr_arg ( · % m ) h_eq; norm_num [ Nat.add_mod, Nat.mul_mod ] at this ⊢; aesop;
            have h_mod_n : p.2 * m ≡ q.2 * m [MOD n] := by
              have := congr_arg ( · % n ) h_eq; norm_num [ Nat.add_mod, Nat.mul_mod ] at this ⊢; aesop;
            -- Since $m$ and $n$ are coprime, we can divide both sides of the congruences by $n$ and $m$ respectively.
            have h_div_m : p.1 ≡ q.1 [MOD m] := by
              rw [ Nat.modEq_iff_dvd ] at *;
              simp_all +decide [ ← sub_mul ];
              exact Int.dvd_of_dvd_mul_left_of_gcd_one h_mod_m hmn
            have h_div_n : p.2 ≡ q.2 [MOD n] := by
              rw [ Nat.modEq_iff_dvd ] at *;
              simp_all +decide [ ← sub_mul ];
              exact Int.dvd_of_dvd_mul_left_of_gcd_one h_mod_n hmn.symm;
            exact Prod.ext ( Nat.mod_eq_of_lt hp.1.1 ▸ Nat.mod_eq_of_lt hq.1.1 ▸ h_div_m ) ( Nat.mod_eq_of_lt hp.2.1 ▸ Nat.mod_eq_of_lt hq.2.1 ▸ h_div_n );
        convert h_sum using 1;
        · unfold ramanujanSum;
          unfold e; norm_num [ Complex.exp_re, Complex.exp_im ] ; ring;
          ac_rfl;
        · unfold ramanujanSum; simp +decide [ Finset.sum_mul _ _ _, add_mul, mul_add, mul_assoc, mul_comm, mul_left_comm, div_eq_mul_inv ] ;
          by_cases hm : m = 0 <;> by_cases hn : n = 0 <;> simp_all +decide [ Complex.exp_add, mul_assoc, mul_comm, mul_left_comm ];
          simp +decide [ Finset.mul_sum _ _ _, mul_assoc, mul_comm, mul_left_comm, ← Complex.exp_add, e ];
      rw [ h_mu, h_phi, h_ramanujan ] ; ring

/-
The singular series term vanishes for non-square-free q.
-/
theorem singularSeriesTerm_eq_zero_of_not_squarefree (q N : ℕ) (hq : ¬ Squarefree q) :
  singularSeriesTerm q N = 0 := by
    unfold singularSeriesTerm;
    unfold ArithmeticFunction.moebius; aesop

/-
The Ramanujan sum c_p(N) is bounded by gcd(p, N) for prime p.
-/
theorem ramanujanSum_bound_prime (p N : ℕ) (hp : p.Prime) :
  ‖ramanujanSum p N‖ ≤ Nat.gcd p N := by
    by_cases h : p ∣ N <;> simp_all +decide [ ramanujanSum ];
    · obtain ⟨ k, rfl ⟩ := h;
      refine' le_trans ( norm_sum_le _ _ ) _;
      norm_num [ e ];
      norm_num [ Complex.norm_exp ];
      exact le_trans ( Finset.card_filter_le _ _ ) ( by simpa );
    · -- When $p$ does not divide $N$, we have $c_p(N) = -1$.
      have h_not_div : ∑ a ∈ Finset.filter (fun x => Nat.Coprime x p) (Finset.range p), Complex.exp (2 * Real.pi * Complex.I * (a * N) / p) = -1 := by
        -- Let $z = e^{2 \pi i N / p}$. Since $p$ is prime and does not divide $N$, $z$ is a primitive $p$-th root of unity.
        set z : ℂ := Complex.exp (2 * Real.pi * Complex.I * N / p)
        have hz : ∑ a ∈ Finset.range p, z ^ a = 0 := by
          rw [ geom_sum_eq ];
          · rw [ ← Complex.exp_nat_mul, mul_comm, Complex.exp_eq_one_iff.mpr ⟨ N, by push_cast; ring_nf; norm_num [ hp.ne_zero ] ⟩ ] ; norm_num;
          · contrapose! h; rw [ Complex.exp_eq_one_iff ] at *; aesop;
            rw [ div_eq_iff ] at h <;> norm_num [ Complex.ext_iff, hp.ne_zero ] at *;
            exact Int.natCast_dvd_natCast.mp ⟨ w, by push_cast [ ← @Int.cast_inj ℝ ] ; nlinarith [ Real.pi_pos ] ⟩;
        -- Since $p$ is prime and does not divide $N$, the set $\{a \in \{0, 1, \ldots, p-1\} \mid \gcd(a, p) = 1\}$ is exactly $\{1, 2, \ldots, p-1\}$.
        have h_set : Finset.filter (fun x => Nat.Coprime x p) (Finset.range p) = Finset.Ico 1 p := by
          ext ( _ | x ) <;> aesop;
          exact Nat.Coprime.symm ( hp.coprime_iff_not_dvd.mpr <| Nat.not_dvd_of_pos_of_lt ( Nat.succ_pos _ ) a );
        simp_all +decide [ Finset.sum_Ico_eq_sub _ hp.pos, ← Complex.exp_nat_mul ];
        convert hz using 2 ; ring;
        rw [ ← Complex.exp_nat_mul ] ; ring;
      unfold e; aesop;
      simp_all +decide [ mul_div_assoc ];
      exact Nat.gcd_pos_of_pos_left _ hp.pos

/-
The Ramanujan sum is a multiplicative arithmetic function.
-/
noncomputable def ramanujanSumFunc (N : ℕ) : ArithmeticFunction ℂ :=
  { toFun := fun q => ramanujanSum q N
    map_zero' := by simp [ramanujanSum] }

theorem ramanujanSum_multiplicative (N : ℕ) :
  (ramanujanSumFunc N).IsMultiplicative := by
    have h_coprime : ∀ m n : ℕ, Nat.Coprime m n → (ramanujanSum (m * n) N) = (ramanujanSum m N) * (ramanujanSum n N) := by
      intros m n h_coprime;
      -- By definition of ramanujanSum, we can write
      have h_def : ramanujanSum (m * n) N = ∑ a ∈ Finset.filter (fun x => Nat.gcd x (m * n) = 1) (Finset.range (m * n)), Complex.exp (2 * Real.pi * Complex.I * (a * N) / (m * n)) := by
        unfold ramanujanSum;
        unfold e; norm_num [ mul_div_assoc ] ;
      -- By the properties of the exponential function and the Chinese Remainder Theorem, we can split the sum into a product of sums over $m$ and $n$.
      have h_split : ∑ a ∈ Finset.filter (fun x => Nat.gcd x (m * n) = 1) (Finset.range (m * n)), Complex.exp (2 * Real.pi * Complex.I * (a * N) / (m * n)) = ∑ a ∈ Finset.filter (fun x => Nat.gcd x m = 1) (Finset.range m), ∑ b ∈ Finset.filter (fun x => Nat.gcd x n = 1) (Finset.range n), Complex.exp (2 * Real.pi * Complex.I * ((a * n + b * m) * N) / (m * n)) := by
        have h_split : Finset.filter (fun x => Nat.gcd x (m * n) = 1) (Finset.range (m * n)) = Finset.image (fun (p : ℕ × ℕ) => (p.1 * n + p.2 * m) % (m * n)) (Finset.filter (fun x => Nat.gcd x m = 1) (Finset.range m) ×ˢ Finset.filter (fun x => Nat.gcd x n = 1) (Finset.range n)) := by
          ext ; aesop;
          · -- By the Chinese Remainder Theorem, there exist unique $a_1$ and $b$ such that $a_1 \equiv a \pmod{m}$ and $b \equiv a \pmod{n}$.
            obtain ⟨a1, b, ha1, hb⟩ : ∃ a1 b : ℕ, a1 < m ∧ b < n ∧ a1 * n + b * m ≡ a [MOD m * n] ∧ Nat.gcd a1 m = 1 ∧ Nat.gcd b n = 1 := by
              -- By the Chinese Remainder Theorem, there exist unique $a_1$ and $b$ such that $a_1 \equiv a \pmod{m}$ and $b \equiv a \pmod{n}$, and $a_1 < m$ and $b < n$.
              obtain ⟨a1, b, ha1, hb⟩ : ∃ a1 b : ℕ, a1 < m ∧ b < n ∧ a1 * n + b * m ≡ a [MOD m * n] := by
                -- By the Chinese Remainder Theorem, there exist unique $a_1$ and $b$ such that $a_1 \equiv a \pmod{m}$ and $b \equiv a \pmod{n}$, and $a_1 < m$ and $b < n$. Use this fact.
                have h_crt : ∃ a1 b : ℕ, a1 * n + b * m ≡ a [MOD m * n] := by
                  have h_crt : ∃ a1 b : ℤ, a1 * n + b * m = a := by
                    have := Nat.gcd_eq_gcd_ab m n ; aesop;
                    exact ⟨ a * Nat.gcdB m n, a * Nat.gcdA m n, by nlinarith ⟩;
                  obtain ⟨ a1, b, h ⟩ := h_crt;
                  exact ⟨ Int.toNat ( a1 % ( m * n ) ), Int.toNat ( b % ( m * n ) ), by rw [ ← Int.natCast_modEq_iff ] ; simpa [ Int.ModEq, Int.add_emod, Int.mul_emod, Int.emod_nonneg _ ( by nlinarith : ( m * n : ℤ ) ≠ 0 ) ] using congr_arg ( · % ( m * n : ℤ ) ) h ⟩;
                obtain ⟨ a1, b, h ⟩ := h_crt; use a1 % m, b % n; aesop;
                · exact Nat.mod_lt _ ( Nat.pos_of_ne_zero ( by aesop_cat ) );
                · exact Nat.mod_lt _ ( Nat.pos_of_ne_zero ( by aesop_cat ) );
                · simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ];
                  rw [ ← h ] ; norm_cast; simp +decide [ Nat.mod_eq_of_lt ( show a1 % m < m from Nat.mod_lt _ ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ), Nat.mod_eq_of_lt ( show b % n < n from Nat.mod_lt _ ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ) ] ;
                  erw [ ← Nat.mod_add_div a1 m, ← Nat.mod_add_div b n ] ; norm_num [ add_mul, mul_assoc, Nat.mul_mod, Nat.mod_eq_of_lt ( show a1 % m < m from Nat.mod_lt _ ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ), Nat.mod_eq_of_lt ( show b % n < n from Nat.mod_lt _ ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ) ] ;
                  simp +decide [ mul_assoc, mul_comm, mul_left_comm ];
                  norm_cast; simp +decide [ ← mul_assoc, ← add_assoc, ← ZMod.natCast_eq_natCast_iff' ] ;
              use a1, b;
              have := hb.2.gcd_eq ; aesop;
              · by_contra h_contra;
                obtain ⟨ p, hp₁, hp₂ ⟩ := Nat.Prime.not_coprime_iff_dvd.mp h_contra;
                exact Nat.Prime.not_dvd_one hp₁ ( this ▸ Nat.dvd_gcd ( show p ∣ a1 * n + b * m from dvd_add ( dvd_mul_of_dvd_left hp₂.1 _ ) ( dvd_mul_of_dvd_right hp₂.2 _ ) ) ( show p ∣ m * n from dvd_mul_of_dvd_left hp₂.2 _ ) );
              · by_contra h_contra;
                -- If $\gcd(b, n) \neq 1$, then there exists a prime $p$ such that $p \mid b$ and $p \mid n$.
                obtain ⟨p, hp_prime, hp_div_b, hp_div_n⟩ : ∃ p, Nat.Prime p ∧ p ∣ b ∧ p ∣ n := by
                  exact Nat.Prime.not_coprime_iff_dvd.mp h_contra;
                exact Nat.Prime.not_dvd_one hp_prime ( this ▸ Nat.dvd_gcd ( show p ∣ a1 * n + b * m from dvd_add ( dvd_mul_of_dvd_right hp_div_n _ ) ( dvd_mul_of_dvd_left hp_div_b _ ) ) ( show p ∣ m * n from dvd_mul_of_dvd_right hp_div_n _ ) );
            exact ⟨ a1, b, ⟨ ⟨ ha1, hb.2.2.1 ⟩, hb.1, hb.2.2.2 ⟩, hb.2.1.symm ▸ Nat.mod_eq_of_lt left ⟩;
          · exact Nat.mod_lt _ ( Nat.mul_pos ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ( Nat.pos_of_ne_zero ( by aesop_cat ) ) );
          · rw [ ← Nat.gcd_rec, Nat.gcd_comm ];
            simp_all +decide [ Nat.coprime_mul_iff_left, Nat.coprime_mul_iff_right, Nat.Coprime, Nat.Coprime.symm ];
        rw [ h_split, Finset.sum_image ];
        · rw [ Finset.sum_product ];
          refine' Finset.sum_congr rfl fun x hx => Finset.sum_congr rfl fun y hy => _;
          rw [ Complex.exp_eq_exp_iff_exists_int ];
          use -((x * n + y * m) / (m * n)) * N; push_cast [ Nat.mod_def ] ; ring;
          rw [ Nat.cast_sub ( show n * m * ( ( x * n + y * m ) / ( n * m ) ) ≤ x * n + y * m from Nat.mul_div_le _ _ ) ] ; push_cast ; ring;
          by_cases hm : m = 0 <;> by_cases hn : n = 0 <;> simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ] ; ring;
          norm_cast ; ring;
        · intro p hp q hq h_eq; aesop;
          · -- Since $m$ and $n$ are coprime, we have $fst * n + snd * m \equiv fst_1 * n + snd_1 * m \pmod{m}$ implies $fst \equiv fst_1 \pmod{m}$.
            have h_mod_m : fst ≡ fst_1 [MOD m] := by
              have := congr_arg ( · % m ) h_eq; norm_num [ Nat.add_mod, Nat.mul_mod ] at this; aesop;
              exact?;
            exact Nat.mod_eq_of_lt left ▸ Nat.mod_eq_of_lt left_1 ▸ h_mod_m;
          · -- Since $m$ and $n$ are coprime, we have $snd \equiv snd_1 \pmod{n}$.
            have h_snd_mod : snd ≡ snd_1 [MOD n] := by
              have := congr_arg ( · % n ) h_eq; norm_num [ Nat.add_mod, Nat.mul_mod ] at this; aesop;
              have := Nat.modEq_iff_dvd.mp this.symm; aesop;
              rw [ Nat.modEq_iff_dvd ];
              have h_div : (n : ℤ) ∣ (snd - snd_1) * m := by
                simpa only [ sub_mul ] using this;
              rw [ dvd_sub_comm ] ; exact Int.dvd_of_dvd_mul_left_of_gcd_one h_div <| by simpa [ Int.gcd_natCast_natCast ] using h_coprime.symm;
            exact Nat.mod_eq_of_lt left_2 ▸ Nat.mod_eq_of_lt left_3 ▸ h_snd_mod;
      -- By the properties of the exponential function, we can split the exponent into a sum.
      have h_exp_split : ∀ a b : ℕ, Complex.exp (2 * Real.pi * Complex.I * ((a * n + b * m) * N) / (m * n)) = Complex.exp (2 * Real.pi * Complex.I * (a * N) / m) * Complex.exp (2 * Real.pi * Complex.I * (b * N) / n) := by
        intro a b; rw [ ← Complex.exp_add ] ; ring;
        by_cases hm : m = 0 <;> by_cases hn : n = 0 <;> simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ];
        · exact Eq.symm ( Complex.exp_eq_one_iff.mpr ⟨ b * N, by push_cast; ring ⟩ );
        · exact Eq.symm ( Complex.exp_eq_one_iff.mpr ⟨ a * N, by push_cast; ring ⟩ );
      simp_all +decide [ Complex.exp_add, Finset.mul_sum _ _ _, Finset.sum_mul ];
      simp +decide [ Finset.sum_mul _ _ _, ramanujanSum ];
      simp +decide [ e, Finset.mul_sum _ _ _, mul_div_assoc ];
    refine' ⟨ _, _ ⟩;
    · unfold ramanujanSumFunc;
      unfold ramanujanSum; norm_num;
      unfold e; norm_num;
    · aesop

/-
For square-free q, |c_q(N)| <= gcd(q, N).
-/
theorem ramanujanSum_bound_squarefree (q N : ℕ) (hq : Squarefree q) :
  ‖ramanujanSum q N‖ ≤ Nat.gcd q N := by
    -- Both |c_q(N)| and gcd(q, N) are multiplicative functions of q (restricted to square-free q).
    have h_mul : ∀ {m n : ℕ}, Nat.Coprime m n → ‖ramanujanSum (m * n) N‖ = ‖ramanujanSum m N‖ * ‖ramanujanSum n N‖ ∧ Nat.gcd (m * n) N = Nat.gcd m N * Nat.gcd n N := by
      aesop;
      · have := ramanujanSum_multiplicative N;
        have := this.2 a;
        simpa using congr_arg Norm.norm this;
      · exact?;
    -- For any prime $p$, $c_p(N)$ divides $\gcd(p, N)$.
    have h_prime_div : ∀ p : ℕ, Nat.Prime p → ‖ramanujanSum p N‖ ≤ Nat.gcd p N := by
      exact?;
    -- By the multiplicative property, we can write $q$ as a product of distinct primes.
    obtain ⟨ps, hps⟩ : ∃ ps : Finset ℕ, (∀ p ∈ ps, Nat.Prime p) ∧ q = ∏ p ∈ ps, p := by
      exact ⟨ q.primeFactors, fun p hp => Nat.prime_of_mem_primeFactors hp, Eq.symm <| Nat.prod_primeFactors_of_squarefree hq ⟩;
    -- By induction on the number of prime factors of $q$, we can show that the norm of the Ramanujan sum of $q$ is the product of the norms of the Ramanujan sums of its prime factors.
    have h_ind : ∀ {ps : Finset ℕ}, (∀ p ∈ ps, Nat.Prime p) → ‖ramanujanSum (∏ p ∈ ps, p) N‖ = ∏ p ∈ ps, ‖ramanujanSum p N‖ := by
      intro ps hps; induction ps using Finset.induction <;> aesop;
      · unfold ramanujanSum; aesop;
        norm_num [ e ];
      · rw [ h_mul ( Nat.Coprime.prod_right fun p hp => by have := Nat.coprime_primes left_1 ( right_1 p hp ) ; aesop ) |>.1, a_2 ];
    aesop;
    refine' le_trans ( Finset.prod_le_prod ( fun _ _ => norm_nonneg _ ) fun p hp => h_prime_div p ( left p hp ) ) _;
    -- By the multiplicative property of gcd, we can write gcd(∏ p ∈ ps, p, N) as the product of gcd(p, N) for p in ps.
    have h_gcd_mul : ∀ {ps : Finset ℕ}, (∀ p ∈ ps, Nat.Prime p) → Nat.gcd (∏ p ∈ ps, p) N = ∏ p ∈ ps, Nat.gcd p N := by
      intros ps hps; induction ps using Finset.induction <;> aesop;
      rw [ ← a_2, h_mul ( show Nat.Coprime a ( ∏ p ∈ s, p ) from Nat.Coprime.prod_right fun p hp => left_1.coprime_iff_not_dvd.mpr fun h => a_1 <| by have := Nat.prime_dvd_prime_iff_eq left_1 ( right p hp ) ; aesop ) |>.2 ];
    rw [ h_gcd_mul left, Nat.cast_prod ]

/-
The magnitude of the singular series term is bounded by gcd(q, N) / phi(q)^2.
-/
theorem singular_series_term_bound (q N : ℕ) (hq : q ≠ 0) :
  ‖singularSeriesTerm q N‖ ≤ (Nat.gcd q N : ℝ) / (Nat.totient q : ℝ) ^ 2 := by
    by_cases hq_sq_free : Squarefree q <;> simp_all +decide [ singularSeriesTerm, localFactor ];
    · rw [ inv_mul_eq_div ] ; gcongr ; exact ramanujanSum_bound_squarefree q N hq_sq_free;
    · positivity

/-
The magnitude of the singular series term is bounded by gcd(q, N) / phi(q)^2 for square-free q.
-/
theorem singular_series_term_bound_squarefree (q N : ℕ) (hq : Squarefree q) :
  ‖singularSeriesTerm q N‖ ≤ (Nat.gcd q N : ℝ) / (Nat.totient q : ℝ) ^ 2 := by
    have := @singular_series_term_bound q N ?_ <;> aesop

/-
Euler's totient function satisfies phi(n) >= sqrt(n)/2 for n >= 1.
-/
theorem totient_lower_bound (n : ℕ) (hn : n ≥ 1) :
  (Nat.totient n : ℝ) ≥ Real.sqrt n / 2 := by
    -- If $n$ is odd, then $\varphi(n) \geq 1$ since $n$ has at least one odd divisor.
    by_cases h_odd : Odd n;
    · -- Since $n$ is odd, we have $\varphi(n) \geq \sqrt{n}$.
      have h_odd_phi : (Nat.totient n : ℝ) ≥ Real.sqrt n := by
        -- Let $n = p_1^{e_1} p_2^{e_2} \cdots p_k^{e_k}$ be the prime factorization of $n$.
        set f := Nat.factorization n with hf;
        -- Since $n$ is odd, we can apply the inequality $\varphi(n) \geq \sqrt{n}$.
        have h_phi_odd : (∏ p ∈ f.support, (p ^ (f p - 1) * (p - 1))) ≥ Real.sqrt (∏ p ∈ f.support, (p ^ f p)) := by
          -- For each prime $p$ dividing $n$, we have $p^{e-1}(p-1) \geq \sqrt{p^e}$.
          have h_prime_contribution : ∀ p ∈ f.support, (p ^ (f p - 1) * (p - 1) : ℝ) ≥ Real.sqrt (p ^ f p) := by
            intro p hp; rcases k : f p with ( _ | _ | k ) <;> aesop;
            · rw [ Nat.factorization_eq_zero_iff ] at k ; aesop;
            · rcases p with ( _ | _ | _ | p ) <;> norm_num at *;
              · exact absurd ( even_iff_two_dvd.mpr left_1 ) ( by simpa using h_odd );
              · rw [ Real.sqrt_le_left ] <;> nlinarith;
            · rw [ Real.sqrt_le_iff ];
              ring_nf;
              field_simp;
              exact ⟨ mul_nonneg ( mul_nonneg ( Nat.cast_nonneg _ ) ( pow_nonneg ( Nat.cast_nonneg _ ) _ ) ) ( by linarith [ show ( p : ℝ ) ≥ 2 by norm_cast; exact left.two_le ] ), le_trans ( mul_le_mul_of_nonneg_left ( pow_le_pow_right₀ ( show ( p : ℝ ) ≥ 1 by norm_cast; exact left.one_lt.le ) ( by linarith ) ) ( by positivity ) ) ( le_mul_of_one_le_right ( by positivity ) ( by nlinarith [ show ( p : ℝ ) ≥ 2 by norm_cast; exact left.two_le ] ) ) ⟩;
          simp +zetaDelta at *;
          rw [ Real.sqrt_eq_rpow, ← Real.finset_prod_rpow _ _ fun x hx => by positivity ];
          exact Finset.prod_le_prod ( fun _ _ => by positivity ) fun p hp => by simpa only [ Real.sqrt_eq_rpow, Nat.cast_pred ( Nat.pos_of_mem_primeFactors hp ) ] using h_prime_contribution p ( Nat.prime_of_mem_primeFactors hp ) ( Nat.dvd_of_mem_primeFactors hp ) ( by positivity ) ;
        convert h_phi_odd using 1;
        · rw [ Nat.totient_eq_prod_factorization ] <;> aesop;
          rw [ Finsupp.prod, Finsupp.prod, Finset.prod_mul_distrib ];
          rfl;
        · exact congrArg Real.sqrt ( mod_cast Eq.symm <| Nat.factorization_prod_pow_eq_self <| by positivity );
      linarith [ Real.sqrt_nonneg n ];
    · -- Let $n = 2^k \cdot m$ where $m$ is odd.
      obtain ⟨k, m, rfl, hm_odd⟩ : ∃ k m : ℕ, n = 2^k * m ∧ Odd m := by
        use Nat.factorization n 2, n / 2^Nat.factorization n 2;
        exact ⟨ by rw [ Nat.mul_div_cancel' ( Nat.ordProj_dvd _ _ ) ], by exact Nat.odd_iff.mpr ( Nat.mod_two_ne_zero.mp fun h => absurd ( Nat.dvd_of_mod_eq_zero h ) ( Nat.not_dvd_ordCompl ( by norm_num ) ( by aesop ) ) ) ⟩;
      rw [ Nat.totient_mul, Nat.totient_prime_pow ] <;> norm_num;
      · rcases k with ( _ | k ) <;> simp_all +decide [ pow_succ' ];
        rw [ ← Real.sqrt_mul <| by positivity ];
        rw [ div_le_iff₀, Real.sqrt_le_left ] <;> ring <;> norm_cast <;> norm_num;
        rcases m with ( _ | _ | m ) <;> simp_all +decide [ pow_mul ];
        · nlinarith [ pow_pos ( zero_lt_two' ℕ ) k ];
        · have h_phi_m_ge_sqrt_m : (Nat.totient (m + 2) : ℝ) ≥ Real.sqrt (m + 2) := by
            have h_phi_m_ge_sqrt_m : (Nat.totient (m + 2) : ℝ) ^ 2 ≥ m + 2 := by
              -- Since $m$ is odd, we have $\varphi(m) \geq \sqrt{m}$.
              have h_phi_m_ge_sqrt_m : ∀ n : ℕ, Odd n → (Nat.totient n : ℝ) ^ 2 ≥ n := by
                intros n hn_odd
                have h_phi_n_ge_sqrt_n : (Nat.totient n : ℝ) ^ 2 ≥ n := by
                  have h_phi_n_ge_sqrt_n : (Nat.totient n : ℝ) = ∏ p ∈ Nat.primeFactors n, (p - 1) * p ^ (Nat.factorization n p - 1) := by
                    rw [Nat.totient_eq_prod_factorization];
                    · simp +decide [ mul_comm, Finsupp.prod ];
                    · grind
                  have h_phi_n_ge_sqrt_n : (Nat.totient n : ℝ) ^ 2 ≥ ∏ p ∈ Nat.primeFactors n, p ^ (Nat.factorization n p) := by
                    have h_phi_n_ge_sqrt_n : ∀ p ∈ Nat.primeFactors n, (p - 1) ^ 2 * p ^ (2 * (Nat.factorization n p - 1)) ≥ p ^ (Nat.factorization n p) := by
                      intros p hp
                      have h_phi_n_ge_sqrt_n : (p - 1) ^ 2 ≥ p := by
                        rcases p with ( _ | _ | _ | p ) <;> norm_num at *;
                        · exact absurd ( even_iff_two_dvd.mpr hp.1 ) ( by simpa using hn_odd );
                        · nlinarith;
                      rcases k : Nat.factorization n p with ( _ | k ) <;> simp_all +decide [ pow_succ', pow_mul' ];
                      · exact Nat.sub_pos_of_lt hp.1.one_lt;
                      · nlinarith [ show 0 < p ^ ‹_› by exact pow_pos hp.1.pos _, show p ^ ‹_› * p ^ ‹_› ≥ p ^ ‹_› by exact le_mul_of_one_le_right ( pow_nonneg hp.1.pos.le _ ) ( one_le_pow₀ hp.1.one_lt.le ) ];
                    aesop;
                    rw [ ← Finset.prod_pow ];
                    exact Finset.prod_le_prod ( fun _ _ => by positivity ) fun p hp => by rw [ mul_pow, ← pow_mul' ] ; exact_mod_cast h_phi_n_ge_sqrt_n p ( Nat.prime_of_mem_primeFactors hp ) ( Nat.dvd_of_mem_primeFactors hp ) ( by aesop ) ;
                  convert h_phi_n_ge_sqrt_n using 1;
                  exact mod_cast Eq.symm ( Nat.factorization_prod_pow_eq_self hn_odd.pos.ne' );
                exact h_phi_n_ge_sqrt_n;
              exact_mod_cast h_phi_m_ge_sqrt_m _ hm_odd
            exact Real.sqrt_le_iff.mpr ⟨ by positivity, h_phi_m_ge_sqrt_m ⟩;
          rw [ ge_iff_le, Real.sqrt_le_iff ] at h_phi_m_ge_sqrt_m ; norm_cast at * ; aesop;
          nlinarith [ pow_pos ( zero_lt_two' ℕ ) k, pow_le_pow_right₀ ( show 1 ≤ 2 by norm_num ) ( show k ≥ 0 by norm_num ) ];
      · contrapose! h_odd; aesop;
      · cases k <;> cases hm_odd <;> aesop

/-
The sum of 1/phi(q)^2 over square-free q converges.
-/
theorem summable_one_div_totient_sq_squarefree :
  Summable (fun q : ℕ => if Squarefree q then 1 / (Nat.totient q : ℝ) ^ 2 else 0) := by
    -- The sum is over square-free q.
    -- This equals Product_p (1 + 1/phi(p)^2).
    have h_prod : ∀ q : ℕ, Squarefree q → (1 / ((Nat.totient q) ^ 2 : ℝ)) = ∏ p ∈ Nat.primeFactors q, (1 / ((p - 1) ^ 2 : ℝ)) := by
      intro q hq
      have h_phi : Nat.totient q = ∏ p ∈ Nat.primeFactors q, (p - 1) := by
        rw [ Nat.totient_eq_prod_factorization ];
        · exact Finset.prod_congr rfl fun p hp => by rw [ Nat.factorization_eq_one_of_squarefree ] <;> aesop;
        · aesop_cat;
      norm_num [ h_phi, Finset.prod_pow ];
      exact congr_arg ( · ^ 2 ) ( Finset.prod_congr rfl fun x hx => by rw [ Nat.cast_pred ( Nat.pos_of_mem_primeFactors hx ) ] );
    -- The sum of 1/phi(q)^2 over square-free q is equal to the product of (1 + 1/phi(p)^2) over primes p.
    have h_sum_prod : ∀ n : ℕ, (∑ q ∈ Finset.filter Squarefree (Finset.range n), (1 / ((Nat.totient q) ^ 2 : ℝ))) ≤ (∏ p ∈ Finset.filter Nat.Prime (Finset.range n), (1 + (1 / ((p - 1) ^ 2 : ℝ)))) := by
      -- By definition of product, we can expand it to include all square-free numbers up to $n$.
      intro n
      have h_expand : (∑ q ∈ Finset.filter Squarefree (Finset.range n), (1 / ((Nat.totient q) ^ 2 : ℝ))) ≤ (∑ q ∈ Finset.powerset (Finset.filter Nat.Prime (Finset.range n)), (∏ p ∈ q, (1 / ((p - 1) ^ 2 : ℝ)))) := by
        rw [ Finset.sum_congr rfl fun q hq => h_prod q <| Finset.mem_filter.mp hq |>.2 ];
        have h_subset : Finset.image (fun q => q.primeFactors) (Finset.filter Squarefree (Finset.range n)) ⊆ Finset.powerset (Finset.filter Nat.Prime (Finset.range n)) := by
          intro; aesop;
          exact fun p hp => Finset.mem_filter.mpr ⟨ Finset.mem_range.mpr ( Nat.lt_of_le_of_lt ( Nat.le_of_mem_primeFactors hp ) left ), Nat.prime_of_mem_primeFactors hp ⟩;
        refine' le_trans _ ( Finset.sum_le_sum_of_subset_of_nonneg h_subset fun _ _ _ => Finset.prod_nonneg fun _ _ => one_div_nonneg.mpr <| sq_nonneg _ );
        rw [ Finset.sum_image ] ; aesop;
        intro x hx y hy; aesop;
        rw [ ← Nat.prod_primeFactors_of_squarefree right, ← Nat.prod_primeFactors_of_squarefree right_1, a ];
      simp_all +decide [ add_comm ( 1 : ℝ ), Finset.prod_add ];
    -- The product of (1 + 1/phi(p)^2) over primes p converges.
    have h_prod_conv : Summable (fun p : ℕ => if Nat.Prime p then Real.log (1 + (1 / ((p - 1) ^ 2 : ℝ))) else 0) := by
      have h_prod_conv : Summable (fun p : ℕ => if Nat.Prime p then (1 / ((p - 1) ^ 2 : ℝ)) else 0) := by
        rw [ ← summable_nat_add_iff 1 ];
        exact Summable.of_nonneg_of_le ( fun n => by positivity ) ( fun n => by split_ifs <;> first | positivity | simp ) ( Real.summable_one_div_nat_pow.2 one_lt_two );
      refine' .of_nonneg_of_le ( fun p => _ ) ( fun p => _ ) h_prod_conv <;> aesop;
      · exact Real.log_nonneg ( le_add_of_nonneg_right <| inv_nonneg.2 <| sq_nonneg _ );
      · exact le_trans ( Real.log_le_sub_one_of_pos ( by exact add_pos_of_pos_of_nonneg zero_lt_one ( inv_nonneg.2 ( sq_nonneg _ ) ) ) ) ( by norm_num );
    -- Since the product of (1 + 1/phi(p)^2) over primes p converges, the sum of 1/phi(q)^2 over square-free q also converges.
    have h_sum_conv : Summable (fun q : ℕ => if Squarefree q then (1 / ((Nat.totient q) ^ 2 : ℝ)) else 0) := by
      have h_exp : ∀ n : ℕ, (∏ p ∈ Finset.filter Nat.Prime (Finset.range n), (1 + (1 / ((p - 1) ^ 2 : ℝ)))) ≤ Real.exp (∑ p ∈ Finset.filter Nat.Prime (Finset.range n), Real.log (1 + (1 / ((p - 1) ^ 2 : ℝ)))) := by
        exact fun n => by rw [ Real.exp_sum, Finset.prod_congr rfl fun x hx => Real.exp_log ( by positivity ) ] ;
      have h_exp_conv : Filter.Tendsto (fun n : ℕ => Real.exp (∑ p ∈ Finset.filter Nat.Prime (Finset.range n), Real.log (1 + (1 / ((p - 1) ^ 2 : ℝ))))) Filter.atTop (nhds (Real.exp (∑' p : ℕ, if Nat.Prime p then Real.log (1 + (1 / ((p - 1) ^ 2 : ℝ))) else 0))) := by
        refine' Real.continuous_exp.continuousAt.tendsto.comp _;
        convert h_prod_conv.hasSum.tendsto_sum_nat using 1;
        exact funext fun n => by rw [ Finset.sum_filter ] ;
      refine' summable_iff_not_tendsto_nat_atTop_of_nonneg ( fun q => by positivity ) |>.2 _;
      exact fun h => not_tendsto_atTop_of_tendsto_nhds h_exp_conv <| Filter.tendsto_atTop_mono ( fun n => by simpa [ Finset.sum_filter ] using h_sum_prod n |> le_trans <| h_exp n ) h;
    convert h_sum_conv using 1