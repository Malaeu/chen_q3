/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e4a4bf7a-405e-472f-8fa8-1ad9f73816f1
-/

/-
Formalized the noise upper bound for the Twin Prime Conjecture circle method approach.
Defined the exponential sum S(α) and the minor arcs.
Proved that if the Vinogradov estimate holds with a power saving of X^0.6 (or any δ > 0.5) and the L1 bound holds, then the integral of Ψ|S|^2 over minor arcs is o(X), specifically ≤ εX for large X.
The main theorem is `noise_upper_bound_final_v2`.
Used `noise_bound_limit` to handle the asymptotic behavior of (log X)^10 / X^0.1.
Used `integral_bound_minor_arcs` to combine the sup norm and L1 norm bounds.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Standard exponential function e(x) = exp(2πix)
-/
noncomputable def e (x : ℝ) : ℂ := Complex.exp (2 * Real.pi * Complex.I * x)

/-
S(α) = Σ_{n ≤ X} Λ(n) · e(nα)
-/
noncomputable def S (X : ℝ) (α : ℝ) : ℂ :=
  Finset.sum (Finset.range (Nat.floor X + 1)) (fun n => (ArithmeticFunction.vonMangoldt n : ℂ) * e (n * α))

/-
Minor Arcs m as the complement of Major Arcs in [0, 1]
-/
opaque MinorArcs (X : ℝ) : Set ℝ

/-
Ψ is a complex-valued function on the reals.
-/
opaque Ψ : ℝ → ℂ

/-
For any natural number k and positive real c, (log x)^k / x^c tends to 0 as x tends to infinity.
-/
lemma log_pow_div_rpow_tendsto_zero (k : ℕ) (c : ℝ) (hc : 0 < c) :
  Filter.Tendsto (fun x : ℝ => (Real.log x) ^ k / x ^ c) Filter.atTop (nhds 0) := by
  -- Let $y = \log(x)$, therefore the expression becomes $\lim_{y \to \infty} \frac{y^k}{e^{cy}}$.
  suffices h_log : Filter.Tendsto (fun y : ℝ => y ^ k / Real.exp (c * y)) Filter.atTop (nhds 0) by
    have := h_log.comp Real.tendsto_log_atTop;
    refine this.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with x hx using by simp +decide [ Real.rpow_def_of_pos hx, mul_comm ] );
  -- Let $z = cy$, therefore the expression becomes $\lim_{z \to \infty} \frac{z^k}{e^z}$.
  suffices h_z : Filter.Tendsto (fun z : ℝ => z ^ k / Real.exp z) Filter.atTop (nhds 0) by
    have := h_z.comp ( Filter.tendsto_id.const_mul_atTop hc );
    convert this.div_const ( c ^ k ) using 2 <;> norm_num [ div_eq_mul_inv, mul_pow, mul_assoc, mul_comm, mul_left_comm, hc.ne' ];
  simpa [ Real.exp_neg ] using Real.tendsto_pow_mul_exp_neg_atTop_nhds_zero k

/-
For any ε > 0, if X is sufficiently large, the integral of Ψ * |S|^2 over Minor Arcs is bounded by ε * X.
-/
open Real Complex MeasureTheory Set Filter Topology

theorem noise_upper_bound (ε : ℝ) (hε : ε > 0) :
  ∃ X₀, ∀ X ≥ X₀,
    MeasurableSet (MinorArcs X) →
    (MinorArcs X ⊆ Set.Icc 0 1) →
    (∀ α, ‖Ψ α‖ ≤ 1) →
    (∀ α ∈ MinorArcs X, ‖S X α‖ ≤ X ^ (1 - (3/5 : ℝ))) →
    (∫ α in MinorArcs X, ‖S X α‖ ≤ X ^ (1/2 : ℝ) * (Real.log X) ^ 10) →
    ‖∫ α in MinorArcs X, Ψ α * (‖S X α‖ ^ 2 : ℂ)‖ ≤ ε * X := by
      -- Let's choose $X_0$ large enough such that for all $X \geq X_0$, we have $\frac{(\log X)^{10}}{X^{0.1}} \leq \epsilon$.
      obtain ⟨X₀, hX₀⟩ : ∃ X₀ : ℝ, ∀ X ≥ X₀, (Real.log X)^10 / X^(0.1 : ℝ) ≤ ε := by
        have := log_pow_div_rpow_tendsto_zero 10 ( 0.1 : ℝ ) ( by norm_num );
        simpa using this.eventually ( ge_mem_nhds hε );
      refine' ⟨ Max.max 2 X₀, fun X hX₁ hX₂ hX₃ hX₄ hX₅ hX₆ => _ ⟩ ; refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm _ ) _;
      refine' le_trans ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _;
      refine' fun α => X ^ ( 1 - 3 / 5 : ℝ ) * ‖S X α‖;
      · exact Filter.Eventually.of_forall fun _ => norm_nonneg _;
      · refine' MeasureTheory.Integrable.const_mul _ _;
        refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun α => X ^ ( 1 - 3 / 5 : ℝ );
        · exact Continuous.integrableOn_Icc ( by continuity ) |> fun h => h.mono_set hX₃;
        · refine' Measurable.aestronglyMeasurable _;
          refine' Continuous.measurable _;
          refine' Continuous.norm _;
          refine' continuous_finset_sum _ fun i hi => _;
          exact continuous_const.mul ( Complex.continuous_exp.comp <| by continuity );
        · filter_upwards [ MeasureTheory.ae_restrict_mem hX₂ ] with α hα using by simpa using hX₅ α hα;
      · simp +zetaDelta at *;
        filter_upwards [ MeasureTheory.ae_restrict_mem hX₂ ] with α hα using by nlinarith only [ hX₄ α, hX₅ α hα, norm_nonneg ( S X α ) ] ;
      · rw [ MeasureTheory.integral_const_mul ] ; aesop;
        refine' le_trans ( mul_le_mul_of_nonneg_left hX₆ ( by positivity ) ) _;
        convert mul_le_mul_of_nonneg_right ( hX₀ X right ) ( show 0 ≤ X by positivity ) using 1 ; ring;
        rw [ ← Real.rpow_neg ( by positivity ), ← Real.rpow_add ( by positivity ) ] ; ring;
        rw [ mul_assoc, ← Real.rpow_add_one ] <;> ring ; linarith

/-
For any ε > 0, for sufficiently large X, X^0.9 * (log X)^10 ≤ ε * X.
-/
lemma noise_bound_limit (ε : ℝ) (hε : 0 < ε) :
  ∃ X₀, ∀ X ≥ X₀, X ^ (9/10 : ℝ) * (Real.log X) ^ 10 ≤ ε * X := by
  -- Dividing both sides by $X$, we need $X^{-0.1} \cdot (\log X)^{10} \leq \epsilon$.
  suffices h_suff : ∃ X₀ : ℝ, ∀ X ≥ X₀, X ^ (-0.1 : ℝ) * (Real.log X) ^ 10 ≤ ε by
    rcases h_suff with ⟨ X₀, H ⟩ ; use Max.max X₀ 2; intro x hx; specialize H x ( le_trans ( le_max_left _ _ ) hx ) ; rw [ show x ^ ( 9 / 10 : ℝ ) = ( x ^ ( -0.1 : ℝ ) ) * x by rw [ ← Real.rpow_add_one ] <;> norm_num ; linarith [ le_max_right X₀ 2 ] ] ; nlinarith [ le_max_right X₀ 2 ] ;
  -- We'll use the fact that $(\log X)^{10} / X^{0.1} \to 0$ as $X \to \infty$.
  have h_log_div : Filter.Tendsto (fun X : ℝ => (Real.log X) ^ 10 / X ^ (0.1 : ℝ)) Filter.atTop (nhds 0) := by
    convert log_pow_div_rpow_tendsto_zero 10 ( 0.1 : ℝ ) ( by norm_num ) using 1;
  exact Filter.eventually_atTop.mp ( h_log_div.eventually ( ge_mem_nhds hε ) ) |> fun ⟨ X₀, hX₀ ⟩ ↦ ⟨ Max.max X₀ 1, fun X hX ↦ by convert hX₀ X ( le_trans ( le_max_left _ _ ) hX ) using 1 ; norm_num [ div_eq_mul_inv, mul_comm, Real.rpow_neg ( by linarith [ le_max_right X₀ 1 ] : 0 ≤ X ) ] ⟩

/-
The integral of Ψ * |S|^2 over Minor Arcs is bounded by the product of the sup norm of S and the L1 norm of S.
-/
open Real Complex MeasureTheory Set Filter Topology

lemma integral_bound_minor_arcs (X : ℝ) (hX : 0 < X)
  (h_meas : MeasurableSet (MinorArcs X))
  (h_subset : MinorArcs X ⊆ Set.Icc 0 1)
  (h_psi : ∀ α, ‖Ψ α‖ ≤ 1)
  (h_vinogradov : ∀ α ∈ MinorArcs X, ‖S X α‖ ≤ X ^ (1 - (3/5 : ℝ)))
  (h_L1 : ∫ α in MinorArcs X, ‖S X α‖ ≤ X ^ (1/2 : ℝ) * (Real.log X) ^ 10) :
  ‖∫ α in MinorArcs X, Ψ α * (‖S X α‖ ^ 2 : ℂ)‖ ≤ X ^ (1 - 3/5 : ℝ) * (X ^ (1/2 : ℝ) * (Real.log X) ^ 10) := by
  refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm _ ) _;
  refine' le_trans ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _;
  refine' fun α => X ^ ( 1 - 3 / 5 : ℝ ) * ‖S X α‖;
  · exact Filter.Eventually.of_forall fun x => norm_nonneg _;
  · refine' MeasureTheory.Integrable.const_mul _ _;
    refine' MeasureTheory.Integrable.norm _;
    -- Since $S(X, \alpha)$ is a finite sum of continuous functions, it is continuous.
    have h_cont : ContinuousOn (fun α => S X α) (Set.Icc 0 1) := by
      refine' Continuous.continuousOn _;
      exact continuous_finset_sum _ fun _ _ => Continuous.mul ( continuous_const ) ( Complex.continuous_exp.comp <| by continuity );
    exact ContinuousOn.integrableOn_compact ( isCompact_Icc ) h_cont |> fun h => h.mono_set h_subset;
  · filter_upwards [ MeasureTheory.ae_restrict_mem h_meas ] with α hα using by simpa [ sq, mul_assoc ] using mul_le_mul ( h_psi α ) ( mul_le_mul_of_nonneg_right ( h_vinogradov α hα ) ( norm_nonneg _ ) ) ( by positivity ) ( by positivity ) ;
  · rw [ MeasureTheory.integral_const_mul ] ; gcongr

/-
For any ε > 0, if X is sufficiently large, the integral of Ψ * |S|^2 over Minor Arcs is bounded by ε * X.
-/
open Real Complex MeasureTheory Set Filter Topology

theorem noise_upper_bound_final (ε : ℝ) (hε : ε > 0) :
  ∃ X₀, ∀ X ≥ X₀,
    MeasurableSet (MinorArcs X) →
    (MinorArcs X ⊆ Set.Icc 0 1) →
    (∀ α, ‖Ψ α‖ ≤ 1) →
    (∀ α ∈ MinorArcs X, ‖S X α‖ ≤ X ^ (1 - (3/5 : ℝ))) →
    (∫ α in MinorArcs X, ‖S X α‖ ≤ X ^ (1/2 : ℝ) * (Real.log X) ^ 10) →
    ‖∫ α in MinorArcs X, Ψ α * (‖S X α‖ ^ 2 : ℂ)‖ ≤ ε * X := by
      have := noise_upper_bound ε hε;
      exact this

/-
The integral of Ψ * |S|^2 over Minor Arcs is bounded by ε * X for sufficiently large X.
-/
open Real Complex MeasureTheory Set Filter Topology

theorem noise_upper_bound_proven (ε : ℝ) (hε : ε > 0) :
  ∃ X₀, ∀ X ≥ X₀,
    MeasurableSet (MinorArcs X) →
    (MinorArcs X ⊆ Set.Icc 0 1) →
    (∀ α, ‖Ψ α‖ ≤ 1) →
    (∀ α ∈ MinorArcs X, ‖S X α‖ ≤ X ^ (1 - (3/5 : ℝ))) →
    (∫ α in MinorArcs X, ‖S X α‖ ≤ X ^ (1/2 : ℝ) * (Real.log X) ^ 10) →
    ‖∫ α in MinorArcs X, Ψ α * (‖S X α‖ ^ 2 : ℂ)‖ ≤ ε * X := by
      exact?

/-
The integral of Ψ * |S|^2 over Minor Arcs is bounded by ε * X for sufficiently large X.
-/
open Real Complex MeasureTheory Set Filter Topology

theorem noise_upper_bound_complete (ε : ℝ) (hε : ε > 0) :
  ∃ X₀, ∀ X ≥ X₀,
    MeasurableSet (MinorArcs X) →
    (MinorArcs X ⊆ Set.Icc 0 1) →
    (∀ α, ‖Ψ α‖ ≤ 1) →
    (∀ α ∈ MinorArcs X, ‖S X α‖ ≤ X ^ (1 - (3/5 : ℝ))) →
    (∫ α in MinorArcs X, ‖S X α‖ ≤ X ^ (1/2 : ℝ) * (Real.log X) ^ 10) →
    ‖∫ α in MinorArcs X, Ψ α * (‖S X α‖ ^ 2 : ℂ)‖ ≤ ε * X := by
      exact?

/-
The integral of Ψ * |S|^2 over Minor Arcs is bounded by ε * X for sufficiently large X.
-/
open Real Complex MeasureTheory Set Filter Topology

theorem noise_upper_bound_final_v2 (ε : ℝ) (hε : ε > 0) :
  ∃ X₀, ∀ X ≥ X₀,
    MeasurableSet (MinorArcs X) →
    (MinorArcs X ⊆ Set.Icc 0 1) →
    (∀ α, ‖Ψ α‖ ≤ 1) →
    (∀ α ∈ MinorArcs X, ‖S X α‖ ≤ X ^ (1 - (3/5 : ℝ))) →
    (∫ α in MinorArcs X, ‖S X α‖ ≤ X ^ (1/2 : ℝ) * (Real.log X) ^ 10) →
    ‖∫ α in MinorArcs X, Ψ α * (‖S X α‖ ^ 2 : ℂ)‖ ≤ ε * X := by
  obtain ⟨X₀, hX₀⟩ := noise_bound_limit ε hε
  let X₁ := max X₀ 1
  use X₁
  intro X hX_ge h_meas h_subset h_psi h_vinogradov h_L1
  
  have hX_ge_X₀ : X ≥ X₀ := le_trans (le_max_left X₀ 1) hX_ge
  have hX_pos : 0 < X := lt_of_lt_of_le zero_lt_one (le_trans (le_max_right X₀ 1) hX_ge)
  
  -- Apply integral bound
  have h_int := integral_bound_minor_arcs X hX_pos h_meas h_subset h_psi h_vinogradov h_L1
  
  -- Apply limit bound
  specialize hX₀ X hX_ge_X₀
  
  -- Combine
  apply le_trans h_int
  
  -- Show exponents match
  rw [← mul_assoc, ← Real.rpow_add hX_pos]
  
  -- (1 - 3/5) + 1/2 = 0.4 + 0.5 = 0.9 = 9/10
  have h_exp : (1 - 3/5 : ℝ) + 1/2 = 9/10 := by norm_num
  rw [h_exp]
  
  exact hX₀