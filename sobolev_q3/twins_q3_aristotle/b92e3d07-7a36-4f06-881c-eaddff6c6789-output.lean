/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b92e3d07-7a36-4f06-881c-eaddff6c6789

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Twin primes definition
-/
def TwinPrime (p : ℕ) : Prop := Nat.Prime p ∧ Nat.Prime (p + 2)

/-
Definitions of twin prime count and exponential sum over twin primes.
-/
def twinCount (N : ℕ) : ℕ := (Finset.filter TwinPrime (Finset.range (N + 1))).card

noncomputable def twinExpSum (α : ℝ) (f : ℕ → ℝ) (N : ℕ) : ℂ :=
  Finset.sum (Finset.filter (fun p => TwinPrime p ∧ p ≤ N) (Finset.range (N + 1)))
    (fun p => Complex.exp (2 * Real.pi * Complex.I * α * f p))

/-
For a twin prime p > 5, if p = 6k - 1, then k mod 5 is 0, 2, or 3.
-/
lemma twin_prime_mod_five {p : ℕ} (hp : TwinPrime p) (h_gt_5 : p > 5) :
  ∃ k, p = 6 * k - 1 ∧ (k % 5 = 0 ∨ k % 5 = 2 ∨ k % 5 = 3) := by
  -- Since p is a twin prime > 5, p = 6k - 1 for some k by twin_prime_mod_six.
  obtain ⟨k, hk⟩ : ∃ k, p = 6 * k - 1 := by
    -- Since p is a twin prime greater than 5, it must be of the form 6k-1.
    have hp_form : p % 6 = 5 := by
      have hp_mod : p % 2 = 1 ∧ p % 3 ≠ 0 := by
        exact ⟨ hp.1.eq_two_or_odd.resolve_left ( by linarith ), fun h => by have := Nat.dvd_of_mod_eq_zero h; rw [ hp.1.dvd_iff_eq ] at this <;> linarith ⟩;
      rw [ ← Nat.mod_mod_of_dvd p ( by decide : 2 ∣ 6 ), ← Nat.mod_mod_of_dvd p ( by decide : 3 ∣ 6 ) ] at hp_mod; have := Nat.mod_lt p ( by decide : 6 > 0 ) ; interval_cases _ : p % 6 <;> simp_all +decide ;
      exact absurd ( Nat.dvd_of_mod_eq_zero ( show ( p + 2 ) % 3 = 0 by omega ) ) ( by rw [ hp.2.dvd_iff_eq ] <;> linarith );
    exact ⟨ p / 6 + 1, by omega ⟩;
  refine' ⟨ k, hk, _ ⟩;
  have := Nat.mod_lt k ( by decide : 5 > 0 ) ; interval_cases _ : k % 5 <;> simp_all +decide;
  · have := Nat.dvd_of_mod_eq_zero ( show ( 6 * k - 1 ) % 5 = 0 by omega ) ; rw [ hp.1.dvd_iff_eq ] at this <;> omega;
  · have := Nat.dvd_of_mod_eq_zero ( show ( 6 * k - 1 + 2 ) % 5 = 0 from by omega ) ; rw [ hp.2.dvd_iff_eq ] at this <;> omega;

/-
Bound for a geometric sum with ratio on the unit circle.
-/
lemma geometric_sum_bound (θ : ℝ) (hθ : ‖Complex.exp (2 * Real.pi * Complex.I * θ) - 1‖ ≠ 0) (N : ℕ) :
  ‖∑ n ∈ Finset.range N, Complex.exp (2 * Real.pi * Complex.I * n * θ)‖ ≤ 2 / ‖Complex.exp (2 * Real.pi * Complex.I * θ) - 1‖ := by
  -- The sum is a geometric series $\sum_{n=0}^{N-1} r^n = \frac{1-r^N}{1-r}$.
  have h_geo_series : ∑ n ∈ Finset.range N, Complex.exp (2 * Real.pi * Complex.I * n * θ) = (1 - Complex.exp (2 * Real.pi * Complex.I * N * θ)) / (1 - Complex.exp (2 * Real.pi * Complex.I * θ)) := by
    rw [ eq_div_iff ];
    · induction N <;> simp_all +decide [ Finset.sum_range_succ, Complex.exp_add, mul_add, add_mul ];
      ring;
    · exact sub_ne_zero_of_ne <| Ne.symm <| by aesop;
  simp_all +decide [ div_eq_inv_mul, norm_sub_rev ];
  exact le_trans ( norm_sub_le _ _ ) ( by norm_num [ Complex.norm_exp ] )

/-
Bound for the sum of exponentials over valid residues modulo 5.
-/
lemma block_bound :
  let β := 6 * Real.log 3
  ‖1 + Complex.exp (2 * Real.pi * Complex.I * 2 * β) + Complex.exp (2 * Real.pi * Complex.I * 3 * β)‖ < 3 := by
  norm_num [ Complex.norm_def, Complex.normSq, Complex.exp_re, Complex.exp_im ];
  rw [ Real.sqrt_lt' ] <;> norm_num [ Complex.log_re, Complex.log_im ] ; ring_nf;
  -- Since $\cos(\pi \cdot \log 3 \cdot 12) \neq 1$, we have $\cos(\pi \cdot \log 3 \cdot 12) < 1$.
  have h_cos_lt_1 : Real.cos (Real.pi * Real.log 3 * 12) < 1 := by
    by_contra h_cos_eq_one
    have h_cos_eq_one' : ∃ k : ℤ, Real.pi * Real.log 3 * 12 = 2 * k * Real.pi := by
      have h_cos_eq_one' : Real.cos (Real.pi * Real.log 3 * 12) = 1 := by
        linarith [ Real.cos_le_one ( Real.pi * Real.log 3 * 12 ) ];
      rw [ Real.cos_eq_one_iff ] at h_cos_eq_one'; obtain ⟨ k, hk ⟩ := h_cos_eq_one'; exact ⟨ k, by linarith ⟩ ;
    -- Dividing both sides of the equation by $2\pi$, we get $6 \ln 3 = k$.
    obtain ⟨k, hk⟩ : ∃ k : ℤ, 6 * Real.log 3 = k := by
      exact h_cos_eq_one'.imp fun k hk => by nlinarith [ Real.pi_pos ] ;
    -- Since $6 \ln 3$ is not an integer, we have a contradiction.
    have h_not_int : ¬ ∃ k : ℤ, 6 * Real.log 3 = k := by
      -- We'll use that $6 \ln 3$ is not an integer. We can calculate that $6 \ln 3 \approx 6.59167$.
      have h_not_int : 6 * Real.log 3 > 6 ∧ 6 * Real.log 3 < 7 := by
        norm_num [ ← Real.log_rpow, Real.lt_log_iff_exp_lt, Real.log_lt_iff_lt_exp ];
        exact ⟨ by have := Real.exp_one_lt_d9.le; norm_num1 at *; rw [ show Real.exp 6 = ( Real.exp 1 ) ^ 6 by rw [ ← Real.exp_nat_mul ] ; norm_num ] ; exact lt_of_le_of_lt ( pow_le_pow_left₀ ( by positivity ) this _ ) ( by norm_num ), by have := Real.exp_one_gt_d9.le; norm_num1 at *; rw [ show Real.exp 7 = ( Real.exp 1 ) ^ 7 by rw [ ← Real.exp_nat_mul ] ; norm_num ] ; exact lt_of_lt_of_le ( by norm_num ) ( pow_le_pow_left₀ ( by positivity ) this _ ) ⟩;
      exact fun ⟨ k, hk ⟩ => by rcases k with ⟨ _ | _ | _ | _ | _ | _ | _ | _ | k ⟩ <;> norm_num at hk <;> linarith;
    exact h_not_int ⟨ k, hk ⟩;
  rw [ show Real.pi * Real.log 3 * 24 = 2 * ( Real.pi * Real.log 3 * 12 ) by ring, show Real.pi * Real.log 3 * 36 = 3 * ( Real.pi * Real.log 3 * 12 ) by ring, Real.cos_two_mul, Real.sin_two_mul, Real.cos_three_mul, Real.sin_three_mul ] ; ring_nf at *;
  rw [ show Real.sin ( Real.pi * Real.log 3 * 12 ) ^ 4 = ( Real.sin ( Real.pi * Real.log 3 * 12 ) ^ 2 ) ^ 2 by ring, show Real.sin ( Real.pi * Real.log 3 * 12 ) ^ 6 = ( Real.sin ( Real.pi * Real.log 3 * 12 ) ^ 2 ) ^ 3 by ring, Real.sin_sq ] ; nlinarith [ mul_self_nonneg ( Real.cos ( Real.pi * Real.log 3 * 12 ) - 1 ), mul_self_nonneg ( Real.cos ( Real.pi * Real.log 3 * 12 ) + 1 ), pow_pos ( sub_pos.mpr h_cos_lt_1 ) 3, pow_pos ( sub_pos.mpr h_cos_lt_1 ) 4, pow_pos ( sub_pos.mpr h_cos_lt_1 ) 5 ]

/-
Bounds for 30*ln(3) and 6*ln(3).
-/
lemma log_three_approx :
  32.95 < 30 * Real.log 3 ∧ 30 * Real.log 3 < 32.97 ∧
  6.59 < 6 * Real.log 3 ∧ 6 * Real.log 3 < 6.60 := by
  refine' ⟨ _, _, _, _ ⟩;
  · norm_num [ ← Real.log_rpow, Real.lt_log_iff_exp_lt ];
    have := Real.exp_one_lt_d9.le;
    rw [ show Real.exp ( 659 / 20 ) = ( Real.exp 1 ) ^ 32 * Real.exp ( 19 / 20 ) by rw [ ← Real.exp_nat_mul, ← Real.exp_add ] ; norm_num ];
    exact lt_of_le_of_lt ( mul_le_mul_of_nonneg_right ( pow_le_pow_left₀ ( by positivity ) this _ ) ( by positivity ) ) ( by have := Real.exp_one_lt_d9.le; norm_num1 at *; rw [ show Real.exp ( 19 / 20 ) = Real.exp 1 / Real.exp ( 1 / 20 ) by rw [ ← Real.exp_sub ] ; norm_num ] ; rw [ mul_div, div_lt_iff₀ ( by positivity ) ] ; nlinarith [ Real.add_one_le_exp 1, Real.add_one_le_exp ( 1 / 20 ) ] );
  · rw [ ← Real.log_rpow ( by norm_num ) ];
    rw [ Real.log_lt_iff_lt_exp ( by positivity ) ];
    have := Real.exp_one_gt_d9.le;
    rw [ show Real.exp 32.97 = ( Real.exp 1 ) ^ 32 * Real.exp ( 0.97 ) by rw [ ← Real.exp_nat_mul, ← Real.exp_add ] ; norm_num ];
    -- We'll use that $e^{0.97} > 2.63$ to conclude the proof.
    have h_exp_0_97 : Real.exp 0.97 > 2.63 := by
      norm_num [ Real.exp_eq_exp_ℝ, NormedSpace.exp_eq_tsum_div ] at *;
      exact lt_of_lt_of_le ( by norm_num [ Finset.sum_range_succ, Nat.factorial ] ) ( Summable.sum_le_tsum ( Finset.range 10 ) ( fun _ _ => by positivity ) ( by exact Real.summable_pow_div_factorial _ ) );
    exact lt_of_lt_of_le ( by norm_num ) ( mul_le_mul ( pow_le_pow_left₀ ( by norm_num ) this _ ) h_exp_0_97.le ( by positivity ) ( by positivity ) );
  · norm_num [ ← Real.log_rpow, Real.lt_log_iff_exp_lt ];
    have := Real.exp_one_lt_d9.le;
    rw [ show Real.exp ( 659 / 100 ) = ( Real.exp 1 ) ^ ( 659 / 100 : ℝ ) by rw [ ← Real.exp_mul ] ; norm_num ];
    refine' lt_of_le_of_lt ( Real.rpow_le_rpow ( by positivity ) this ( by norm_num ) ) _ ; norm_num;
    rw [ ← Real.log_lt_log_iff ( by positivity ) ( by positivity ), Real.log_rpow ] <;> norm_num;
    field_simp;
    rw [ ← Real.log_rpow, ← Real.log_rpow, Real.log_lt_log_iff ] <;> norm_num;
    field_simp;
    norm_cast;
  · norm_num [ ← Real.log_rpow, Real.log_lt_log ];
    rw [ lt_div_iff₀' ] <;> norm_num;
    rw [ ← Real.log_rpow, Real.log_lt_iff_lt_exp ] <;> norm_num;
    have := Real.exp_one_gt_d9.le ; norm_num1 at * ; rw [ show Real.exp 33 = ( Real.exp 1 ) ^ 33 by rw [ ← Real.exp_nat_mul ] ; norm_num ] ; exact lt_of_lt_of_le ( by norm_num ) ( pow_le_pow_left₀ ( by positivity ) this _ )

/-
Dummy theorem to recover parser state.
-/
theorem dummy_recovery : True := by
  trivial

/-
The smooth part of the twin prime sum is bounded.
-/
lemma smooth_sum_bounded :
  ∃ C, ∀ N, ‖Finset.sum (Finset.range (N + 1)) (fun k =>
    (if k % 5 = 0 ∨ k % 5 = 2 ∨ k % 5 = 3 then ((1 / (Real.log ((k : ℝ) + 2))^2) : ℂ) else 0) *
    Complex.exp (2 * Real.pi * Complex.I * ((6 * k - 1) : ℂ) * Real.log 3))‖ ≤ C := by
  have candidate_sum_bound : ∃ C : ℝ, ∀ N : ℕ, ‖∑ k ∈ Finset.range (N + 1), (if k % 5 = 0 ∨ k % 5 = 2 ∨ k % 5 = 3 then Complex.exp (2 * Real.pi * Complex.I * (6 * k - 1) * Real.log 3) else 0)‖ ≤ C := by
    have candidate_sum_bound : ∃ C : ℝ, ∀ N : ℕ, ‖∑ k ∈ Finset.range (N + 1), (if k % 5 = 0 ∨ k % 5 = 2 ∨ k % 5 = 3 then Complex.exp (2 * Real.pi * Complex.I * 6 * k * Real.log 3) else 0)‖ ≤ C := by
      have candidate_sum_bound : ∃ C : ℝ, ∀ N : ℕ, ‖∑ k ∈ Finset.range (N + 1), (if k % 5 = 0 ∨ k % 5 = 2 ∨ k % 5 = 3 then Complex.exp (2 * Real.pi * Complex.I * 6 * k * Real.log 3) else 0)‖ ≤ C := by
        have h_geom_sum : ∀ N : ℕ, ‖∑ k ∈ Finset.range (N + 1), (if k % 5 = 0 ∨ k % 5 = 2 ∨ k % 5 = 3 then Complex.exp (2 * Real.pi * Complex.I * 6 * k * Real.log 3) else 0)‖ ≤ ∑ i ∈ Finset.range 5, ‖∑ k ∈ Finset.range ((N + 1 + 4 - i) / 5), Complex.exp (2 * Real.pi * Complex.I * 6 * (5 * k + i) * Real.log 3) * (if i = 0 ∨ i = 2 ∨ i = 3 then 1 else 0)‖ := by
          intro N
          have h_split : Finset.range (N + 1) = Finset.biUnion (Finset.range 5) (fun i => Finset.image (fun k => 5 * k + i) (Finset.range ((N + 1 + 4 - i) / 5))) := by
            ext x
            simp [Finset.mem_range, Finset.mem_biUnion, Finset.mem_image];
            exact ⟨ fun hx => ⟨ x % 5, Nat.mod_lt _ ( by decide ), x / 5, Nat.div_lt_of_lt_mul <| by omega, by omega ⟩, by rintro ⟨ a, ha, b, hb, rfl ⟩ ; omega ⟩;
          rw [ h_split, Finset.sum_biUnion ];
          · convert norm_sum_le _ _ using 2 ; norm_num [ Finset.sum_image ];
            rename_i i hi; fin_cases hi <;> rfl;
          · exact fun i hi j hj hij => Finset.disjoint_left.mpr fun x hx₁ hx₂ => hij <| by norm_num at *; omega;
        -- Each geometric sum is bounded by a constant, so the total sum is also bounded.
        have h_geo_bound : ∀ i ∈ Finset.range 5, ∃ C_i : ℝ, ∀ N : ℕ, ‖∑ k ∈ Finset.range N, Complex.exp (2 * Real.pi * Complex.I * 6 * (5 * k + i) * Real.log 3)‖ ≤ C_i := by
          intro i hi
          have h_geo_series : ∀ N : ℕ, ∑ k ∈ Finset.range N, Complex.exp (2 * Real.pi * Complex.I * 6 * (5 * k + i) * Real.log 3) = Complex.exp (2 * Real.pi * Complex.I * 6 * i * Real.log 3) * ∑ k ∈ Finset.range N, (Complex.exp (2 * Real.pi * Complex.I * 30 * Real.log 3)) ^ k := by
            exact fun N => by rw [ Finset.mul_sum _ _ _ ] ; exact Finset.sum_congr rfl fun _ _ => by rw [ ← Complex.exp_nat_mul ] ; rw [ ← Complex.exp_add ] ; ring;
          by_cases h : Complex.exp ( 2 * Real.pi * Complex.I * 30 * Real.log 3 ) = 1 <;> simp_all +decide [ geom_sum_eq ];
          · rw [ Complex.exp_eq_one_iff ] at h;
            obtain ⟨ n, hn ⟩ := h; norm_num [ Complex.ext_iff, Complex.log_re, Complex.log_im ] at hn;
            -- Simplify the equation $2 * π * 30 * Real.log 3 = n * (2 * π)$ to get $30 * Real.log 3 = n$.
            have h_simplified : 30 * Real.log 3 = n := by
              nlinarith [ Real.pi_pos ];
            have := log_three_approx; norm_num at this; rcases n with ⟨ _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | n ⟩ <;> norm_num at h_simplified <;> linarith;
          · norm_num [ Complex.norm_exp ];
            refine' ⟨ Real.exp ( - ( 2 * Real.pi * 6 * i * ( Complex.log 3 |> Complex.im ) ) ) * ( 2 / ‖Complex.exp ( 2 * Real.pi * Complex.I * 30 * Complex.log 3 ) - 1‖ ), fun N => mul_le_mul_of_nonneg_left ( div_le_div_of_nonneg_right ( _ ) ( norm_nonneg _ ) ) ( Real.exp_nonneg _ ) ⟩;
            refine' le_trans ( norm_sub_le _ _ ) _ ; norm_num [ Complex.norm_exp ];
            norm_num [ Complex.log_im ];
        choose! C hC using h_geo_bound;
        use ∑ i ∈ Finset.range 5, C i * ( if i = 0 ∨ i = 2 ∨ i = 3 then 1 else 0 );
        intro N; refine le_trans ( h_geom_sum N ) ?_; refine Finset.sum_le_sum fun i hi => ?_; specialize hC i hi ( ( N + 1 + 4 - i ) / 5 ) ; aesop;
      exact candidate_sum_bound;
    obtain ⟨ C, hC ⟩ := candidate_sum_bound; use C; intro N; convert hC N using 1; simp +decide [ sub_mul, mul_sub, Complex.exp_sub ] ; ring;
    norm_num [ Complex.exp_ne_zero, mul_assoc, mul_comm, mul_left_comm, Finset.sum_ite ];
    rw [ ← Finset.mul_sum _ _ _ ] ; rw [ Complex.norm_mul ] ; norm_num [ Complex.norm_exp ] ;
    norm_num [ Complex.log_im ];
  -- Apply summation by parts to the smooth sum.
  have smooth_sum_parts : ∀ N : ℕ, ∑ k ∈ Finset.range (N + 1), (if k % 5 = 0 ∨ k % 5 = 2 ∨ k % 5 = 3 then (1 / (Real.log (k + 2)) ^ 2 : ℂ) else 0) * Complex.exp (2 * Real.pi * Complex.I * (6 * k - 1) * Real.log 3) = (∑ k ∈ Finset.range (N + 1), (1 / (Real.log (k + 2)) ^ 2 - 1 / (Real.log (k + 3)) ^ 2) * (∑ j ∈ Finset.range (k + 1), (if j % 5 = 0 ∨ j % 5 = 2 ∨ j % 5 = 3 then Complex.exp (2 * Real.pi * Complex.I * (6 * j - 1) * Real.log 3) else 0))) + (1 / (Real.log (N + 3)) ^ 2) * (∑ j ∈ Finset.range (N + 1), (if j % 5 = 0 ∨ j % 5 = 2 ∨ j % 5 = 3 then Complex.exp (2 * Real.pi * Complex.I * (6 * j - 1) * Real.log 3) else 0)) := by
    intro N;
    induction' N with N ih;
    · norm_num;
      ring;
    · rw [ Finset.sum_range_succ, ih ];
      norm_num [ Finset.sum_range_succ ];
      norm_num [ add_assoc, Finset.sum_add_distrib, mul_add, add_mul, sub_mul, mul_sub ] ; ring;
      split_ifs <;> ring;
  -- Apply the bound on the candidate sum to the smooth sum.
  obtain ⟨C, hC⟩ := candidate_sum_bound;
  have smooth_sum_bound : ∀ N : ℕ, ‖∑ k ∈ Finset.range (N + 1), (if k % 5 = 0 ∨ k % 5 = 2 ∨ k % 5 = 3 then (1 / (Real.log (k + 2)) ^ 2 : ℂ) else 0) * Complex.exp (2 * Real.pi * Complex.I * (6 * k - 1) * Real.log 3)‖ ≤ C * (∑ k ∈ Finset.range (N + 1), (1 / (Real.log (k + 2)) ^ 2 - 1 / (Real.log (k + 3)) ^ 2)) + C * (1 / (Real.log (N + 3)) ^ 2) := by
    intros N
    rw [smooth_sum_parts N];
    refine' le_trans ( norm_add_le _ _ ) ( add_le_add _ _ );
    · refine' le_trans ( norm_sum_le _ _ ) _;
      rw [ Finset.mul_sum _ _ _ ];
      refine' Finset.sum_le_sum fun i hi => _;
      rw [ norm_mul ];
      rw [ mul_comm ] ; gcongr;
      · exact le_trans ( norm_nonneg _ ) ( hC 0 );
      · exact hC i;
      · norm_cast;
        rw [ Real.norm_of_nonneg ( sub_nonneg_of_le <| one_div_le_one_div_of_le ( sq_pos_of_pos <| Real.log_pos <| by norm_cast; linarith ) <| pow_le_pow_left₀ ( Real.log_nonneg <| by norm_cast; linarith ) ( Real.log_le_log ( by positivity ) <| by norm_cast; linarith ) _ ) ];
    · norm_num +zetaDelta at *;
      rw [ mul_comm ] ; gcongr ; exact hC N;
  -- Notice that the series $\sum_{k=0}^{N} \left( \frac{1}{(\ln(k+2))^2} - \frac{1}{(\ln(k+3))^2} \right)$ is telescoping.
  have telecoping_series : ∀ N : ℕ, ∑ k ∈ Finset.range (N + 1), (1 / (Real.log (k + 2)) ^ 2 - 1 / (Real.log (k + 3)) ^ 2) = 1 / (Real.log 2) ^ 2 - 1 / (Real.log (N + 3)) ^ 2 := by
    exact fun N => by induction' N with N ih <;> norm_num [ add_assoc, Finset.sum_range_succ ] at * ; linear_combination ih;
  exact ⟨ C * ( 1 / Real.log 2 ^ 2 ), fun N => le_trans ( smooth_sum_bound N ) ( by rw [ telecoping_series N ] ; nlinarith [ show 0 ≤ C by exact le_trans ( norm_nonneg _ ) ( hC 0 ) ] ) ⟩