/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9fd458a5-f091-4fc5-afe1-d7c494d171e5

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

noncomputable def heat_kernel (t : ℝ) (x y : ℝ) : ℝ :=
  Real.exp (-(x - y)^2 / (4 * t))

noncomputable def prime_node (p : ℕ) : ℝ := Real.log p / (2 * Real.pi)

def nodes_in_window (K : ℝ) (N : ℕ) : Finset ℕ :=
  (Finset.range (N + 1)).filter (fun n =>
    Nat.Prime n ∧ |prime_node n| ≤ K)

noncomputable def prime_weight (n : ℕ) : ℝ :=
  if Nat.Prime n then Real.log n / Real.sqrt n else 0

lemma prime_weight_bound (n : ℕ) (hn : Nat.Prime n) (hn3 : n ≥ 3) :
  prime_weight n ≤ 2 / Real.exp 1 := by
    unfold prime_weight;
    -- We'll use the fact that $f(x) = \frac{\log x}{\sqrt{x}}$ is maximized at $x = e^2$.
    have h_max : ∀ x : ℝ, x > 0 → Real.log x / Real.sqrt x ≤ 2 / Real.exp 1 := by
      intro x hx_pos
      have h_max : Real.log x ≤ 2 * Real.sqrt x / Real.exp 1 := by
        have := Real.log_le_sub_one_of_pos ( show 0 < Real.sqrt x / Real.exp 1 by positivity );
        rw [ Real.log_div ( by positivity ) ( by positivity ), Real.log_sqrt hx_pos.le, Real.log_exp ] at this ; ring_nf at this ⊢ ; linarith;
      rw [ div_le_iff₀ ] <;> first | positivity | convert h_max using 1 ; ring;
    exact if_pos hn ▸ h_max _ ( Nat.cast_pos.mpr hn.pos )

noncomputable def gram_matrix (t : ℝ) (nodes : Finset ℕ) : Matrix (Fin nodes.card) (Fin nodes.card) ℝ :=
  fun i j => heat_kernel t (prime_node (nodes.toList[i])) (prime_node (nodes.toList[j]))

noncomputable def twisted_prime_matrix (t α : ℝ) (nodes : Finset ℕ) :
    Matrix (Fin nodes.card) (Fin nodes.card) ℂ :=
  fun i j =>
    let m := nodes.toList[i]
    let n := nodes.toList[j]
    (prime_weight n : ℂ) *
    Complex.exp (2 * Real.pi * Complex.I * α * prime_node n) *
    (gram_matrix t nodes i j : ℂ)

def minor_arcs (N : ℕ) : Set ℝ :=
  {α : ℝ | ∀ (a : ℤ) (q : ℕ), q ≤ (N : ℝ)^(1/10 : ℝ) → |α - a/q| > 1/(q * N)}

#check Matrix.instL2OpNormedRing

#check EuclideanSpace

attribute [local instance] Matrix.instL2OpNormedRing

lemma operator_norm_bound (t α : ℝ) (nodes : Finset ℕ) :
  ‖twisted_prime_matrix t α nodes‖ ≤
  Real.sqrt (∑ i, ∑ j, ‖twisted_prime_matrix t α nodes i j‖^2) := by
  refine' csInf_le _ _;
  · exact ⟨ 0, fun c hc => hc.1 ⟩;
  · refine' ⟨ Real.sqrt_nonneg _, fun x => _ ⟩;
    rw [ EuclideanSpace.norm_eq ];
    -- Apply the triangle inequality to the sum.
    have h_triangle : ∀ i, ‖∑ j, (twisted_prime_matrix t α nodes) i j * x j‖^2 ≤ (∑ j, ‖(twisted_prime_matrix t α nodes) i j‖^2) * (∑ j, ‖x j‖^2) := by
      -- Apply the Cauchy-Schwarz inequality to the sum.
      have h_cauchy_schwarz : ∀ i, ‖∑ j, (twisted_prime_matrix t α nodes) i j * x j‖^2 ≤ (∑ j, ‖(twisted_prime_matrix t α nodes) i j‖ * ‖x j‖)^2 := by
        exact fun i => pow_le_pow_left₀ ( norm_nonneg _ ) ( norm_sum_le _ _ |> le_trans <| Finset.sum_le_sum fun _ _ => by rw [ norm_mul ] ) _;
      exact fun i => le_trans ( h_cauchy_schwarz i ) ( by exact? );
    refine' Real.sqrt_le_iff.mpr ⟨ _, _ ⟩;
    · positivity;
    · refine' le_trans ( Finset.sum_le_sum fun i _ => h_triangle i ) _;
      norm_num [ mul_pow, EuclideanSpace.norm_eq ];
      rw [ Real.sq_sqrt ( Finset.sum_nonneg fun _ _ => Finset.sum_nonneg fun _ _ => sq_nonneg _ ), Real.sq_sqrt ( Finset.sum_nonneg fun _ _ => sq_nonneg _ ) ];
      rw [ Finset.sum_mul _ _ _ ]

attribute [local instance] Matrix.instL2OpNormedRing

lemma exp_sum_operator_connection (α : ℝ) (N : ℕ) :
  ∃ (k : ℕ) (v : Fin k → ℂ) (M : Matrix (Fin k) (Fin k) ℂ),
    ‖∑ n ∈ Finset.range (N+1),
      (if Nat.Prime n then (Real.log n : ℂ) else 0) * Complex.exp (2 * Real.pi * Complex.I * α * n)‖
    ≤ ‖M‖ * ‖v‖^2 := by
  -- Let's choose k=1, v=1, and M as the sum itself.
  use 1, fun _ => 1, fun _ _ => ∑ n ∈ Finset.range (N + 1), (if Nat.Prime n then (Real.log n : ℂ) else 0) * Complex.exp (2 * Real.pi * Complex.I * α * n);
  -- Since the norm of the matrix is the absolute value of the sum, we have:
  simp [Matrix.norm_def];
  refine' le_trans _ ( le_csInf _ _ );
  exact?;
  · use ‖(Matrix.toEuclideanLin.trans LinearMap.toContinuousLinearMap : Matrix (Fin 1) (Fin 1) ℂ → EuclideanSpace ℂ (Fin 1) →L[ℂ] EuclideanSpace ℂ (Fin 1)) fun (x x : Fin 1) => ∑ x ∈ Finset.range (N + 1), if Nat.Prime x then Complex.log (↑x : ℂ) * Complex.exp (2 * (↑π : ℂ) * Complex.I * (↑α : ℂ) * (↑x : ℂ)) else 0‖;
    exact ⟨ norm_nonneg _, fun x => ContinuousLinearMap.le_opNorm _ _ ⟩;
  · norm_num +zetaDelta at *;
    intro b hb h; specialize h ( EuclideanSpace.single 0 1 ) ; simp_all +decide [ EuclideanSpace.norm_eq ] ;
    convert h using 1;
    erw [ Matrix.toEuclideanLin_apply ] ; norm_num