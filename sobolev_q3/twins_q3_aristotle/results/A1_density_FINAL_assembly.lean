/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 99060a23-d2c5-48a3-9830-e9a527bbe58c

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

noncomputable def HeatKernel (t : â„) (x : â„) : â„ :=
  (4 * Real.pi * t) ^ (-(1:â„)/2) * Real.exp (-x^2 / (4 * t))

noncomputable def FejerKernel (B : â„) (x : â„) : â„ := max 0 (1 - |x| / B)

noncomputable def Atom (B t Ï„ : â„) (x : â„) : â„ :=
  FejerKernel B (x - Ï„) * HeatKernel t (x - Ï„) +
  FejerKernel B (x + Ï„) * HeatKernel t (x + Ï„)

def W_K (K : â„) : Set (â„ â†’ â„) :=
  { f | ContinuousOn f (Set.Icc (-K) K) âˆ§ (âˆ€ x, f (-x) = f x) âˆ§ (âˆ€ x âˆˆ Set.Icc (-K) K, f x â‰¥ 0) }

def AtomSet (K : â„) : Set (â„ â†’ â„) :=
  { f | âˆƒ B t Ï„, B > 0 âˆ§ t > 0 âˆ§ Ï„ âˆˆ Set.Icc (-K) K âˆ§ f = Atom B t Ï„ }

def diff_set (Î¦ : â„ â†’ â„) (g : â„ â†’ â„) (K : â„) : Set â„ :=
  (fun x â†¦ |Î¦ x - g x|) '' Set.Icc (-K) K

#check Convex.toCone
#check convex_convexHull

open MeasureTheory Set Filter Topology

noncomputable def real_convolution (f g : â„ â†’ â„) (x : â„) : â„ := âˆ« y, f y * g (x - y)

def AtomCone_K (K : â„) : Set (â„ â†’ â„) :=
  (Convex.toCone (convexHull â„ (AtomSet K)) (convex_convexHull â„ (AtomSet K)) : Set (â„ â†’ â„))

lemma HeatKernel_integral (t : â„) (ht : t > 0) : âˆ« x, HeatKernel t x = 1 := by
  have h_gauss : âˆ« x, Real.exp (-x^2 / (4 * t)) = Real.sqrt (4 * Real.pi * t) := by
    convert integral_gaussian ( 1 / ( 4 * t ) ) using 1 <;> norm_num [ div_eq_inv_mul ] ; ring;
  -- Substitute the result of the Gaussian integral into the expression.
  have h_subst : âˆ« x, (4 * Real.pi * t) ^ (-1 / 2 : â„) * Real.exp (-x^2 / (4 * t)) = (4 * Real.pi * t) ^ (-1 / 2 : â„) * Real.sqrt (4 * Real.pi * t) := by
    rw [ â† h_gauss, MeasureTheory.integral_const_mul ];
  convert h_subst using 1;
  rw [ Real.sqrt_eq_rpow, â† Real.rpow_add ] <;> norm_num ; positivity

lemma HeatKernel_mass_concentration (Î´ : â„) (hÎ´ : Î´ > 0) :
  Filter.Tendsto (fun t => âˆ« x in {y | |y| > Î´}, HeatKernel t x)
    (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
      -- The integral of the heat kernel over $|x| > \delta$ can be bounded by the integral of a Gaussian function with a small variance.
      have h_integral_bound : âˆ€ t > 0, âˆ« x in {y : â„ | |y| > Î´}, HeatKernel t x â‰¤ (4 * Real.pi * t) ^ (-(1:â„)/2) * âˆ« x in {y : â„ | |y| > Î´}, Real.exp (-x^2 / (4 * t)) := by
        intro t ht; rw [ â† MeasureTheory.integral_const_mul ] ; refine' MeasureTheory.integral_mono_of_nonneg _ _ _ ; aesop;
        Â· exact Filter.Eventually.of_forall fun x => by unfold HeatKernel; positivity;
        Â· exact MeasureTheory.Integrable.const_mul ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) |> MeasureTheory.Integrable.integrableOn ) ) ) ) ) ) ) ) ) ) _;
        Â· filter_upwards [ ] with x using by unfold HeatKernel; ring_nf; norm_num;
      -- The integral of the Gaussian function over $|x| > \delta$ can be bounded by the integral of a Gaussian function with a small variance.
      have h_gaussian_bound : âˆ€ t > 0, âˆ« x in {y : â„ | |y| > Î´}, Real.exp (-x^2 / (4 * t)) â‰¤ âˆ« x in Set.Ioi Î´, Real.exp (-x^2 / (4 * t)) * 2 := by
        intro t ht
        have h_gaussian_bound : âˆ« x in {y : â„ | |y| > Î´}, Real.exp (-x^2 / (4 * t)) â‰¤ âˆ« x in Set.Ioi Î´ âˆª Set.Iio (-Î´), Real.exp (-x^2 / (4 * t)) := by
          rw [ show { y : â„ | |y| > Î´ } = ( Set.Ioi Î´ âˆª Set.Iio ( -Î´ ) ) by ext x; norm_num [ abs_eq_max_neg, lt_max_iff, lt_neg ] ];
        rw [ MeasureTheory.setIntegral_union ] at h_gaussian_bound <;> norm_num at *;
        Â· rw [ MeasureTheory.integral_mul_const ];
          rw [ show ( âˆ« x in Set.Iio ( -Î´ ), Real.exp ( -x ^ 2 / ( 4 * t ) ) ) = ( âˆ« x in Set.Ioi Î´, Real.exp ( -x ^ 2 / ( 4 * t ) ) ) by rw [ â† MeasureTheory.integral_Iic_eq_integral_Iio ] ; rw [ â† neg_neg Î´, â† integral_comp_neg_Iic ] ; norm_num ] at h_gaussian_bound ; linarith;
        Â· positivity;
        Â· exact MeasureTheory.Integrable.integrableOn ( by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) );
        Â· exact MeasureTheory.Integrable.integrableOn ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) ) ) ) ) ) );
      -- The integral of the Gaussian function over $(\delta, \infty)$ can be bounded by the integral of a Gaussian function with a small variance.
      have h_gaussian_tail_bound : âˆ€ t > 0, âˆ« x in Set.Ioi Î´, Real.exp (-x^2 / (4 * t)) * 2 â‰¤ Real.exp (-Î´^2 / (4 * t)) * âˆ« x in Set.Ioi 0, Real.exp (-x^2 / (4 * t)) * 2 := by
        intros t ht
        have h_split_integral : âˆ« x in Set.Ioi Î´, Real.exp (-x^2 / (4 * t)) * 2 = âˆ« x in Set.Ioi 0, Real.exp (-(x + Î´)^2 / (4 * t)) * 2 := by
          rw [ â† MeasureTheory.integral_indicator ( measurableSet_Ioi ), â† MeasureTheory.integral_indicator ( measurableSet_Ioi ) ];
          rw [ â† MeasureTheory.integral_add_right_eq_self _ Î´ ] ; congr ; ext x ; rw [ Set.indicator_apply, Set.indicator_apply ] ; aesop;
        rw [ h_split_integral, â† MeasureTheory.integral_const_mul ];
        refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
        Â· exact Filter.Eventually.of_forall fun x => by positivity;
        Â· exact MeasureTheory.Integrable.const_mul ( MeasureTheory.Integrable.mul_const ( by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) |> MeasureTheory.Integrable.integrableOn ) _ ) _;
        Â· filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioi ] with x hx using by rw [ â† mul_assoc, â† Real.exp_add ] ; exact mul_le_mul_of_nonneg_right ( Real.exp_le_exp.mpr <| by rw [ â† add_div, div_le_div_iff_of_pos_right <| by positivity ] ; nlinarith only [ hx.out, hÎ´ ] ) zero_le_two;
      -- The integral of the Gaussian function over $(0, \infty)$ is equal to $\sqrt{4\pi t}$.
      have h_gaussian_integral : âˆ€ t > 0, âˆ« x in Set.Ioi 0, Real.exp (-x^2 / (4 * t)) * 2 = Real.sqrt (4 * Real.pi * t) := by
        intro t ht; rw [ MeasureTheory.integral_mul_const ] ; have := integral_gaussian_Ioi ( 1 / ( 4 * t ) ) ; simp_all +decide [ div_eq_inv_mul, mul_assoc, mul_comm, mul_left_comm ] ;
      -- Substitute the bounds into the integral expression.
      have h_integral_subst : âˆ€ t > 0, âˆ« x in {y : â„ | |y| > Î´}, HeatKernel t x â‰¤ (4 * Real.pi * t) ^ (-(1:â„)/2) * Real.exp (-Î´^2 / (4 * t)) * Real.sqrt (4 * Real.pi * t) := by
        intro t ht; convert le_trans ( h_integral_bound t ht ) ( mul_le_mul_of_nonneg_left ( le_trans ( h_gaussian_bound t ht ) ( le_trans ( h_gaussian_tail_bound t ht ) ( by rw [ h_gaussian_integral t ht ] ) ) ) ( by positivity ) ) using 1 ; ring;
      -- Simplify the expression to get the final bound.
      have h_integral_simplified : âˆ€ t > 0, âˆ« x in {y : â„ | |y| > Î´}, HeatKernel t x â‰¤ Real.exp (-Î´^2 / (4 * t)) := by
        intro t ht; convert h_integral_subst t ht using 1; norm_num [ Real.sqrt_eq_rpow, Real.rpow_neg ( by positivity : 0 â‰¤ 4 * Real.pi * t ) ] ; ring;
        rw [ mul_inv_cancelâ‚€ ( by positivity ), one_mul ];
      -- Since $\exp(-\delta^2 / (4t))$ tends to $0$ as $t$ tends to $0$, we can conclude.
      have h_exp_zero : Filter.Tendsto (fun t => Real.exp (-Î´^2 / (4 * t))) (ğ“[>] 0) (ğ“ 0) := by
        norm_num [ div_eq_mul_inv ];
        exact Filter.Tendsto.const_mul_atTop ( by positivity ) ( Filter.Tendsto.atTop_mul_const ( by positivity ) ( tendsto_inv_nhdsGT_zero ) );
      exact squeeze_zero_norm' ( Filter.eventually_of_mem self_mem_nhdsWithin fun t ht => by rw [ Real.norm_of_nonneg ( MeasureTheory.integral_nonneg fun _ => by exact mul_nonneg ( Real.rpow_nonneg ( by nlinarith [ Real.pi_pos, ht.out ] ) _ ) ( Real.exp_nonneg _ ) ) ] ; exact h_integral_simplified t ht ) h_exp_zero

lemma HeatKernel_nonneg (t : â„) (ht : t > 0) (x : â„) : 0 â‰¤ HeatKernel t x := by
  -- The exponential function is always positive, and the power of a positive number is also positive.
  apply mul_nonneg; apply Real.rpow_nonneg; positivity; apply Real.exp_nonneg

lemma FejerKernel_bounds (B : â„) (hB : B > 0) (x : â„) :
  0 â‰¤ FejerKernel B x âˆ§ FejerKernel B x â‰¤ 1 := by
    -- By definition of FejerKernel, we know that it is non-negative and less than or equal to 1 because it is the maximum of 0 and (1 - |x|/B), and (1 - |x|/B) is less than or equal to 1.
    simp [FejerKernel];
    -- Since $|x| \geq 0$ and $B > 0$, their division is non-negative.
    apply div_nonneg; exact abs_nonneg x; exact hB.le

lemma exists_compact_extension (K : â„) (hK : K > 0) (Î¦ : â„ â†’ â„)
    (hÎ¦_cont : ContinuousOn Î¦ (Set.Icc (-K) K)) :
  âˆƒ Î¨ : â„ â†’ â„, Continuous Î¨ âˆ§ HasCompactSupport Î¨ âˆ§ âˆ€ x âˆˆ Set.Icc (-K) K, Î¨ x = Î¦ x := by
    -- Define a smooth cut-off function $\chi$ that is 1 on $[-K, K]$ and 0 outside $[-K-1, K+1]$.
    obtain âŸ¨Ï‡, hÏ‡âŸ© : âˆƒ Ï‡ : â„ â†’ â„, Continuous Ï‡ âˆ§ (âˆ€ x, 0 â‰¤ Ï‡ x âˆ§ Ï‡ x â‰¤ 1) âˆ§ (âˆ€ x âˆˆ Set.Icc (-K) K, Ï‡ x = 1) âˆ§ (âˆ€ x, |x| â‰¥ K + 1 â†’ Ï‡ x = 0) := by
      -- Define the smooth cut-off function $\chi$.
      use fun x => max 0 (min 1 (1 - (abs x - K)));
      aesop;
      Â· fun_prop;
      Â· cases abs_cases x <;> cases min_cases ( 1 : â„ ) ( 1 - ( |x| - K ) ) <;> cases max_cases ( 0 : â„ ) ( Min.min 1 ( 1 - ( |x| - K ) ) ) <;> linarith;
      Â· exact Or.inr ( by linarith );
    -- Define $\Psi(x) = \chi(x) \Phi(x)$.
    use fun x => Ï‡ x * Î¦ (max (-K) (min x K));
    aesop;
    Â· refine' Continuous.mul left _;
      refine' ContinuousOn.comp_continuous _ _ _;
      exacts [ Set.Icc ( -K ) K, hÎ¦_cont, by apply_rules [ Continuous.max, Continuous.min, continuous_id, continuous_const ], fun x => âŸ¨ by cases max_cases ( -K ) ( Min.min x K ) <;> cases min_cases x K <;> linarith, by cases max_cases ( -K ) ( Min.min x K ) <;> cases min_cases x K <;> linarith âŸ© ];
    Â· rw [ hasCompactSupport_iff_eventuallyEq ];
      norm_num [ Filter.EventuallyEq ];
      exact âŸ¨ âŸ¨ -K - 1, fun x hx => Or.inl <| right x <| by cases abs_cases x <;> linarith âŸ©, âŸ¨ K + 1, fun x hx => Or.inl <| right x <| by cases abs_cases x <;> linarith âŸ© âŸ©

lemma HeatKernel_approx_identity_uniform (f : â„ â†’ â„) (hf_cont : Continuous f)
    (hf_supp : HasCompactSupport f) (Îµ : â„) (hÎµ : Îµ > 0) :
  âˆƒ tâ‚€ > 0, âˆ€ t âˆˆ Set.Ioo 0 tâ‚€, âˆ€ x, |real_convolution f (HeatKernel t) x - f x| < Îµ := by
    -- By the properties of the heat kernel and the uniform continuity of $f$, we can find such a $tâ‚€$.
    have h_uniform_cont : âˆƒ Î´ > 0, âˆ€ x y : â„, |x - y| < Î´ â†’ |f x - f y| < Îµ / 2 := by
      have h_unif_cont : UniformContinuous f := by
        exact?;
      exact Metric.uniformContinuous_iff.mp h_unif_cont ( Îµ / 2 ) ( half_pos hÎµ );
    obtain âŸ¨ Î´, hÎ´_pos, hÎ´ âŸ© := h_uniform_cont;
    -- Using the fact that the heat kernel is an approximation to the identity, we can bound the integral of the convolution.
    have h_conv_bound : âˆ€ t > 0, âˆ€ x : â„, |real_convolution f (HeatKernel t) x - f x| â‰¤ âˆ« y, |f (x - y) - f x| * HeatKernel t y := by
      intros t ht x;
      -- By the properties of the heat kernel and the uniform continuity of $f$, we can bound the integral of the convolution. We'll use the fact that $|a - b| \leq |a| + |b|$.
      have h_conv_bound : âˆ« y, (f (x - y) - f x) * HeatKernel t y = real_convolution f (HeatKernel t) x - f x * âˆ« y, HeatKernel t y := by
        simp +decide [ sub_mul, mul_sub, â† MeasureTheory.integral_const_mul ];
        rw [ MeasureTheory.integral_sub ];
        Â· rw [ â† MeasureTheory.integral_sub_left_eq_self ] ; congr ; ext ; ring;
        Â· -- Since $f$ is continuous and has compact support, it is bounded. Let $M$ be an upper bound for $|f|$.
          obtain âŸ¨M, hMâŸ© : âˆƒ M, âˆ€ x, |f x| â‰¤ M := by
            have := hf_supp.exists_bound_of_continuous hf_cont;
            tauto;
          refine' MeasureTheory.Integrable.mono' _ _ _;
          refine' fun y => M * HeatKernel t y;
          Â· refine' MeasureTheory.Integrable.const_mul _ _;
            have := HeatKernel_integral t ht;
            exact MeasureTheory.integrable_of_integral_eq_one this;
          Â· refine' MeasureTheory.AEStronglyMeasurable.mul _ _;
            Â· exact Continuous.aestronglyMeasurable ( hf_cont.comp ( continuous_const.sub continuous_id' ) );
            Â· exact Continuous.aestronglyMeasurable ( by exact Continuous.mul ( continuous_const ) ( Real.continuous_exp.comp ( by continuity ) ) );
          Â· filter_upwards [ ] with y using by rw [ Real.norm_eq_abs, abs_mul, abs_of_nonneg ( show 0 â‰¤ HeatKernel t y by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ] ; exact mul_le_mul_of_nonneg_right ( hM _ ) ( show 0 â‰¤ HeatKernel t y by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ;
        Â· refine' MeasureTheory.Integrable.const_mul _ _;
          have h_integrable : âˆ« x, HeatKernel t x = 1 := by
            exact?;
          exact MeasureTheory.integrable_of_integral_eq_one h_integrable;
      -- By the properties of the heat kernel and the uniform continuity of $f$, we can bound the integral of the convolution. We'll use the fact that $|a - b| \leq |a| + |b|$ and the triangle inequality.
      have h_conv_bound : |âˆ« y, (f (x - y) - f x) * HeatKernel t y| â‰¤ âˆ« y, |f (x - y) - f x| * HeatKernel t y := by
        convert MeasureTheory.norm_integral_le_integral_norm ( _ : â„ â†’ â„ ) using 1;
        norm_num [ abs_mul, abs_of_nonneg ( show 0 â‰¤ HeatKernel t _ from by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ];
      have h_heat_kernel_integral : âˆ« y, HeatKernel t y = 1 := by
        exact?;
      aesop;
    -- Using the fact that the heat kernel is an approximation to the identity, we can bound the integral of the convolution by splitting it into two parts: one over $|y| < \delta$ and one over $|y| \geq \delta$.
    have h_conv_split : âˆ€ t > 0, âˆ€ x : â„, âˆ« y, |f (x - y) - f x| * HeatKernel t y â‰¤ (âˆ« y in {y | |y| < Î´}, |f (x - y) - f x| * HeatKernel t y) + (âˆ« y in {y | |y| â‰¥ Î´}, |f (x - y) - f x| * HeatKernel t y) := by
      intro t ht x; rw [ â† MeasureTheory.setIntegral_union ] <;> norm_num;
      Â· rw [ show { y : â„ | |y| < Î´ } âˆª { y : â„ | Î´ â‰¤ |y| } = Set.univ by ext y; by_cases hy : |y| < Î´ <;> aesop ] ; norm_num;
      Â· exact Set.disjoint_left.mpr fun y hyâ‚ hyâ‚‚ => hyâ‚.out.not_le hyâ‚‚.out;
      Â· exact measurableSet_Ici.mem.comp measurable_norm;
      Â· refine' MeasureTheory.Integrable.integrableOn _;
        -- Since $f$ is continuous with compact support, $|f(x-y) - f(x)|$ is bounded.
        have h_bounded : âˆƒ M > 0, âˆ€ y, |f (x - y) - f x| â‰¤ M := by
          have h_bounded : âˆƒ M > 0, âˆ€ y, |f y| â‰¤ M := by
            have := hf_supp.exists_bound_of_continuous hf_cont;
            exact âŸ¨ Max.max this.choose 1, by positivity, fun y => le_trans ( this.choose_spec y ) ( le_max_left _ _ ) âŸ©;
          exact âŸ¨ h_bounded.choose + h_bounded.choose, add_pos h_bounded.choose_spec.1 h_bounded.choose_spec.1, fun y => le_trans ( abs_sub _ _ ) ( add_le_add ( h_bounded.choose_spec.2 _ ) ( h_bounded.choose_spec.2 _ ) ) âŸ©;
        obtain âŸ¨ M, hM_pos, hM âŸ© := h_bounded;
        refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun y => M * HeatKernel t y;
        Â· refine' MeasureTheory.Integrable.const_mul _ _;
          have h_gauss_integrable : âˆ« y, Real.exp (-y^2 / (4 * t)) = Real.sqrt (4 * Real.pi * t) := by
            convert integral_gaussian ( 1 / ( 4 * t ) ) using 1 <;> norm_num [ div_eq_inv_mul ] ; ring;
          exact MeasureTheory.Integrable.const_mul ( by exact ( by contrapose! h_gauss_integrable; rw [ MeasureTheory.integral_undef h_gauss_integrable ] ; positivity ) ) _;
        Â· refine' MeasureTheory.AEStronglyMeasurable.mul _ _;
          Â· exact Continuous.aestronglyMeasurable ( by continuity );
          Â· exact Continuous.aestronglyMeasurable ( by exact Continuous.mul ( continuous_const ) ( Real.continuous_exp.comp ( by continuity ) ) );
        Â· filter_upwards [ ] with y using by rw [ Real.norm_of_nonneg ( mul_nonneg ( abs_nonneg _ ) ( show 0 â‰¤ HeatKernel t y by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ) ] ; exact mul_le_mul_of_nonneg_right ( hM y ) ( show 0 â‰¤ HeatKernel t y by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ;
      Â· refine' MeasureTheory.Integrable.integrableOn _;
        -- Since $f$ is continuous with compact support, $|f(x-y) - f(x)|$ is bounded.
        have h_bounded : âˆƒ M > 0, âˆ€ y, |f (x - y) - f x| â‰¤ M := by
          have h_bounded : âˆƒ M > 0, âˆ€ y, |f y| â‰¤ M := by
            have := hf_supp.exists_bound_of_continuous hf_cont;
            exact âŸ¨ Max.max this.choose 1, by positivity, fun y => le_trans ( this.choose_spec y ) ( le_max_left _ _ ) âŸ©;
          exact âŸ¨ h_bounded.choose + h_bounded.choose, add_pos h_bounded.choose_spec.1 h_bounded.choose_spec.1, fun y => le_trans ( abs_sub _ _ ) ( add_le_add ( h_bounded.choose_spec.2 _ ) ( h_bounded.choose_spec.2 _ ) ) âŸ©;
        obtain âŸ¨ M, hM_pos, hM âŸ© := h_bounded;
        refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun y => M * HeatKernel t y;
        Â· refine' MeasureTheory.Integrable.const_mul _ _;
          have h_gauss_integrable : âˆ« y, Real.exp (-y^2 / (4 * t)) = Real.sqrt (4 * Real.pi * t) := by
            convert integral_gaussian ( 1 / ( 4 * t ) ) using 1 <;> norm_num [ div_eq_inv_mul ] ; ring;
          exact MeasureTheory.Integrable.const_mul ( by exact ( by contrapose! h_gauss_integrable; rw [ MeasureTheory.integral_undef h_gauss_integrable ] ; positivity ) ) _;
        Â· refine' MeasureTheory.AEStronglyMeasurable.mul _ _;
          Â· exact Continuous.aestronglyMeasurable ( by continuity );
          Â· exact Continuous.aestronglyMeasurable ( by exact Continuous.mul ( continuous_const ) ( Real.continuous_exp.comp ( by continuity ) ) );
        Â· filter_upwards [ ] with y using by rw [ Real.norm_of_nonneg ( mul_nonneg ( abs_nonneg _ ) ( show 0 â‰¤ HeatKernel t y by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ) ] ; exact mul_le_mul_of_nonneg_right ( hM y ) ( show 0 â‰¤ HeatKernel t y by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ;
    -- Using the fact that the heat kernel is an approximation to the identity, we can bound the integral of the convolution over $|y| \geq \delta$.
    have h_conv_tail : âˆ€ t > 0, âˆ€ x : â„, âˆ« y in {y | |y| â‰¥ Î´}, |f (x - y) - f x| * HeatKernel t y â‰¤ 2 * (SupSet.sSup (Set.image (fun x => |f x|) (Set.univ))) * âˆ« y in {y | |y| â‰¥ Î´}, HeatKernel t y := by
      intros t ht x
      have h_conv_tail_bound : âˆ€ y âˆˆ {y | |y| â‰¥ Î´}, |f (x - y) - f x| â‰¤ 2 * (SupSet.sSup (Set.image (fun x => |f x|) (Set.univ))) := by
        intros y hy
        have h_abs : |f (x - y)| â‰¤ SupSet.sSup (Set.image (fun x => |f x|) (Set.univ)) âˆ§ |f x| â‰¤ SupSet.sSup (Set.image (fun x => |f x|) (Set.univ)) := by
          have h_abs : âˆ€ x, |f x| â‰¤ SupSet.sSup (Set.image (fun x => |f x|) (Set.univ)) := by
            intros x
            apply le_csSup;
            Â· obtain âŸ¨ M, hM âŸ© := hf_supp.exists_bound_of_continuous hf_cont;
              exact âŸ¨ M, Set.forall_mem_image.2 fun x _ => hM x âŸ©;
            Â· aesop;
          exact âŸ¨ h_abs _, h_abs _ âŸ©;
        exact le_trans ( abs_sub _ _ ) ( by linarith );
      rw [ â† MeasureTheory.integral_const_mul ];
      refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
      Â· exact Filter.Eventually.of_forall fun y => mul_nonneg ( abs_nonneg _ ) ( by unfold HeatKernel; positivity );
      Â· refine' MeasureTheory.Integrable.const_mul _ _;
        have h_conv_tail_integrable : MeasureTheory.Integrable (HeatKernel t) MeasureTheory.volume := by
          have h_conv_tail_integrable : âˆ« y, HeatKernel t y = 1 := by
            exact?;
          exact MeasureTheory.integrable_of_integral_eq_one h_conv_tail_integrable;
        exact h_conv_tail_integrable.integrableOn;
      Â· filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_le measurable_const <| measurable_norm ] with y hy using mul_le_mul_of_nonneg_right ( h_conv_tail_bound y hy ) <| by unfold HeatKernel; positivity;
    -- Using the fact that the heat kernel is an approximation to the identity, we can bound the integral of the convolution over $|y| < \delta$.
    have h_conv_head : âˆ€ t > 0, âˆ€ x : â„, âˆ« y in {y | |y| < Î´}, |f (x - y) - f x| * HeatKernel t y â‰¤ (Îµ / 2) * âˆ« y, HeatKernel t y := by
      intros t ht x
      have h_conv_head_bound : âˆ« y in {y | |y| < Î´}, |f (x - y) - f x| * HeatKernel t y â‰¤ (Îµ / 2) * âˆ« y in {y | |y| < Î´}, HeatKernel t y := by
        rw [ â† MeasureTheory.integral_const_mul ];
        refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
        Â· filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_lt measurable_norm measurable_const ] with y hy using mul_nonneg ( abs_nonneg _ ) ( by unfold HeatKernel; positivity );
        Â· refine' MeasureTheory.Integrable.const_mul _ _;
          -- The heat kernel is integrable over the entire real line, and since the set {y | |y| < Î´} is a subset of the real line, the integral over this subset is also finite.
          have h_heat_kernel_integrable : MeasureTheory.IntegrableOn (HeatKernel t) Set.univ := by
            have h_heat_kernel_integrable : âˆ« x, HeatKernel t x = 1 := by
              exact?;
            exact MeasureTheory.integrable_of_integral_eq_one ( by simpa using h_heat_kernel_integrable );
          exact h_heat_kernel_integrable.mono_set <| Set.subset_univ _;
        Â· filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_lt ( measurable_norm ) measurable_const ] with y hy using mul_le_mul_of_nonneg_right ( le_of_lt <| hÎ´ _ _ <| by simpa using hy ) <| by unfold HeatKernel; positivity;
      refine le_trans h_conv_head_bound ?_;
      refine' mul_le_mul_of_nonneg_left ( MeasureTheory.setIntegral_le_integral _ _ ) ( by positivity );
      Â· have h_heat_kernel_integrable : âˆ« x, HeatKernel t x = 1 := by
          exact?;
        exact MeasureTheory.integrable_of_integral_eq_one h_heat_kernel_integrable;
      Â· exact Filter.Eventually.of_forall fun x => by unfold HeatKernel; positivity;
    -- Using the fact that the heat kernel is an approximation to the identity, we can bound the integral of the convolution over $|y| \geq \delta$ by choosing $t$ small enough.
    have h_conv_tail_small : âˆƒ tâ‚€ > 0, âˆ€ t âˆˆ Set.Ioo 0 tâ‚€, 2 * (SupSet.sSup (Set.image (fun x => |f x|) (Set.univ))) * âˆ« y in {y | |y| â‰¥ Î´}, HeatKernel t y < Îµ / 2 := by
      have h_conv_tail_small : Filter.Tendsto (fun t => âˆ« y in {y | |y| â‰¥ Î´}, HeatKernel t y) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
        convert HeatKernel_mass_concentration Î´ hÎ´_pos using 1;
        ext t; rw [ MeasureTheory.setIntegral_congr_set ] ; aesop;
        rw [ MeasureTheory.ae_eq_set ];
        constructor <;> rw [ MeasureTheory.measure_eq_zero_iff_ae_notMem ] <;> aesop;
        Â· filter_upwards [ MeasureTheory.measure_eq_zero_iff_ae_notMem.mp ( MeasureTheory.measure_singleton ( Î´ ) ), MeasureTheory.measure_eq_zero_iff_ae_notMem.mp ( MeasureTheory.measure_singleton ( -Î´ ) ) ] with x hxâ‚ hxâ‚‚ using fun hxâ‚ƒ => lt_of_le_of_ne hxâ‚ƒ ( by cases abs_cases x <;> cases lt_or_gt_of_ne hxâ‚ <;> cases lt_or_gt_of_ne hxâ‚‚ <;> linarith );
        Â· exact Filter.Eventually.of_forall fun x hx => le_of_lt hx;
      have := h_conv_tail_small.const_mul ( 2 * SupSet.sSup ( ( fun x => |f x| ) '' Set.univ ) );
      have := Metric.tendsto_nhdsWithin_nhds.mp this ( Îµ / 2 ) ( half_pos hÎµ );
      exact âŸ¨ this.choose, this.choose_spec.1, fun t ht => by linarith [ abs_lt.mp ( this.choose_spec.2 ht.1 ( by simpa [ abs_of_pos ht.1 ] using ht.2 ) ) ] âŸ©;
    -- Using the fact that the integral of the heat kernel is 1, we can simplify the bound.
    have h_conv_integral : âˆ€ t > 0, âˆ« y, HeatKernel t y = 1 := by
      exact?;
    exact âŸ¨ h_conv_tail_small.choose, h_conv_tail_small.choose_spec.1, fun t ht x => lt_of_le_of_lt ( h_conv_bound t ht.1 x ) ( lt_of_le_of_lt ( h_conv_split t ht.1 x ) ( by nlinarith [ h_conv_head t ht.1 x, h_conv_tail t ht.1 x, h_conv_tail_small.choose_spec.2 t ht, h_conv_integral t ht.1 ] ) ) âŸ©

lemma fejer_sum_approx (K : â„) (hK : K > 0) (t : â„) (ht : t > 0) (s : Finset â„)
    (w : â„ â†’ â„) (hw_nonneg : âˆ€ y âˆˆ s, 0 â‰¤ w y) (hs_subset : âˆ€ y âˆˆ s, y âˆˆ Set.Icc (-K) K)
    (Îµ : â„) (hÎµ : Îµ > 0) :
  âˆƒ B > 0, âˆ€ x âˆˆ Set.Icc (-K) K,
    |âˆ‘ y âˆˆ s, w y * Atom B t y x - (âˆ‘ y âˆˆ s, w y * HeatKernel t (x - y) +
      âˆ‘ y âˆˆ s, w y * HeatKernel t (x + y))| < Îµ := by
        -- By definition of $Atom$, we can write:
        have h_atom : âˆ€ B > 0, âˆ€ x âˆˆ Set.Icc (-K) K, âˆ‘ y âˆˆ s, w y * Atom B t y x =
                      âˆ‘ y âˆˆ s, w y * FejerKernel B (x - y) * HeatKernel t (x - y) +
                      âˆ‘ y âˆˆ s, w y * FejerKernel B (x + y) * HeatKernel t (x + y) := by
                        intro B hB x hx; rw [ â† Finset.sum_add_distrib ] ; congr ; ext y ; unfold Atom ; ring;
        -- Since $FejerKernel B (x - y)$ and $FejerKernel B (x + y)$ are bounded by 1, we can choose $B$ large enough such that the difference between the sums is less than $\epsilon$.
        have h_bounded : âˆ€ B > 0, âˆ€ x âˆˆ Set.Icc (-K) K, |âˆ‘ y âˆˆ s, w y * FejerKernel B (x - y) * HeatKernel t (x - y) - âˆ‘ y âˆˆ s, w y * HeatKernel t (x - y)| â‰¤ âˆ‘ y âˆˆ s, w y * |FejerKernel B (x - y) - 1| * HeatKernel t (x - y) âˆ§ |âˆ‘ y âˆˆ s, w y * FejerKernel B (x + y) * HeatKernel t (x + y) - âˆ‘ y âˆˆ s, w y * HeatKernel t (x + y)| â‰¤ âˆ‘ y âˆˆ s, w y * |FejerKernel B (x + y) - 1| * HeatKernel t (x + y) := by
          intros B hB x hx
          have h_bounded : âˆ€ y âˆˆ s, |w y * FejerKernel B (x - y) * HeatKernel t (x - y) - w y * HeatKernel t (x - y)| â‰¤ w y * |FejerKernel B (x - y) - 1| * HeatKernel t (x - y) âˆ§ |w y * FejerKernel B (x + y) * HeatKernel t (x + y) - w y * HeatKernel t (x + y)| â‰¤ w y * |FejerKernel B (x + y) - 1| * HeatKernel t (x + y) := by
            intro y hy; constructor <;> rw [ abs_le ] <;> constructor <;> cases abs_cases ( FejerKernel B ( x - y ) - 1 ) <;> cases abs_cases ( FejerKernel B ( x + y ) - 1 ) <;> nlinarith [ hw_nonneg y hy, show 0 â‰¤ w y * HeatKernel t ( x - y ) by exact mul_nonneg ( hw_nonneg y hy ) ( HeatKernel_nonneg t ht _ ), show 0 â‰¤ w y * HeatKernel t ( x + y ) by exact mul_nonneg ( hw_nonneg y hy ) ( HeatKernel_nonneg t ht _ ) ] ;
          exact âŸ¨ by simpa only [ â† Finset.sum_sub_distrib ] using Finset.abs_sum_le_sum_abs _ _ |> le_trans <| Finset.sum_le_sum fun y hy => h_bounded y hy |>.1, by simpa only [ â† Finset.sum_sub_distrib ] using Finset.abs_sum_le_sum_abs _ _ |> le_trans <| Finset.sum_le_sum fun y hy => h_bounded y hy |>.2 âŸ©;
        -- Since $|FejerKernel B (x - y) - 1| \leq \frac{|x - y|}{B}$ and $|FejerKernel B (x + y) - 1| \leq \frac{|x + y|}{B}$, we can choose $B$ large enough such that the sums are less than $\epsilon$.
        have h_small : âˆ€ B > 0, âˆ€ x âˆˆ Set.Icc (-K) K, âˆ‘ y âˆˆ s, w y * |FejerKernel B (x - y) - 1| * HeatKernel t (x - y) â‰¤ âˆ‘ y âˆˆ s, w y * (|x - y| / B) * HeatKernel t (x - y) âˆ§ âˆ‘ y âˆˆ s, w y * |FejerKernel B (x + y) - 1| * HeatKernel t (x + y) â‰¤ âˆ‘ y âˆˆ s, w y * (|x + y| / B) * HeatKernel t (x + y) := by
          intros B hB x hx
          have h_abs : âˆ€ y âˆˆ s, |FejerKernel B (x - y) - 1| â‰¤ |x - y| / B âˆ§ |FejerKernel B (x + y) - 1| â‰¤ |x + y| / B := by
            unfold FejerKernel;
            intro y hy; constructor <;> rw [ abs_le ] <;> constructor <;> cases max_cases ( 0 : â„ ) ( 1 - |x - y| / B ) <;> cases max_cases ( 0 : â„ ) ( 1 - |x + y| / B ) <;> nlinarith [ abs_nonneg ( x - y ), abs_nonneg ( x + y ), div_mul_cancelâ‚€ ( |x - y| ) hB.ne', div_mul_cancelâ‚€ ( |x + y| ) hB.ne' ] ;
          exact âŸ¨ Finset.sum_le_sum fun y hy => mul_le_mul_of_nonneg_right ( mul_le_mul_of_nonneg_left ( h_abs y hy |>.1 ) ( hw_nonneg y hy ) ) ( by exact ( show 0 â‰¤ HeatKernel t ( x - y ) from by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ), Finset.sum_le_sum fun y hy => mul_le_mul_of_nonneg_right ( mul_le_mul_of_nonneg_left ( h_abs y hy |>.2 ) ( hw_nonneg y hy ) ) ( by exact ( show 0 â‰¤ HeatKernel t ( x + y ) from by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ) âŸ©;
        -- Since $|x - y| \leq 2K$ and $|x + y| \leq 2K$ for all $x, y \in [-K, K]$, we can further bound the sums.
        have h_bound : âˆ€ B > 0, âˆ€ x âˆˆ Set.Icc (-K) K, âˆ‘ y âˆˆ s, w y * (|x - y| / B) * HeatKernel t (x - y) â‰¤ (2 * K / B) * âˆ‘ y âˆˆ s, w y * HeatKernel t (x - y) âˆ§ âˆ‘ y âˆˆ s, w y * (|x + y| / B) * HeatKernel t (x + y) â‰¤ (2 * K / B) * âˆ‘ y âˆˆ s, w y * HeatKernel t (x + y) := by
          intros B hB x hx
          have h_bound : âˆ€ y âˆˆ s, |x - y| â‰¤ 2 * K âˆ§ |x + y| â‰¤ 2 * K := by
            exact fun y hy => âŸ¨ abs_le.mpr âŸ¨ by linarith [ hx.1, hx.2, hs_subset y hy |>.1, hs_subset y hy |>.2 ], by linarith [ hx.1, hx.2, hs_subset y hy |>.1, hs_subset y hy |>.2 ] âŸ©, abs_le.mpr âŸ¨ by linarith [ hx.1, hx.2, hs_subset y hy |>.1, hs_subset y hy |>.2 ], by linarith [ hx.1, hx.2, hs_subset y hy |>.1, hs_subset y hy |>.2 ] âŸ© âŸ©;
          simp_all +decide [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _ ];
          exact âŸ¨ Finset.sum_le_sum fun y hy => by nlinarith [ h_bound y hy, show 0 â‰¤ w y * ( HeatKernel t ( x - y ) * Bâ»Â¹ ) by exact mul_nonneg ( hw_nonneg y hy ) ( mul_nonneg ( by exact ( show 0 â‰¤ HeatKernel t ( x - y ) by exact ( by unfold HeatKernel; positivity ) ) ) ( inv_nonneg.2 hB.le ) ) ], Finset.sum_le_sum fun y hy => by nlinarith [ h_bound y hy, show 0 â‰¤ w y * ( HeatKernel t ( x + y ) * Bâ»Â¹ ) by exact mul_nonneg ( hw_nonneg y hy ) ( mul_nonneg ( by exact ( show 0 â‰¤ HeatKernel t ( x + y ) by exact ( by unfold HeatKernel; positivity ) ) ) ( inv_nonneg.2 hB.le ) ) ] âŸ©;
        -- Choose $B$ large enough such that $(2 * K / B) * (âˆ‘ y âˆˆ s, w y * HeatKernel t (x - y) + âˆ‘ y âˆˆ s, w y * HeatKernel t (x + y)) < Îµ / 2$.
        obtain âŸ¨B, hB_pos, hB_smallâŸ© : âˆƒ B > 0, âˆ€ x âˆˆ Set.Icc (-K) K, (2 * K / B) * (âˆ‘ y âˆˆ s, w y * HeatKernel t (x - y) + âˆ‘ y âˆˆ s, w y * HeatKernel t (x + y)) < Îµ / 2 := by
          -- Since the sums $\sum_{y \in s} w_y \HeatKernel t (x - y)$ and $\sum_{y \in s} w_y \HeatKernel t (x + y)$ are bounded, we can choose $B$ large enough such that $(2 * K / B) * (\sum_{y \in s} w_y \HeatKernel t (x - y) + \sum_{y \in s} w_y \HeatKernel t (x + y)) < \epsilon / 2$.
          have h_bounded_sums : âˆƒ M > 0, âˆ€ x âˆˆ Set.Icc (-K) K, (âˆ‘ y âˆˆ s, w y * HeatKernel t (x - y) + âˆ‘ y âˆˆ s, w y * HeatKernel t (x + y)) â‰¤ M := by
            have h_bounded_sums : ContinuousOn (fun x => âˆ‘ y âˆˆ s, w y * HeatKernel t (x - y) + âˆ‘ y âˆˆ s, w y * HeatKernel t (x + y)) (Set.Icc (-K) K) := by
              refine' ContinuousOn.add _ _;
              Â· refine' continuousOn_finset_sum _ fun y hy => ContinuousOn.mul _ _;
                Â· exact continuousOn_const;
                Â· refine' ContinuousOn.mul _ _;
                  Â· exact continuousOn_const;
                  Â· fun_prop;
              Â· refine' ContinuousOn.congr _ _;
                use fun x => âˆ‘ y âˆˆ s, w y * ( 4 * Real.pi * t ) ^ ( - ( 1 : â„ ) / 2 ) * Real.exp ( - ( x + y ) ^ 2 / ( 4 * t ) );
                Â· fun_prop;
                Â· intro x hx; simp +decide [ mul_assoc, HeatKernel ] ;
            obtain âŸ¨ M, hM âŸ© := IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) h_bounded_sums;
            exact âŸ¨ Max.max M 1, by positivity, fun x hx => le_trans ( le_abs_self _ ) ( le_trans ( hM x hx ) ( le_max_left _ _ ) ) âŸ©;
          obtain âŸ¨ M, hM_pos, hM âŸ© := h_bounded_sums;
          exact âŸ¨ 2 * K * M / ( Îµ / 2 ) + 1, by positivity, fun x hx => by rw [ div_mul_eq_mul_div, div_lt_iffâ‚€ ] <;> nlinarith [ hM x hx, mul_div_cancelâ‚€ ( 2 * K * M ) ( by positivity : ( Îµ / 2 ) â‰  0 ), mul_pos hK hM_pos ] âŸ©;
        use B, hB_pos;
        intro x hx; rw [ h_atom B hB_pos x hx ] ; rw [ abs_lt ] ; constructor <;> linarith [ abs_le.mp ( h_bounded B hB_pos x hx |>.1 ), abs_le.mp ( h_bounded B hB_pos x hx |>.2 ), h_small B hB_pos x hx, h_bound B hB_pos x hx, hB_small x hx ] ;

lemma sum_atoms_in_cone (K : â„) (s : Finset â„) (w : â„ â†’ â„) (hw : âˆ€ y âˆˆ s, 0 â‰¤ w y)
    (B : â„) (hB : B > 0) (t : â„) (ht : t > 0) (hs : âˆ€ y âˆˆ s, y âˆˆ Set.Icc (-K) K)
    (h_sum_pos : âˆ‘ y âˆˆ s, w y > 0) :
  (fun x => âˆ‘ y âˆˆ s, w y * Atom B t y x) âˆˆ AtomCone_K K := by
    refine' âŸ¨ _, _ âŸ©;
    exact ( âˆ‘ y âˆˆ s, w y ) â€¢ ( convexHull â„ ( AtomSet K ) );
    aesop;
    Â· exact âŸ¨ âˆ‘ y âˆˆ s, w y, by aesop âŸ©;
    Â· refine' âŸ¨ fun x => âˆ‘ y âˆˆ s, ( w y / âˆ‘ y âˆˆ s, w y ) * Atom B t y x, _, _ âŸ©;
      Â· rw [ convexHull_eq ];
        refine' âŸ¨ â„, s, fun y => w y / âˆ‘ y âˆˆ s, w y, fun y x => Atom B t y x, _, _, _, _ âŸ© <;> simp_all +decide [ Finset.centerMass ];
        Â· exact fun y hy => div_nonneg ( hw y hy ) h_sum_pos.le;
        Â· rw [ â† Finset.sum_div, div_self h_sum_pos.ne' ];
        Â· exact fun y hy => âŸ¨ B, t, y, hB, ht, hs y hy, rfl âŸ©;
        Â· simp +decide [ â† Finset.sum_div _ _ _, â† Finset.sum_smul, h_sum_pos.ne' ];
          exact?;
      Â· ext; simp +decide [ div_eq_inv_mul, mul_assoc, mul_left_comm, Finset.mul_sum _ _ _, h_sum_pos.ne' ] ;

lemma exists_even_compact_extension (K : â„) (hK : K > 0) (Î¦ : â„ â†’ â„)
    (hÎ¦_cont : ContinuousOn Î¦ (Set.Icc (-K) K)) (hÎ¦_even : Even Î¦) :
  âˆƒ Î¨ : â„ â†’ â„, Continuous Î¨ âˆ§ HasCompactSupport Î¨ âˆ§ Even Î¨ âˆ§ âˆ€ x âˆˆ Set.Icc (-K) K, Î¨ x = Î¦ x := by
    by_contra h_even_trans;
    obtain âŸ¨Î¨â‚€, hÎ¨â‚€âŸ© : âˆƒ Î¨â‚€ : â„ â†’ â„, Continuous Î¨â‚€ âˆ§ HasCompactSupport Î¨â‚€ âˆ§ âˆ€ x âˆˆ Set.Icc (-K) K, Î¨â‚€ x = Î¦ x := by
      exact?;
    refine h_even_trans âŸ¨ fun x => ( Î¨â‚€ x + Î¨â‚€ ( -x ) ) / 2, ?_, ?_, ?_, ?_ âŸ©;
    Â· exact Continuous.div_const ( hÎ¨â‚€.1.add ( hÎ¨â‚€.1.comp ( ContinuousNeg.continuous_neg ) ) ) _;
    Â· simp_all +decide [ hasCompactSupport_iff_eventuallyEq, Filter.EventuallyEq ];
      exact âŸ¨ by rcases hÎ¨â‚€.2.1.1 with âŸ¨ a, ha âŸ© ; exact âŸ¨ Min.min a ( - ( hÎ¨â‚€.2.1.2.choose : â„ ) ), fun b hb => by rw [ ha b ( by linarith [ min_le_left a ( -hÎ¨â‚€.2.1.2.choose ) ] ), hÎ¨â‚€.2.1.2.choose_spec ( -b ) ( by linarith [ min_le_right a ( -hÎ¨â‚€.2.1.2.choose ) ] ) ] ; ring âŸ©, by rcases hÎ¨â‚€.2.1.2 with âŸ¨ b, hb âŸ© ; exact âŸ¨ Max.max b ( - ( hÎ¨â‚€.2.1.1.choose : â„ ) ), fun c hc => by rw [ hb c ( by linarith [ le_max_left b ( -hÎ¨â‚€.2.1.1.choose ) ] ), hÎ¨â‚€.2.1.1.choose_spec ( -c ) ( by linarith [ le_max_right b ( -hÎ¨â‚€.2.1.1.choose ) ] ) ] ; ring âŸ© âŸ©;
    Â· exact âŸ¨ fun x => ( Î¨â‚€ x + Î¨â‚€ ( -x ) ) / 4, by ext; norm_num; ring âŸ©;
    Â· intro x hx; specialize hÎ¦_even; cases' hÎ¦_even with hÎ¦_even hÎ¦_even; aesop;
      have := h_even_trans ( fun x => Î¨â‚€ x ) left_1 left_2 ( by
        exact âŸ¨ fun x => Î¨â‚€ x / 2, by ext; simp âŸ© ) ; aesop

lemma HeatKernel_even (t : â„) : Even (HeatKernel t) := by
  -- The heat kernel is even because it is symmetric around its center.
  use fun x => (4 * Real.pi * t) ^ (-(1 : â„) / 2) * Real.exp (-x^2 / (4 * t)) / 2;
  -- By definition of addition of functions, we can split the sum into two equal parts.
  funext x; simp [add_comm, add_left_comm];
  -- By definition of the heat kernel, we have:
  simp [HeatKernel]

lemma even_convolution (f g : â„ â†’ â„) (hf : Even f) (hg : Even g) : Even (real_convolution f g) := by
  unfold real_convolution;
  unfold Even at *; aesop;
  -- Let's choose $r(x) = \int y, w y * (w_1 (x - y) + w_1 (x - y))$.
  use fun x => âˆ« y, w y * (w_1 (x - y) + w_1 (x - y));
  -- By linearity of the integral, we can split the integral into two parts.
  funext x; simp [mul_add, add_mul, two_mul];
  -- By the linearity of the integral, we can split the integral into two parts.
  simp [â† two_mul, MeasureTheory.integral_const_mul]