/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 4cade134-0298-4ddb-bb7c-23c189a150e0

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 41e00457-25c4-4fdc-b700-f585d537aaaf

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions of the exponential function e(x), the heat kernel k_t, the log-scale nodes xi, and the index set of primes P_{N,K}.
-/
open Real Complex BigOperators Finset

-- 0. Conventions
def e (x : ℝ) : ℂ := Complex.exp (2 * π * I * x)

-- 1. RKHS environment
variable (t : ℝ) (K : ℝ)

def k_t (u v : ℝ) : ℝ := Real.exp (- (u - v)^2 / (4 * t))

def xi (p : ℕ) : ℝ := Real.log p / (2 * π)

def P_NK (N : ℕ) (K : ℝ) : Finset ℕ :=
  (range (N + 1)).filter (fun p => p.Prime ∧ xi p ≤ K)

abbrev Index (N : ℕ) (K : ℝ) := {p // p ∈ P_NK N K}

/-
Definitions of the Gram matrix G, the weight matrix W, and the twist matrix U_alpha.
-/
-- 1.2 Feature map + Gram matrix
def G (N : ℕ) (t K : ℝ) : Matrix (Index N K) (Index N K) ℂ :=
  fun p q => k_t t (xi p.val) (xi q.val)

-- 2. Prime weights
def w (p : ℕ) : ℝ := ArithmeticFunction.vonMangoldt p / Real.sqrt p

def W (N : ℕ) (K : ℝ) : Matrix (Index N K) (Index N K) ℂ :=
  Matrix.diagonal (fun p => w p.val)

-- 3. Additive circle twist
def U (N : ℕ) (K : ℝ) (alpha : ℝ) : Matrix (Index N K) (Index N K) ℂ :=
  Matrix.diagonal (fun p => e (alpha * p.val))

/-
Checking Matrix.PosSemidef and Matrix.norm definitions.
-/
#check Matrix.PosSemidef
#check Matrix.conjTranspose
#check Matrix.norm_def
#print Matrix.PosSemidef

/-
Definition of the real Gram matrix G_real.
-/
open Matrix BigOperators

-- 3.2 Matrix model for the operator norm
def G_real (N : ℕ) (t K : ℝ) : Matrix (Index N K) (Index N K) ℝ :=
  fun p q => k_t t (xi p.val) (xi q.val)

/-
Checking Matrix.PosSemidef.sqrt.
-/
#check Matrix.PosSemidef.sqrt

/-
Definition of sqrtG using a conditional on the positive semidefiniteness of G_real.
-/
open Matrix BigOperators Complex Classical

noncomputable def sqrtG (N : ℕ) (t K : ℝ) : Matrix (Index N K) (Index N K) ℂ :=
  if h : (G_real N t K).PosSemidef then
    (h.sqrt).map (algebraMap ℝ ℂ)
  else
    0

/-
Definitions of the balanced matrix B and the energy operator Q_op.
-/
open Matrix BigOperators Complex Classical

noncomputable def B (N : ℕ) (t K : ℝ) (alpha : ℝ) : Matrix (Index N K) (Index N K) ℂ :=
  let sG := sqrtG N t K
  sG * W N K * U N K alpha * sG

noncomputable def Q_op (N : ℕ) (t K : ℝ) (alpha : ℝ) : Matrix (Index N K) (Index N K) ℂ :=
  let B_val := B N t K alpha
  B_val * B_valᴴ

/-
Definitions of MajorArcs and MinorArcs. MajorArcs are unions of small intervals around rational points a/q on the circle. MinorArcs are the complement.
-/
open Set Real

def MajorArcs (N : ℕ) (Q : ℝ) : Set UnitAddCircle :=
  ⋃ (q : ℕ), ⋃ (_ : 1 ≤ q ∧ (q : ℝ) ≤ Q),
    ⋃ (a : ℕ), ⋃ (_ : 1 ≤ a ∧ a ≤ q ∧ a.Coprime q),
      {alpha : UnitAddCircle | dist alpha ((a : ℝ) / (q : ℝ)) ≤ Q / ((q : ℝ) * N)}

def MinorArcs (N : ℕ) (Q : ℝ) : Set UnitAddCircle :=
  (univ : Set UnitAddCircle) \ MajorArcs N Q

/-
Hypothesis Q3-2: There exist constants rho < 1, N0, and parameter choices t(N), K(N), Q(N) such that for all N >= N0 and all alpha (as a real number) whose projection to the circle is in the minor arcs, the operator norm of B is bounded by rho.
-/
open scoped Matrix.Norms.L2Operator
open Set Real

def Q3_2 : Prop :=
  ∃ (rho : ℝ) (N0 : ℕ) (t : ℕ → ℝ) (K : ℕ → ℝ) (Q : ℕ → ℝ),
    rho < 1 ∧
    ∀ N ≥ N0,
      ∀ (alpha : ℝ), (alpha : UnitAddCircle) ∈ MinorArcs N (Q N) →
        ‖B N (t N) (K N) alpha‖ ≤ rho

/-
Definition of the exponential sum S(alpha;N).
-/
noncomputable def S (N : ℕ) (alpha : ℝ) : ℂ :=
  ∑ n ∈ range (N + 1), ArithmeticFunction.vonMangoldt n * e (alpha * n)

/-
Definition of l2Norm for complex vectors.
-/
open Matrix BigOperators Complex

noncomputable def l2Norm {n : Type*} [Fintype n] (v : n → ℂ) : ℝ :=
  Real.sqrt (∑ i, ‖v i‖^2)

/-
Checking Finset.fintypeCoeSort.
-/
#check Finset.fintypeCoeSort

/-
Definition of BridgeRep. This axiom asserts that S(alpha;N) can be represented as an inner product involving a power of the operator B, plus a small error term, on the minor arcs. Note: We use dotProduct and l2Norm to handle L2 norms and inner products correctly.
-/
open scoped Matrix.Norms.L2Operator
open Set Real Complex Matrix BigOperators

noncomputable instance (N : ℕ) (K : ℝ) : Fintype (Index N K) :=
  Finset.fintypeCoeSort (P_NK N K)

noncomputable def BridgeRep (t : ℕ → ℝ) (K : ℕ → ℝ) (Q : ℕ → ℝ) : Prop :=
  ∃ (c0 : ℝ) (J : ℕ → ℕ) (u v : (N : ℕ) → Index N (K N) → ℂ) (Err : (N : ℕ) → ℝ → ℂ),
    c0 > 0 ∧
    (∀ (N : ℕ), c0 * Real.log (N : ℝ) ≤ (J N : ℝ)) ∧
    (∃ C, ∀ (N : ℕ), l2Norm (u N) ≤ C * Real.sqrt (N : ℝ) ∧ l2Norm (v N) ≤ C * Real.sqrt (N : ℝ)) ∧
    (∀ ε > 0, ∃ N0, ∀ (N : ℕ), N ≥ N0 → ∀ (alpha : ℝ), (alpha : UnitAddCircle) ∈ MinorArcs N (Q N) → ‖Err N alpha‖ ≤ ε * Real.sqrt (N : ℝ)) ∧
    (∀ (N : ℕ), ∀ (alpha : ℝ), (alpha : UnitAddCircle) ∈ MinorArcs N (Q N) →
      S N alpha = dotProduct (star (u N)) ((B N (t N) (K N) alpha) ^ (J N) *ᵥ (v N)) + Err N alpha)

/-
Definition of Q3-1 (Minor Arc Bound). It states that the exponential sum S(alpha;N) is bounded by N^(1/2 - delta) on the minor arcs.
-/
open scoped Matrix.Norms.L2Operator
open Set Real Complex Matrix BigOperators

def Q3_1 (Q : ℕ → ℝ) : Prop :=
  ∃ (delta : ℝ) (C : ℝ) (N0 : ℕ),
    delta > 0 ∧
    ∀ N ≥ N0, ∀ (alpha : ℝ), (alpha : UnitAddCircle) ∈ MinorArcs N (Q N) →
      ‖S N alpha‖ ≤ C * (N : ℝ) ^ ((1 : ℝ) / 2 - delta)

/-
Definition of BridgeRepV2. This version includes the stronger bound on the product of L2 norms of u and v, and the error term bound required for the deduction.
-/
open scoped Matrix.Norms.L2Operator
open Set Real Complex Matrix BigOperators

noncomputable def BridgeRepV2 (t : ℕ → ℝ) (K : ℕ → ℝ) (Q : ℕ → ℝ) : Prop :=
  ∃ (c0 : ℝ) (J : ℕ → ℕ) (u v : (N : ℕ) → Index N (K N) → ℂ) (Err : (N : ℕ) → ℝ → ℂ) (gamma : ℝ),
    c0 > 0 ∧ gamma > 0 ∧
    (∀ (N : ℕ), c0 * Real.log (N : ℝ) ≤ (J N : ℝ)) ∧
    (∃ C, ∀ (N : ℕ), l2Norm (u N) * l2Norm (v N) ≤ C * Real.sqrt (N : ℝ)) ∧
    (∃ C, ∀ (N : ℕ), ∀ (alpha : ℝ), (alpha : UnitAddCircle) ∈ MinorArcs N (Q N) → ‖Err N alpha‖ ≤ C * (N : ℝ) ^ ((1 : ℝ) / 2 - gamma)) ∧
    (∀ (N : ℕ), ∀ (alpha : ℝ), (alpha : UnitAddCircle) ∈ MinorArcs N (Q N) →
      S N alpha = dotProduct (star (u N)) ((B N (t N) (K N) alpha) ^ (J N) *ᵥ (v N)) + Err N alpha)

/-
If the operator norm of a matrix B is bounded by rho, then the norm of B^J is bounded by rho^J.
-/
theorem spectral_gap_geometric_decay {n : Type*} [Fintype n] [DecidableEq n] :
  ∀ (rho : ℝ) (hrho : 0 ≤ rho) (J : ℕ),
    ∀ (B : Matrix n n ℂ), ‖B‖ ≤ rho → ‖B ^ J‖ ≤ rho ^ J := by
      introv hr;
      refine' fun h => Nat.recOn J _ _ <;> simp_all +decide [ pow_succ, norm_mul_le ];
      · refine' le_trans ( csInf_le _ _ ) _;
        exact 1;
        · exact ⟨ 0, fun c hc => hc.1 ⟩;
        · simp +decide [ toEuclideanLin ];
        · norm_num;
      · exact fun n hn => le_trans ( norm_mul_le _ _ ) ( mul_le_mul hn h ( by positivity ) ( by positivity ) )

/-
Checking the types of Matrix.l2_opNorm_mulVec and Matrix.norm_def
-/
#check Matrix.l2_opNorm_mulVec
#check Matrix.norm_def

/-
The magnitude of the dot product of `star u` and `v` is bounded by the product of their L2 norms.
-/
theorem l2_cauchy_schwarz {n : Type*} [Fintype n] (u v : n → ℂ) :
  ‖dotProduct (star u) v‖ ≤ l2Norm u * l2Norm v := by
    -- Apply the Cauchy-Schwarz inequality to the dot product.
    have h_cauchy_schwarz : ‖∑ i, starRingEnd ℂ (u i) * v i‖^2 ≤ (∑ i, ‖u i‖^2) * (∑ i, ‖v i‖^2) := by
      -- Apply the Cauchy-Schwarz inequality to the vectors $u$ and $v$.
      have h_cauchy_schwarz : ∀ (u v : n → ℂ), ‖∑ i, u i * v i‖^2 ≤ (∑ i, ‖u i‖^2) * (∑ i, ‖v i‖^2) := by
        intro u v
        have h_cauchy_schwarz : ∀ (u v : n → ℝ), (∑ i, u i * v i)^2 ≤ (∑ i, u i^2) * (∑ i, v i^2) := by
          exact?;
        have := h_cauchy_schwarz ( fun i => ‖u i‖ ) ( fun i => ‖v i‖ );
        exact le_trans ( pow_le_pow_left₀ ( norm_nonneg _ ) ( norm_sum_le _ _ ) _ ) ( by simpa [ mul_pow ] using this );
      simpa using h_cauchy_schwarz ( fun i => starRingEnd ℂ ( u i ) ) v;
    convert Real.le_sqrt_of_sq_le h_cauchy_schwarz using 1;
    rw [ Real.sqrt_mul ( Finset.sum_nonneg fun _ _ => sq_nonneg _ ), l2Norm, l2Norm ]

/-
Checking the norm notation with L2Operator scope open.
-/
open scoped Matrix.Norms.L2Operator
#check (by
-- The norm of the zero matrix is zero by definition.
simp [Matrix.norm_def] : ‖(0 : Matrix (Fin 2) (Fin 2) ℂ)‖ = 0)

/-
The L2 norm of `M * v` is bounded by the operator norm of `M` times the L2 norm of `v`.
-/
theorem l2Norm_bound_mulVec {n : Type*} [Fintype n] [DecidableEq n] (M : Matrix n n ℂ) (v : n → ℂ) :
  l2Norm (M *ᵥ v) ≤ ‖M‖ * l2Norm v := by
    have := Matrix.l2_opNorm_mulVec ( M ) ( v );
    simp_all +decide [ EuclideanSpace.norm_eq, Real.sqrt_sq_eq_abs ];
    convert this using 1

/-
The absolute value of the inner product <u, Mv> is bounded by the operator norm of M times the L2 norms of u and v.
-/
theorem bilinear_bound {n : Type*} [Fintype n] [DecidableEq n] :
  ∀ (u v : n → ℂ) (M : Matrix n n ℂ),
    ‖dotProduct (star u) (M *ᵥ v)‖ ≤ ‖M‖ * l2Norm u * l2Norm v := by
      intros u v M;
      -- Apply the Cauchy-Schwarz inequality to the inner product.
      have h_cauchy_schwarz : ‖dotProduct (star u) (M.mulVec v)‖ ≤ l2Norm u * l2Norm (M.mulVec v) := by
        exact?;
      exact h_cauchy_schwarz.trans ( by nlinarith [ show 0 ≤ l2Norm u by exact Real.sqrt_nonneg _, show 0 ≤ l2Norm v by exact Real.sqrt_nonneg _, show 0 ≤ ‖M‖ by exact norm_nonneg M, show l2Norm ( M *ᵥ v ) ≤ ‖M‖ * l2Norm v from by simpa [ mul_comm ] using l2Norm_bound_mulVec M v ] )

/-
If the bridge representation holds and the operator norm is bounded by rho < 1, then the bilinear form decays as N^(1/2 - delta).
-/
theorem Q3_2_implies_bounded_bilinear
  (t K Q : ℕ → ℝ)
  (c0 : ℝ) (J : ℕ → ℕ) (u v : (N : ℕ) → Index N (K N) → ℂ)
  (hc0 : c0 > 0)
  (hJ : ∀ (N : ℕ), c0 * Real.log (N : ℝ) ≤ (J N : ℝ))
  (huv : ∃ C, ∀ (N : ℕ), l2Norm (u N) * l2Norm (v N) ≤ C * Real.sqrt (N : ℝ))
  (rho : ℝ) (N0_rho : ℕ) (hrho : rho < 1) (hrho_nonneg : 0 ≤ rho)
  (hB : ∀ N ≥ N0_rho, ∀ (alpha : ℝ), (alpha : UnitAddCircle) ∈ MinorArcs N (Q N) → ‖B N (t N) (K N) alpha‖ ≤ rho) :
  ∃ (C : ℝ) (delta : ℝ) (N0 : ℕ), delta > 0 ∧
    ∀ N ≥ N0, ∀ (alpha : ℝ), (alpha : UnitAddCircle) ∈ MinorArcs N (Q N) →
      ‖dotProduct (star (u N)) ((B N (t N) (K N) alpha) ^ (J N) *ᵥ (v N))‖
        ≤ C * (N : ℝ) ^ ((1 : ℝ) / 2 - delta) := by
          obtain ⟨C, hC⟩ := huv
          have hdelta : ∃ delta > 0, ∀ N ≥ 1, rho ^ (J N) ≤ (N : ℝ) ^ (-delta : ℝ) := by
            by_cases hrho_zero : rho = 0;
            · use 1; norm_num [ hrho_zero ];
              intro N hN; rw [ Real.rpow_neg_one ] ; by_cases hJN : J N = 0 <;> simp_all +decide;
              field_simp;
              exact_mod_cast le_of_not_gt fun h => absurd ( hJ N ) ( by norm_num [ hJN ] ; nlinarith [ Real.log_pos ( show ( N : ℝ ) > 1 by norm_cast ) ] );
            · -- Since $\rho < 1$, we can choose $\delta = -c_0 \log \rho$.
              use -c0 * Real.log rho;
              constructor;
              · exact mul_pos_of_neg_of_neg ( neg_neg_of_pos hc0 ) ( Real.log_neg ( lt_of_le_of_ne hrho_nonneg ( Ne.symm hrho_zero ) ) hrho );
              · intro N hN; rw [ Real.rpow_def_of_pos ( by positivity ) ] ; norm_num;
                rw [ ← Real.rpow_natCast, Real.rpow_def_of_pos ( lt_of_le_of_ne hrho_nonneg ( Ne.symm hrho_zero ) ) ] ; norm_num ; nlinarith [ hJ N, Real.log_nonneg ( show ( N : ℝ ) ≥ 1 by norm_cast ), Real.log_le_sub_one_of_pos ( show ( N : ℝ ) > 0 by positivity ), Real.log_le_sub_one_of_pos ( show ( rho : ℝ ) > 0 by positivity ) ];
          -- By combining the results from the spectral gap and the bilinear bound, we can conclude the proof.
          obtain ⟨delta, hdelta_pos, hdelta_bound⟩ := hdelta
          use C, delta, max N0_rho 1;
          have h_bound : ∀ N ≥ max N0_rho 1, ∀ alpha : ℝ, (alpha : UnitAddCircle) ∈ MinorArcs N (Q N) → ‖(star (u N)) ⬝ᵥ (B N (t N) (K N) alpha) ^ (J N) *ᵥ (v N)‖ ≤ rho ^ (J N) * (C * Real.sqrt N) := by
            intros N hN alpha halpha
            have h_bound : ‖(star (u N)) ⬝ᵥ (B N (t N) (K N) alpha) ^ (J N) *ᵥ (v N)‖ ≤ ‖(B N (t N) (K N) alpha) ^ (J N)‖ * l2Norm (u N) * l2Norm (v N) := by
              convert bilinear_bound _ _ _ using 1;
            have h_bound : ‖(B N (t N) (K N) alpha) ^ (J N)‖ ≤ rho ^ (J N) := by
              exact le_trans ( by simpa using spectral_gap_geometric_decay rho hrho_nonneg ( J N ) ( B N ( t N ) ( K N ) alpha ) ( hB N ( le_trans ( le_max_left _ _ ) hN ) alpha halpha ) ) ( by norm_num );
            exact le_trans ‹_› ( by simpa only [ mul_assoc ] using mul_le_mul h_bound ( hC N ) ( by exact mul_nonneg ( by exact Real.sqrt_nonneg _ ) ( by exact Real.sqrt_nonneg _ ) ) ( by positivity ) );
          simp_all +decide [ Real.sqrt_eq_rpow, Real.rpow_sub' ];
          intro N hN₁ hN₂ alpha halpha; convert le_trans ( h_bound N hN₁ hN₂ alpha halpha ) ( mul_le_mul_of_nonneg_right ( hdelta_bound N hN₂ ) ( mul_nonneg ( show 0 ≤ C by have := hC 1; norm_num at this; nlinarith [ show 0 ≤ l2Norm ( u 1 ) * l2Norm ( v 1 ) by exact mul_nonneg ( Real.sqrt_nonneg _ ) ( Real.sqrt_nonneg _ ) ] ) ( Real.rpow_nonneg ( Nat.cast_nonneg _ ) _ ) ) ) using 1 ; rw [ Real.rpow_sub ( by positivity ) ] ; ring;
          rw [ Real.rpow_neg ( by positivity ) ]

/-
Helper lemma: If A and B are bounded by power laws with decay rates d1 and d2, their sum is bounded by a power law with decay rate min(d1, d2).
-/
theorem bound_sum_decay {N : ℝ} (hN : 1 ≤ N) {A B C1 C2 d1 d2 : ℝ}
  (hA : A ≤ C1 * N ^ ((1 : ℝ) / 2 - d1))
  (hB : B ≤ C2 * N ^ ((1 : ℝ) / 2 - d2))
  (hC1 : 0 ≤ C1) (hC2 : 0 ≤ C2) :
  A + B ≤ (C1 + C2) * N ^ ((1 : ℝ) / 2 - min d1 d2) := by
    rw [ add_mul ];
    exact add_le_add ( hA.trans ( mul_le_mul_of_nonneg_left ( Real.rpow_le_rpow_of_exponent_le hN ( by linarith [ min_le_left d1 d2 ] ) ) hC1 ) ) ( hB.trans ( mul_le_mul_of_nonneg_left ( Real.rpow_le_rpow_of_exponent_le hN ( by linarith [ min_le_right d1 d2 ] ) ) hC2 ) )

/-
Helper lemma: The norm of a sum is bounded by the sum of the bounds, which decays with the minimum rate.
-/
theorem norm_bound_sum_decay {N : ℝ} (hN : 1 ≤ N) {Main Err : ℂ} {C_main C_err d_main d_err : ℝ}
  (h_main : ‖Main‖ ≤ C_main * N ^ ((1 : ℝ) / 2 - d_main))
  (h_err : ‖Err‖ ≤ C_err * N ^ ((1 : ℝ) / 2 - d_err))
  (h_C_main : 0 ≤ C_main) (h_C_err : 0 ≤ C_err) :
  ‖Main + Err‖ ≤ (C_main + C_err) * N ^ ((1 : ℝ) / 2 - min d_main d_err) := by
    refine le_trans ( norm_add_le _ _ ) ?_;
    exact le_trans ( add_le_add h_main h_err ) ( by rw [ add_mul ] ; gcongr <;> cases min_cases d_main d_err <;> linarith )

/-
If h decomposes into f and g, both of which satisfy power-law bounds on the set where P holds, then h satisfies a power-law bound.
-/
theorem asymptotic_bound_sum {X : Type*} (P : ℕ → X → Prop) (f g h : ℕ → X → ℂ)
  (h_decomp : ∀ N x, P N x → h N x = f N x + g N x)
  (h_f : ∃ C1 d1 N1, d1 > 0 ∧ ∀ N ≥ N1, ∀ x, P N x → ‖f N x‖ ≤ C1 * (N : ℝ) ^ ((1 : ℝ) / 2 - d1))
  (h_g : ∃ C2 d2 N2, d2 > 0 ∧ ∀ N ≥ N2, ∀ x, P N x → ‖g N x‖ ≤ C2 * (N : ℝ) ^ ((1 : ℝ) / 2 - d2)) :
  ∃ C d N0, d > 0 ∧ ∀ N ≥ N0, ∀ x, P N x → ‖h N x‖ ≤ C * (N : ℝ) ^ ((1 : ℝ) / 2 - d) := by
    obtain ⟨ C1, d1, N1, hd1, hf ⟩ := h_f;
    obtain ⟨ C2, d2, N2, hd2, hg ⟩ := h_g;
    refine' ⟨ |C1| + |C2|, Min.min d1 d2, Max.max N1 N2 + 1, lt_min hd1 hd2, fun N hN x hx => _ ⟩;
    rw [ h_decomp N x hx, add_mul ];
    refine' le_trans ( norm_add_le _ _ ) _;
    exact add_le_add ( le_trans ( hf N ( by linarith [ le_max_left N1 N2 ] ) x hx ) ( mul_le_mul_of_nonneg_right ( le_abs_self _ ) ( by positivity ) |> le_trans <| mul_le_mul_of_nonneg_left ( Real.rpow_le_rpow_of_exponent_le ( mod_cast by linarith [ le_max_left N1 N2 ] ) <| by cases min_cases d1 d2 <;> linarith ) <| by positivity ) ) ( le_trans ( hg N ( by linarith [ le_max_right N1 N2 ] ) x hx ) ( mul_le_mul_of_nonneg_right ( le_abs_self _ ) ( by positivity ) |> le_trans <| mul_le_mul_of_nonneg_left ( Real.rpow_le_rpow_of_exponent_le ( mod_cast by linarith [ le_max_right N1 N2 ] ) <| by cases min_cases d1 d2 <;> linarith ) <| by positivity ) )

/-
A function f decays on minor arcs if its norm is bounded by C * N^(1/2 - d) for some d > 0 and N large enough, for all alpha in the minor arcs.
-/
def DecaysOnMinorArcs (f : ℕ → ℝ → ℂ) (Q : ℕ → ℝ) : Prop :=
  ∃ C d N0, d > 0 ∧ ∀ N ≥ N0, ∀ (alpha : ℝ), (alpha : UnitAddCircle) ∈ MinorArcs N (Q N) →
    ‖f N alpha‖ ≤ C * (N : ℝ) ^ ((1 : ℝ) / 2 - d)

/-
If f and g decay on minor arcs, then their sum f + g also decays on minor arcs.
-/
theorem DecaysOnMinorArcs_add {Q : ℕ → ℝ} {f g : ℕ → ℝ → ℂ}
  (hf : DecaysOnMinorArcs f Q) (hg : DecaysOnMinorArcs g Q) :
  DecaysOnMinorArcs (fun N alpha => f N alpha + g N alpha) Q := by
    -- Apply `asymptotic_bound_sum` with `P N alpha := (alpha : UnitAddCircle) ∈ MinorArcs N (Q N)`.
    apply asymptotic_bound_sum;
    exact?;
    · bound;
    · exact hg

/-
The main term of the exponential sum approximation, defined as the bilinear form involving the matrix B raised to power J.
-/
def MainTerm (t K : ℕ → ℝ) (J : ℕ → ℕ) (u v : (N : ℕ) → Index N (K N) → ℂ) (N : ℕ) (alpha : ℝ) : ℂ :=
  dotProduct (star (u N)) ((B N (t N) (K N) alpha) ^ (J N) *ᵥ (v N))

/-
Under the assumptions of Q3-2 and the bridge representation parameters, the MainTerm decays on minor arcs.
-/
theorem Q3_2_implies_MainTerm_decay
  (t K Q : ℕ → ℝ) (c0 : ℝ) (J : ℕ → ℕ) (u v : (N : ℕ) → Index N (K N) → ℂ)
  (hc0 : c0 > 0)
  (hJ : ∀ (N : ℕ), c0 * Real.log (N : ℝ) ≤ (J N : ℝ))
  (huv : ∃ C, ∀ (N : ℕ), l2Norm (u N) * l2Norm (v N) ≤ C * Real.sqrt (N : ℝ))
  (rho : ℝ) (N0_rho : ℕ) (hrho : rho < 1) (hrho_nonneg : 0 ≤ rho)
  (hB : ∀ N ≥ N0_rho, ∀ (alpha : ℝ), (alpha : UnitAddCircle) ∈ MinorArcs N (Q N) → ‖B N (t N) (K N) alpha‖ ≤ rho) :
  DecaysOnMinorArcs (MainTerm t K J u v) Q := by
    exact Q3_2_implies_bounded_bilinear t K Q c0 J u v hc0 hJ huv rho N0_rho hrho hrho_nonneg hB

/-
If f decays on minor arcs and g equals f on minor arcs, then g decays on minor arcs.
-/
theorem DecaysOnMinorArcs_congr {Q : ℕ → ℝ} {f g : ℕ → ℝ → ℂ}
  (h_eq : ∀ N (alpha : ℝ), (alpha : UnitAddCircle) ∈ MinorArcs N (Q N) → f N alpha = g N alpha)
  (hf : DecaysOnMinorArcs f Q) :
  DecaysOnMinorArcs g Q := by
    obtain ⟨ C, d, N0, hd, hC ⟩ := hf;
    exact ⟨ C, d, N0, hd, fun N hN alpha halpha => by simpa only [ h_eq N alpha halpha ] using hC N hN alpha halpha ⟩