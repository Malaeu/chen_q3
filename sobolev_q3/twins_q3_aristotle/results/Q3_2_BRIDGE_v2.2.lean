/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 41e00457-25c4-4fdc-b700-f585d537aaaf

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions of the exponential function e(x), the heat kernel k_t, the log-scale nodes xi, and the index set of primes P_{N,K}.
-/
open Real Complex BigOperators Finset

-- 0. Conventions
def e (x : ℝ) : ℂ := Complex.exp (2 * π * I * x)

-- 1. RKHS environment
variable (t : ℝ) (K : ℝ)

def k_t (u v : ℝ) : ℝ := Real.exp (- (u - v)^2 / (4 * t))

def xi (p : ℕ) : ℝ := Real.log p / (2 * π)

def P_NK (N : ℕ) (K : ℝ) : Finset ℕ :=
  (range (N + 1)).filter (fun p => p.Prime ∧ xi p ≤ K)

abbrev Index (N : ℕ) (K : ℝ) := {p // p ∈ P_NK N K}

/-
Definitions of the Gram matrix G, the weight matrix W, and the twist matrix U_alpha.
-/
-- 1.2 Feature map + Gram matrix
def G (N : ℕ) (t K : ℝ) : Matrix (Index N K) (Index N K) ℂ :=
  fun p q => k_t t (xi p.val) (xi q.val)

-- 2. Prime weights
def w (p : ℕ) : ℝ := ArithmeticFunction.vonMangoldt p / Real.sqrt p

def W (N : ℕ) (K : ℝ) : Matrix (Index N K) (Index N K) ℂ :=
  Matrix.diagonal (fun p => w p.val)

-- 3. Additive circle twist
def U (N : ℕ) (K : ℝ) (alpha : ℝ) : Matrix (Index N K) (Index N K) ℂ :=
  Matrix.diagonal (fun p => e (alpha * p.val))

/-
Checking Matrix.PosSemidef and Matrix.norm definitions.
-/
#check Matrix.PosSemidef
#check Matrix.conjTranspose
#check Matrix.norm_def
#print Matrix.PosSemidef

/-
Definition of the real Gram matrix G_real.
-/
open Matrix BigOperators

-- 3.2 Matrix model for the operator norm
def G_real (N : ℕ) (t K : ℝ) : Matrix (Index N K) (Index N K) ℝ :=
  fun p q => k_t t (xi p.val) (xi q.val)

/-
Checking Matrix.PosSemidef.sqrt.
-/
#check Matrix.PosSemidef.sqrt

/-
Definition of sqrtG using a conditional on the positive semidefiniteness of G_real.
-/
open Matrix BigOperators Complex Classical

noncomputable def sqrtG (N : ℕ) (t K : ℝ) : Matrix (Index N K) (Index N K) ℂ :=
  if h : (G_real N t K).PosSemidef then
    (h.sqrt).map (algebraMap ℝ ℂ)
  else
    0

/-
Definitions of the balanced matrix B and the energy operator Q_op.
-/
open Matrix BigOperators Complex Classical

noncomputable def B (N : ℕ) (t K : ℝ) (alpha : ℝ) : Matrix (Index N K) (Index N K) ℂ :=
  let sG := sqrtG N t K
  sG * W N K * U N K alpha * sG

noncomputable def Q_op (N : ℕ) (t K : ℝ) (alpha : ℝ) : Matrix (Index N K) (Index N K) ℂ :=
  let B_val := B N t K alpha
  B_val * B_valᴴ

/-
Definitions of MajorArcs and MinorArcs. MajorArcs are unions of small intervals around rational points a/q on the circle. MinorArcs are the complement.
-/
open Set Real

def MajorArcs (N : ℕ) (Q : ℝ) : Set UnitAddCircle :=
  ⋃ (q : ℕ), ⋃ (_ : 1 ≤ q ∧ (q : ℝ) ≤ Q),
    ⋃ (a : ℕ), ⋃ (_ : 1 ≤ a ∧ a ≤ q ∧ a.Coprime q),
      {alpha : UnitAddCircle | dist alpha ((a : ℝ) / (q : ℝ)) ≤ Q / ((q : ℝ) * N)}

def MinorArcs (N : ℕ) (Q : ℝ) : Set UnitAddCircle :=
  (univ : Set UnitAddCircle) \ MajorArcs N Q

/-
Hypothesis Q3-2: There exist constants rho < 1, N0, and parameter choices t(N), K(N), Q(N) such that for all N >= N0 and all alpha (as a real number) whose projection to the circle is in the minor arcs, the operator norm of B is bounded by rho.
-/
open scoped Matrix.Norms.L2Operator
open Set Real

def Q3_2 : Prop :=
  ∃ (rho : ℝ) (N0 : ℕ) (t : ℕ → ℝ) (K : ℕ → ℝ) (Q : ℕ → ℝ),
    rho < 1 ∧
    ∀ N ≥ N0,
      ∀ (alpha : ℝ), (alpha : UnitAddCircle) ∈ MinorArcs N (Q N) →
        ‖B N (t N) (K N) alpha‖ ≤ rho

/-
Definition of the exponential sum S(alpha;N).
-/
noncomputable def S (N : ℕ) (alpha : ℝ) : ℂ :=
  ∑ n ∈ range (N + 1), ArithmeticFunction.vonMangoldt n * e (alpha * n)

/-
Definition of l2Norm for complex vectors.
-/
open Matrix BigOperators Complex

noncomputable def l2Norm {n : Type*} [Fintype n] (v : n → ℂ) : ℝ :=
  Real.sqrt (∑ i, ‖v i‖^2)

/-
Checking Finset.fintypeCoeSort.
-/
#check Finset.fintypeCoeSort

/-
Definition of BridgeRep. This axiom asserts that S(alpha;N) can be represented as an inner product involving a power of the operator B, plus a small error term, on the minor arcs. Note: We use dotProduct and l2Norm to handle L2 norms and inner products correctly.
-/
open scoped Matrix.Norms.L2Operator
open Set Real Complex Matrix BigOperators

noncomputable instance (N : ℕ) (K : ℝ) : Fintype (Index N K) :=
  Finset.fintypeCoeSort (P_NK N K)

noncomputable def BridgeRep (t : ℕ → ℝ) (K : ℕ → ℝ) (Q : ℕ → ℝ) : Prop :=
  ∃ (c0 : ℝ) (J : ℕ → ℕ) (u v : (N : ℕ) → Index N (K N) → ℂ) (Err : (N : ℕ) → ℝ → ℂ),
    c0 > 0 ∧
    (∀ (N : ℕ), c0 * Real.log (N : ℝ) ≤ (J N : ℝ)) ∧
    (∃ C, ∀ (N : ℕ), l2Norm (u N) ≤ C * Real.sqrt (N : ℝ) ∧ l2Norm (v N) ≤ C * Real.sqrt (N : ℝ)) ∧
    (∀ ε > 0, ∃ N0, ∀ (N : ℕ), N ≥ N0 → ∀ (alpha : ℝ), (alpha : UnitAddCircle) ∈ MinorArcs N (Q N) → ‖Err N alpha‖ ≤ ε * Real.sqrt (N : ℝ)) ∧
    (∀ (N : ℕ), ∀ (alpha : ℝ), (alpha : UnitAddCircle) ∈ MinorArcs N (Q N) →
      S N alpha = dotProduct (star (u N)) ((B N (t N) (K N) alpha) ^ (J N) *ᵥ (v N)) + Err N alpha)

/-
Definition of Q3-1 (Minor Arc Bound). It states that the exponential sum S(alpha;N) is bounded by N^(1/2 - delta) on the minor arcs.
-/
open scoped Matrix.Norms.L2Operator
open Set Real Complex Matrix BigOperators

def Q3_1 (Q : ℕ → ℝ) : Prop :=
  ∃ (delta : ℝ) (C : ℝ) (N0 : ℕ),
    delta > 0 ∧
    ∀ N ≥ N0, ∀ (alpha : ℝ), (alpha : UnitAddCircle) ∈ MinorArcs N (Q N) →
      ‖S N alpha‖ ≤ C * (N : ℝ) ^ ((1 : ℝ) / 2 - delta)

/-
Definition of BridgeRepV2. This version includes the stronger bound on the product of L2 norms of u and v, and the error term bound required for the deduction.
-/
open scoped Matrix.Norms.L2Operator
open Set Real Complex Matrix BigOperators

noncomputable def BridgeRepV2 (t : ℕ → ℝ) (K : ℕ → ℝ) (Q : ℕ → ℝ) : Prop :=
  ∃ (c0 : ℝ) (J : ℕ → ℕ) (u v : (N : ℕ) → Index N (K N) → ℂ) (Err : (N : ℕ) → ℝ → ℂ) (gamma : ℝ),
    c0 > 0 ∧ gamma > 0 ∧
    (∀ (N : ℕ), c0 * Real.log (N : ℝ) ≤ (J N : ℝ)) ∧
    (∃ C, ∀ (N : ℕ), l2Norm (u N) * l2Norm (v N) ≤ C * Real.sqrt (N : ℝ)) ∧
    (∃ C, ∀ (N : ℕ), ∀ (alpha : ℝ), (alpha : UnitAddCircle) ∈ MinorArcs N (Q N) → ‖Err N alpha‖ ≤ C * (N : ℝ) ^ ((1 : ℝ) / 2 - gamma)) ∧
    (∀ (N : ℕ), ∀ (alpha : ℝ), (alpha : UnitAddCircle) ∈ MinorArcs N (Q N) →
      S N alpha = dotProduct (star (u N)) ((B N (t N) (K N) alpha) ^ (J N) *ᵥ (v N)) + Err N alpha)