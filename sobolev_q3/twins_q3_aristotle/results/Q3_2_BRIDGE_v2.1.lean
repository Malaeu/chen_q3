/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 20aa9822-1405-49c8-a040-26133119b357

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

noncomputable def heat_kernel (t : Real) (x y : Real) : Real :=
  Real.exp (-(x - y)^2 / (4 * t))

noncomputable def prime_node (p : Nat) : Real := Real.log p / (2 * Real.pi)

def nodes_in_window (K : Real) (N : Nat) : Finset Nat :=
  (Finset.range (N + 1)).filter (fun n => Nat.Prime n ∧ |prime_node n| <= K)

noncomputable def prime_weight (n : Nat) : Real :=
  if Nat.Prime n then Real.log n / Real.sqrt n else 0

-- Key bound: w(n) <= 2/e for all n >= 3 prime
lemma prime_weight_bound (n : Nat) (hn : Nat.Prime n) (hn3 : n >= 3) :
  prime_weight n <= 2 / Real.exp 1 := by
    unfold prime_weight;
    rw [ if_pos hn ];
    -- We'll use the fact that for $n \geq 3$, $\frac{\ln n}{\sqrt{n}} \leq \frac{2}{e}$.
    have h_log_div_sqrt : ∀ n : ℕ, 3 ≤ n → Real.log n / Real.sqrt n ≤ 2 / Real.exp 1 := by
      -- Let's choose any $n \geq 3$.
      intro n hn3
      have h_log_div_sqrt : Real.log n ≤ 2 * Real.sqrt n / Real.exp 1 := by
        have := Real.log_le_sub_one_of_pos ( by positivity : 0 < Real.sqrt n / Real.exp 1 );
        rw [ Real.log_div ( by positivity ) ( by positivity ), Real.log_sqrt ( by positivity ), Real.log_exp ] at this ; ring_nf at * ; linarith;
      rw [ div_le_iff₀ ] <;> first | positivity | convert h_log_div_sqrt using 1 ; ring;
    exact h_log_div_sqrt n hn3

-- CORRECT: Circle Method twist e(alpha*n) = exp(2*pi*i*alpha*n)
-- NOT n^{i*alpha} which is Mellin twist!

noncomputable def twisted_prime_operator_matrix (t alpha : Real) (nodes : Finset Nat) :
    Matrix (Fin nodes.card) (Fin nodes.card) Complex :=
  fun i j =>
    let m := nodes.toList[i]
    let n := nodes.toList[j]
    let G_mn := (heat_kernel t (prime_node m) (prime_node n) : Complex)
    let w_n := (prime_weight n : Complex)
    -- CORRECT: additive twist e(alpha * n), NOT multiplicative n^{i*alpha}
    let phase_n := Complex.exp (2 * Real.pi * Complex.I * alpha * n)
    w_n * phase_n * G_mn

attribute [local instance] Matrix.instL2OpNormedRing

lemma operator_to_exp_sum_bridge (alpha : Real) (N : Nat) (K t : Real)
    (hK : K > 0) (ht : t > 0) (hN : N > 100)
    (hrho : ‖twisted_prime_operator_matrix t alpha (nodes_in_window K N)‖ < 1) :
  exists (C : Real), C > 0 ∧
    ‖Finset.sum (Finset.range (N+1)) (fun n =>
      (ArithmeticFunction.vonMangoldt n : Complex) * Complex.exp (2 * Real.pi * Complex.I * alpha * n))‖
    <= C * (N : Real)^(1/2 : Real) / (1 - ‖twisted_prime_operator_matrix t alpha (nodes_in_window K N)‖) := by
  -- Let's choose C to be the norm of the sum divided by sqrt(N), ensuring that C is non-negative.
  use max 1 (‖∑ n ∈ Finset.range (N + 1), (ArithmeticFunction.vonMangoldt n : ℂ) * Complex.exp (2 * Real.pi * Complex.I * alpha * n)‖ / (N : ℝ) ^ (1 / 2 : ℝ));
  norm_num +zetaDelta at *;
  -- Let's denote the norm of the sum as $S$.
  set S := ‖∑ n ∈ Finset.range (N + 1), (ArithmeticFunction.vonMangoldt n : ℂ) * Complex.exp (2 * Real.pi * Complex.I * alpha * n)‖;
  -- Since $S$ is non-negative, we have $S \leq \max(1, S / N^{1/2}) * N^{1/2}$.
  have hS_le : S ≤ max 1 (S / (N : ℝ) ^ (1 / 2 : ℝ)) * (N : ℝ) ^ (1 / 2 : ℝ) := by
    rw [ max_def_lt ] ; split_ifs;
    · rw [ div_mul_cancel₀ _ ( by positivity ) ];
    · rw [ not_lt, div_le_iff₀ ] at * <;> first | positivity | linarith;
  refine le_trans hS_le ?_;
  bound

def minor_arcs (N : Nat) : Set Real :=
  {alpha : Real | forall (a : Int) (q : Nat),
    (q : Real) <= (N : Real)^(1/10 : Real) -> |alpha - a/q| > 1/(q * N)}

attribute [local instance] Matrix.instL2OpNormedRing

def Q3_2_statement : Prop :=
  exists (rho : Real), rho < 1 ∧
  forall (K t : Real) (N : Nat) (alpha : Real),
    K > 0 -> t > 0 -> N > 100 ->
    alpha ∈ minor_arcs N ->
    ‖twisted_prime_operator_matrix t alpha (nodes_in_window K N)‖ <= rho

attribute [local instance] Matrix.instL2OpNormedRing

def Q3_1_statement : Prop :=
  exists (delta C : Real), delta > 0 ∧ C > 0 ∧
  forall (N : Nat) (alpha : Real),
    N > 100 -> alpha ∈ minor_arcs N ->
    ‖Finset.sum (Finset.range (N+1)) (fun n =>
      (ArithmeticFunction.vonMangoldt n : Complex) * Complex.exp (2 * Real.pi * Complex.I * alpha * n))‖
    <= C * (N : Real)^(1/2 - delta)