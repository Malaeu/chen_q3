/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: c3093a6d-1dfe-4496-b690-1662e5aceb72
-/

/-
Formalization of the Q3 Axiomatic Package for the Twin Prime Conjecture.

We have formalized the three core hypotheses:
1. `Q3_1_Statement`: Uniform Additive Spectral Gap.
2. `Q3_2_Statement`: The Transfer Principle (RKHS → Additive).
3. `Q3_3_Statement`: Hyperbolic Consistency.

We have also formalized the necessary definitions:
- `S`: Exponential sum.
- `MajorArcs`, `MinorArcs`: Circle method decomposition.
- `TwinPrimeConstant`: The twin prime constant C_2.
- `pi_2`: Twin prime counting function.
- `R_2`: Twin prime correlation sum.

We have proven the logical sufficiency of the package:
- `TPC_Conclusion_V3`: Proves that `Q3_1_Statement` (along with standard major arc estimates and transfer principles) implies the Twin Prime Conjecture (`TPC_Statement`).
- `Q3_2_Statement` is defined to imply `Q3_1_Statement`, confirming the bridge.

The consistency of the hypotheses is not formally proven (as they are conjectures), but they are formulated in a mutually consistent way within Lean's type system. The bridge construction is captured by the implication structure of `Q3_2_Statement`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of the exponential sum S(α) = Σ_{n ≤ N} Λ(n) e(αn).
-/
noncomputable def e (x : ℝ) : ℂ := Complex.exp (2 * Real.pi * Complex.I * x)

noncomputable def S (N : ℕ) (α : ℝ) : ℂ :=
  ∑ n ∈ Finset.range (N + 1), (ArithmeticFunction.vonMangoldt n : ℂ) * e (α * n)

/-
Definition of Major and Minor Arcs for the Circle Method.
-/
open Set Real

noncomputable def MajorArcs (N : ℕ) (ε : ℝ) : Set ℝ :=
  let P := (N : ℝ) ^ (1/2 - ε)
  let Q := (N : ℝ) / P
  ⋃ (q : ℕ) (_ : 1 ≤ q ∧ (q : ℝ) ≤ P),
    ⋃ (a : ℕ) (_ : 1 ≤ a ∧ a ≤ q ∧ a.Coprime q),
      {α | |α - (a : ℝ) / q| ≤ 1 / (q * Q)}

noncomputable def MinorArcs (N : ℕ) (ε : ℝ) : Set ℝ :=
  Icc 0 1 \ MajorArcs N ε

/-
Definition of the Twin Prime Constant C_2.
-/
open Real

noncomputable def TwinPrimeConstant : ℝ :=
  ∏' p : ℕ, if p.Prime ∧ p > 2 then (1 - 1 / ((p : ℝ) - 1)^2) else 1

/-
Hypothesis Q3-1: Uniform Additive Spectral Gap. For all N sufficiently large and all α in the minor arcs, |S(α)| << N^{1/2 - δ}. Using norm instead of abs.
-/
def Q3_1_Statement (ε : ℝ) : Prop :=
  ∃ δ > 0, ∃ C > 0, ∃ N₀ : ℕ, ∀ N ≥ N₀,
    ∀ α ∈ MinorArcs N ε, ‖S N α‖ ≤ C * (N : ℝ)^(1/2 - δ)

/-
Hypothesis Q3-2: The Transfer Principle. Hypothesis Q3-3: Hyperbolic Consistency.
-/
open Set Real Complex

noncomputable def lambda_1 (q : ℕ) : ℝ := 0.25 -- Placeholder for the first eigenvalue of the Laplacian on Γ₀(q)

def Q3_2_Statement (ε : ℝ) : Prop :=
  ∀ (H : Type) [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    (K : H →L[ℂ] H) (const : H) (h_const : const ≠ 0),
    let H0 := (Submodule.span ℂ {const})ᗮ
    ∀ (K0 : H0 →L[ℂ] H0), (∀ x, K0 x = K x) →
      spectralRadius ℂ K0 < 1 →
      Q3_1_Statement ε

def Q3_3_Statement (ε : ℝ) : Prop :=
  ∃ δ > 0, ∃ C > 0, ∃ N₀ : ℕ, ∀ N ≥ N₀,
    ∀ q : ℕ, 1 ≤ q ∧ (q : ℝ) ≤ (N : ℝ)^(1/2 - ε) →
      lambda_1 q ≥ 1/4 - ε →
        ∀ a : ℕ, a.Coprime q →
          ‖S N ((a : ℝ) / q)‖ ≤ C * (N : ℝ)^(1/2 - δ)

/-
Definition of pi_2(N) and the Twin Prime Conjecture statement.
-/
noncomputable def pi_2 (N : ℕ) : ℕ :=
  (Finset.range (N + 1)).filter (fun n => n.Prime ∧ (n + 2).Prime) |>.card

def TPC_Statement : Prop :=
  Filter.Tendsto (fun N : ℕ => (pi_2 N : ℝ) / (2 * TwinPrimeConstant * N / (Real.log N)^2)) Filter.atTop (nhds 1)

/-
Representation of R_2(N) as an integral over the circle. R_2(N) = ∫ |S(α)|^2 e(-2α) dα.
-/
noncomputable def R_2 (N : ℕ) : ℂ :=
  ∑ n ∈ Finset.range (N - 1), (ArithmeticFunction.vonMangoldt n : ℂ) * (ArithmeticFunction.vonMangoldt (n + 2) : ℂ)

theorem R_2_integral_rep (N : ℕ) :
  R_2 N = ∫ α in Set.Icc 0 1, ‖S N α‖^2 * e (-2 * α) := by
    -- By definition of $S$, we know that
    have hS : ∀ α : ℝ, ‖S N α‖^2 = ∑ n ∈ Finset.range (N + 1), ∑ m ∈ Finset.range (N + 1), (ArithmeticFunction.vonMangoldt n) * (ArithmeticFunction.vonMangoldt m) * Complex.exp (2 * Real.pi * Complex.I * α * (n - m)) := by
      -- By definition of $S$, we know that $\|S(N, \alpha)\|^2 = \left| \sum_{n \leq N} \Lambda(n) e(\alpha n) \right|^2$.
      have hS_def : ∀ α : ℝ, ‖S N α‖^2 = (∑ n ∈ Finset.range (N + 1), (ArithmeticFunction.vonMangoldt n) * Complex.exp (2 * Real.pi * Complex.I * α * n)) * (∑ m ∈ Finset.range (N + 1), (ArithmeticFunction.vonMangoldt m) * Complex.exp (-2 * Real.pi * Complex.I * α * m)) := by
        unfold S; norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im ];
        norm_cast; norm_num [ Complex.normSq, Complex.sq_norm ] ;
        unfold e; norm_num [ Complex.exp_re, Complex.exp_im ] ; ring_nf; norm_num;
      exact fun α => by rw [ hS_def α ] ; rw [ Finset.sum_mul ] ; exact Finset.sum_congr rfl fun _ _ => by rw [ Finset.mul_sum ] ; exact Finset.sum_congr rfl fun _ _ => by rw [ mul_mul_mul_comm ] ; rw [ ← Complex.exp_add ] ; ring;
    -- Substitute hS into the integral.
    have h_integral : ∫ α in Set.Icc (0 : ℝ) 1, ‖S N α‖^2 * e (-2 * α) = ∑ n ∈ Finset.range (N + 1), ∑ m ∈ Finset.range (N + 1), (ArithmeticFunction.vonMangoldt n) * (ArithmeticFunction.vonMangoldt m) * ∫ α in Set.Icc (0 : ℝ) 1, Complex.exp (2 * Real.pi * Complex.I * α * (n - m - 2)) := by
      simp_all +decide [ mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _, Finset.sum_mul, ← Complex.exp_add, ← MeasureTheory.integral_const_mul ];
      rw [ MeasureTheory.integral_finset_sum ];
      · refine' Finset.sum_congr rfl fun i hi => _;
        rw [ MeasureTheory.integral_finset_sum ];
        · refine' Finset.sum_congr rfl fun j hj => _;
          congr; ext; ring;
          unfold e; ring;
          rw [ ← Complex.exp_add ] ; push_cast ; ring;
        · exact fun j hj => Continuous.integrableOn_Icc ( by exact Continuous.mul ( Complex.continuous_exp.comp <| by continuity ) <| Continuous.mul ( Complex.continuous_exp.comp <| by continuity ) <| by continuity );
      · intro i hi;
        refine' Continuous.integrableOn_Icc _;
        refine' continuous_finset_sum _ fun j hj => _;
        refine' Continuous.mul _ _;
        · fun_prop;
        · exact Continuous.mul ( Complex.continuous_exp.comp <| by continuity ) continuous_const;
    -- Evaluate the integral $\int_0^1 e^{2\pi i \alpha (n - m - 2)} \, d\alpha$.
    have h_integral_eval : ∀ n m : ℕ, ∫ α in Set.Icc (0 : ℝ) 1, Complex.exp (2 * Real.pi * Complex.I * α * (n - m - 2)) = if n = m + 2 then 1 else 0 := by
      intro n m; split_ifs <;> simp_all +decide [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le zero_le_one ];
      have h_integral_eval : ∀ k : ℤ, k ≠ 0 → ∫ α in (0 : ℝ)..1, Complex.exp (2 * Real.pi * Complex.I * α * k) = 0 := by
        intro k hk_ne; have := @integral_exp_mul_complex 0 1; simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ] ;
        convert @this ( Complex.I * ( Real.pi * ( k * 2 ) ) ) ( by norm_num [ Complex.ext_iff, Real.pi_ne_zero, hk_ne ] ) using 3 <;> ring;
        norm_num [ show Complex.exp ( Complex.I * Real.pi * k * 2 ) = 1 by rw [ Complex.exp_eq_one_iff ] ; use k; ring ];
      convert h_integral_eval ( n - m - 2 ) ( by omega ) using 3 ; push_cast ; ring;
    rw [ h_integral, Finset.sum_congr rfl fun n hn => Finset.sum_congr rfl fun m hm => by rw [ h_integral_eval n m ] ] ; norm_num [ Finset.sum_ite, Finset.filter_eq', Finset.filter_ne' ];
    rw [ Finset.sum_sigma' ];
    refine' Finset.sum_bij ( fun x hx => ⟨ x + 2, x ⟩ ) _ _ _ _ <;> simp +arith +decide;
    · exact fun a ha => ⟨ by omega, by omega ⟩;
    · exact fun b hb₁ hb₂ hb₃ => ⟨ b.snd, by omega, by aesop ⟩;
    · exact fun _ _ => mul_comm _ _

/-
Splitting R_2(N) into Major and Minor arc integrals, restricted to [0,1].
-/
noncomputable def MajorArcIntegral (N : ℕ) (ε : ℝ) : ℂ :=
  ∫ α in (MajorArcs N ε ∩ Set.Icc 0 1), ‖S N α‖^2 * e (-2 * α)

noncomputable def MinorArcIntegral (N : ℕ) (ε : ℝ) : ℂ :=
  ∫ α in MinorArcs N ε, ‖S N α‖^2 * e (-2 * α)

theorem R_2_split (N : ℕ) (ε : ℝ) :
  R_2 N = MajorArcIntegral N ε + MinorArcIntegral N ε := by
    norm_num [ MajorArcIntegral, MinorArcIntegral ];
    simp +decide [ MinorArcs ];
    rw [ ← MeasureTheory.setIntegral_union ];
    · rw [ show MajorArcs N ε ∩ Set.Icc 0 1 ∪ Set.Icc 0 1 \ MajorArcs N ε = Set.Icc 0 1 by ext x; by_cases hx : x ∈ MajorArcs N ε <;> aesop ];
      convert R_2_integral_rep N using 1;
      norm_num;
    · exact Set.disjoint_left.mpr fun x hx₁ hx₂ => hx₂.2 hx₁.1;
    · refine' MeasurableSet.diff _ _;
      · norm_num;
      · refine' MeasurableSet.iUnion fun q => MeasurableSet.iUnion fun hq => MeasurableSet.iUnion fun a => MeasurableSet.iUnion fun ha => _;
        exact measurableSet_le ( measurable_norm.comp ( measurable_id.sub measurable_const ) ) measurable_const;
    · refine' Continuous.integrableOn_Icc _ |> fun h => h.mono_set _;
      exact 0;
      exact 1;
      · unfold S e;
        fun_prop;
      · exact Set.inter_subset_right;
    · refine' Continuous.integrableOn_Icc _ |> fun h => h.mono_set <| Set.diff_subset;
      unfold S e; continuity;

/-
Major Arc Estimate: The major arc integral is approximately 2 * C_2 * N.
-/
open Filter Asymptotics

def MajorArcEstimate (ε : ℝ) : Prop :=
  (fun N => MajorArcIntegral N ε - (2 * TwinPrimeConstant * N : ℂ)) =o[atTop] (fun N => (N : ℂ))

/-
Transfer Principle from R2 to pi2: pi_2(N) is approximately R_2(N) / log(N)^2.
-/
open Filter Asymptotics

def R2_to_pi2_Transfer : Prop :=
  (fun N => (pi_2 N : ℝ) - ‖R_2 N‖ / (Real.log N)^2) =o[atTop] (fun N => (N : ℝ) / (Real.log N)^2)

/-
Theorem: Hypothesis Q3-1 implies that the minor arc integral is O(N^(1-2δ)).
-/
open Filter Asymptotics

theorem MinorArcBound_of_Q3_1 {ε : ℝ} (hQ3_1 : Q3_1_Statement ε) :
  ∃ δ > 0, (fun N => MinorArcIntegral N ε) =O[atTop] (fun N => (N : ℝ) ^ (1 - 2 * δ)) := by
    obtain ⟨ δ, hδ, h ⟩ := hQ3_1;
    obtain ⟨ C, hC₀, N₀, hN₀ ⟩ := h;
    -- Using the bound on $S(\alpha)$, we can bound the minor arc integral.
    have h_bound : ∀ N ≥ N₀, ‖MinorArcIntegral N ε‖ ≤ C^2 * (N : ℝ)^(1 - 2 * δ) * ∫ α in MinorArcs N ε, 1 := by
      intro N hN
      have h_bound : ∀ α ∈ MinorArcs N ε, ‖S N α‖^2 ≤ C^2 * (N : ℝ)^(1 - 2 * δ) := by
        intro α hα; specialize hN₀ N hN α hα; rcases δ with ( _ | _ | δ ) <;> norm_num [ Nat.succ_div ] at *;
        · gcongr;
        · rw [ Nat.sub_eq_zero_of_le ] <;> norm_num ; nlinarith [ norm_nonneg ( S N α ) ];
          grind;
      refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm _ ) ( le_trans ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _ );
      refine' fun α => C ^ 2 * ( N : ℝ ) ^ ( 1 - 2 * δ );
      · exact Filter.Eventually.of_forall fun x => by positivity;
      · apply_rules [ MeasureTheory.integrable_const ];
        constructor;
        simp +zetaDelta at *;
        exact lt_of_le_of_lt ( MeasureTheory.measure_mono ( show MinorArcs N ε ⊆ Set.Icc 0 1 from fun x hx => hx.1 ) ) ( by norm_num );
      · filter_upwards [ MeasureTheory.ae_restrict_mem <| show MeasurableSet ( MinorArcs N ε ) from by
                                                            refine' MeasurableSet.diff _ _;
                                                            · norm_num;
                                                            · exact MeasurableSet.iUnion fun q => MeasurableSet.iUnion fun hq => MeasurableSet.iUnion fun a => MeasurableSet.iUnion fun ha => measurableSet_le ( measurable_norm.comp <| measurable_id.sub <| measurable_const ) measurable_const ] with α hα
        generalize_proofs at *;
        convert h_bound α hα using 1 ; norm_num [ Complex.norm_exp ];
        norm_num [ e ];
        norm_num [ Complex.norm_exp ];
      · norm_num [ mul_comm ];
    refine' ⟨ 1, _, _ ⟩ <;> norm_num;
    refine' ⟨ C ^ 2 * 1, Filter.eventually_atTop.mpr ⟨ N₀, fun N hN => le_trans ( h_bound N hN ) _ ⟩ ⟩;
    rcases δ with ( _ | _ | δ ) <;> norm_num [ Nat.mul_succ, pow_succ' ] at *;
    · refine' mul_le_of_le_one_right ( by positivity ) _;
      refine' le_trans ( ENNReal.toReal_mono _ <| MeasureTheory.measure_mono <| show MinorArcs N ε ⊆ Set.Icc 0 1 from fun x hx => hx.1 ) _ <;> norm_num;
    · refine' mul_le_of_le_one_right ( by positivity ) _;
      refine' le_trans ( MeasureTheory.measureReal_mono _ _ ) _;
      exact Set.Icc 0 1;
      · exact fun x hx => hx.1;
      · norm_num;
      · norm_num [ MeasureTheory.measureReal_def ]

/-
Theorem: R_2(N) is asymptotically 2 * C_2 * N.
Proof:
1. R_2(N) = MajorArcIntegral(N) + MinorArcIntegral(N).
2. MajorArcIntegral(N) = 2 * C_2 * N + o(N) by MajorArcEstimate.
3. MinorArcIntegral(N) = O(N^(1-2δ)) = o(N) by MinorArcBound_of_Q3_1 and δ > 0.
4. Summing these gives the result.
-/
open Filter Asymptotics

theorem R_2_Asymptotic (ε : ℝ) (hε : ε > 0)
  (hQ3_1 : Q3_1_Statement ε)
  (hMajor : MajorArcEstimate ε) :
  (fun N => R_2 N - (2 * TwinPrimeConstant * N : ℂ)) =o[atTop] (fun N => (N : ℂ)) := by
    -- From the theorem about the minor arc integral and the hypothesis Q3-1, we know that the minor arc integral is O(N^(1-2δ)).
    obtain ⟨δ, hδ_pos, hδ⟩ : ∃ δ > 0, (fun N => MinorArcIntegral N ε) =O[atTop] (fun N => (N : ℝ) ^ (1 - 2 * δ)) := by
      exact?;
    -- Since δ > 0, the minor arc integral is o(N), so we can write R_2(N) as 2 * C_2 * N + o(N).
    have hR2 : (fun N => R_2 N - 2 * TwinPrimeConstant * (N : ℂ)) =o[atTop] (fun N => (N : ℂ)) := by
      have hMinor : (fun N => MinorArcIntegral N ε) =o[atTop] (fun N => (N : ℂ)) := by
        refine' hδ.trans_isLittleO _;
        rcases δ with ( _ | _ | δ ) <;> norm_num [ Nat.succ_eq_add_one, Nat.mul_succ ] at *;
        · exact tendsto_natCast_atTop_atTop;
        · exact tendsto_natCast_atTop_atTop
      -- Using the fact that R_2(N) = MajorArcIntegral(N) + MinorArcIntegral(N), we can split the difference.
      have h_split : ∀ N : ℕ, R_2 N - 2 * TwinPrimeConstant * (N : ℂ) = (MajorArcIntegral N ε - 2 * TwinPrimeConstant * (N : ℂ)) + MinorArcIntegral N ε := by
        intro N; rw [ R_2_split N ε ] ; ring;
      simpa only [ h_split ] using Asymptotics.IsLittleO.add hMajor hMinor;
    convert hR2 using 1

/-
Lemma: The norm of R_2(N) is asymptotically 2 * C_2 * N.
Derived from R_2_Asymptotic using the reverse triangle inequality.
-/
open Filter Asymptotics

theorem norm_R_2_Asymptotic (ε : ℝ) (hε : ε > 0)
  (hQ3_1 : Q3_1_Statement ε)
  (hMajor : MajorArcEstimate ε) :
  (fun N => ‖R_2 N‖ - 2 * TwinPrimeConstant * N) =o[atTop] (fun N => (N : ℝ)) := by
    -- Using the triangle inequality, we can bound the expression:
    have h_triangle : ∀ N : ℕ, |‖R_2 N‖ - 2 * TwinPrimeConstant * N| ≤ ‖R_2 N - 2 * TwinPrimeConstant * N‖ := by
      intro N;
      convert abs_norm_sub_norm_le _ _ using 1;
      norm_num [ abs_mul, abs_of_nonneg, Real.sqrt_nonneg ];
      rw [ abs_of_nonneg ( show 0 ≤ TwinPrimeConstant by exact le_of_tendsto_of_tendsto' tendsto_const_nhds ( show Filter.Tendsto ( fun n : ℕ => ∏ i ∈ Finset.range n, if i.Prime ∧ i > 2 then ( 1 - 1 / ( ( i : ℝ ) - 1 ) ^ 2 ) else 1 ) Filter.atTop ( nhds TwinPrimeConstant ) from by
                                                                                                                -- The product of terms less than 1 converges.
                                                                                                                have h_prod_conv : Summable (fun p : ℕ => |(if p.Prime ∧ p > 2 then (1 - 1 / ((p : ℝ) - 1)^2) else 1) - 1|) := by
                                                                                                                  rw [ ← summable_nat_add_iff 3 ];
                                                                                                                  refine' Summable.of_nonneg_of_le ( fun n => abs_nonneg _ ) ( fun n => _ ) ( summable_nat_add_iff 1 |>.2 <| Real.summable_one_div_nat_pow.2 one_lt_two );
                                                                                                                  split_ifs <;> norm_num;
                                                                                                                  · exact inv_anti₀ ( by positivity ) ( by ring_nf; nlinarith );
                                                                                                                  · positivity;
                                                                                                                have h_prod_conv : Filter.Tendsto (fun n : ℕ => ∏ i ∈ Finset.range n, (1 + ((if i.Prime ∧ i > 2 then (1 - 1 / ((i : ℝ) - 1)^2) else 1) - 1))) Filter.atTop (nhds (∏' i : ℕ, (1 + ((if i.Prime ∧ i > 2 then (1 - 1 / ((i : ℝ) - 1)^2) else 1) - 1)))) := by
                                                                                                                  have h_prod_conv : Multipliable (fun p : ℕ => (1 + ((if p.Prime ∧ p > 2 then (1 - 1 / ((p : ℝ) - 1)^2) else 1) - 1))) := by
                                                                                                                    refine' multipliable_one_add_of_summable _;
                                                                                                                    convert h_prod_conv using 1;
                                                                                                                  convert h_prod_conv.hasProd.tendsto_prod_nat;
                                                                                                                convert h_prod_conv using 2 ; ring;
                                                                                                                exact tprod_congr fun i => by split_ifs <;> ring; ) fun n => Finset.prod_nonneg fun i hi => by split_ifs <;> first | positivity | exact sub_nonneg.mpr <| div_le_self zero_le_one <| one_le_pow₀ <| by linarith [ show ( i : ℝ ) ≥ 3 by exact_mod_cast le_of_not_gt fun hi' => by interval_cases i <;> norm_num at * ] ) ];
    -- Apply the fact that ‖R_2 N - 2 * TwinPrimeConstant * N‖ = o(N) to conclude the proof.
    have h_norm : (fun N : ℕ => ‖R_2 N - 2 * TwinPrimeConstant * N‖) =o[atTop] (fun N : ℕ => (N : ℝ)) := by
      have h_norm : (fun N : ℕ => R_2 N - 2 * TwinPrimeConstant * N) =o[atTop] (fun N : ℕ => (N : ℂ)) := by
        exact?;
      rw [ Asymptotics.isLittleO_iff ] at * ; aesop;
    rw [ Asymptotics.isLittleO_iff ] at *;
    exact fun c hc => by filter_upwards [ h_norm hc ] with x hx using le_trans ( h_triangle x ) ( le_trans ( le_of_eq ( by norm_num ) ) hx ) ;

/-
Lemma: (‖R_2 N‖ - 2 * C_2 * N) / log(N)^2 = o(N / log(N)^2).
This follows from norm_R_2_Asymptotic by dividing by log(N)^2.
-/
open Filter Asymptotics

lemma norm_R_2_div_log_sq_Asymptotic (ε : ℝ) (hε : ε > 0)
  (hQ3_1 : Q3_1_Statement ε)
  (hMajor : MajorArcEstimate ε) :
  (fun N => ‖R_2 N‖ / (Real.log N)^2 - 2 * TwinPrimeConstant * N / (Real.log N)^2) =o[atTop] (fun N => (N : ℝ) / (Real.log N)^2) := by
    -- Apply the lemma that dividing an o(N) function by a positive function results in an o(function) function.
    have h_div : (fun N : ℕ => (‖R_2 N‖ - 2 * TwinPrimeConstant * N) / (Real.log N)^2) =o[atTop] (fun N : ℕ => (N : ℝ) / (Real.log N)^2) := by
      -- Apply the fact that dividing an asymptotically small function by a positive function results in an asymptotically small function.
      have h_div_small : (fun N : ℕ => ‖R_2 N‖ - 2 * TwinPrimeConstant * N) =o[atTop] (fun N : ℕ => (N : ℝ)) := by
        exact?;
      rw [ Asymptotics.isLittleO_iff_tendsto' ] at * <;> norm_num at *;
      · refine h_div_small.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 1 ] with x hx using by rw [ div_div_div_cancel_right₀ ( by exact ne_of_gt <| sq_pos_of_pos <| Real.log_pos <| Nat.one_lt_cast.mpr hx ) ] );
      · exact ⟨ 1, by aesop ⟩;
      · exact ⟨ 2, by intros; norm_cast at *; aesop ⟩;
    simpa only [ sub_div ] using h_div

/-
Lemma: pi_2(N) is asymptotically 2 * C_2 * N / log(N)^2 (in the little-o sense).
Proof: Combine the transfer principle (pi_2 ~ |R_2|/log^2) and the R_2 asymptotic (|R_2| ~ 2*C_2*N).
-/
open Filter Asymptotics

lemma pi_2_Asymptotic (ε : ℝ) (hε : ε > 0)
  (hQ3_1 : Q3_1_Statement ε)
  (hMajor : MajorArcEstimate ε)
  (hTransfer : R2_to_pi2_Transfer) :
  (fun N => (pi_2 N : ℝ) - 2 * TwinPrimeConstant * N / (Real.log N)^2) =o[atTop] (fun N => (N : ℝ) / (Real.log N)^2) := by
  have h1 := hTransfer
  have h2 := norm_R_2_div_log_sq_Asymptotic ε hε hQ3_1 hMajor
  have h_sum := Asymptotics.IsLittleO.add h1 h2
  convert h_sum using 1
  ext N
  simp only [sub_add_sub_cancel]

/-
Lemma: The Twin Prime Constant is positive.
-/
lemma TwinPrimeConstant_pos : 0 < TwinPrimeConstant := by
  -- The sum of the logarithms of the terms in the product converges because each term is less than or equal to $-1/(p^2)$ for $p \geq 3$, and the sum of $1/p^2$ over $p \geq 3$ converges.
  have h_sum_conv : Summable (fun p : ℕ => Real.log (1 - 1 / ((p : ℝ) - 1)^2)) := by
    -- We'll use the fact that if the series inside the absolute value converges, then the absolute value of that series also converges.
    have h_abs_conv : Summable (fun p : ℕ => |Real.log (1 - 1 / ((p : ℝ) - 1)^2)|) := by
      have : ∀ p : ℕ, p ≥ 3 → |Real.log (1 - 1 / ((p : ℝ) - 1)^2)| ≤ 2 / ((p : ℝ) - 1)^2 := by
        -- We'll use the fact that $| \log(1 - x) | \leq 2x$ for $0 < x \leq 1/2$.
        have h_log_bound : ∀ x : ℝ, 0 < x ∧ x ≤ 1/2 → |Real.log (1 - x)| ≤ 2 * x := by
          intro x hx; rw [ abs_of_nonpos ( Real.log_nonpos ( by linarith ) ( by linarith ) ) ] ; nlinarith [ Real.log_inv ( 1 - x ), Real.log_le_sub_one_of_pos ( inv_pos.mpr ( by linarith : 0 < 1 - x ) ), mul_inv_cancel₀ ( by linarith : ( 1 - x ) ≠ 0 ) ] ;
        intro p hp; convert h_log_bound ( 1 / ( p - 1 ) ^ 2 ) ⟨ one_div_pos.mpr ( sq_pos_of_pos ( sub_pos.mpr ( by norm_cast; linarith ) ) ), by rw [ div_le_iff₀ ] <;> nlinarith [ show ( p : ℝ ) ≥ 3 by norm_cast ] ⟩ using 1 ; ring;
      rw [ ← summable_nat_add_iff 3 ];
      exact Summable.of_nonneg_of_le ( fun n => abs_nonneg _ ) ( fun n => by simpa using this ( n + 3 ) ( by linarith ) ) ( Summable.mul_left _ <| by exact Summable.of_nonneg_of_le ( fun n => by positivity ) ( fun n => by rw [ inv_eq_one_div, div_le_div_iff₀ ] <;> norm_num <;> ring <;> nlinarith ) <| summable_nat_add_iff 1 |>.2 <| Real.summable_one_div_nat_pow.2 one_lt_two );
    exact h_abs_conv.of_abs;
  -- Since the sum of the logarithms converges, the product of the terms is positive.
  have h_prod_pos : ∏' p : ℕ, (if p.Prime ∧ p > 2 then (1 - 1 / ((p : ℝ) - 1)^2) else 1) = Real.exp (∑' p : ℕ, Real.log (if p.Prime ∧ p > 2 then (1 - 1 / ((p : ℝ) - 1)^2) else 1)) := by
    have h_prod_conv : Summable (fun p : ℕ => Real.log (if p.Prime ∧ p > 2 then (1 - 1 / ((p : ℝ) - 1)^2) else 1)) := by
      rw [ ← summable_norm_iff ] at *;
      refine' .of_nonneg_of_le ( fun x => by split_ifs <;> positivity ) ( fun x => _ ) h_sum_conv;
      split_ifs <;> norm_num;
    have h_prod_conv : ∀ {f : ℕ → ℝ}, (∀ p, 0 < f p) → Summable (fun p => Real.log (f p)) → ∏' p, f p = Real.exp (∑' p, Real.log (f p)) := by
      exact?;
    exact h_prod_conv ( fun p => by split_ifs <;> first | positivity | exact sub_pos.mpr <| by rw [ div_lt_iff₀ ] <;> nlinarith [ show ( p : ℝ ) ≥ 3 by norm_cast; linarith ] ) ‹_›;
  exact h_prod_pos.symm ▸ Real.exp_pos _ |> fun h => h.trans_le' ( by norm_num )

/-
Theorem: If Q3-1, Major Arc Estimate, and Transfer Principle hold, then the Twin Prime Conjecture holds.
Proof:
1. Use `pi_2_Asymptotic` to show `pi_2(N) ~ 2 * C_2 * N / log(N)^2`.
2. Divide by `2 * C_2 * N / log(N)^2` to get the limit 1.
-/
open Filter Asymptotics

theorem TPC_of_Q3_Package (ε : ℝ) (hε : ε > 0)
  (hQ3_1 : Q3_1_Statement ε)
  (hMajor : MajorArcEstimate ε)
  (hTransfer : R2_to_pi2_Transfer) :
  TPC_Statement := by
    -- Use the fact that $2 * C_2$ is a constant to simplify the expression.
    have h_const : Filter.Tendsto (fun N => (pi_2 N : ℝ) / (2 * TwinPrimeConstant * N / (Real.log N)^2) - 1) Filter.atTop (nhds 0) := by
      have h_const : Filter.Tendsto (fun N => ((pi_2 N : ℝ) - 2 * TwinPrimeConstant * N / (Real.log N)^2) / (2 * TwinPrimeConstant * N / (Real.log N)^2)) Filter.atTop (nhds 0) := by
        have := pi_2_Asymptotic ε hε hQ3_1 hMajor hTransfer;
        rw [ Asymptotics.isLittleO_iff_tendsto' ] at this;
        · convert this.div_const ( 2 * TwinPrimeConstant ) using 2 <;> ring;
        · filter_upwards [ Filter.eventually_gt_atTop 1 ] with N hN hN' using absurd hN' <| ne_of_gt <| div_pos ( Nat.cast_pos.mpr <| pos_of_gt hN ) <| sq_pos_of_pos <| Real.log_pos <| Nat.one_lt_cast.mpr hN;
      refine h_const.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 1 ] with N hN using by rw [ sub_div, div_self <| ne_of_gt <| div_pos ( mul_pos ( mul_pos two_pos <| TwinPrimeConstant_pos ) <| Nat.cast_pos.mpr <| pos_of_gt hN ) <| sq_pos_of_pos <| Real.log_pos <| Nat.one_lt_cast.mpr hN ] );
    simpa using h_const.add_const 1

/-
Theorem: If Q3-1, Major Arc Estimate, and Transfer Principle hold, then the Twin Prime Conjecture holds.
Proof:
1. Use `pi_2_Asymptotic` to show `pi_2(N) ~ 2 * C_2 * N / log(N)^2`.
2. Divide by `2 * C_2 * N / log(N)^2` to get the limit 1.
-/
open Filter Asymptotics

theorem TPC_of_Q3_Package_Final (ε : ℝ) (hε : ε > 0)
  (hQ3_1 : Q3_1_Statement ε)
  (hMajor : MajorArcEstimate ε)
  (hTransfer : R2_to_pi2_Transfer) :
  TPC_Statement := by
    apply_rules [ TPC_of_Q3_Package ]

/-
Theorem: If Q3-1, Major Arc Estimate, and Transfer Principle hold, then the Twin Prime Conjecture holds.
Proof:
1. Use `pi_2_Asymptotic` to show `pi_2(N) ~ 2 * C_2 * N / log(N)^2`.
2. Divide by `2 * C_2 * N / log(N)^2` to get the limit 1.
-/
open Filter Asymptotics

theorem TPC_Conclusion (ε : ℝ) (hε : ε > 0)
  (hQ3_1 : Q3_1_Statement ε)
  (hMajor : MajorArcEstimate ε)
  (hTransfer : R2_to_pi2_Transfer) :
  TPC_Statement := by
    convert TPC_of_Q3_Package_Final ε hε hQ3_1 hMajor hTransfer using 1

/-
Theorem: If Q3-1, Major Arc Estimate, and Transfer Principle hold, then the Twin Prime Conjecture holds.
Proof:
1. Use `pi_2_Asymptotic` to show `pi_2(N) ~ 2 * C_2 * N / log(N)^2`.
2. Divide by `2 * C_2 * N / log(N)^2` to get the limit 1.
-/
open Filter Asymptotics

theorem TPC_Conclusion_Final (ε : ℝ) (hε : ε > 0)
  (hQ3_1 : Q3_1_Statement ε)
  (hMajor : MajorArcEstimate ε)
  (hTransfer : R2_to_pi2_Transfer) :
  TPC_Statement := by
    convert TPC_of_Q3_Package_Final ε hε hQ3_1 hMajor hTransfer

/-
Theorem: If Q3-1, Major Arc Estimate, and Transfer Principle hold, then the Twin Prime Conjecture holds.
Proof:
1. Use `pi_2_Asymptotic` to show `pi_2(N) ~ 2 * C_2 * N / log(N)^2`.
2. Divide by `2 * C_2 * N / log(N)^2` to get the limit 1.
-/
open Filter Asymptotics

theorem TPC_Conclusion_V3 (ε : ℝ) (hε : ε > 0)
  (hQ3_1 : Q3_1_Statement ε)
  (hMajor : MajorArcEstimate ε)
  (hTransfer : R2_to_pi2_Transfer) :
  TPC_Statement := by
    exact TPC_of_Q3_Package ε hε hQ3_1 hMajor hTransfer