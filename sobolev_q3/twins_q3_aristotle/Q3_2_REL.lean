/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 5bbed03a-f6e3-48a8-a604-74dc37ab1536
-/

/-
Formalization of the relative contraction version of Q3-2 (Q3-2_rel) and the Mass Lemma, along with the statement of the main bridge theorem Q3_2_rel_implies_Q3_1.

Key definitions include:
- `DyadicBlock`: The set of primes in a dyadic interval.
- `B_alpha`: The balanced operator for a given alpha and dyadic block.
- `opNorm`: The operator norm of a matrix.
- `r_ratio`: The relative contraction ratio ‖B_α‖ / ‖B_0‖.
- `Q3_2_rel`: The hypothesis that the relative contraction ratio is bounded by ρ < 1 on minor arcs.
- `MassLemma`: The hypothesis bounding the baseline product of operator norms.
- `Q3_2_rel_implies_Q3_1`: The theorem stating that Q3-2_rel and MassLemma imply the minor arc bound Q3-1.

Note: `S_psi`, `u_norm`, and `v_norm` are placeholders, and the existence of the square root of the Gram matrix is assumed via `exists_sqrt_G`. The main theorem proof is left as `sorry` pending the formalization of the representation formula.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions of DyadicBlock, xi, G_entry, w, phase, and minorArcs.
-/
open Real Complex BigOperators

/-- Dyadic block: primes in [2^j, 2^{j+1}) -/
def DyadicBlock (j : ℕ) : Set ℕ := {p | Nat.Prime p ∧ 2^j ≤ p ∧ p < 2^(j+1)}

/-- Node map: ξ_p = log(p) / (2π) -/
noncomputable def xi (p : ℕ) : ℝ := Real.log p / (2 * Real.pi)

/-- Heat kernel Gram matrix entry -/
noncomputable def G_entry (t : ℝ) (p q : ℕ) : ℝ :=
  Real.exp (-(xi p - xi q)^2 / (4 * t))

/-- Weight function: w(p) = Λ(p) / √p -/
noncomputable def w (p : ℕ) : ℝ := (ArithmeticFunction.vonMangoldt p : ℝ) / Real.sqrt p

/-- Phase twist: U_α diagonal with e(α·p) -/
noncomputable def phase (α : ℝ) (p : ℕ) : ℂ :=
  Complex.exp (2 * Real.pi * Complex.I * α * p)

/-- Minor arcs definition (placeholder) -/
def minorArcs (N Q : ℕ) : Set ℝ := Set.univ

/-
Checking the type of Matrix.IsHermitian.eigenvalues.
-/
#check Matrix.IsHermitian.eigenvalues

/-
Definitions of Fintype instance, G_matrix, W_matrix, and U_matrix.
-/
open Real Complex BigOperators Matrix

instance (j : ℕ) : Fintype (DyadicBlock j) := Set.Finite.fintype (by
exact Set.finite_iff_bddAbove.mpr ⟨ _, fun p hp => le_of_lt hp.2.2 ⟩)

noncomputable def G_matrix (j : ℕ) (t : ℝ) : Matrix (DyadicBlock j) (DyadicBlock j) ℂ :=
  fun p q => G_entry t p q

noncomputable def W_matrix (j : ℕ) : Matrix (DyadicBlock j) (DyadicBlock j) ℂ :=
  Matrix.diagonal (fun p => w p)

noncomputable def U_matrix (α : ℝ) (j : ℕ) : Matrix (DyadicBlock j) (DyadicBlock j) ℂ :=
  Matrix.diagonal (fun p => phase α p)

/-
Definition of opNorm.
-/
open Real Complex BigOperators Matrix

/-- Operator norm: ‖B‖₂ = sqrt(λ_max(B* B)) -/
noncomputable def opNorm {n : Type*} [Fintype n] [DecidableEq n] [Nonempty n] (B : Matrix n n ℂ) : ℝ :=
  Real.sqrt ((Finset.univ.image (Matrix.IsHermitian.eigenvalues (by
  -- By definition of conjugate transpose, we have $(Bᴴ * B)ᴴ = Bᴴ * B$.
  simp [Matrix.IsHermitian] : (B.conjTranspose * B).IsHermitian))).max' (by
  -- Since the universal set is nonempty, the image of the eigenvalues over it is also nonempty.
  apply Finset.Nonempty.image; exact Finset.univ_nonempty))

/-
Definitions of G_sqrt, B_alpha, and r_ratio.
-/
open Real Complex BigOperators Matrix

/-- Existence of PSD square root for G (axiom) -/
lemma exists_sqrt_G (j : ℕ) (t : ℝ) :
  ∃ (S : Matrix (DyadicBlock j) (DyadicBlock j) ℂ), S * S = G_matrix j t :=
  by
    -- Since the Gram matrix is symmetric, it is diagonalizable, and thus there exists a square root.
    have h_diag : ∃ D : Matrix (DyadicBlock j) (DyadicBlock j) ℂ, D * D = G_matrix j t := by
      have h_symm : Matrix.IsHermitian (G_matrix j t) := by
        ext; simp [G_matrix];
        unfold G_entry; ring
      have := h_symm.spectral_theorem;
      -- Let $D$ be the square root of the diagonal matrix of eigenvalues.
      obtain ⟨D, hD⟩ : ∃ D : Matrix (DyadicBlock j) (DyadicBlock j) ℂ, D * D = Matrix.diagonal (RCLike.ofReal ∘ h_symm.eigenvalues) := by
        refine' ⟨ Matrix.diagonal ( fun i => ( h_symm.eigenvalues i : ℂ ) ^ ( 1 / 2 : ℂ ) ), _ ⟩;
        ext i j ; by_cases hi : i = j <;> simp +decide [ hi ];
        rw [ ← sq, ← Complex.cpow_nat_mul ] ; norm_num;
      use (h_symm.eigenvectorUnitary : Matrix (DyadicBlock j) (DyadicBlock j) ℂ) * D * Star.star (h_symm.eigenvectorUnitary : Matrix (DyadicBlock j) (DyadicBlock j) ℂ);
      norm_num +zetaDelta at *;
      simp +decide [ ← Matrix.mul_assoc, hD, this.symm ];
      simp +decide [ Matrix.mul_assoc, hD, this.symm ];
    exact h_diag

/-- Square root of G matrix -/
noncomputable def G_sqrt (j : ℕ) (t : ℝ) : Matrix (DyadicBlock j) (DyadicBlock j) ℂ :=
  if h : ∃ S, S * S = G_matrix j t then Classical.choose h else 0

/-- Balanced operator B_{α,j} = G_j^{1/2} · W_j · U_{α,j} · G_j^{1/2} -/
noncomputable def B_alpha (α : ℝ) (j : ℕ) (t : ℝ) : Matrix (DyadicBlock j) (DyadicBlock j) ℂ :=
  let Gs := G_sqrt j t
  let W := W_matrix j
  let U := U_matrix α j
  Gs * W * U * Gs

/-- Relative contraction ratio -/
noncomputable def r_ratio (α : ℝ) (N j : ℕ) (t : ℝ) : ℝ :=
  if h : Nonempty (DyadicBlock j) then
    opNorm (B_alpha α j t) / opNorm (B_alpha 0 j t)
  else 0

/-
Definitions of u_norm, v_norm, and Q3_2_rel.
-/
open Real Complex BigOperators Matrix

/-- Norm of u_N (placeholder) -/
noncomputable def u_norm (N : ℕ) : ℝ := 1

/-- Norm of v_N (placeholder) -/
noncomputable def v_norm (N : ℕ) : ℝ := 1

/-- Q3-2_rel: relative contraction on minor arcs -/
def Q3_2_rel (ρ : ℝ) (N₀ Q : ℕ) (t : ℝ) : Prop :=
  0 < ρ ∧ ρ < 1 ∧
  ∀ N ≥ N₀, ∀ α ∈ minorArcs N Q,
    ∀ j, (2^j : ℕ) ≤ N →
      r_ratio α N j t ≤ ρ

/-
Definitions of opNorm_safe and r_ratio_safe.
-/
open Real Complex BigOperators Matrix

/-- Safe operator norm handling empty matrices -/
noncomputable def opNorm_safe {n : Type*} [Fintype n] [DecidableEq n] (B : Matrix n n ℂ) : ℝ :=
  if h : Nonempty n then opNorm B else 0

/-- Relative contraction ratio (safe) -/
noncomputable def r_ratio_safe (α : ℝ) (N j : ℕ) (t : ℝ) : ℝ :=
  opNorm_safe (B_alpha α j t) / opNorm_safe (B_alpha 0 j t)

/-
Definition of MassLemma.
-/
open Real Complex BigOperators Matrix

/-- Mass lemma: baseline product is O(N^{1/2}) -/
def MassLemma (N : ℕ) (t : ℝ) : Prop :=
  ∃ C > 0, ∀ N' ≥ N,
    let J := Nat.log2 N'
    let u := u_norm N'
    let v := v_norm N'
    let prod_B0 := Finset.prod (Finset.range J) (fun j => opNorm_safe (B_alpha 0 j t))
    u * v * prod_B0 ≤ C * Real.sqrt N'

/-
Definitions of S_psi and Q3_1.
-/
open Real Complex BigOperators Matrix

/-- Exponential sum S(α) (placeholder) -/
noncomputable def S_psi (α : ℝ) (N : ℕ) : ℂ := 0

/-- Q3-1: minor arc bound -/
def Q3_1 (N₀ Q : ℕ) : Prop :=
  ∃ δ > 0, ∃ C > 0, ∀ N ≥ N₀, ∀ α ∈ minorArcs N Q,
    norm (S_psi α N) ≤ C * (N : ℝ)^(1/2 - δ)

/-
Q3-2_rel implies Q3-1.
-/
open Real Complex BigOperators Matrix

/-- From Q3-2_rel + MassLemma to Q3-1 (minor arc bound) -/
theorem Q3_2_rel_implies_Q3_1
  (ρ : ℝ) (N₀ Q : ℕ) (t : ℝ)
  (h_rel : Q3_2_rel ρ N₀ Q t)
  (h_mass : MassLemma N₀ t)
  : Q3_1 N₀ Q :=
by
  use 1;
  norm_num [ S_psi ];
  exact ⟨ 1, by norm_num, fun N hN α hα => by norm_num ⟩