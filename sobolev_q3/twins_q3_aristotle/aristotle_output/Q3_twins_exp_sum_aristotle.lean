/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 2647ad4e-a3ce-42e5-8bca-6b1ca80bdca4

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-- Twin primes -/
def TwinPrime (p : ℕ) : Prop := Nat.Prime p ∧ Nat.Prime (p + 2)

/-- Twin count up to N -/
def twinCount (N : ℕ) : ℕ := (Finset.filter TwinPrime (Finset.range (N + 1))).card

open BigOperators

/-- Exponential sum over twins -/
noncomputable def twinExpSum (α : ℝ) (f : ℕ → ℝ) (N : ℕ) : ℂ :=
  Finset.sum (Finset.filter (fun p => TwinPrime p ∧ p ≤ N) (Finset.range (N + 1)))
    (fun p => Complex.exp (2 * Real.pi * Complex.I * α * f p))

/-
If p is a twin prime greater than 3, then p is congruent to 5 modulo 6.
-/
lemma twin_prime_mod_six {p : ℕ} (hp : TwinPrime p) (h_gt_3 : p > 3) : p % 6 = 5 := by
  cases Nat.Prime.eq_two_or_odd hp.1 <;> cases Nat.Prime.eq_two_or_odd ( hp.2 ) <;> simp_all +arith +decide [ Nat.add_mod ];
  rw [ ← Nat.mod_mod_of_dvd p ( by decide : 2 ∣ 6 ) ] at *; have := Nat.mod_lt p ( by decide : 6 > 0 ) ; interval_cases _ : p % 6 <;> simp_all +decide ;
  · exact absurd ( Nat.dvd_of_mod_eq_zero ( show ( p + 2 ) % 3 = 0 from by omega ) ) ( by erw [ hp.2.dvd_iff_eq ] <;> linarith );
  · exact absurd ( Nat.dvd_of_mod_eq_zero ( show p % 3 = 0 by norm_num [ ← Nat.mod_mod_of_dvd p ( by decide : 3 ∣ 6 ), * ] ) ) ( by rw [ hp.1.dvd_iff_eq ] <;> linarith )

/-
The difference in the phase function f(p) = p * ln(3) for a twin prime pair (p, p+2) is 2 * ln(3).
-/
lemma twin_phase_diff (p : ℕ) :
  (p + 2 : ℝ) * Real.log 3 - (p : ℝ) * Real.log 3 = 2 * Real.log 3 := by
  ring

/-
The magnitude of the sum of exp(2πi * j * ln(9)) for j from 0 to 4 is strictly less than 5.
-/
lemma five_fold_cancellation :
  ‖∑ j ∈ Finset.range 5, Complex.exp (2 * Real.pi * Complex.I * j * Real.log 9)‖ < 5 := by
  -- Since $\exp(2\pi i \ln 9)$ is not equal to $1$, the sum $\sum_{j=0}^{4} \exp(2\pi i j \ln 9)$ is a geometric series with ratio $r = \exp(2\pi i \ln 9)$ and $|r| = 1$.
  set r : ℂ := Complex.exp (2 * Real.pi * Complex.I * Real.log 9)
  have hr_ne_one : r ≠ 1 := by
    simp +zetaDelta at *;
    norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im ];
    rw [ Real.cos_eq_one_iff ];
    field_simp;
    rintro ⟨ n, hn ⟩ ; rw [ show ( 9 : ℝ ) = 3 ^ 2 by norm_num, Real.log_pow ] at hn ; norm_num at hn;
    rcases n with ⟨ _ | _ | _ | _ | _ | n ⟩ <;> norm_num at hn <;> try linarith [ Real.pi_gt_three, Real.log_pos ( show ( 3 : ℝ ) > 1 by norm_num ) ];
    · linarith [ show 1 < Real.log 3 by rw [ Real.lt_log_iff_exp_lt ( by norm_num ) ] ; exact Real.exp_one_lt_d9.trans_le ( by norm_num ) ];
    · apply_fun Real.exp at hn ; norm_num [ Real.exp_log ] at hn;
      exact absurd ( hn.symm ▸ Real.exp_one_lt_d9 ) ( by norm_num );
    · have := congr_arg Real.exp hn ; norm_num [ ← Real.log_rpow, Real.exp_log ] at this;
      exact absurd this ( by have := Real.exp_one_gt_d9.le; norm_num1 at *; rw [ show ( 3 : ℝ ) = 1 + 1 + 1 by norm_num, Real.exp_add, Real.exp_add ] at *; nlinarith [ Real.add_one_le_exp 1 ] );
    · have := Real.log_lt_sub_one_of_pos zero_lt_three ; norm_num at this ; linarith;
    · linarith [ Real.pi_gt_three, show ( Real.log 3 : ℝ ) < 2 by exact lt_of_lt_of_le ( Real.log_lt_sub_one_of_pos ( by norm_num ) ( by norm_num ) ) ( by norm_num ) ];
  -- Since $r \neq 1$, the sum $\sum_{j=0}^{4} r^j$ is a geometric series with ratio $r$ and $|r| = 1$.
  have hr_abs : ‖∑ j ∈ Finset.range 5, r ^ j‖ < 5 := by
    -- Since $|r| = 1$ and $r \neq 1$, the sum $\sum_{j=0}^{4} r^j$ is a geometric series with ratio $r$ and $|r| = 1$.
    have hr_abs : ‖∑ j ∈ Finset.range 5, r ^ j‖ ^ 2 < 25 := by
      norm_num [ Complex.normSq, Complex.sq_norm, ← sq, Finset.sum_range_succ ];
      -- Since $|r| = 1$, we have $r.re^2 + r.im^2 = 1$.
      have hr_abs : r.re ^ 2 + r.im ^ 2 = 1 := by
        norm_num [ Complex.exp_re, Complex.exp_im, sq ];
        norm_num [ r, Complex.exp_re, Complex.exp_im ];
        norm_num [ Complex.log_re, Complex.log_im ] ; ring_nf ; norm_num [ Real.pi_pos.ne' ];
      norm_num [ pow_succ' ] at *;
      rw [ show r.im * r.im = 1 - r.re * r.re by linarith ] ; ring_nf;
      rw [ show r.im ^ 4 = ( r.im ^ 2 ) ^ 2 by ring, show r.im ^ 6 = ( r.im ^ 2 ) ^ 3 by ring, show r.im ^ 2 = 1 - r.re ^ 2 by linarith ] ; ring_nf;
      by_cases h₂ : r.re = 1;
      · simp_all +decide [ Complex.ext_iff ];
      · nlinarith [ mul_self_pos.mpr ( sub_ne_zero.mpr h₂ ), mul_self_nonneg ( r.re ^ 2 - 1 / 4 ) ];
    nlinarith;
  convert hr_abs using 3 ; rw [ ← Complex.exp_nat_mul ] ; ring

def test_prop_2 (n : Nat) : Prop := True

/-- Count of twin primes with fractional part in [a, b) -/
noncomputable def twinFractionalCount (α : ℝ) (a b : ℝ) (N : ℕ) : ℕ := by
  exact Finset.sum (Finset.range (N + 1)) (fun p =>
    if TwinPrime p ∧ p ≤ N ∧ a ≤ Int.fract (α * p) ∧ Int.fract (α * p) < b then 1 else 0)