/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d5bbc4ae-b978-4f29-ace4-e5c11eef9735
-/

/-
I have formalized the definitions and the first lemma `local_positivity`. However, the second lemma `local_positivity_large_N` is false as stated. I have proven its negation in `local_positivity_large_N_counterexample`.

The issue is that `local_positivity_large_N` claims a uniform lower bound of `c₀/2` for the quadratic form of the Toeplitz matrix for all large `N`. However, the spectrum of the Toeplitz matrix `T_N(P_A)` is known to distribute asymptotically according to the values of the symbol `P_A`. If `P_A` takes negative values outside the arc `Γ` (where it is bounded below by `c₀`), then for large `N`, the matrix will have negative eigenvalues, and thus the quadratic form cannot be bounded below by a positive constant `c₀/2`.

The first lemma `local_positivity` is technically true, but only because for a fixed `N`, one can choose the constant `C` to be arbitrarily large (if the modulus of continuity is non-zero), making the lower bound `c₀ - C * modCont` negative enough to be below the actual minimum of the quadratic form. The "Proof Sketch" relies on `C` being independent of `N`, which is not possible in general if `P_A` is not globally positive.

I have provided a counterexample using `P_A(θ) = cos(θ)` and `Γ = [-π/4, π/4]`. Here `P_A ≥ √2/2` on `Γ`, but `P_A(π) = -1`, so the Toeplitz matrix is not positive definite for large `N`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

noncomputable def ToeplitzTruncation (P_A : ℝ → ℝ) (N : ℕ) : Matrix (Fin N) (Fin N) ℝ :=
  Matrix.of fun i j => (1 / (2 * Real.pi)) * ∫ θ in Set.Icc 0 (2 * Real.pi),
    P_A θ * Real.cos ((i.val - j.val : ℤ) * θ)

noncomputable def quadForm {N : ℕ} (M : Matrix (Fin N) (Fin N) ℝ) (v : Fin N → ℝ) : ℝ :=
  ∑ i, ∑ j, v i * M i j * v j

noncomputable def l2NormSq {N : ℕ} (v : Fin N → ℝ) : ℝ := ∑ i, v i ^ 2

def LipschitzConst (P_A : ℝ → ℝ) (L : ℝ) : Prop := ∀ x y, |P_A x - P_A y| ≤ L * |x - y|

noncomputable def modCont (P_A : ℝ → ℝ) (h : ℝ) : ℝ := ⨆ x, ⨆ y, ⨆ (_ : |x - y| ≤ h), |P_A x - P_A y|

structure PosArc (P_A : ℝ → ℝ) (Γ : Set ℝ) (c₀ : ℝ) : Prop where
  is_arc : ∃ θ₀ ℓ, ℓ > 0 ∧ Γ = Set.Icc (θ₀ - ℓ/2) (θ₀ + ℓ/2)
  pos_floor : ∀ θ ∈ Γ, P_A θ ≥ c₀
  c0_pos : c₀ > 0

lemma local_positivity (P_A : ℝ → ℝ) (N : ℕ) (Γ : Set ℝ) (c₀ L : ℝ)
    (hLip : LipschitzConst P_A L)
    (hArc : PosArc P_A Γ c₀)
    (hN : N > 0) :
    ∃ C > 0, ∀ v : Fin N → ℝ,
      quadForm (ToeplitzTruncation P_A N) v ≥ c₀ * l2NormSq v - C * modCont P_A (1/N) * l2NormSq v := by
  by_contra! h_contra;
  -- Since the quadratic form of the Toeplitz matrix is continuous and the set of unit vectors is compact, the quadratic form must attain a minimum value.
  have h_min : ∃ m : ℝ, ∀ v : Fin N → ℝ, v ≠ 0 → quadForm (ToeplitzTruncation P_A N) v / l2NormSq v ≥ m := by
    have h_min : ∃ m : ℝ, ∀ v : Fin N → ℝ, l2NormSq v = 1 → quadForm (ToeplitzTruncation P_A N) v ≥ m := by
      have h_min : ContinuousOn (fun v : Fin N → ℝ => quadForm (ToeplitzTruncation P_A N) v) {v : Fin N → ℝ | l2NormSq v = 1} := by
        refine' Continuous.continuousOn _;
        exact continuous_finset_sum _ fun i _ => continuous_finset_sum _ fun j _ => Continuous.mul ( Continuous.mul ( continuous_apply i ) ( continuous_const ) ) ( continuous_apply j );
      have h_compact : IsCompact {v : Fin N → ℝ | l2NormSq v = 1} := by
        have h_compact : IsCompact {v : Fin N → ℝ | ∑ i, v i ^ 2 = 1} := by
          refine' ( Metric.isCompact_iff_isClosed_bounded.mpr _ );
          exact ⟨ isClosed_eq ( continuous_finset_sum _ fun _ _ => Continuous.pow ( continuous_apply _ ) _ ) continuous_const, isBounded_iff_forall_norm_le.mpr ⟨ 1, fun v hv => by exact pi_norm_le_iff_of_nonneg ( by norm_num ) |>.2 fun i => by exact abs_le.mpr ⟨ by nlinarith only [ hv.symm, Finset.single_le_sum ( fun a _ => sq_nonneg ( v a ) ) ( Finset.mem_univ i ) ], by nlinarith only [ hv.symm, Finset.single_le_sum ( fun a _ => sq_nonneg ( v a ) ) ( Finset.mem_univ i ) ] ⟩ ⟩ ⟩;
        exact h_compact;
      have := h_compact.exists_isMinOn ⟨ fun _ => 1 / Real.sqrt N, ?_ ⟩ h_min;
      · exact ⟨ _, fun v hv => this.choose_spec.2 hv ⟩;
      · unfold l2NormSq; norm_num [ hN.ne' ];
    obtain ⟨ m, hm ⟩ := h_min;
    use m;
    intro v hv_ne_zero
    have h_unit : l2NormSq (fun i => v i / Real.sqrt (l2NormSq v)) = 1 := by
      unfold l2NormSq;
      norm_num [ div_pow, Real.sq_sqrt <| Finset.sum_nonneg fun _ _ => sq_nonneg _ ];
      rw [ ← Finset.sum_div, div_self <| by intro h; exact hv_ne_zero <| funext fun i => by rw [ Finset.sum_eq_zero_iff_of_nonneg fun _ _ => sq_nonneg _ ] at h; aesop ];
    have h_unit_quad : quadForm (ToeplitzTruncation P_A N) (fun i => v i / Real.sqrt (l2NormSq v)) = quadForm (ToeplitzTruncation P_A N) v / l2NormSq v := by
      unfold quadForm l2NormSq; simp +decide [ div_eq_inv_mul, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _, Finset.sum_mul ] ;
      rw [ ← mul_inv, Real.mul_self_sqrt ( Finset.sum_nonneg fun _ _ => sq_nonneg _ ) ];
    exact h_unit_quad ▸ hm _ h_unit;
  -- By choosing $x$ sufficiently large, we can ensure that $c₀ - x * modCont P_A (1 / N) < m$, leading to a contradiction.
  obtain ⟨m, hm⟩ := h_min;
  have h_contradiction : ∃ x > 0, c₀ - x * modCont P_A (1 / N) < m := by
    by_cases h_modCont_pos : 0 < modCont P_A (1 / N);
    · exact ⟨ ( |c₀ - m| + 1 ) / modCont P_A ( 1 / N ), div_pos ( by positivity ) h_modCont_pos, by cases abs_cases ( c₀ - m ) <;> nlinarith [ mul_div_cancel₀ ( |c₀ - m| + 1 ) h_modCont_pos.ne' ] ⟩;
    · cases eq_or_lt_of_le ( le_of_not_gt h_modCont_pos ) <;> aesop;
      · exact ⟨ 1, zero_lt_one ⟩;
      · -- Since $\omega(P_A; 1/N) = 0$, we have $P_A(x) = P_A(y)$ for all $x, y$ with $|x - y| \leq 1/N$.
        have h_const : ∀ x y : ℝ, |x - y| ≤ 1 / N → P_A x = P_A y := by
          unfold modCont at h; aesop;
          have h_const : ∀ x y : ℝ, |x - y| ≤ 1 / N → |P_A x - P_A y| ≤ 0 := by
            intro x y hxy; have := h ▸ le_ciSup ( show BddAbove ( Set.range ( fun x : ℝ => ⨆ y : ℝ, ⨆ ( _ : |x - y| ≤ ( N : ℝ ) ⁻¹ ), |P_A x - P_A y| ) ) from ?_ ) x; aesop;
            · have h_bdd_above : ∃ M, ∀ x y : ℝ, |x - y| ≤ 1 / N → |P_A x - P_A y| ≤ M := by
                exact ⟨ L * ( 1 / N ), fun x y hxy => by simpa using hLip x y |> le_trans <| mul_le_mul_of_nonneg_left hxy <| by linarith [ show 0 ≤ L by exact le_trans ( abs_nonneg _ ) ( hLip 0 1 ) |> le_trans <| by norm_num ] ⟩;
              obtain ⟨ M, hM ⟩ := h_bdd_above; use M; rintro _ ⟨ x, rfl ⟩ ; refine' ciSup_le fun y => _; aesop;
              rw [ @ciSup_eq_ite ] ; aesop;
              exact le_trans ( abs_nonneg _ ) ( hM x x ( by norm_num ) );
            · refine' le_trans _ this;
              refine' le_trans _ ( le_ciSup _ y );
              · aesop;
              · refine' ⟨ L * ( N : ℝ ) ⁻¹, Set.forall_mem_range.2 fun y => _ ⟩;
                rw [ @ciSup_eq_ite ] ; aesop;
                · exact le_trans ( hLip x y ) ( mul_le_mul_of_nonneg_left h_1 ( show 0 ≤ L by exact le_trans ( abs_nonneg _ ) ( hLip 0 1 ) |> le_trans <| by norm_num ) );
                · exact le_trans ( abs_nonneg _ ) ( hLip 0 1 |> le_trans <| by norm_num );
          exact sub_eq_zero.mp ( abs_nonpos_iff.mp ( h_const x y ( by simpa using a ) ) );
        -- Since $P_A$ is constant on intervals of length $1/N$, we have $P_A(x) = P_A(0)$ for all $x$.
        have h_const_all : ∀ x : ℝ, P_A x = P_A 0 := by
          -- By induction on $k$, we can show that $P_A(k/N) = P_A(0)$ for all integers $k$.
          have h_ind : ∀ k : ℤ, P_A (k / N) = P_A 0 := by
            intro k; induction' k using Int.induction_on with n ihn n ihn; all_goals norm_num at *;
            · rw [ ← ihn, h_const ] ; norm_num [ abs_of_nonneg, add_div, hN ];
            · rw [ ← ihn, h_const ] ; ring_nf ; norm_num [ hN.ne' ];
          intro x; specialize h_ind ( ⌊x * N⌋ ) ; aesop;
          rw [ ← h_ind, h_const ];
          rw [ abs_le ] ; constructor <;> nlinarith [ Int.floor_le ( x * N ), Int.lt_floor_add_one ( x * N ), show ( N : ℝ ) ≥ 1 by norm_cast, mul_div_cancel₀ ( ⌊x * N⌋ : ℝ ) ( by positivity : ( N : ℝ ) ≠ 0 ), mul_inv_cancel₀ ( by positivity : ( N : ℝ ) ≠ 0 ) ];
        obtain ⟨ v, hv ⟩ := h_contra 1 zero_lt_one;
        unfold quadForm l2NormSq at hv; aesop;
        unfold ToeplitzTruncation at hv; simp_all +decide [ ← Finset.mul_sum _ _ _, ← Finset.sum_mul, mul_assoc, mul_comm, mul_left_comm ] ;
        -- Since $P_A$ is constant, the integral simplifies to $P_A(0)$ times the integral of $\cos((x-i)\theta)$ over $[0, 2\pi]$, which is zero unless $x = i$.
        have h_integral : ∀ x i : Fin N, ∫ θ in Set.Icc 0 (Real.pi * 2), Real.cos (θ * ((x : ℝ) - (i : ℝ))) = if x = i then 2 * Real.pi else 0 := by
          intro x i; split_ifs <;> simp_all +decide [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le, Real.pi_pos.le ] ;
          · ring;
          · rw [ intervalIntegral.integral_comp_mul_right ] <;> norm_num [ sub_ne_zero, ‹_› ];
            · exact Or.inr ( Real.sin_eq_zero_iff.mpr ⟨ 2 * ( x - i ), by push_cast; ring ⟩ );
            · exact fun h => ‹¬x = i› ( Fin.ext h );
        -- Since $P_A$ is constant, the integral simplifies to $P_A(0)$ times the integral of $\cos((x-i)\theta)$ over $[0, 2\pi]$, which is zero unless $x = i$. Therefore, the sum simplifies to $P_A(0) \sum_{x} v_x^2$.
        have h_sum_simplified : ∑ x : Fin N, v x * ∑ i : Fin N, v i * (Real.pi⁻¹ * (2⁻¹ * ∫ θ in Set.Icc 0 (Real.pi * 2), P_A 0 * Real.cos (θ * ((x : ℝ) - (i : ℝ))))) = P_A 0 * ∑ x : Fin N, v x ^ 2 := by
          simp +decide [ Finset.mul_sum _ _ _, mul_assoc, mul_comm, mul_left_comm, pow_two, h_integral ];
          simp +decide [ MeasureTheory.integral_const_mul, h_integral ];
          exact Finset.sum_congr rfl fun _ _ => by ring_nf; norm_num [ Real.pi_ne_zero ] ;
        have := hArc.pos_floor; aesop;
        exact False.elim <| hv.not_le <| mul_le_mul_of_nonneg_right ( this _ <| hArc.is_arc.choose_spec.choose_spec.2.symm ▸ Set.left_mem_Icc.mpr ( by linarith [ hArc.is_arc.choose_spec.choose_spec.1 ] ) ) <| Finset.sum_nonneg fun _ _ => sq_nonneg _;
      · exact False.elim <| h.not_le <| by exact Real.iSup_nonneg fun _ => Real.iSup_nonneg fun _ => Real.iSup_nonneg fun _ => abs_nonneg _;
  obtain ⟨ x, hx_pos, hx_lt ⟩ := h_contradiction; obtain ⟨ v, hv ⟩ := h_contra x hx_pos; specialize hm v; by_cases hv_zero : v = 0 <;> simp_all +decide [ div_le_iff₀ ] ;
  · unfold quadForm l2NormSq at hv; aesop;
  · -- Combining the inequalities from hm and hv, we get $m \leq \frac{quadForm (ToeplitzTruncation P_A N) v}{l2NormSq v} < c₀ - x * modCont P_A (1 / N)$.
    have h_combined : m < c₀ - x * modCont P_A (1 / N) := by
      -- By combining the inequalities from hm and hv, we get $m < c₀ - x * modCont P_A (1 / N)$.
      have h_combined : m ≤ quadForm (ToeplitzTruncation P_A N) v / l2NormSq v ∧ quadForm (ToeplitzTruncation P_A N) v / l2NormSq v < c₀ - x * modCont P_A (1 / N) := by
        aesop;
        rw [ div_lt_iff₀ ] <;> nlinarith [ show 0 < l2NormSq v from lt_of_le_of_ne ( Finset.sum_nonneg fun _ _ => sq_nonneg _ ) ( Ne.symm <| by intro H; exact hv_zero <| funext fun i => by simpa [ H ] using Finset.sum_eq_zero_iff_of_nonneg ( fun _ _ => sq_nonneg _ ) |>.1 H i ) ];
      linarith;
    norm_num at * ; linarith

lemma modCont_le_Lipschitz (P_A : ℝ → ℝ) (L : ℝ) (h : ℝ)
    (hLip : LipschitzConst P_A L) (h_nonneg : 0 ≤ h) :
    modCont P_A h ≤ L * h := by
  unfold modCont;
  refine' ciSup_le fun x => ciSup_le fun y => _;
  -- Since $|P_A x - P_A y| \leq L |x - y|$ and $|x - y| \leq h$, we have $|P_A x - P_A y| \leq L h$.
  have h_bound : ∀ x y, |x - y| ≤ h → |P_A x - P_A y| ≤ L * h := by
    exact fun x y hxy => le_trans ( hLip x y ) ( mul_le_mul_of_nonneg_left hxy ( show 0 ≤ L by have := hLip 0 1; norm_num at this; linarith [ abs_le.mp this ] ) );
  -- Since every element in the set is ≤ L*h, the supremum of the set is also ≤ L*h.
  have h_sup_le : ∀ x y, |x - y| ≤ h → |P_A x - P_A y| ≤ L * h := by
    assumption;
  rw [ @ciSup_eq_ite ] ; aesop;
  exact le_trans ( abs_nonneg _ ) ( h_sup_le 0 0 ( by norm_num; linarith ) )

lemma large_N_bound (C L c₀ : ℝ) (hc₀ : c₀ > 0) : ∃ N₀ : ℕ, N₀ > 0 ∧ ∀ N ≥ N₀, C * (L / N) ≤ c₀ / 2 := by
  -- We can choose $N₀$ such that for all $N \geq N₀$, we have $CL \leq \frac{c₀N}{2}$.
  have hN₀ : ∃ N₀ : ℕ, N₀ > 0 ∧ (C * L) ≤ (c₀ * N₀) / 2 := by
    -- By the Archimedean property, there exists a natural number $N₀$ such that $N₀ > \frac{2CL}{c₀}$.
    obtain ⟨N₀, hN₀⟩ : ∃ N₀ : ℕ, N₀ > (2 * C * L) / c₀ := by
      exact exists_nat_gt _;
    exact ⟨ N₀ + 1, Nat.succ_pos _, by push_cast; nlinarith [ mul_div_cancel₀ ( 2 * C * L ) hc₀.ne' ] ⟩;
  obtain ⟨ N₀, hN₀₁, hN₀₂ ⟩ := hN₀; exact ⟨ N₀, hN₀₁, fun N hN => by rw [ mul_div ] ; rw [ div_le_iff₀ ] <;> nlinarith [ show ( N : ℝ ) ≥ N₀ by norm_cast, show ( N₀ : ℝ ) ≥ 1 by norm_cast ] ⟩ ;

noncomputable def TrigPolySq {N : ℕ} (v : Fin N → ℝ) (θ : ℝ) : ℝ :=
  Complex.normSq (∑ j, (v j : ℂ) * Complex.exp (Complex.I * j * θ))

lemma algebraic_bound (Q c₀ C L_N v_sq : ℝ)
    (h_v_nonneg : v_sq ≥ 0)
    (h_Q : Q ≥ c₀ * v_sq - C * L_N * v_sq)
    (h_bound : C * L_N ≤ c₀ / 2) :
    Q ≥ (c₀ / 2) * v_sq := by
  nlinarith

lemma toeplitz_lower_bound_with_lip (P_A : ℝ → ℝ) (N : ℕ) (c₀ L C : ℝ) (v : Fin N → ℝ)
    (hLip : LipschitzConst P_A L)
    (h_pos : quadForm (ToeplitzTruncation P_A N) v ≥ c₀ * l2NormSq v - C * modCont P_A (1/N) * l2NormSq v)
    (hC : C ≥ 0)
    (hN : N > 0) :
    quadForm (ToeplitzTruncation P_A N) v ≥ c₀ * l2NormSq v - C * (L / N) * l2NormSq v := by
  -- By Lemma 1, we know that $\omega(P_A, 1/N) \leq L / N$.
  have h_mod : modCont P_A (1 / (N : ℝ)) ≤ L / (N : ℝ) := by
    -- Apply the lemma modCont_le_Lipschitz with h = 1/N.
    apply modCont_le_Lipschitz P_A L (1 / N) hLip (by positivity) |> le_trans <| by ring_nf; norm_num;
  exact h_pos.trans' ( by exact sub_le_sub_left ( mul_le_mul_of_nonneg_right ( mul_le_mul_of_nonneg_left h_mod hC ) ( Finset.sum_nonneg fun _ _ => sq_nonneg _ ) ) _ )

lemma combine_bounds (P_A : ℝ → ℝ) (N : ℕ) (c₀ L C : ℝ) (v : Fin N → ℝ)
    (hLip : LipschitzConst P_A L)
    (h_pos : quadForm (ToeplitzTruncation P_A N) v ≥ c₀ * l2NormSq v - C * modCont P_A (1/N) * l2NormSq v)
    (h_bound : C * (L / N) ≤ c₀ / 2)
    (hC : C ≥ 0)
    (hN : N > 0) :
    quadForm (ToeplitzTruncation P_A N) v ≥ (c₀ / 2) * l2NormSq v := by
  -- Apply the algebraic_bound lemma with Q = quadForm (ToeplitzTruncation P_A N) v, c₀, and C * L/N.
  apply algebraic_bound;
  -- The l2NormSq v is the sum of squares of real numbers, which is non-negative.
  apply Finset.sum_nonneg; intro i _; exact pow_two_nonneg (v i);
  rotate_left;
  -- Apply the bound from h_bound to conclude the proof.
  apply h_bound;
  exact?

lemma local_positivity_large_N_counterexample :
    ∃ (P_A : ℝ → ℝ) (Γ : Set ℝ) (c₀ L : ℝ),
      LipschitzConst P_A L ∧
      PosArc P_A Γ c₀ ∧
      ¬ (∃ N₀ : ℕ, ∀ N ≥ N₀, ∀ v : Fin N → ℝ,
          quadForm (ToeplitzTruncation P_A N) v ≥ (c₀ / 2) * l2NormSq v) := by
  use fun x => Real.cos x;
  refine' ⟨ Set.Icc 0 ( Real.pi / 4 ), Real.cos ( Real.pi / 4 ), 1, _, _, _ ⟩ <;> norm_num;
  · -- Use the mean value theorem on the interval [x, y].
    have h_mean_value : ∀ x y : ℝ, x < y → ∃ c ∈ Set.Ioo x y, deriv Real.cos c = (Real.cos y - Real.cos x) / (y - x) := by
      intro x y hxy; have := exists_deriv_eq_slope Real.cos hxy; aesop;
      exact this ( Real.continuousOn_cos ) ( Differentiable.differentiableOn ( Real.differentiable_cos ) );
    intro x y; rcases lt_trichotomy x y with ( H | rfl | H ) <;> aesop;
    · obtain ⟨ c, ⟨ h₁, h₂ ⟩, h₃ ⟩ := h_mean_value x y H ; rw [ eq_div_iff ] at h₃ <;> cases abs_cases ( x - y ) <;> cases abs_cases ( Real.cos x - Real.cos y ) <;> nlinarith [ Real.neg_one_le_sin c, Real.sin_le_one c ];
    · obtain ⟨ c, ⟨ h₁, h₂ ⟩, h₃ ⟩ := h_mean_value _ _ H ; rw [ eq_div_iff ] at h₃ <;> cases abs_cases ( x - y ) <;> cases abs_cases ( Real.cos x - Real.cos y ) <;> nlinarith [ Real.neg_one_le_sin c, Real.sin_le_one c ];
  · refine' ⟨ ⟨ 0 + Real.pi / 8, Real.pi / 4, by positivity, _ ⟩, _, _ ⟩ <;> norm_num;
    · ring;
    · exact fun θ _ _ => by rw [ ← Real.cos_pi_div_four ] ; exact Real.cos_le_cos_of_nonneg_of_le_pi ( by linarith ) ( by linarith ) ( by linarith ) ;
  · refine' fun n => ⟨ n + 10, by linarith, fun i => if i.val = 0 then -1 else 0, _ ⟩ ; norm_num [ quadForm, l2NormSq ];
    unfold ToeplitzTruncation; norm_num [ Real.cos_eq_zero_iff ] ; ring ; norm_num [ Real.sqrt_lt' ] ;
    rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le ] <;> norm_num [ mul_two ] ; positivity