/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 6cd52bc6-5e5c-411a-a784-86009f2c5f24

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def digamma (z : ℂ) : ℂ := (deriv Complex.Gamma z) / (Complex.Gamma z)

def a (ξ : ℝ) : ℝ := Real.log Real.pi - (digamma (1/4 + Complex.I * Real.pi * (ξ : ℂ))).re

def w_B (B t_sym ξ : ℝ) : ℝ :=
  max 0 (1 - |ξ| / B) * Real.exp (-4 * Real.pi^2 * t_sym * ξ^2)

def g (B t_sym ξ : ℝ) : ℝ := a ξ * w_B B t_sym ξ

def P_A (B t_sym θ : ℝ) : ℝ :=
  2 * Real.pi * ∑' m : ℤ, g B t_sym (θ + m)

def B_min : ℝ := 3
def t_sym_val : ℝ := 3 / 50

def c_star : ℝ := 1.5

/-
The imaginary part of $1/(z+n)^2$ is negative for $z$ in the first quadrant.
-/
lemma im_one_div_sq_neg (z : ℂ) (hz_re : z.re > 0) (hz_im : z.im > 0) (n : ℕ) :
    (1 / (z + n) ^ 2).im < 0 := by
      norm_num [ Complex.normSq, sq ];
      -- Combine the fractions and simplify the numerator.
      field_simp;
      nlinarith [ mul_pos hz_re hz_im ]

/-
Definition of trigamma function.
-/
def trigamma (z : ℂ) : ℂ := deriv digamma z

lemma trigamma_eq_deriv_digamma (z : ℂ) : trigamma z = deriv digamma z := rfl

/-
The series for trigamma is summable.
-/
def trigamma_term (z : ℂ) (n : ℕ) : ℂ := 1 / (z + n) ^ 2

lemma summable_trigamma_term (z : ℂ) (hz : z ∉ {w : ℂ | ∃ n : ℕ, w = -n}) :
    Summable (trigamma_term z) := by
      -- The term is $O(1/n^2)$, so it is summable.
      have h_summable : Summable (fun n : ℕ => ‖1 / (z + (n : ℂ)) ^ 2‖) := by
        have h_summable : Summable (fun n : ℕ => ‖1 / ((n : ℂ) + z) ^ 2‖) := by
          have h_bound : ∃ C > 0, ∀ n : ℕ, n ≥ Nat.ceil (2 * ‖z‖) → ‖1 / ((n : ℂ) + z) ^ 2‖ ≤ C / (n ^ 2 : ℝ) := by
            use 4, by norm_num, fun n hn => ?_;
            norm_num at *;
            rw [ inv_eq_one_div, div_le_div_iff₀ ] <;> norm_cast <;> norm_num;
            · have := norm_add_le ( n + z ) ( -z ) ; norm_num at * ; nlinarith [ norm_nonneg z ];
            · exact sq_pos_of_pos ( norm_pos_iff.mpr <| by intro H; exact hz n <| by linear_combination' H );
            · exact sq_pos_of_pos ( Nat.cast_pos.mp ( lt_of_lt_of_le ( by norm_num; contrapose! hz; aesop ) hn ) )
          rw [ ← summable_nat_add_iff ⌈2 * ‖z‖⌉₊ ];
          exact Summable.of_nonneg_of_le ( fun n => norm_nonneg _ ) ( fun n => h_bound.choose_spec.2 _ ( Nat.le_add_left _ _ ) ) ( Summable.mul_left _ <| by simpa using summable_nat_add_iff ⌈2 * ‖z‖⌉₊ |>.2 <| Real.summable_one_div_nat_pow.2 one_lt_two );
        simpa only [ add_comm ] using h_summable;
      exact .of_norm h_summable

/-
Derivative of a(ξ) in terms of trigamma.
-/
lemma deriv_a_eq (ξ : ℝ) :
    deriv a ξ = Real.pi * (trigamma (1/4 + Complex.I * Real.pi * ξ)).im := by
      -- The derivative of the real part of the digamma function is the real part of the derivative of the digamma function.
      have h_real_part : deriv (fun ξ : ℝ => Complex.re (digamma (1 / 4 + Complex.I * Real.pi * ξ))) ξ = Complex.re (deriv (fun z : ℂ => digamma z) (1 / 4 + Complex.I * Real.pi * ξ) * (Complex.I * Real.pi)) := by
        convert HasDerivAt.deriv _ using 1;
        have h_complex_deriv : HasDerivAt (fun ξ : ℂ => digamma ξ) (deriv (fun z : ℂ => digamma z) (1 / 4 + Complex.I * Real.pi * ξ)) (1 / 4 + Complex.I * Real.pi * ξ) := by
          have h_complex_deriv : DifferentiableAt ℂ (fun z : ℂ => digamma z) (1 / 4 + Complex.I * Real.pi * ξ) := by
            -- The Gamma function is differentiable everywhere except at non-positive integers.
            have h_gamma_diff : DifferentiableAt ℂ (fun z => Complex.Gamma z) (1 / 4 + Complex.I * Real.pi * ξ) := by
              apply_rules [ Complex.differentiableAt_Gamma ];
              norm_num [ Complex.ext_iff ];
              exact fun m hm => by linarith;
            apply_rules [ DifferentiableAt.div, h_gamma_diff ];
            · have h_gamma_diff : AnalyticAt ℂ (Complex.Gamma) (1 / 4 + Complex.I * Real.pi * ξ) := by
                apply_rules [ DifferentiableOn.analyticAt ];
                refine' fun z hz => Complex.differentiableAt_Gamma _ _ |> DifferentiableAt.differentiableWithinAt;
                exact { z : ℂ | z.re > 0 };
                · exact fun m => ne_of_apply_ne Complex.re <| by norm_num; linarith [ hz.out ];
                · exact IsOpen.mem_nhds ( isOpen_lt continuous_const Complex.continuous_re ) ( by norm_num );
              exact h_gamma_diff.deriv.differentiableAt;
            · exact Complex.Gamma_ne_zero_of_re_pos ( by norm_num [ Complex.add_re, Complex.mul_re ] );
          exact h_complex_deriv.hasDerivAt;
        have h_chain : HasDerivAt (fun ξ : ℝ => digamma (1 / 4 + Complex.I * Real.pi * ξ)) (deriv (fun z : ℂ => digamma z) (1 / 4 + Complex.I * Real.pi * ξ) * (Complex.I * Real.pi)) ξ := by
          convert HasDerivAt.comp ξ h_complex_deriv ( HasDerivAt.add ( hasDerivAt_const _ _ ) ( HasDerivAt.mul ( hasDerivAt_const _ _ ) ( hasDerivAt_id _ |> HasDerivAt.ofReal_comp ) ) ) using 1 ; norm_num;
        rw [ hasDerivAt_iff_tendsto_slope_zero ] at *;
        convert Complex.continuous_re.continuousAt.tendsto.comp h_chain using 2 ; norm_num;
      unfold a;
      rw [ deriv_const_sub, h_real_part ] ; norm_num [ Complex.ext_iff, trigamma ] ; ring

/-
The imaginary part of the trigamma sum is negative in the first quadrant.
-/
def trigamma_sum (z : ℂ) : ℂ := ∑' n : ℕ, 1 / (z + n) ^ 2

lemma im_trigamma_sum_neg (z : ℂ) (hz_re : z.re > 0) (hz_im : z.im > 0) :
    (trigamma_sum z).im < 0 := by
      -- Since the imaginary part of each term in the sum is negative, the sum of these terms must also have a negative imaginary part.
      have h_sum_neg : ∑' n : ℕ, (trigamma_term z n).im < 0 := by
        have h_sum_neg : ∀ n : ℕ, (trigamma_term z n).im < 0 := by
          exact fun n => im_one_div_sq_neg z hz_re hz_im n;
        rw [ Summable.tsum_eq_zero_add ];
        · exact add_neg_of_neg_of_nonpos ( h_sum_neg 0 ) ( tsum_nonpos fun n => le_of_lt ( h_sum_neg _ ) );
        · have h_summable : Summable (fun n : ℕ => trigamma_term z n) := by
            exact summable_trigamma_term z ( by rintro ⟨ n, rfl ⟩ ; exact absurd hz_re ( by norm_num ) );
          convert Complex.imCLM.summable h_summable using 1;
      convert h_sum_neg using 1;
      rw [ ← Complex.im_tsum ];
      · exact?;
      · exact summable_trigamma_term z ( by rintro ⟨ n, rfl ⟩ ; norm_num at hz_re hz_im )