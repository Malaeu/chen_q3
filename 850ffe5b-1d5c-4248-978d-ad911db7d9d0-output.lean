/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 850ffe5b-1d5c-4248-978d-ad911db7d9d0

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

noncomputable def heat_kernel (t : ℝ) (x y : ℝ) : ℝ :=
  Real.exp (-(x - y)^2 / (4 * t))

noncomputable def prime_node (p : ℕ) : ℝ := Real.log p / (2 * Real.pi)

def nodes_in_window (K : ℝ) (N : ℕ) : Finset ℕ :=
  (Finset.range (N + 1)).filter (fun n =>
    Nat.Prime n ∧ |prime_node n| ≤ K)

noncomputable def prime_weight (n : ℕ) : ℝ :=
  if Nat.Prime n then Real.log n / Real.sqrt n else 0

lemma prime_weight_bound (n : ℕ) (hn : Nat.Prime n) (hn3 : n ≥ 3) :
  prime_weight n ≤ 2 / Real.exp 1 := by
    unfold prime_weight;
    -- By simplifying, we can see that the inequality holds.
    have h_simplified : (Real.log n) / Real.sqrt n ≤ 2 / Real.exp 1 := by
      have h_ln_sqrt : Real.log n ≤ 2 * Real.sqrt n / Real.exp 1 := by
        have := Real.log_le_sub_one_of_pos ( show 0 < Real.sqrt n / Real.exp 1 by positivity );
        rw [ Real.log_div ( by positivity ) ( by positivity ), Real.log_sqrt ( by positivity ), Real.log_exp ] at this ; ring_nf at * ; linarith
      rw [ div_le_iff₀ ( Real.sqrt_pos.mpr ( Nat.cast_pos.mpr hn.pos ) ) ] ; convert h_ln_sqrt using 1 ; ring;
    aesop

noncomputable def gram_matrix (t : ℝ) (nodes : Finset ℕ) : Matrix (Fin nodes.card) (Fin nodes.card) ℝ :=
  fun i j => heat_kernel t (prime_node (nodes.toList[i])) (prime_node (nodes.toList[j]))

noncomputable def twisted_prime_matrix (t α : ℝ) (nodes : Finset ℕ) :
    Matrix (Fin nodes.card) (Fin nodes.card) ℂ :=
  fun i j =>
    let m := nodes.toList[i]
    let n := nodes.toList[j]
    (prime_weight n : ℂ) *
    Complex.exp (2 * Real.pi * Complex.I * α * prime_node n) *
    (gram_matrix t nodes i j : ℂ)

def minor_arcs (N : ℕ) : Set ℝ :=
  {α : ℝ | ∀ (a : ℤ) (q : ℕ), (q : ℝ) ≤ (N : ℝ)^(1/10 : ℝ) → |α - a/q| > 1/(q * N)}

open scoped Matrix.Norms.Operator

#synth Norm (Matrix (Fin 10) (Fin 10) ℂ)