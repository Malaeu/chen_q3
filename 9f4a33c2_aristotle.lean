/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9f4a33c2-dfa7-4024-b81d-00d75497ca06

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Real Complex MeasureTheory Set
open scoped BigOperators

-- Digamma function
def digamma (z : ℂ) : ℂ := (deriv Complex.Gamma z) / (Complex.Gamma z)

-- Archimedean density a(ξ)
def a (ξ : ℝ) : ℝ := Real.log Real.pi - (digamma (1/4 + I * Real.pi * ξ)).re

-- Fixed parameters
def B_min : ℝ := 3
def t_sym : ℝ := 3 / 50  -- = 0.06

-- Fejér×heat window
def w (B t ξ : ℝ) : ℝ :=
  max 0 (1 - |ξ| / B) * Real.exp (-4 * Real.pi^2 * t * ξ^2)

-- Weighted density
def g (B t ξ : ℝ) : ℝ := a ξ * w B t ξ

-- Archimedean symbol (periodized)
def P_A (B t θ : ℝ) : ℝ :=
  2 * Real.pi * ∑' (m : ℤ), g B t (θ + m)

-- Uniform floor constant
def c_star : ℝ := 1.5

def trigamma (z : ℂ) : ℂ := ∑' n : ℕ, 1 / (z + n)^2

lemma im_one_div_sq_neg {z : ℂ} (hz : 0 < z.re) (hzi : 0 < z.im) : (1 / z^2).im < 0 := by
  norm_num [ sq, Complex.normSq, Complex.div_im ];
  -- Combine like terms and simplify the expression.
  field_simp
  ring;
  -- Since $z.re$ and $z.im$ are both positive, their product is positive, and multiplying by $-2$ makes it negative.
  apply neg_neg_of_pos; exact mul_pos (mul_pos hz hzi) (by norm_num)

lemma trigamma_summable {z : ℂ} (hz : 0 < z.re) : Summable (fun n : ℕ => 1 / (z + n)^2) := by
  rw [ ← summable_nat_add_iff ( ⌈‖z‖⌉₊ + 1 ) ] at *;
  -- Since ‖z‖ is finite, |z + n| is approximately n for large n. Therefore, |z + n|^2 is at least (n - ‖z‖)^2, which grows like n^2. Hence, ∑' n : ℕ, ‖(z + n)^2‖⁻¹ should be summable because it's similar to ∑' n : ℕ, 1 / n^2, which is a convergent p-series with p=2.
  have h_comparison : ∀ n : ℕ, ‖(z + (n + (⌈‖z‖⌉₊ + 1)) : ℂ)‖ ≥ (n + (⌈‖z‖⌉₊ + 1)) - ‖z‖ := by
    intro n; have := norm_sub_le ( z + ( n + ( ⌈‖z‖⌉₊ + 1 ) ) ) z; simp_all +decide;
    convert this using 1 ; norm_cast;
  have h_comparison : ∀ n : ℕ, ‖(z + (n + (⌈‖z‖⌉₊ + 1)) : ℂ)‖^2 ≥ (n + 1)^2 := by
    exact fun n => pow_le_pow_left₀ ( by positivity ) ( by have := h_comparison n; nlinarith [ Nat.le_ceil ( ‖z‖ ), show ( ⌈‖z‖⌉₊ : ℝ ) ≥ ‖z‖ by exact Nat.le_ceil _ ] ) _;
  -- Since ‖(z + (n + (⌈‖z‖⌉₊ + 1)))‖^2 ≥ (n + 1)^2, we have ‖(z + (n + (⌈‖z‖⌉₊ + 1)))‖⁻¹^2 ≤ 1 / (n + 1)^2.
  have h_comparison : ∀ n : ℕ, ‖(z + (n + (⌈‖z‖⌉₊ + 1)) : ℂ)‖⁻¹^2 ≤ 1 / (n + 1)^2 := by
    exact fun n => by simpa using inv_anti₀ ( by positivity ) ( h_comparison n ) ;
  have h_comparison : Summable (fun n : ℕ => ‖(z + (n + (⌈‖z‖⌉₊ + 1)) : ℂ)‖⁻¹^2) := by
    exact Summable.of_nonneg_of_le ( fun n => sq_nonneg _ ) h_comparison ( by simpa using summable_nat_add_iff 1 |>.2 <| Real.summable_one_div_nat_pow.2 one_lt_two );
  exact Summable.of_norm <| by simpa using h_comparison.norm;

lemma im_trigamma_neg {z : ℂ} (hz : 0 < z.re) (hzi : 0 < z.im) : (trigamma z).im < 0 := by
  -- Since the imaginary part of each term in the series is negative, the sum of these terms will also have a negative imaginary part.
  have h_im_sum_neg : ∀ n : ℕ, (1 / (z + n)^2).im < 0 := by
    -- Since $z + n$ has a positive real part and a positive imaginary part, the imaginary part of $1/(z + n)^2$ is negative.
    intros n
    have h_im_term : (1 / (z + n)^2).im = -2 * (z.re + n) * z.im / ((z.re + n)^2 + z.im^2)^2 := by
      simp +decide [ sq, Complex.normSq, Complex.div_im ] ; ring;
      rw [ inv_pow ] ; ring;
    exact h_im_term.symm ▸ div_neg_of_neg_of_pos ( by nlinarith ) ( by positivity );
  rw [ trigamma ];
  rw [ Complex.im_tsum ];
  · rw [ Summable.tsum_eq_zero_add ];
    · exact add_neg_of_neg_of_nonpos ( h_im_sum_neg 0 ) ( tsum_nonpos fun n => le_of_lt ( h_im_sum_neg _ ) );
    · have h_summable : Summable (fun n : ℕ => (1 / (z + n)^2 : ℂ)) := by
        exact?;
      convert Complex.imCLM.summable h_summable using 1;
  · exact?

#check deriv (fun t : ℝ => (digamma (1/4 + I * Real.pi * t)).re)
#check deriv digamma
#synth Module ℝ ℂ

lemma deriv_re_digamma (ξ : ℝ) : deriv (fun t : ℝ => (digamma (1/4 + I * Real.pi * t)).re) ξ = -Real.pi * (deriv (fun z : ℂ => digamma z) (1/4 + I * Real.pi * ξ)).im := by
  convert HasDerivAt.deriv _ using 1;
  -- Apply the chain rule to find the derivative:
  have h_chain : HasDerivAt (fun t : ℝ => digamma (1 / 4 + Complex.I * Real.pi * t)) (deriv (fun z : ℂ => digamma z) (1 / 4 + Complex.I * Real.pi * ξ) * Complex.I * Real.pi) ξ := by
    have h_chain : HasDerivAt (fun t : ℝ => digamma (1 / 4 + Complex.I * Real.pi * t)) (deriv (fun z : ℂ => digamma z) (1 / 4 + Complex.I * Real.pi * ξ) * (Complex.I * Real.pi)) ξ := by
      have h_diff : DifferentiableAt ℂ (fun z : ℂ => digamma z) (1 / 4 + Complex.I * Real.pi * ξ) := by
        refine' DifferentiableAt.div _ _ _;
        · have h_diff : AnalyticAt ℂ (deriv Complex.Gamma) (1 / 4 + Complex.I * Real.pi * ξ) := by
            have h_diff : AnalyticAt ℂ Complex.Gamma (1 / 4 + Complex.I * Real.pi * ξ) := by
              refine' DifferentiableOn.analyticAt _ _;
              exact { z : ℂ | 0 < z.re };
              · intro z hz; exact Complex.differentiableAt_Gamma _ ( by contrapose! hz; aesop ) |> DifferentiableAt.differentiableWithinAt;
              · exact IsOpen.mem_nhds ( isOpen_lt continuous_const Complex.continuous_re ) ( by norm_num );
            exact h_diff.deriv;
          exact h_diff.differentiableAt;
        · refine' Complex.differentiableAt_Gamma _ _;
          norm_num [ Complex.ext_iff ];
          exact fun m hm => by linarith;
        · exact Complex.Gamma_ne_zero_of_re_pos ( by norm_num [ Complex.add_re, Complex.mul_re ] )
      convert HasDerivAt.comp ξ ( h_diff.hasDerivAt ) ( HasDerivAt.add ( hasDerivAt_const _ _ ) ( HasDerivAt.mul ( hasDerivAt_const _ _ ) ( hasDerivAt_id _ |> HasDerivAt.ofReal_comp ) ) ) using 1 ; norm_num;
    simpa only [ mul_assoc ] using h_chain;
  rw [ hasDerivAt_iff_tendsto_slope_zero ] at *;
  convert Complex.continuous_re.continuousAt.tendsto.comp h_chain using 2 ; norm_num ; ring;
  norm_num [ Complex.ext_iff ]

lemma deriv_a_eq {ξ : ℝ} (hξ : 0 < ξ) : deriv a ξ = Real.pi * (deriv (fun z : ℂ => digamma z) (1/4 + I * Real.pi * ξ)).im := by
  -- Apply the chain rule to compute the derivative.
  have h_chain : deriv a ξ = -deriv (fun t : ℝ => (digamma (1 / 4 + Complex.I * Real.pi * t)).re) ξ := by
    unfold a;
    rw [ deriv_const_sub ];
  -- Apply the chain rule to the derivative of the real part of the digamma function.
  have h_chain : deriv (fun t : ℝ => (digamma (1 / 4 + Complex.I * Real.pi * t)).re) ξ = -Real.pi * (deriv (fun z : ℂ => digamma z) (1 / 4 + Complex.I * Real.pi * ξ)).im := by
    convert deriv_re_digamma ξ using 1;
  aesop

lemma continuousOn_a : ContinuousOn a (Ici 0) := by
  refine' ContinuousOn.sub _ _;
  · exact continuousOn_const;
  · -- The digamma function is analytic in the right half-plane, which includes the region where the real part is positive.
    have h_analytic : ∀ z : ℂ, 0 < z.re → AnalyticAt ℂ (fun z => digamma z) z := by
      intro z hz;
      have h_analytic : AnalyticAt ℂ (fun z => deriv Complex.Gamma z / Complex.Gamma z) z := by
        have h_gamma_analytic : AnalyticAt ℂ Complex.Gamma z := by
          refine' DifferentiableOn.analyticAt _ _;
          exact { w : ℂ | 0 < w.re };
          · -- The Gamma function is differentiable on the right half-plane by definition.
            have h_gamma_diff : ∀ w : ℂ, 0 < w.re → DifferentiableAt ℂ Complex.Gamma w := by
              intro w hw;
              apply_rules [ Complex.differentiableAt_Gamma ];
              exact fun m => ne_of_apply_ne Complex.re <| by norm_num; linarith;
            exact fun w hw => DifferentiableAt.differentiableWithinAt ( h_gamma_diff w hw );
          · exact IsOpen.mem_nhds ( isOpen_lt continuous_const Complex.continuous_re ) hz
        have h_deriv_gamma_analytic : AnalyticAt ℂ (deriv Complex.Gamma) z := by
          apply_rules [ AnalyticAt.deriv, h_gamma_analytic ]
        exact h_deriv_gamma_analytic.div h_gamma_analytic ( Complex.Gamma_ne_zero_of_re_pos hz );
      exact h_analytic;
    exact continuousOn_of_forall_continuousAt fun x hx => Complex.continuous_re.continuousAt.comp ( h_analytic _ ( by norm_num [ Complex.ext_iff ] ) |> fun h => h.continuousAt ) |> ContinuousAt.comp <| Continuous.continuousAt <| by continuity

def digamma_re_series_term (z : ℂ) (n : ℕ) : ℝ :=
  1 / (n + 1) - (z.re + n) / ((z.re + n)^2 + z.im^2)

def digamma_re_partial_sum (z : ℂ) (N : ℕ) : ℝ :=
  -Real.eulerMascheroniConstant + ∑ n ∈ Finset.range N, digamma_re_series_term z n