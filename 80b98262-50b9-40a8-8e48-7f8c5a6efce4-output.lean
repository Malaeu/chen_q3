/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 80b98262-50b9-40a8-8e48-7f8c5a6efce4

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Twin primes: p where both p and p+2 are prime
-/
def is_twin_prime (p : ℕ) : Prop := Nat.Prime p ∧ Nat.Prime (p + 2)

/-
Set of twin primes up to N (smaller element)
-/
def twins_up_to (N : ℕ) : Finset ℕ :=
  (Finset.range N).filter is_twin_prime

/-
Exponential sum with α = ln(6)
-/
noncomputable def S_twins_ln6 (N : ℕ) : ℂ :=
  ∑ p ∈ twins_up_to N, Complex.exp (2 * Real.pi * Complex.I * p * Real.log 6)

/-
For all twin primes p > 5, p ≡ 5 (mod 6).
-/
lemma mod6_structure (p : ℕ) (hp : is_twin_prime p) (hp_gt_5 : 5 < p) : p % 6 = 5 := by
  -- Since $p$ is prime and greater than 5, it must be congruent to 1 or 5 modulo 6.
  have h_mod : p % 2 = 1 ∧ p % 3 ≠ 0 := by
    exact ⟨ hp.1.eq_two_or_odd.resolve_left ( by linarith ), fun h => by have := Nat.dvd_of_mod_eq_zero h; rw [ hp.1.dvd_iff_eq ] at this <;> linarith ⟩;
  rw [ ← Nat.mod_mod_of_dvd p ( by decide : 2 ∣ 6 ), ← Nat.mod_mod_of_dvd p ( by decide : 3 ∣ 6 ) ] at h_mod; have := Nat.mod_lt p ( by decide : 6 > 0 ) ; interval_cases _ : p % 6 <;> simp_all +decide ;
  exact absurd ( Nat.dvd_of_mod_eq_zero ( show ( p + 2 ) % 3 = 0 by omega ) ) ( by rw [ hp.2.dvd_iff_eq ] <;> linarith )

/-
Decomposition of the exponential sum: S_N ≈ term(p=3) + S_reduced.
-/
def K_N (N : ℕ) : Finset ℕ :=
  (Finset.range (N + 1)).filter (fun k => k > 0 ∧ is_twin_prime (6 * k - 1) ∧ 6 * k - 1 < N)

noncomputable def S_reduced (N : ℕ) : ℂ :=
  Complex.exp (-2 * Real.pi * Complex.I * Real.log 6) *
  ∑ k ∈ K_N N, Complex.exp (2 * Real.pi * Complex.I * k * 6 * Real.log 6)

lemma sum_decomposition (N : ℕ) (hN : N > 5) :
  ‖S_twins_ln6 N - (Complex.exp (2 * Real.pi * Complex.I * 3 * Real.log 6) + S_reduced N)‖ < 1e-9 := by
  -- The set of twin primes up to N is {3} U {p | p in twins, 5 <= p < N}. The mapping k -> 6k-1 maps K_N bijectively to {p | p in twins, 5 <= p < N}.
  have h_union : twins_up_to N = {3} ∪ (Finset.image (fun k => 6 * k - 1) (Finset.filter (fun k => is_twin_prime (6 * k - 1)) (Finset.Ico 1 ((N + 6) / 6)))) := by
    ext p
    simp [twins_up_to];
    constructor <;> intro h;
    · -- If $p$ is a twin prime greater than 5, then $p \equiv 5 \pmod{6}$.
      by_cases hp : p > 5;
      · -- Since $p > 5$, we have $p \equiv 5 \pmod{6}$.
        have hp_mod : p % 6 = 5 := by
          exact mod6_structure p h.2 hp;
        exact Or.inr ⟨ p / 6 + 1, ⟨ ⟨ by linarith [ Nat.mod_add_div p 6 ], by omega ⟩, by convert h.2 using 1; omega ⟩, by omega ⟩;
      · interval_cases p <;> simp_all +decide [ is_twin_prime ];
        linarith;
    · rcases h with ( rfl | ⟨ a, ⟨ ⟨ ha₁, ha₂ ⟩, ha₃ ⟩, rfl ⟩ ) <;> norm_num [ is_twin_prime ] at *;
      · linarith;
      · exact ⟨ by omega, ha₃ ⟩;
  unfold S_twins_ln6 S_reduced;
  rw [ h_union, Finset.sum_union ] <;> norm_num [ Finset.mul_sum _ _ _ ];
  · rw [ Finset.sum_image ] <;> norm_num;
    · rw [ show K_N N = Finset.filter ( fun k => is_twin_prime ( 6 * k - 1 ) ) ( Finset.Ico 1 ( N / 6 + 1 ) ) from ?_ ];
      · rw [ Finset.sum_congr rfl fun x hx => by rw [ Nat.cast_sub ( by linarith [ Finset.mem_Ico.mp ( Finset.mem_filter.mp hx |>.1 ) ] ) ] ] ; norm_num [ ← Complex.exp_add ] ; ring_nf ; norm_num;
        norm_num [ Complex.norm_def, Complex.normSq, Complex.exp_re, Complex.exp_im ] ; ring_nf ; norm_num [ Complex.log_re, Complex.log_im ];
      · ext; simp [K_N];
        grind;
    · exact fun x hx y hy hxy => by linarith [ Nat.sub_add_cancel ( by linarith [ hx.1.1 ] : 1 ≤ 6 * x ), Nat.sub_add_cancel ( by linarith [ hy.1.1 ] : 1 ≤ 6 * y ) ] ;
  · intros; omega;

#check Transcendental
#check Transcendental.irrational

/-
The statement of the main theorem: |S_N| = O(N^{1/2 - δ}) for some δ > 0.
-/
def Q3_statement : Prop :=
  ∃ (δ : ℝ) (C : ℝ), δ > 0 ∧ C > 0 ∧
  ∀ N : ℕ, N > 100 →
    ‖S_twins_ln6 N‖ ≤ C * (N : ℝ) ^ (1/2 - δ)