/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d7048fc1-00f1-4429-b1a2-182fefa1d2e7
-/

/-
Formalization of the Growth Target P(X) theorem and its corollary for the twin prime spectral gap problem.
We define the Gaussian kernel K, commutator matrix A, Gram matrix G, and commutator energy matrix Q.
We prove that the Rayleigh quotient R(1) is bounded below by a constant times the square of the span of the spectral coordinates, assuming the Universal Scaling Lemma (Lemma 3).
We also prove that if the span tends to infinity, the Rayleigh quotient tends to infinity.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions of K, A, G, Q, and MatrixSum.
-/
open Matrix BigOperators Real

variable {N : ℕ}
variable (ξ : Fin N → ℝ)
variable (t : ℝ)

def K (i j : Fin N) : ℝ := 2 * Real.pi * t * exp (- (ξ i - ξ j)^2 / (4 * t))

def A : Matrix (Fin N) (Fin N) ℝ := fun i j => (ξ j - ξ i) * K ξ t i j

def G : Matrix (Fin N) (Fin N) ℝ := fun i j => sqrt (2 * Real.pi * t) * exp (- (ξ i - ξ j)^2 / (8 * t))

def Q : Matrix (Fin N) (Fin N) ℝ := (A ξ t)ᵀ * (A ξ t)

def MatrixSum (M : Matrix (Fin N) (Fin N) ℝ) : ℝ := ∑ i, ∑ j, M i j

/-
Upper bound for the sum of entries of G. Since each entry is at most sqrt(2*pi*t), the sum is at most N^2 * sqrt(2*pi*t).
-/
theorem sum_G_upper_bound (t : ℝ) (ht : t > 0) (N : ℕ) (ξ : Fin N → ℝ) :
  MatrixSum (G ξ t) ≤ (N : ℝ)^2 * sqrt (2 * Real.pi * t) := by
    exact le_trans ( Finset.sum_le_sum fun i hi ↦ Finset.sum_le_sum fun j hj ↦ show G ξ t i j ≤ Real.sqrt ( 2 * Real.pi * t ) by exact mul_le_of_le_one_right ( Real.sqrt_nonneg _ ) ( Real.exp_le_one_iff.2 <| by rw [ div_le_iff₀ ] <;> nlinarith ) ) <| by norm_num ; nlinarith;

/-
Definition of the span of the spectral coordinates.
-/
def span {N : ℕ} (hN : N ≥ 2) (ξ : Fin N → ℝ) : ℝ :=
  ξ ⟨N - 1, Nat.sub_lt (lt_of_lt_of_le (by norm_num) hN) (by norm_num)⟩ -
  ξ ⟨0, lt_of_lt_of_le (by norm_num) hN⟩

/-
Growth Target P(X): The Rayleigh quotient R(1) = Sum(Q)/Sum(G) is at least C * span^2, assuming Lemma 3.
-/
theorem growth_target (t : ℝ) (ht : t > 0)
  (h_lemma3 : ∃ c > 0, ∀ N : ℕ, ∀ hN : N ≥ 2, ∀ ξ : Fin N → ℝ, StrictMono ξ →
    MatrixSum (Q ξ t) ≥ c * (N : ℝ)^2 * (span hN ξ)^2) :
  ∃ C > 0, ∀ N : ℕ, ∀ hN : N ≥ 2, ∀ ξ : Fin N → ℝ, StrictMono ξ →
  MatrixSum (Q ξ t) / MatrixSum (G ξ t) ≥ C * (span hN ξ)^2 := by
    obtain ⟨ c, hc₀, hc ⟩ := h_lemma3; use c / Real.sqrt ( 2 * Real.pi * t ) ; aesop;
    · positivity;
    · -- By definition of $MatrixSum$, we know that $MatrixSum (G ξ t) > 0$ for any $ξ$.
      have h_pos : 0 < MatrixSum (G ξ t) := by
        exact Finset.sum_pos ( fun i _ => Finset.sum_pos ( fun j _ => mul_pos ( Real.sqrt_pos.mpr <| by positivity ) <| Real.exp_pos _ ) ⟨ i, Finset.mem_univ _ ⟩ ) ⟨ ⟨ 0, by linarith ⟩, Finset.mem_univ _ ⟩;
      -- By combining the results from Lemma 3 and the upper bound for the sum of entries of G, we get the desired inequality.
      have h_combined : MatrixSum (Q ξ t) / MatrixSum (G ξ t) ≥ (c * (N : ℝ) ^ 2 * span (by
      linarith) ξ ^ 2) / (N ^ 2 * Real.sqrt (2 * Real.pi * t)) := by
        all_goals generalize_proofs at *;
        gcongr <;> aesop;
        · exact le_trans ( by positivity ) ( hc N pf_1 ξ a );
        · exact?
      generalize_proofs at *;
      convert h_combined.le using 1 ; ring_nf ; norm_num [ ne_of_gt ( zero_lt_two.trans_le hN ) ]

/-
Checking if Filter and Tendsto are available.
-/
#check Filter
#check Filter.atTop
#check Filter.Tendsto

/-
Helper definition for span that handles N < 2 by returning 0.
-/
noncomputable def span' (N : ℕ) (ξ : Fin N → ℝ) : ℝ :=
  if h : N ≥ 2 then span h ξ else 0

/-
Corollary: If the span tends to infinity as N -> infinity, then the Rayleigh quotient tends to infinity.
-/
theorem growth_corollary (t : ℝ) (ht : t > 0)
  (h_lemma3 : ∃ c > 0, ∀ N : ℕ, ∀ hN : N ≥ 2, ∀ ξ : Fin N → ℝ, StrictMono ξ →
    MatrixSum (Q ξ t) ≥ c * (N : ℝ)^2 * (span hN ξ)^2)
  (ξ_seq : (N : ℕ) → Fin N → ℝ)
  (h_mono : ∀ N, StrictMono (ξ_seq N))
  (h_span : Filter.Tendsto (fun N ↦ span' N (ξ_seq N)) Filter.atTop Filter.atTop) :
  Filter.Tendsto (fun N ↦ MatrixSum (Q (ξ_seq N) t) / MatrixSum (G (ξ_seq N) t)) Filter.atTop Filter.atTop := by
    -- By Lemma 3, there exists a constant $C > 0$ such that $R(1) \geq C \cdot \text{span}^2$ for all $N \geq 2$.
    obtain ⟨C, hC_pos, hC⟩ : ∃ C > 0, ∀ N : ℕ, ∀ hN : N ≥ 2, ∀ ξ : Fin N → ℝ, StrictMono ξ → MatrixSum (Q ξ t) / MatrixSum (G ξ t) ≥ C * (span hN ξ)^2 := by
      exact?;
    -- Since $\lim_{N \to \infty} \text{span}(N) = \infty$, it follows that $\lim_{N \to \infty} \text{span}(N)^2 = \infty$.
    have h_span_sq_inf : Filter.Tendsto (fun N => (span' N (ξ_seq N))^2) Filter.atTop Filter.atTop := by
      exact Filter.tendsto_pow_atTop ( by norm_num ) |> Filter.Tendsto.comp <| h_span;
    refine' Filter.tendsto_atTop_mono' _ _ ( h_span_sq_inf.const_mul_atTop hC_pos );
    filter_upwards [ Filter.eventually_ge_atTop 2 ] with N hN using by unfold span'; aesop;