/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9d149379-1ce6-44b9-a63b-81330c793c13

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions required for A1_density_WK.
-/
noncomputable def FejerKernel (B : ℝ) (x : ℝ) : ℝ := max 0 (1 - |x| / B)

noncomputable def HeatKernel (t : ℝ) (x : ℝ) : ℝ :=
  (4 * Real.pi * t) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / (4 * t))

def W_K (K : ℝ) : Set (ℝ → ℝ) :=
  {Φ | ContinuousOn Φ (Set.Icc (-K) K) ∧
       Function.support Φ ⊆ Set.Icc (-K) K ∧
       Even Φ ∧
       ∀ x, 0 ≤ Φ x}

noncomputable def Atom (B t τ : ℝ) (x : ℝ) : ℝ :=
  FejerKernel B (x - τ) * HeatKernel t (x - τ) +
  FejerKernel B (x + τ) * HeatKernel t (x + τ)

def AtomSet (K : ℝ) : Set (ℝ → ℝ) :=
  {g | ∃ B > 0, ∃ t > 0, ∃ τ ∈ Set.Icc (-K) K, g = Atom B t τ}

def AtomCone_K (K : ℝ) : Set (ℝ → ℝ) :=
  Convex.toCone (convexHull ℝ (AtomSet K)) (convex_convexHull ℝ (AtomSet K))

def diff_set (Φ : ℝ → ℝ) (g : ℝ → ℝ) (K : ℝ) : Set ℝ :=
  (fun x ↦ |Φ x - g x|) '' Set.Icc (-K) K

noncomputable def real_convolution (f g : ℝ → ℝ) (x : ℝ) : ℝ := ∫ t, f t * g (x - t)

/-
HeatKernel_integral lemma.
-/
lemma HeatKernel_integral (t : ℝ) (ht : t > 0) : ∫ x, HeatKernel t x = 1 := by
  -- The integral of the Gaussian function over the entire real line is equal to 1.
  have h_gauss_integral : ∫ x, Real.exp (-x^2 / (4 * t)) = Real.sqrt (4 * Real.pi * t) := by
    -- Apply the Gaussian integral theorem with $a = \frac{1}{4t}$.
    have h_gauss : ∫ x, Real.exp (-x^2 / (4 * t)) = Real.sqrt (Real.pi / (1 / (4 * t))) := by
      convert integral_gaussian ( 1 / ( 4 * t ) ) using 1 ; norm_num [ div_eq_inv_mul ];
    exact h_gauss.trans ( by rw [ div_div_eq_mul_div ] ; ring );
  -- Substitute the definition of the HeatKernel into the integral.
  have h_integral : ∫ x, HeatKernel t x = (4 * Real.pi * t) ^ (-(1:ℝ)/2) * ∫ x, Real.exp (-x^2 / (4 * t)) := by
    rw [ ← MeasureTheory.integral_const_mul ];
    exact rfl;
  -- Substitute the known value of the Gaussian integral into the expression for the HeatKernel integral.
  rw [h_integral, h_gauss_integral];
  rw [ Real.sqrt_eq_rpow, ← Real.rpow_add ] <;> norm_num ; positivity

/-
HeatKernel_mass_concentration and HeatKernel_nonneg lemmas.
-/
lemma HeatKernel_mass_concentration (δ : ℝ) (hδ : δ > 0) :
  Filter.Tendsto (fun t => ∫ x in {y | |y| > δ}, HeatKernel t x)
    (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
      -- By definition of $HeatKernel$, we know that
      have h_heat_kernel : ∀ t > 0, ∫ x in {y | abs y > δ}, HeatKernel t x = ∫ x in {y | abs y > δ / Real.sqrt t}, (4 * Real.pi) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / 4) := by
        intro t ht_pos
        have h_subst : ∀ {f : ℝ → ℝ}, ∫ x in {y | abs y > δ}, f x = ∫ x in {y | abs y > δ / Real.sqrt t}, f (Real.sqrt t * x) * Real.sqrt t := by
          intro f
          have h_subst : ∫ x in {y | abs y > δ}, f x = ∫ x in (Set.image (fun x => Real.sqrt t * x) {y | abs y > δ / Real.sqrt t}), f x := by
            congr with x ; aesop;
            · use x / Real.sqrt t;
              exact ⟨ by rw [ abs_div, abs_of_pos ( Real.sqrt_pos.mpr ht_pos ) ] ; gcongr, mul_div_cancel₀ _ ( ne_of_gt ( Real.sqrt_pos.mpr ht_pos ) ) ⟩;
            · rwa [ abs_of_pos ( Real.sqrt_pos.mpr ht_pos ), div_lt_iff₀' ( Real.sqrt_pos.mpr ht_pos ) ] at *;
          rw [ h_subst, MeasureTheory.integral_image_eq_integral_abs_deriv_smul ] <;> norm_num [ ht_pos.le ];
          any_goals intro x hx; exact HasDerivAt.hasDerivWithinAt ( by simpa using HasDerivAt.const_mul ( Real.sqrt t ) ( hasDerivAt_id x ) );
          · norm_num [ mul_comm, abs_of_pos ( Real.sqrt_pos.mpr ht_pos ) ];
          · exact measurableSet_Ioi.mem.comp measurable_norm;
          · exact fun x hx y hy hxy => mul_left_cancel₀ ( ne_of_gt ( Real.sqrt_pos.mpr ht_pos ) ) hxy;
        convert h_subst using 1;
        unfold HeatKernel; norm_num [ ht_pos.le, ht_pos.ne', mul_assoc, mul_comm, mul_left_comm, div_eq_mul_inv, Real.rpow_neg, Real.rpow_two, Real.pi_pos.le ] ;
        norm_num [ Real.rpow_neg_eq_inv_rpow, mul_pow, mul_assoc, mul_comm, mul_left_comm, ht_pos.le, ht_pos.ne' ];
        norm_num [ ← mul_assoc, ← Real.sqrt_eq_rpow, ht_pos.le, ht_pos.ne', Real.pi_pos.le, Real.pi_pos.ne', mul_comm, mul_left_comm, mul_assoc, Real.sqrt_mul, Real.sqrt_inv ];
      -- As $t \to 0$, $\delta / \sqrt{t} \to \infty$, so the integral over $|x| > \delta / \sqrt{t}$ tends to zero.
      have h_lim_zero : Filter.Tendsto (fun t => ∫ x in {y | abs y > δ / Real.sqrt t}, (4 * Real.pi) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / 4)) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
        -- The integral of the Gaussian function over the set where |x| > δ / sqrt(t) tends to zero as δ / sqrt(t) tends to infinity.
        have h_gauss_tail : Filter.Tendsto (fun M => ∫ x in {y | abs y > M}, (4 * Real.pi) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / 4)) (Filter.atTop) (nhds 0) := by
          have h_gauss_tail : Filter.Tendsto (fun M => ∫ x in Set.univ, (4 * Real.pi) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / 4) * (if abs x > M then 1 else 0)) Filter.atTop (nhds 0) := by
            have h_gauss_tail : Filter.Tendsto (fun M => ∫ x in Set.univ, (4 * Real.pi) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / 4) * (if abs x > M then 1 else 0)) Filter.atTop (nhds (∫ x in Set.univ, (4 * Real.pi) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / 4) * 0)) := by
              refine' MeasureTheory.tendsto_integral_filter_of_dominated_convergence _ _ _ _ _ <;> norm_num +zetaDelta at *;
              refine' fun x => ( 4 * Real.pi ) ^ ( - ( 1 / 2 ) : ℝ ) * Real.exp ( -x ^ 2 / 4 );
              · exact ⟨ 0, fun t ht => Measurable.aestronglyMeasurable ( by exact Measurable.ite ( measurableSet_lt measurable_const ( measurable_norm ) ) ( by exact Continuous.measurable ( by continuity ) ) measurable_const ) ⟩;
              · exact ⟨ 0, fun t ht => Filter.Eventually.of_forall fun x => by split_ifs <;> rw [ abs_of_nonneg ] <;> positivity ⟩;
              · exact MeasureTheory.Integrable.const_mul ( by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) ) _;
              · filter_upwards [ ] with x using tendsto_const_nhds.congr' ( by filter_upwards [ Filter.eventually_gt_atTop |x| ] with n hn; split_ifs <;> linarith );
            aesop;
          convert h_gauss_tail using 2 ; norm_num [ ← MeasureTheory.integral_indicator, Set.indicator_apply ];
          rw [ ← MeasureTheory.integral_indicator ] <;> norm_num [ Set.indicator ];
          exact measurableSet_Ioi.mem.comp measurable_norm;
        refine h_gauss_tail.comp ?_;
        refine' Filter.Tendsto.const_mul_atTop hδ _;
        refine' Filter.Tendsto.inv_tendsto_nhdsGT_zero _;
        refine' Filter.Tendsto.inf _ _ <;> simpa using Real.continuous_sqrt.tendsto 0;
      exact Filter.Tendsto.congr' ( Filter.eventuallyEq_of_mem self_mem_nhdsWithin fun t ht => by rw [ h_heat_kernel t ht ] ) h_lim_zero

lemma HeatKernel_nonneg (t : ℝ) (ht : t > 0) (x : ℝ) : 0 ≤ HeatKernel t x := by
  -- The exponential function is always positive, and the term $(4\pi t)^{-1/2}$ is also positive since $t > 0$. Therefore, their product is positive.
  apply mul_nonneg; exact Real.rpow_nonneg (by positivity) _; exact Real.exp_nonneg _

/-
uniform_riemann_sum lemma.
-/
lemma uniform_riemann_sum (a b : ℝ) (hab : a < b) (X : Set ℝ) (hX : IsCompact X)
    (F : ℝ → ℝ → ℝ) (hF : ContinuousOn (Function.uncurry F) (X ×ˢ Set.Icc a b))
    (ε : ℝ) (hε : ε > 0) :
  ∃ (s : Finset ℝ) (w : ℝ → ℝ), (∀ y ∈ s, w y > 0) ∧ (∀ y ∈ s, y ∈ Set.Icc a b) ∧
  ∀ x ∈ X, |(∫ y in Set.Icc a b, F x y) - ∑ y ∈ s, w y * F x y| < ε := by
    obtain ⟨δ, hδ_pos, hδ⟩ : ∃ δ > 0, ∀ x ∈ X, ∀ y ∈ Set.Icc a b, ∀ z ∈ Set.Icc a b, |y - z| < δ → |F x y - F x z| < ε / (2 * (b - a)) := by
      have h_unif_cont : UniformContinuousOn (fun p : ℝ × ℝ => F p.1 p.2) (X ×ˢ Set.Icc a b) := by
        apply_rules [ IsCompact.uniformContinuousOn_of_continuous ];
        exact hX.prod CompactIccSpace.isCompact_Icc;
      rcases Metric.uniformContinuousOn_iff.mp h_unif_cont ( ε / ( 2 * ( b - a ) ) ) ( div_pos hε ( mul_pos two_pos ( sub_pos.mpr hab ) ) ) with ⟨ δ, hδ, hδ' ⟩ ; use δ ; aesop;
    -- Let's choose a partition of the interval [a, b] with width less than δ.
    obtain ⟨n, hn⟩ : ∃ n : ℕ, n > 0 ∧ (b - a) / n < δ := by
      exact ⟨ ⌊ ( b - a ) / δ⌋₊ + 1, Nat.succ_pos _, by rw [ div_lt_iff₀ ] <;> push_cast <;> nlinarith [ Nat.lt_floor_add_one ( ( b - a ) / δ ), mul_div_cancel₀ ( b - a ) hδ_pos.ne' ] ⟩;
    use Finset.image (fun i : ℕ => a + (i + 1 / 2) * (b - a) / n) (Finset.range n), fun y => (b - a) / n;
    aesop;
    · exact div_nonneg ( mul_nonneg ( by positivity ) ( by linarith ) ) ( by positivity );
    · rw [ add_div', div_le_iff₀ ] <;> norm_num <;> nlinarith [ show ( a_1 : ℝ ) + 1 ≤ n by norm_cast ];
    · -- By the properties of the integral, we can approximate the integral over each subinterval by the value of the function at the midpoint times the width of the subinterval.
      have h_integral_approx : ∀ i ∈ Finset.range n, |∫ y in (a + i * (b - a) / n).. (a + (i + 1) * (b - a) / n), F x y - F x (a + (i + 1 / 2) * (b - a) / n)| ≤ (b - a) / n * (ε / (2 * (b - a))) := by
        intros i hi
        have h_integral_approx : ∀ y ∈ Set.Icc (a + i * (b - a) / n) (a + (i + 1) * (b - a) / n), |F x y - F x (a + (i + 1 / 2) * (b - a) / n)| ≤ ε / (2 * (b - a)) := by
          intros y hy
          have h_dist : |y - (a + (i + 1 / 2) * (b - a) / n)| < δ := by
            exact abs_lt.mpr ⟨ by ring_nf at *; linarith [ hy.1, hy.2 ], by ring_nf at *; linarith [ hy.1, hy.2 ] ⟩;
          exact le_of_lt ( hδ x a_1 y ( by nlinarith [ hy.1, hy.2, show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], mul_div_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ( by nlinarith [ hy.1, hy.2, show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], mul_div_cancel₀ ( ( ( i : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ( a + ( ( i : ℝ ) + 1 / 2 ) * ( b - a ) / n ) ( by nlinarith [ hy.1, hy.2, show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], mul_div_cancel₀ ( ( ( i : ℝ ) + 1 / 2 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ( by nlinarith [ hy.1, hy.2, show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], mul_div_cancel₀ ( ( ( i : ℝ ) + 1 / 2 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) h_dist );
        rw [ intervalIntegral.integral_of_le ( by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], mul_div_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( i : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ];
        refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm ( _ : ℝ → ℝ ) ) ( le_trans ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _ );
        refine' fun y => ε / ( 2 * ( b - a ) );
        · exact Filter.Eventually.of_forall fun y => norm_nonneg _;
        · norm_num;
        · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with y hy using h_integral_approx y <| Set.Ioc_subset_Icc_self hy;
        · norm_num [ add_mul, div_eq_mul_inv ];
          rw [ max_eq_left ( by exact mul_nonneg ( sub_nonneg.2 hab.le ) ( inv_nonneg.2 ( Nat.cast_nonneg _ ) ) ) ];
      -- By the properties of the integral, we can approximate the integral over each subinterval by the value of the function at the midpoint times the width of the subinterval. Summing these approximations gives us the desired result.
      have h_sum_integral_approx : |∑ i ∈ Finset.range n, (∫ y in (a + i * (b - a) / n).. (a + (i + 1) * (b - a) / n), F x y) - ∑ i ∈ Finset.range n, (b - a) / n * F x (a + (i + 1 / 2) * (b - a) / n)| ≤ n * ((b - a) / n * (ε / (2 * (b - a)))) := by
        have h_sum_integral_approx : |∑ i ∈ Finset.range n, (∫ y in (a + i * (b - a) / n).. (a + (i + 1) * (b - a) / n), F x y - F x (a + (i + 1 / 2) * (b - a) / n))| ≤ n * ((b - a) / n * (ε / (2 * (b - a)))) := by
          exact le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( le_trans ( Finset.sum_le_sum h_integral_approx ) ( by norm_num ) );
        convert h_sum_integral_approx using 1;
        rw [ ← Finset.sum_sub_distrib, Finset.sum_congr rfl ] ; intros ; rw [ intervalIntegral.integral_sub ] <;> norm_num;
        · exact Or.inl <| by ring;
        · apply_rules [ ContinuousOn.intervalIntegrable ];
          refine' hF.comp ( continuousOn_const.prodMk continuousOn_id ) fun y hy => _;
          aesop;
          · cases Set.mem_uIcc.mp hy <;> nlinarith [ show ( x_1 : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( x_1 : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( x_1 : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ];
          · cases Set.mem_uIcc.mp hy <;> nlinarith [ show ( x_1 : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( x_1 : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( x_1 : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ];
      -- The sum of the integrals over the subintervals is equal to the integral over the entire interval.
      have h_sum_integral : ∑ i ∈ Finset.range n, ∫ y in (a + i * (b - a) / n).. (a + (i + 1) * (b - a) / n), F x y = ∫ y in a..b, F x y := by
        convert intervalIntegral.sum_integral_adjacent_intervals _ <;> aesop;
        · rw [ mul_div_cancel_left₀ _ ( by positivity ), add_sub_cancel ];
        · apply_rules [ ContinuousOn.intervalIntegrable ];
          refine' hF.comp ( continuousOn_const.prodMk ( continuousOn_id ) ) fun y hy => _;
          aesop;
          · cases Set.mem_uIcc.mp hy <;> nlinarith [ show ( k : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( k : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( k : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ];
          · cases Set.mem_uIcc.mp hy <;> nlinarith [ show ( k : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( k : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( k : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ];
      rw [ Finset.sum_image ] <;> norm_num;
      · rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le hab.le ] ; aesop;
        exact h_sum_integral_approx.trans_lt ( by nlinarith [ mul_div_cancel₀ ( b - a ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ε ( by linarith : ( 2 * ( b - a ) ) ≠ 0 ) ] );
      · intro i hi j hj hij; simp_all +decide [ div_eq_mul_inv, ne_of_gt ]

/-
fejer_sum_approx lemma.
-/
lemma fejer_sum_approx (K : ℝ) (hK : K > 0) (t : ℝ) (ht : t > 0) (s : Finset ℝ)
    (w : ℝ → ℝ) (hw_nonneg : ∀ y ∈ s, w y ≥ 0) (hs_subset : ∀ y ∈ s, y ∈ Set.Icc (-K) K)
    (ε : ℝ) (hε : ε > 0) :
  ∃ B > 0, ∀ x ∈ Set.Icc (-K) K,
  |∑ y ∈ s, w y * Atom B t y x - (∑ y ∈ s, w y * HeatKernel t (x - y) +
    ∑ y ∈ s, w y * HeatKernel t (x + y))| < ε := by
      -- Choose $B$ large enough such that $|Atom B t y (x) - HeatKernel t (x - y) - HeatKernel t (x + y)|$ is small for all $x \in [-K, K]$ and $y \in s$.
      obtain ⟨B, hB⟩ : ∃ B > 0, ∀ x ∈ Set.Icc (-K) K, ∀ y ∈ s, |FejerKernel B (x - y) * HeatKernel t (x - y) + FejerKernel B (x + y) * HeatKernel t (x + y) - (HeatKernel t (x - y) + HeatKernel t (x + y))| < ε / (∑ y ∈ s, (w y) + 1) := by
        -- Since $|FejerKernel B (x - y) - 1| \leq \frac{|x - y|}{B}$ and $|FejerKernel B (x + y) - 1| \leq \frac{|x + y|}{B}$, we can bound the difference.
        have h_bound : ∀ B > 0, ∀ x ∈ Set.Icc (-K) K, ∀ y ∈ s, |FejerKernel B (x - y) * HeatKernel t (x - y) + FejerKernel B (x + y) * HeatKernel t (x + y) - (HeatKernel t (x - y) + HeatKernel t (x + y))| ≤ (|x - y| + |x + y|) / B * (HeatKernel t (x - y) + HeatKernel t (x + y)) := by
          intros B hB x hx y hy
          have h_bound : |FejerKernel B (x - y) - 1| ≤ |x - y| / B ∧ |FejerKernel B (x + y) - 1| ≤ |x + y| / B := by
            unfold FejerKernel;
            constructor <;> rw [ abs_le ] <;> constructor <;> cases max_cases ( 0 : ℝ ) ( 1 - |x - y| / B ) <;> cases max_cases ( 0 : ℝ ) ( 1 - |x + y| / B ) <;> nlinarith [ abs_nonneg ( x - y ), abs_nonneg ( x + y ), div_nonneg ( abs_nonneg ( x - y ) ) hB.le, div_nonneg ( abs_nonneg ( x + y ) ) hB.le ];
          rw [ abs_le ];
          constructor <;> nlinarith [ abs_le.mp h_bound.1, abs_le.mp h_bound.2, show 0 ≤ HeatKernel t ( x - y ) by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ), show 0 ≤ HeatKernel t ( x + y ) by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ), div_mul_cancel₀ ( |x - y| ) hB.ne', div_mul_cancel₀ ( |x + y| ) hB.ne', div_add_div_same ( |x - y| ) ( |x + y| ) B ];
        -- Choose $B$ large enough such that $(|x - y| + |x + y|) / B * (HeatKernel t (x - y) + HeatKernel t (x + y)) < \epsilon / (\sum_{y \in s} w(y) + 1)$ for all $x \in [-K, K]$ and $y \in s$.
        obtain ⟨B, hB⟩ : ∃ B > 0, ∀ x ∈ Set.Icc (-K) K, ∀ y ∈ s, (|x - y| + |x + y|) / B * (HeatKernel t (x - y) + HeatKernel t (x + y)) < ε / (∑ y ∈ s, w y + 1) := by
          -- Since $|x - y| + |x + y|$ is bounded on the compact set $[-K, K] \times s$, we can find a maximum value $M$.
          obtain ⟨M, hM⟩ : ∃ M > 0, ∀ x ∈ Set.Icc (-K) K, ∀ y ∈ s, (|x - y| + |x + y|) * (HeatKernel t (x - y) + HeatKernel t (x + y)) ≤ M := by
            have h_compact : IsCompact (Set.image (fun p : ℝ × ℝ => (|p.1 - p.2| + |p.1 + p.2|) * (HeatKernel t (p.1 - p.2) + HeatKernel t (p.1 + p.2))) (Set.Icc (-K) K ×ˢ s)) := by
              refine' IsCompact.image _ _;
              · exact isCompact_Icc.prod ( s.finite_toSet.isCompact );
              · apply_rules [ Continuous.mul, Continuous.add, Continuous.abs, continuous_const, continuous_fst, continuous_snd ];
                · fun_prop;
                · fun_prop;
                · fun_prop;
            obtain ⟨ M, hM ⟩ := h_compact.bddAbove;
            exact ⟨ Max.max M 1, by positivity, fun x hx y hy => le_trans ( hM ⟨ ( x, y ), ⟨ hx, hy ⟩, rfl ⟩ ) ( le_max_left _ _ ) ⟩;
          field_simp;
          exact ⟨ M / ( ε / ( ∑ y ∈ s, w y + 1 ) ) + 1, by exact add_pos_of_nonneg_of_pos ( div_nonneg hM.1.le ( div_nonneg hε.le ( add_nonneg ( Finset.sum_nonneg fun _ _ => hw_nonneg _ ‹_› ) zero_le_one ) ) ) zero_lt_one, fun x hx y hy => by rw [ div_lt_iff₀ ] <;> nlinarith [ hM.2 x hx y hy, show 0 < ε / ( ∑ y ∈ s, w y + 1 ) from div_pos hε ( add_pos_of_nonneg_of_pos ( Finset.sum_nonneg fun _ _ => hw_nonneg _ ‹_› ) zero_lt_one ), div_mul_cancel₀ M ( ne_of_gt ( div_pos hε ( add_pos_of_nonneg_of_pos ( Finset.sum_nonneg fun _ _ => hw_nonneg _ ‹_› ) zero_lt_one ) ) ) ] ⟩;
        exact ⟨ B, hB.1, fun x hx y hy => lt_of_le_of_lt ( h_bound B hB.1 x hx y hy ) ( hB.2 x hx y hy ) ⟩;
      use B, hB.left; intros x hx; rw [ ← Finset.sum_add_distrib ] ; rw [ ← Finset.sum_sub_distrib ] ; refine' lt_of_le_of_lt ( Finset.abs_sum_le_sum_abs _ _ ) _ ; aesop;
      -- Apply the bound from `right` to each term in the sum.
      have h_term_bound : ∀ y ∈ s, |w y * Atom B t y x - (w y * HeatKernel t (x - y) + w y * HeatKernel t (x + y))| ≤ w y * (ε / (∑ y ∈ s, w y + 1)) := by
        intro y hy; specialize right x left_1 right_1 y hy; rw [ show Atom B t y x = FejerKernel B ( x - y ) * HeatKernel t ( x - y ) + FejerKernel B ( x + y ) * HeatKernel t ( x + y ) by rfl ] ; rw [ abs_le ] ; constructor <;> nlinarith [ abs_lt.mp right, hw_nonneg y hy ] ;
      refine' lt_of_le_of_lt ( Finset.sum_le_sum h_term_bound ) _;
      rw [ ← Finset.sum_mul _ _ _, mul_div, div_lt_iff₀ ] <;> nlinarith [ show 0 ≤ ∑ y ∈ s, w y from Finset.sum_nonneg hw_nonneg ]

/-
sum_atoms_in_cone lemma.
-/
lemma sum_atoms_in_cone (K : ℝ) (s : Finset ℝ) (w : ℝ → ℝ) (hw : ∀ y ∈ s, 0 ≤ w y)
    (B : ℝ) (hB : B > 0) (t : ℝ) (ht : t > 0) (hs : ∀ y ∈ s, y ∈ Set.Icc (-K) K)
    (h_sum_pos : ∑ y ∈ s, w y > 0) :
  (fun x => ∑ y ∈ s, w y * Atom B t y x) ∈ AtomCone_K K := by
    -- Since each Atom B t y is in AtomSet K, their sum with non-negative coefficients is in the convex hull of AtomSet K.
    have h_convex : ∑ y ∈ s, (w y / ∑ y ∈ s, w y) • Atom B t y ∈ convexHull ℝ (AtomSet K) := by
      rw [ convexHull_eq ];
      refine' ⟨ _, s, fun y => w y / ∑ y ∈ s, w y, fun y => Atom B t y, _, _, _, _ ⟩ <;> simp_all +decide [ Finset.centerMass ];
      · exact fun y hy => div_nonneg ( hw y hy ) h_sum_pos.le;
      · rw [ ← Finset.sum_div, div_self h_sum_pos.ne' ];
      · exact fun y hy => ⟨ B, hB, t, ht, y, hs y hy, rfl ⟩;
      · rw [ ← Finset.sum_div _ _ _, div_self h_sum_pos.ne', inv_one, one_smul ];
    simp_all +decide [ div_eq_inv_mul, Finset.mul_sum _ _ _ ];
    convert ( Convex.mem_toCone _ ).mpr _ using 1;
    refine' ⟨ ∑ y ∈ s, w y, h_sum_pos, _, h_convex, _ ⟩ ; ext x ; simp +decide [ Finset.mul_sum _ _ _, mul_assoc, mul_left_comm, mul_comm, h_sum_pos.ne' ]

/-
exists_even_compact_extension lemma.
-/
lemma exists_even_compact_extension (K : ℝ) (hK : K > 0) (Φ : ℝ → ℝ)
    (hΦ_cont : ContinuousOn Φ (Set.Icc (-K) K))
    (hΦ_even : Even Φ) :
  ∃ Ψ : ℝ → ℝ, Continuous Ψ ∧ HasCompactSupport Ψ ∧ Even Ψ ∧ ∀ x ∈ Set.Icc (-K) K, Ψ x = Φ x := by
    -- By the Tietze extension theorem, we can extend Φ to a continuous function on the entire real line.
    obtain ⟨Ψ₀, hΨ₀_cont, hΨ₀_ext⟩ : ∃ Ψ₀ : ℝ → ℝ, Continuous Ψ₀ ∧ ∀ x ∈ Set.Icc (-K) K, Ψ₀ x = Φ x := by
      have := @ContinuousMap.exists_extension;
      specialize this ( show Topology.IsClosedEmbedding ( fun x : Set.Icc ( -K ) K => x.val ) from ?_ ) ( ContinuousMap.mk ( fun x => Φ x ) <| by
                          exact continuousOn_iff_continuous_restrict.mp hΦ_cont )
      generalize_proofs at *;
      all_goals generalize_proofs at *;
      · exact?;
      · obtain ⟨ g, hg ⟩ := this; exact ⟨ g, g.continuous, fun x hx => by simpa using congr_arg ( fun f => f ⟨ x, hx ⟩ ) hg ⟩ ;
    -- Let's define the function Ψ as follows: Ψ(x) = Ψ₀(x) * ψ(x), where ψ is a smooth function that is 1 on [-K, K] and 0 outside [-K-1, K+1].
    obtain ⟨ψ, hψ_cont, hψ_support⟩ : ∃ ψ : ℝ → ℝ, Continuous ψ ∧ HasCompactSupport ψ ∧ (∀ x ∈ Set.Icc (-K) K, ψ x = 1) ∧ (∀ x, ψ (-x) = ψ x) := by
      -- Define the function ψ that is 1 on [-K, K] and 0 outside [-K-1, K+1].
      obtain ⟨ψ, hψ_cont, hψ_support⟩ : ∃ ψ : ℝ → ℝ, Continuous ψ ∧ (∀ x, 0 ≤ ψ x) ∧ (∀ x, ψ (-x) = ψ x) ∧ (∀ x ∈ Set.Icc (-K) K, ψ x = 1) ∧ (∀ x, |x| > K + 1 → ψ x = 0) := by
        -- Define the bump function ψ.
        use fun x => max 0 (1 - max 0 ((|x| - K) / (1)));
        aesop;
        · fun_prop;
        · cases max_cases ( 0 : ℝ ) ( |x| - K ) <;> cases max_cases ( 0 : ℝ ) ( 1 - Max.max 0 ( |x| - K ) ) <;> cases abs_cases x <;> linarith;
        · exact Or.inr ( by linarith );
      refine' ⟨ ψ, hψ_cont, _, hψ_support.2.2.1, hψ_support.2.1 ⟩;
      rw [ hasCompactSupport_iff_eventuallyEq ];
      norm_num [ Filter.EventuallyEq ];
      exact ⟨ ⟨ -K - 2, fun x hx => hψ_support.2.2.2 x <| by cases abs_cases x <;> linarith ⟩, ⟨ K + 2, fun x hx => hψ_support.2.2.2 x <| by cases abs_cases x <;> linarith ⟩ ⟩;
    refine' ⟨ fun x => Ψ₀ x * ψ x, hΨ₀_cont.mul hψ_cont, _, _, _ ⟩ <;> aesop;
    · rw [ hasCompactSupport_iff_eventuallyEq ] at *;
      filter_upwards [ left ] with x hx using mul_eq_zero_of_right _ hx;
    · use fun x => Ψ₀ x * ψ x / 2; ext x; ring;
      norm_num ; ring

/-
sSup_lt_of_compact_image_lt lemma.
-/
lemma sSup_lt_of_compact_image_lt (K : Set ℝ) (hK : IsCompact K) (hK_nonempty : K.Nonempty) (f : ℝ → ℝ) (hf_cont : ContinuousOn f K) (ε : ℝ) (h : ∀ x ∈ K, f x < ε) : sSup (f '' K) < ε := by
  have h_sup_lt_ε : ∃ x ∈ K, ∀ y ∈ K, f y ≤ f x := by
    exact ( IsCompact.exists_isMaxOn hK hK_nonempty hf_cont ) |> fun ⟨ x, hx₁, hx₂ ⟩ => ⟨ x, hx₁, fun y hy => hx₂ hy ⟩;
  exact lt_of_le_of_lt ( csSup_le ( Set.Nonempty.image _ hK_nonempty ) ( Set.forall_mem_image.2 h_sup_lt_ε.choose_spec.2 ) ) ( h _ h_sup_lt_ε.choose_spec.1 )

/-
convolution_eq_Icc_of_compact_support lemma.
-/
lemma convolution_eq_Icc_of_compact_support (f g : ℝ → ℝ) (hf : HasCompactSupport f) :
  ∃ L > 0, ∀ x, real_convolution f g x = ∫ y in Set.Icc (-L) L, f y * g (x - y) := by
    -- Since $f$ has compact support, there exists $L > 0$ such that $f(x) = 0$ for all $|x| > L$.
    obtain ⟨L, hL_pos, hL⟩ : ∃ L > 0, ∀ x, |x| > L → f x = 0 := by
      have := hf.exists_pos_le_norm; aesop;
      exact ⟨ w, left, fun x hx => right x hx.le ⟩;
    refine' ⟨ L + 1, by linarith, fun x => _ ⟩;
    rw [ MeasureTheory.setIntegral_eq_integral_of_forall_compl_eq_zero ];
    · rfl;
    · exact fun y hy => by rw [ hL y ( by contrapose! hy; constructor <;> cases abs_cases y <;> linarith ), MulZeroClass.zero_mul ] ;

lemma HeatKernel_approx_identity_uniform (f : ℝ → ℝ) (hf_cont : Continuous f)
    (hf_supp : HasCompactSupport f) (ε : ℝ) (hε : ε > 0) :
  ∃ t₀ > 0, ∀ t ∈ Set.Ioo 0 t₀, ∀ x, |real_convolution f (HeatKernel t) x - f x| < ε := by
    -- Since $f$ is continuous and has compact support, it is uniformly continuous. Given $\epsilon > 0$, there exists $\delta > 0$ such that $|x - y| < \delta \implies |f(x) - f(y)| < \epsilon/2$.
    obtain ⟨δ, hδ_pos, hδ⟩ : ∃ δ > 0, ∀ x y, abs (x - y) < δ → abs (f x - f y) < ε / 2 := by
      have h_unif_cont : UniformContinuous f := by
        exact?
      generalize_proofs at *; exact Metric.uniformContinuous_iff.mp h_unif_cont (ε / 2) (half_pos hε) ;
    -- Let $M = \sup |f(x)|$.
    obtain ⟨M, hM⟩ : ∃ M, ∀ x, abs (f x) ≤ M := by
      have := hf_supp.exists_bound_of_continuous hf_cont; aesop;
    generalize_proofs at *; -- This is to make the proof a bit more robust against changes in the local context. It's not strictly necessary here, but it's good practice.;
    -- Using the uniform continuity and boundedness, we can bound the difference.
    have h_bound : ∀ t > 0, ∀ x, abs (real_convolution f (HeatKernel t) x - f x) ≤ (ε / 2) * (∫ y, HeatKernel t y) + 2 * M * (∫ y in {y | abs y ≥ δ}, HeatKernel t y) := by
      -- Using the uniform continuity and boundedness, we can bound the difference as follows:
      intro t ht x
      have h_split : abs (real_convolution f (HeatKernel t) x - f x) ≤ ∫ y, abs (f (x - y) - f x) * HeatKernel t y := by
        have h_split : real_convolution f (HeatKernel t) x - f x = ∫ y, (f (x - y) - f x) * HeatKernel t y := by
          simp +decide [ sub_mul, real_convolution ];
          rw [ MeasureTheory.integral_sub ];
          · rw [ ← MeasureTheory.integral_sub_left_eq_self ];
            rw [ MeasureTheory.integral_const_mul ] ; norm_num [ HeatKernel_integral t ht ] ; ring;
          · refine' MeasureTheory.Integrable.mono' _ _ _;
            refine' fun y => M * HeatKernel t y;
            · have h_integrable : MeasureTheory.Integrable (fun y => HeatKernel t y) MeasureTheory.MeasureSpace.volume := by
                have h_integrable : ∫ y, HeatKernel t y = 1 := by
                  exact?
                generalize_proofs at *; -- This is to make the proof a bit more robust against changes in the local context. It's not strictly necessary here, but it's good practice.;
                exact MeasureTheory.integrable_of_integral_eq_one h_integrable
              generalize_proofs at *; -- This is to make the proof a bit more robust against changes in the local context. It's not strictly necessary here, but it's good practice.;
              exact h_integrable.const_mul M;
            · exact Continuous.aestronglyMeasurable ( by exact Continuous.mul ( hf_cont.comp ( continuous_const.sub continuous_id' ) ) ( by exact Continuous.mul ( continuous_const ) ( Real.continuous_exp.comp ( by continuity ) ) ) );
            · filter_upwards [ ] with y using by rw [ Real.norm_eq_abs, abs_mul, abs_of_nonneg ( show 0 ≤ HeatKernel t y from by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ] ; exact mul_le_mul_of_nonneg_right ( hM _ ) ( show 0 ≤ HeatKernel t y from by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ;
          · refine' MeasureTheory.Integrable.const_mul _ _;
            exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht )
        generalize_proofs at *; -- This is to make the proof a bit more robust against changes in the local context. It's not strictly necessary here, but it's good practice.;
        rw [ h_split ];
        convert MeasureTheory.norm_integral_le_integral_norm ( _ : ℝ → ℝ ) using 1 ; norm_num [ abs_mul, abs_of_nonneg, Real.exp_nonneg, ht.le ];
        exact congr_arg _ ( funext fun y => by rw [ abs_of_nonneg ( show 0 ≤ HeatKernel t y from mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ] )
      generalize_proofs at *; -- This is to make the proof a bit more robust against changes in the local context. It's not strictly necessary here, but it's good practice.;
      have h_split : abs (real_convolution f (HeatKernel t) x - f x) ≤ (∫ y in {y | abs y < δ}, abs (f (x - y) - f x) * HeatKernel t y) + (∫ y in {y | abs y ≥ δ}, abs (f (x - y) - f x) * HeatKernel t y) := by
        rw [ ← MeasureTheory.setIntegral_union ] <;> norm_num [ Set.compl_setOf ] ; aesop;
        · convert h_split using 1 ; rw [ show { y : ℝ | |y| < δ } ∪ { y : ℝ | δ ≤ |y| } = Set.univ by ext y; by_cases hy : |y| < δ <;> aesop ] ; norm_num;
        · exact Set.disjoint_left.mpr fun y hy₁ hy₂ => hy₁.out.not_le hy₂.out;
        · exact measurableSet_Ici.mem.comp measurable_norm;
        · refine' MeasureTheory.Integrable.integrableOn _;
          refine' MeasureTheory.Integrable.mono' _ _ _;
          refine' fun y => ( 2 * M ) * HeatKernel t y
          all_goals generalize_proofs at *;
          · refine' MeasureTheory.Integrable.const_mul _ _;
            exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht );
          · exact MeasureTheory.AEStronglyMeasurable.mul ( Continuous.aestronglyMeasurable ( by continuity ) ) ( Continuous.aestronglyMeasurable ( by exact Continuous.mul ( Continuous.rpow ( by continuity ) ( by continuity ) <| by continuity ) <| Real.continuous_exp.comp <| by continuity ) );
          · filter_upwards [ ] with y using by rw [ Real.norm_of_nonneg ( mul_nonneg ( abs_nonneg _ ) ( by unfold HeatKernel; positivity ) ) ] ; exact mul_le_mul_of_nonneg_right ( abs_le.mpr ⟨ by linarith [ abs_le.mp ( hM ( x - y ) ), abs_le.mp ( hM x ) ], by linarith [ abs_le.mp ( hM ( x - y ) ), abs_le.mp ( hM x ) ] ⟩ ) ( by unfold HeatKernel; positivity ) ;
        · refine' MeasureTheory.Integrable.integrableOn _;
          refine' MeasureTheory.Integrable.mono' _ _ _;
          refine' fun y => ( 2 * M ) * HeatKernel t y
          all_goals generalize_proofs at *;
          · refine' MeasureTheory.Integrable.const_mul _ _;
            exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht );
          · exact MeasureTheory.AEStronglyMeasurable.mul ( Continuous.aestronglyMeasurable ( by continuity ) ) ( Continuous.aestronglyMeasurable ( by exact Continuous.mul ( Continuous.rpow ( by continuity ) ( by continuity ) <| by continuity ) <| Real.continuous_exp.comp <| by continuity ) );
          · filter_upwards [ ] with y using by rw [ Real.norm_of_nonneg ( mul_nonneg ( abs_nonneg _ ) ( by unfold HeatKernel; positivity ) ) ] ; exact mul_le_mul_of_nonneg_right ( abs_le.mpr ⟨ by linarith [ abs_le.mp ( hM ( x - y ) ), abs_le.mp ( hM x ) ], by linarith [ abs_le.mp ( hM ( x - y ) ), abs_le.mp ( hM x ) ] ⟩ ) ( by unfold HeatKernel; positivity ) ;
      generalize_proofs at *; -- This is to make the proof a bit more robust against changes in the local context. It's not strictly necessary here, but it's good practice.;
      have h_bound : abs (real_convolution f (HeatKernel t) x - f x) ≤ (∫ y in {y | abs y < δ}, (ε / 2) * HeatKernel t y) + (∫ y in {y | abs y ≥ δ}, 2 * M * HeatKernel t y) := by
        refine' le_trans h_split ( add_le_add _ _ );
        · refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
          · exact Filter.Eventually.of_forall fun y => mul_nonneg ( abs_nonneg _ ) ( by unfold HeatKernel; positivity );
          · refine' MeasureTheory.Integrable.const_mul _ _;
            refine' MeasureTheory.Integrable.integrableOn _;
            exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht );
          · filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_lt ( measurable_norm ) measurable_const ] with y hy using mul_le_mul_of_nonneg_right ( le_of_lt <| hδ _ _ <| by simpa using hy ) <| by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) <| Real.exp_nonneg _;
        · refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
          · exact Filter.Eventually.of_forall fun y => mul_nonneg ( abs_nonneg _ ) ( by unfold HeatKernel; positivity );
          · refine' MeasureTheory.Integrable.const_mul _ _;
            refine' MeasureTheory.Integrable.integrableOn _;
            exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht );
          · filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_Ici.preimage <| measurable_norm ] with y hy using mul_le_mul_of_nonneg_right ( by cases abs_cases ( f ( x - y ) - f x ) <;> linarith [ abs_le.mp ( hM ( x - y ) ), abs_le.mp ( hM x ) ] ) <| by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) <| Real.exp_nonneg _;
      generalize_proofs at *; -- This is to make the proof a bit more robust against changes in the local context. It's not strictly necessary here, but it's good practice.;
      have h_bound : abs (real_convolution f (HeatKernel t) x - f x) ≤ (ε / 2) * (∫ y in {y | abs y < δ}, HeatKernel t y) + 2 * M * (∫ y in {y | abs y ≥ δ}, HeatKernel t y) := by
        simpa only [ mul_assoc, MeasureTheory.integral_const_mul ] using h_bound
      generalize_proofs at *; -- This is to make the proof a bit more robust against changes in the local context. It's not strictly necessary here, but it's good practice.;
      refine le_trans h_bound ?_;
      gcongr;
      · exact Filter.Eventually.of_forall fun x => mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ );
      · exact MeasureTheory.Integrable.const_mul ( by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) ) _;
      · exact MeasureTheory.Measure.restrict_le_self
    generalize_proofs at *; -- This is to make the proof a bit more robust against changes in the local context. It's not strictly necessary here, but it's good practice.;
    -- Using the mass concentration property of the heat kernel, we can bound the second term.
    have h_mass_concentration : Filter.Tendsto (fun t => ∫ y in {y | abs y ≥ δ}, HeatKernel t y) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
      have h_mass_concentration : Filter.Tendsto (fun t => ∫ y in {y | abs y > δ}, HeatKernel t y) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
        exact?
      generalize_proofs at *; -- This is to make the proof a bit more robust against changes in the local context. It's not strictly necessary here, but it's good practice.;
      convert h_mass_concentration using 2;
      rw [ MeasureTheory.setIntegral_congr_set ] ; rw [ MeasureTheory.ae_eq_set ] ; aesop;
      · rw [ show { y : ℝ | δ ≤ |y| } \ { y : ℝ | δ < |y| } = { y : ℝ | |y| = δ } by ext; aesop ; linarith ] ; rw [ show { y : ℝ | |y| = δ } = { δ, -δ } by ext; norm_num [ abs_eq ( le_of_lt hδ_pos ) ] ] ; rw [ Set.insert_eq, MeasureTheory.measure_union ] <;> norm_num [ hδ_pos.ne' ] ;
        linarith;
      · rw [ show { y : ℝ | δ < |y| } \ { y : ℝ | δ ≤ |y| } = ∅ by ext; aesop ; linarith ] ; norm_num
    generalize_proofs at *; -- This is to make the proof a bit more robust against changes in the local context. It's not strictly necessary here, but it's good practice.;
    -- Using the fact that the integral of the heat kernel is 1, we can simplify the bound.
    have h_simplified_bound : ∀ t > 0, ∀ x, abs (real_convolution f (HeatKernel t) x - f x) ≤ ε / 2 + 2 * M * (∫ y in {y | abs y ≥ δ}, HeatKernel t y) := by
      exact fun t ht x => le_trans ( h_bound t ht x ) ( by rw [ show ∫ y : ℝ, HeatKernel t y = 1 from by { exact? } ] ; norm_num ) ;
    generalize_proofs at *; -- This is to make the proof a bit more robust against changes in the local context. It's not strictly necessary here, but it's good practice.;
    have := h_mass_concentration.eventually ( gt_mem_nhds <| show 0 < ε / 2 / ( 2 * M + 1 ) from div_pos ( half_pos hε ) <| by linarith [ abs_le.mp <| hM 0 ] ) ; aesop
    generalize_proofs at *; -- This is to make the proof a bit more robust against changes in the local context. It's not strictly necessary here, but it's good practice.;
    rcases ( Metric.mem_nhdsWithin_iff.mp <| this ) with ⟨ t₀, ht₀_pos, ht₀ ⟩ ; use t₀ ; aesop;
    exact lt_of_le_of_lt ( h_simplified_bound t a x ) ( by have := ht₀ ⟨ mem_ball_zero_iff.mpr ( abs_lt.mpr ⟨ by linarith, by linarith ⟩ ), a ⟩ ; rw [ Set.mem_setOf_eq ] at this; rw [ lt_div_iff₀ ] at this <;> nlinarith [ abs_le.mp ( hM 0 ) ] )

/-
HeatKernel is integrable.
-/
lemma HeatKernel_integrable (t : ℝ) (ht : t > 0) :
  MeasureTheory.Integrable (HeatKernel t) MeasureTheory.MeasureSpace.volume := by
  refine' MeasureTheory.integrable_of_integral_eq_one (HeatKernel_integral t ht)

#check HeatKernel_approx_identity_uniform