/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 2e3b3bf8-c308-4d27-af09-2c46e8569df5

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

noncomputable def digamma (z : ℂ) : ℂ := (deriv Complex.Gamma z) / (Complex.Gamma z)

noncomputable def a (ξ : ℝ) : ℝ := Real.log Real.pi - (digamma (1/4 + Complex.I * Real.pi * (ξ : ℂ))).re

noncomputable def A_0 (B t_sym : ℝ) : ℝ :=
  ∫ ξ in -B..B, a ξ * (max 0 (1 - |ξ| / B)) * Real.exp (-4 * Real.pi^2 * t_sym * ξ^2)

noncomputable def L_int (B t_sym : ℝ) : ℝ :=
  ∫ ξ in -B..B, |a ξ| * |ξ| * (max 0 (1 - |ξ| / B)) * Real.exp (-4 * Real.pi^2 * t_sym * ξ^2)

noncomputable def A_star (B_min t_sym : ℝ) : ℝ :=
  sInf { y | ∃ B ≥ B_min, y = A_0 B t_sym }

noncomputable def L_star (B_min t_sym : ℝ) : ℝ :=
  sSup { y | ∃ B ≥ B_min, y = L_int B t_sym }

noncomputable def c_star (B_min t_sym : ℝ) : ℝ :=
  A_star B_min t_sym - Real.pi * L_star B_min t_sym

noncomputable def t_sym_val : ℝ := 3 / 50

/-
The digamma function satisfies the recurrence ψ(z+1) = ψ(z) + 1/z.
-/
theorem digamma_add_one (z : ℂ) (hz : z ≠ 0) (hG : Complex.Gamma z ≠ 0) :
    digamma (z + 1) = digamma z + 1 / z := by
  -- Use the functional equation of the Gamma function: Γ(z+1) = zΓ(z).
  have h_gamma : Complex.Gamma (z + 1) = z * Complex.Gamma z := by
    exact Complex.Gamma_add_one z hz;
  -- Use the functional equation of the Gamma function: Γ'(z+1) = Γ(z) + zΓ'(z).
  have h_gamma_deriv : deriv Complex.Gamma (z + 1) = Complex.Gamma z + z * deriv Complex.Gamma z := by
    have h_gamma_deriv : deriv (fun w => Complex.Gamma (w + 1)) z = deriv Complex.Gamma (z + 1) := by
      exact?;
    rw [ ← h_gamma_deriv ];
    convert HasDerivAt.deriv ( HasDerivAt.congr_of_eventuallyEq ( HasDerivAt.mul ( hasDerivAt_id z ) ( Complex.differentiableAt_Gamma _ _ |> DifferentiableAt.hasDerivAt ) ) <| Filter.eventuallyEq_of_mem ( isOpen_ne.mem_nhds hz ) fun x hx => Complex.Gamma_add_one x hx ) using 1;
    · norm_num;
    · intro m hm; simp_all +decide [ Complex.Gamma_eq_zero_iff ] ;
  unfold digamma;
  rw [ h_gamma, h_gamma_deriv, div_add_div, div_eq_div_iff ] <;> ring <;> aesop

/-
The digamma function satisfies the reflection formula ψ(1-z) - ψ(z) = π cot(πz).
-/
theorem digamma_one_sub (z : ℂ) (hz : ∀ n : ℤ, z ≠ n) :
    digamma (1 - z) - digamma z = Real.pi * Complex.cot (Real.pi * z) := by
  have h_reflection : deriv (fun z => Complex.Gamma z * Complex.Gamma (1 - z)) z = Complex.Gamma z * deriv Complex.Gamma (1 - z) * (-1) + deriv Complex.Gamma z * Complex.Gamma (1 - z) := by
    convert HasDerivAt.deriv ( HasDerivAt.mul ( Complex.differentiableAt_Gamma _ _ |> DifferentiableAt.hasDerivAt ) ( HasDerivAt.comp z ( Complex.differentiableAt_Gamma _ _ |> DifferentiableAt.hasDerivAt ) ( hasDerivAt_id z |> HasDerivAt.const_sub 1 ) ) ) using 1 ; ring;
    · rfl;
    · exact fun m => mod_cast hz ( -m );
    · exact fun m hm => hz ( m + 1 ) ( by norm_num [ Complex.ext_iff ] at *; constructor <;> linarith );
  have h_reflection : deriv (fun z => Complex.Gamma z * Complex.Gamma (1 - z)) z = deriv (fun z => Real.pi / Complex.sin (Real.pi * z)) z := by
    refine' Filter.EventuallyEq.deriv_eq _;
    filter_upwards [ IsOpen.mem_nhds ( isOpen_compl_singleton.preimage continuous_id' ) ( show z ≠ ↑0 by simpa using hz 0 ) ] with x hx;
    rw [ Complex.Gamma_mul_Gamma_one_sub ];
  have h_reflection : deriv (fun z => Real.pi / Complex.sin (Real.pi * z)) z = -Real.pi^2 * Complex.cos (Real.pi * z) / Complex.sin (Real.pi * z)^2 := by
    convert HasDerivAt.deriv ( HasDerivAt.div ( hasDerivAt_const _ _ ) ( HasDerivAt.comp z ( Complex.hasDerivAt_sin _ ) ( HasDerivAt.const_mul _ ( hasDerivAt_id z ) ) ) _ ) using 1 <;> norm_num [ mul_comm ] ; ring;
    rw [ Complex.sin_eq_zero_iff ] ; intro h; obtain ⟨ n, hn ⟩ := h; exact hz n <| by { exact mul_left_cancel₀ ( Complex.ofReal_ne_zero.mpr Real.pi_ne_zero ) <| by linear_combination' hn } ;
  unfold digamma;
  rw [ div_sub_div ];
  · rw [ div_eq_iff ];
    · simp_all +decide [ Complex.cot, mul_assoc, mul_comm, mul_left_comm ];
      have h_gamma_reflection : Complex.Gamma (1 - z) * Complex.Gamma z = Real.pi / Complex.sin (Real.pi * z) := by
        rw [ mul_comm, Complex.Gamma_mul_Gamma_one_sub ];
      simp_all +decide [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, sq ];
      linear_combination -h_reflection - h_gamma_reflection * Real.pi * Complex.cos ( z * Real.pi ) * ( Complex.sin ( z * Real.pi ) ) ⁻¹;
    · simp_all +decide [ Complex.Gamma_eq_zero_iff ];
      exact ⟨ fun n => by intro h; exact hz ( 1 + n ) ( by push_cast; linear_combination' -h ), fun n => by intro h; exact hz ( -n ) ( by push_cast; linear_combination' h ) ⟩;
  · norm_num +zetaDelta at *;
    rw [ Complex.Gamma_eq_zero_iff ];
    exact fun ⟨ m, hm ⟩ => hz ( 1 + m ) ( by push_cast; linear_combination' -hm );
  · simp +zetaDelta at *;
    rw [ Complex.Gamma_eq_zero_iff ];
    exact fun ⟨ m, hm ⟩ => hz ( -m ) ( by push_cast; linear_combination' hm )

/-
The value of the digamma function at 1/2 is -γ - 2 log 2.
-/
theorem digamma_one_half : digamma (1/2) = -Real.eulerMascheroniConstant - 2 * Real.log 2 := by
  -- Use the known value of the digamma function at $z = 1/2$.
  have h_digamma_half : deriv Complex.Gamma (1 / 2) = -2 * Real.log 2 * Complex.Gamma (1 / 2) - Real.eulerMascheroniConstant * Complex.Gamma (1 / 2) := by
    have := @Complex.hasDerivAt_Gamma_one_half;
    convert this.deriv using 1 ; norm_num [ Complex.Gamma_one_half_eq ] ; ring;
    norm_num [ Real.sqrt_eq_rpow, Complex.ofReal_cpow, Real.pi_pos.le ] ; ring;
  unfold digamma;
  rw [ h_digamma_half, div_eq_iff ] <;> ring ; norm_num [ Complex.Gamma_one_half_eq ]

/-
The digamma function satisfies the duplication formula ψ(2z) = log 2 + (ψ(z) + ψ(z+1/2))/2.
-/
theorem digamma_two_mul (z : ℂ) (hz : z ≠ 0) (hG : Complex.Gamma (2 * z) ≠ 0) :
    digamma (2 * z) = Real.log 2 + (digamma z + digamma (z + 1 / 2)) / 2 := by
  -- Using the duplication formula for the Gamma function, we have Γ(2z) = (2^(2z-1) / sqrt(π)) * Γ(z) * Γ(z + 1/2).
  have h_duplication : Complex.Gamma (2 * z) = (2^(2 * z - 1) / Real.sqrt Real.pi) * Complex.Gamma z * Complex.Gamma (z + 1 / 2) := by
    have := @Complex.Gamma_mul_Gamma_add_half z;
    simp_all +decide [ mul_assoc, Complex.cpow_sub ];
    field_simp [mul_comm, mul_assoc, mul_left_comm];
  -- Taking the derivative of both sides of the duplication formula with respect to $z$, we get:
  have h_deriv : deriv (fun z => Complex.Gamma (2 * z)) z = deriv (fun z => (2^(2 * z - 1) / Real.sqrt Real.pi) * Complex.Gamma z * Complex.Gamma (z + 1 / 2)) z := by
    refine' Filter.EventuallyEq.deriv_eq _;
    have h_neighborhood : ∀ᶠ z in nhds z, Complex.Gamma (2 * z) ≠ 0 := by
      refine' ContinuousAt.eventually_ne _ hG;
      refine' Complex.differentiableAt_Gamma _ _ |> DifferentiableAt.continuousAt |> ContinuousAt.comp <| continuousAt_const.mul continuousAt_id;
      intro m hm; simp_all +decide [ Complex.Gamma_eq_zero_iff ] ;
    filter_upwards [ h_neighborhood ] with w hw;
    have := @Complex.Gamma_mul_Gamma_add_half w;
    simp_all +decide [ Complex.cpow_sub, mul_assoc, mul_comm, mul_left_comm, div_eq_mul_inv ];
    field_simp [mul_comm, mul_assoc, mul_left_comm] at *;
    linear_combination' this.symm;
  -- Using the chain rule and the fact that the derivative of $\Gamma(z)$ is $\Gamma'(z)$, we can compute the derivatives on both sides.
  have h_deriv_lhs : deriv (fun z => Complex.Gamma (2 * z)) z = 2 * deriv Complex.Gamma (2 * z) := by
    convert HasDerivAt.deriv ( HasDerivAt.comp z ( Complex.differentiableAt_Gamma _ _ |> DifferentiableAt.hasDerivAt ) ( HasDerivAt.const_mul 2 ( hasDerivAt_id z ) ) ) using 1 <;> norm_num;
    · ring;
    · intro m hm; simp_all +decide [ Complex.Gamma_eq_zero_iff ] ;
  have h_deriv_rhs : deriv (fun z => (2^(2 * z - 1) / Real.sqrt Real.pi) * Complex.Gamma z * Complex.Gamma (z + 1 / 2)) z =
    (2^(2 * z - 1) / Real.sqrt Real.pi) * (deriv Complex.Gamma z * Complex.Gamma (z + 1 / 2) + Complex.Gamma z * deriv Complex.Gamma (z + 1 / 2)) +
    (2^(2 * z - 1) * 2 * Real.log 2 / Real.sqrt Real.pi) * Complex.Gamma z * Complex.Gamma (z + 1 / 2) := by
      convert HasDerivAt.deriv ( HasDerivAt.mul ( HasDerivAt.mul ( HasDerivAt.div_const ( HasDerivAt.cpow ( hasDerivAt_const _ _ ) ( HasDerivAt.sub ( HasDerivAt.const_mul _ ( hasDerivAt_id' z ) ) ( hasDerivAt_const _ _ ) ) _ ) _ ) ( Complex.differentiableAt_Gamma _ _ |> DifferentiableAt.hasDerivAt ) ) ( Complex.differentiableAt_Gamma _ _ |> DifferentiableAt.hasDerivAt |> HasDerivAt.comp _ <| HasDerivAt.add ( hasDerivAt_id' z ) <| hasDerivAt_const _ _ ) ) using 1 <;> norm_num;
      · ring;
      · intro m hm; simp_all +decide [ Complex.Gamma_eq_zero_iff ] ;
        exact hG ( 2 * m ) ( by push_cast; ring );
      · intro m hm; simp_all +decide [ Complex.Gamma_eq_zero_iff ];
  unfold digamma;
  grind

/-
The value of the digamma function at 1/4 is -γ - π/2 - 3 log 2.
-/
theorem digamma_one_fourth : digamma (1/4) = -Real.eulerMascheroniConstant - Real.pi / 2 - 3 * Real.log 2 := by
  have := @digamma_two_mul ( 1 / 4 ) ?_ ?_ <;> norm_num at *;
  · -- Use the reflection formula with z=1/4: ψ(3/4) - ψ(1/4) = π cot(π/4) = π.
    have h_reflection : digamma (3 / 4) - digamma (1 / 4) = Real.pi := by
      have h_reflection : digamma (1 - 1 / 4) - digamma (1 / 4) = Real.pi * Complex.cot (Real.pi * (1 / 4)) := by
        convert digamma_one_sub ( 1 / 4 ) _ using 1 ; norm_num;
        rintro ⟨ _ | _ ⟩ <;> norm_num [ Complex.ext_iff ] <;> linarith;
      convert h_reflection using 1 <;> norm_num [ Complex.cot ];
      field_simp;
      norm_cast ; norm_num;
    have h_digamma_half : digamma (1 / 2) = -Real.eulerMascheroniConstant - 2 * Real.log 2 := by
      convert digamma_one_half using 1;
    norm_num [ Complex.ext_iff ] at *;
    constructor <;> linarith;
  · exact Complex.Gamma_ne_zero_of_re_pos ( by norm_num )

/-
The sequence approximating the digamma function is defined as log n - ∑_{k=0}^n 1/(z+k).
-/
noncomputable def digammaSeq (z : ℂ) (n : ℕ) : ℂ :=
  Real.log n - ∑ k ∈ Finset.range (n + 1), 1 / (z + k)

/-
The sequence digammaSeq converges to -γ + ∑ (1/(n+1) - 1/(n+z)).
-/
theorem tendsto_digammaSeq_series (z : ℂ) (hz : ∀ n : ℕ, z ≠ -n) :
    Filter.Tendsto (digammaSeq z) Filter.atTop (nhds (-Real.eulerMascheroniConstant + ∑' n : ℕ, (1 / (n + 1 : ℂ) - 1 / (n + z)))) := by
  -- Rewrite digammaSeq as (log n - ∑ k ∈ Finset.range (n + 1), 1 / (k + 1)) + ∑ k ∈ Finset.range (n + 1), (1 / (k + 1) - 1 / (k + z)).
  have h_split : ∀ n : ℕ, digammaSeq z n = (Real.log n - ∑ k ∈ Finset.range (n + 1), 1 / (k + 1 : ℝ)) + ∑ k ∈ Finset.range (n + 1), (1 / (k + 1 : ℂ) - 1 / (k + z)) := by
    unfold digammaSeq;
    norm_num [ add_comm, add_left_comm, Finset.sum_add_distrib ];
  -- The first part (log n - ∑ k ∈ Finset.range (n + 1), 1 / (k + 1)) converges to -γ.
  have h_first : Filter.Tendsto (fun n : ℕ => Real.log n - ∑ k ∈ Finset.range (n + 1), 1 / (k + 1 : ℝ)) Filter.atTop (nhds (-Real.eulerMascheroniConstant)) := by
    have h_harmonic : Filter.Tendsto (fun n : ℕ => ∑ k ∈ Finset.range n, (1 / (k + 1 : ℝ)) - Real.log n) Filter.atTop (nhds (Real.eulerMascheroniConstant)) := by
      convert Real.tendsto_harmonic_sub_log using 1;
      norm_num [ harmonic ];
    have := h_harmonic.neg; simp_all +decide [ Finset.sum_range_succ ];
    simpa [ sub_add_eq_sub_sub ] using this.sub ( tendsto_one_div_add_atTop_nhds_zero_nat );
  -- The second part ∑ k ∈ Finset.range (n + 1), (1 / (k + 1 : ℂ) - 1 / (k + z)) converges to ∑' (n : ℕ), (1 / (n + 1 : ℂ) - 1 / (n + z)).
  have h_second : Summable (fun n : ℕ => (1 / (n + 1 : ℂ) - 1 / (n + z))) := by
    -- We'll use the fact that if the denominator grows faster than the numerator, the series converges.
    have h_series_conv : Summable (fun n : ℕ => (z - 1 : ℂ) / ((n + 1) * (n + z))) := by
      refine' Summable.mul_left _ _;
      rw [ ← summable_norm_iff ];
      -- We'll use the comparison test. Since \( \| (n + 1)(n + z) \| \geq n^2 \) for large \( n \), we can compare it to \( \frac{1}{n^2} \).
      have h_compare : ∃ N : ℕ, ∀ n ≥ N, ‖((n + 1 : ℂ) * (n + z))⁻¹‖ ≤ 2 / (n ^ 2 : ℝ) := by
        -- We'll use the fact that for large $n$, the norm of $(n + 1)(n + z)$ is approximately $n^2$.
        have h_norm_approx : ∃ N : ℕ, ∀ n ≥ N, ‖(n + 1 : ℂ) * (n + z)‖ ≥ n^2 / 2 := by
          have h_norm_approx : ∃ N : ℕ, ∀ n ≥ N, ‖(n + z)‖ ≥ n / 2 := by
            norm_num [ Complex.norm_def, Complex.normSq ];
            exact ⟨ Nat.ceil ( 2 * |z.re| + 2 * |z.im| + 1 ), fun n hn => Real.le_sqrt_of_sq_le <| by cases abs_cases z.re <;> cases abs_cases z.im <;> nlinarith [ Nat.ceil_le.mp hn ] ⟩;
          norm_num +zetaDelta at *;
          obtain ⟨ N, hN ⟩ := h_norm_approx;
          exact ⟨ N + 1, fun n hn => by have := hN n ( by linarith ) ; rw [ show ( n : ℂ ) + 1 = ( n : ℂ ) + 1 from rfl ] ; rw [ show ( n : ℂ ) + z = ( n : ℂ ) + z from rfl ] ; rw [ show ( n : ℝ ) ^ 2 / 2 = ( n : ℝ ) * ( n / 2 ) by ring ] ; exact le_trans ( mul_le_mul_of_nonneg_left this <| Nat.cast_nonneg _ ) <| by rw [ show ( n : ℂ ) + 1 = ( n : ℂ ) + 1 from rfl ] ; rw [ show ( n : ℂ ) + z = ( n : ℂ ) + z from rfl ] ; exact mul_le_mul_of_nonneg_right ( by norm_cast; linarith ) <| by positivity ⟩;
        exact ⟨ h_norm_approx.choose + 1, fun n hn => by simpa using inv_anti₀ ( by exact div_pos ( sq_pos_of_pos <| Nat.cast_pos.mpr <| by linarith ) zero_lt_two ) <| h_norm_approx.choose_spec n <| by linarith ⟩;
      rw [ ← summable_nat_add_iff h_compare.choose ];
      exact Summable.of_nonneg_of_le ( fun n => norm_nonneg _ ) ( fun n => h_compare.choose_spec _ ( Nat.le_add_left _ _ ) ) ( Summable.mul_left _ <| by simpa using summable_nat_add_iff h_compare.choose |>.2 <| Real.summable_one_div_nat_pow.2 one_lt_two );
    refine h_series_conv.congr fun n => ?_;
    rw [ div_sub_div ] <;> ring <;> norm_cast <;> norm_num;
    exact fun h => hz n <| by linear_combination' h;
  convert Filter.Tendsto.add ( Complex.continuous_ofReal.continuousAt.tendsto.comp h_first ) ( h_second.hasSum.tendsto_sum_nat.comp ( Filter.tendsto_add_atTop_nat 1 ) ) using 2 ; aesop;
  norm_num

/-
The series ∑ (1/(n+1) - 1/(n+z)) converges for z not a negative integer.
-/
theorem summable_digamma_series (z : ℂ) (hz : ∀ n : ℕ, z ≠ -n) :
    Summable (fun n : ℕ => 1 / (n + 1 : ℂ) - 1 / (n + z)) := by
  field_simp;
  -- Let's simplify the expression inside the sum.
  suffices h_simp : Summable (fun n : ℕ => (z - 1) / ((n + 1 : ℂ) * (n + z))) by
    grind;
  -- Since $|z - 1|$ is a constant, we can factor it out of the sum.
  have h_factor : Summable (fun n : ℕ => 1 / ((n + 1) * (n + z) : ℂ)) := by
    have h_series_converges : Summable (fun n : ℕ => 1 / ((n + 1) * (n + 1)) : ℕ → ℂ) := by
      have h_series_conv : Summable (fun n : ℕ => (1 : ℂ) / ((n + 1) ^ 2)) := by
        have h_summable : Summable (fun n : ℕ => (1 : ℂ) / (n ^ 2)) := by
          exact Summable.of_norm <| by simp;
        exact_mod_cast summable_nat_add_iff 1 |>.2 h_summable;
      simpa only [ sq ] using h_series_conv;
    rw [ ← summable_norm_iff ] at *;
    -- Apply the comparison test with the known convergent series.
    have h_comparison : ∃ N : ℕ, ∀ n ≥ N, ‖(1 : ℂ) / ((n + 1) * (n + z))‖ ≤ ‖(1 : ℂ) / ((n + 1) * (n + 1))‖ * 2 := by
      have h_comparison : ∃ N : ℕ, ∀ n ≥ N, ‖(n + z : ℂ)‖ ≥ ‖(n + 1 : ℂ)‖ / 2 := by
        norm_num [ Complex.norm_def, Complex.normSq ];
        exact ⟨ Nat.ceil ( 2 * |z.re| + 2 * |z.im| + 1 ), fun n hn => Real.le_sqrt_of_sq_le <| by rw [ div_pow, Real.sq_sqrt <| by nlinarith ] ; cases abs_cases z.re <;> cases abs_cases z.im <;> nlinarith [ Nat.ceil_le.mp hn ] ⟩;
      obtain ⟨ N, hN ⟩ := h_comparison; use N; intro n hn; specialize hN n hn; simp_all +decide [ norm_mul, mul_assoc ];
      rw [ mul_comm ] ; gcongr;
      rw [ inv_le_comm₀ ] <;> norm_cast at * <;> norm_num at *;
      · linarith;
      · exact fun h => hz n <| by linear_combination' h;
      · positivity;
    rw [ ← summable_nat_add_iff h_comparison.choose ];
    exact Summable.of_nonneg_of_le ( fun n => norm_nonneg _ ) ( fun n => h_comparison.choose_spec _ ( Nat.le_add_left _ _ ) ) ( h_series_converges.mul_right _ |> Summable.comp_injective <| add_left_injective _ );
  convert h_factor.mul_left ( z - 1 ) using 2 ; ring

/-
The sequence log n - H_{n+1} converges to -γ.
-/
theorem tendsto_log_sub_harmonic :
    Filter.Tendsto (fun n : ℕ => Real.log n - ∑ k ∈ Finset.range (n + 1), 1 / (k + 1 : ℝ)) Filter.atTop (nhds (-Real.eulerMascheroniConstant)) := by
  -- We'll use the fact that the difference between the harmonic series and the natural logarithm converges to the Euler-Mascheroni constant.
  have h_harmonic : Filter.Tendsto (fun n : ℕ => (∑ k ∈ Finset.range n, (1 / (k + 1 : ℝ))) - Real.log n) Filter.atTop (nhds Real.eulerMascheroniConstant) := by
    have := Real.tendsto_harmonic_sub_log
    simpa [ harmonic ] using this;
  norm_num [ Finset.sum_range_succ ];
  convert h_harmonic.neg.add ( tendsto_one_div_add_atTop_nhds_zero_nat.neg ) using 2 <;> norm_num ; ring

/-
The digamma series satisfies the recurrence relation f(z+1) = f(z) + 1/z.
-/
noncomputable def digammaSeries (z : ℂ) : ℂ :=
  -Real.eulerMascheroniConstant + ∑' n : ℕ, (1 / (n + 1 : ℂ) - 1 / (n + z))

theorem digammaSeries_add_one (z : ℂ) (hz : ∀ n : ℕ, z ≠ -n) :
    digammaSeries (z + 1) = digammaSeries z + 1 / z := by
  have := @tendsto_digammaSeq_series ( z + 1 ) ?_;
  · have := @tendsto_digammaSeq_series z hz;
    -- By definition of $digammaSeq$, we have $digammaSeq (z + 1) - digammaSeq z = \frac{1}{z} + \sum_{k=1}^n \left(\frac{1}{z+k} - \frac{1}{z+k}\right)$.
    have h_diff : ∀ n : ℕ, digammaSeq (z + 1) n - digammaSeq z n = 1 / z - 1 / (z + n + 1) := by
      unfold digammaSeq;
      intro n; have := Finset.sum_range_sub' ( fun x => 1 / ( z + x ) ) ( n + 1 ) ; simp_all +decide [ add_comm, add_left_comm, add_assoc, Finset.sum_range_succ ] ;
    -- Taking the limit of both sides of the equation $digammaSeq (z + 1) n - digammaSeq z n = 1 / z - 1 / (z + n + 1)$ as $n$ approaches infinity, we get the desired result.
    have h_limit : Filter.Tendsto (fun n : ℕ => 1 / z - 1 / (z + n + 1)) Filter.atTop (nhds (1 / z)) := by
      rw [ tendsto_iff_norm_sub_tendsto_zero ];
      norm_num [ add_assoc ];
      refine' Filter.Tendsto.inv_tendsto_atTop _;
      norm_num [ Complex.normSq, Complex.norm_def ];
      exact Filter.tendsto_atTop_atTop.mpr fun x => ⟨ Nat.ceil ( x ^ 2 + 1 - z.re ), fun n hn => Real.le_sqrt_of_sq_le ( by nlinarith [ Nat.ceil_le.mp hn ] ) ⟩;
    have h_limit : Filter.Tendsto (fun n : ℕ => digammaSeq (z + 1) n - digammaSeq z n) Filter.atTop (nhds (1 / z)) := by
      simpa only [ h_diff ] using h_limit;
    exact eq_add_of_sub_eq' <| tendsto_nhds_unique ( Filter.Tendsto.sub ( ‹Filter.Tendsto ( digammaSeq ( z + 1 ) ) Filter.atTop ( nhds ( - ( Real.eulerMascheroniConstant : ℂ ) + ∑' n : ℕ, ( 1 / ( n + 1 : ℂ ) - 1 / ( n + ( z + 1 ) ) ) ) ) › ) ( ‹Filter.Tendsto ( digammaSeq z ) Filter.atTop ( nhds ( - ( Real.eulerMascheroniConstant : ℂ ) + ∑' n : ℕ, ( 1 / ( n + 1 : ℂ ) - 1 / ( n + z ) ) ) ) › ) ) h_limit;
  · exact fun n => fun h => hz ( n + 1 ) ( by push_cast; linear_combination' h )