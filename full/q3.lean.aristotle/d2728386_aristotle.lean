/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d2728386-8dd5-4ec2-9e63-c2c80f3cd218

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

noncomputable def digamma (z : ℂ) : ℂ := (deriv Complex.Gamma z) / (Complex.Gamma z)

noncomputable def a (ξ : ℝ) : ℝ := Real.log Real.pi - (digamma (1/4 + Complex.I * Real.pi * (ξ : ℂ))).re

noncomputable def A_0 (B t_sym : ℝ) : ℝ :=
  ∫ ξ in -B..B, a ξ * (max 0 (1 - |ξ| / B)) * Real.exp (-4 * Real.pi^2 * t_sym * ξ^2)

noncomputable def L_int (B t_sym : ℝ) : ℝ :=
  ∫ ξ in -B..B, |a ξ| * |ξ| * (max 0 (1 - |ξ| / B)) * Real.exp (-4 * Real.pi^2 * t_sym * ξ^2)

noncomputable def A_star (B_min t_sym : ℝ) : ℝ :=
  sInf { y | ∃ B ≥ B_min, y = A_0 B t_sym }

noncomputable def L_star (B_min t_sym : ℝ) : ℝ :=
  sSup { y | ∃ B ≥ B_min, y = L_int B t_sym }

noncomputable def c_star (B_min t_sym : ℝ) : ℝ :=
  A_star B_min t_sym - Real.pi * L_star B_min t_sym

noncomputable def B_min_val : ℝ := 3

noncomputable def t_sym_val : ℝ := 3 / 50

noncomputable def I_1 (B t_sym : ℝ) : ℝ :=
  ∫ ξ in -B..B, a ξ * |ξ| * Real.exp (-4 * Real.pi^2 * t_sym * ξ^2)

lemma a_even (ξ : ℝ) : a (-ξ) = a ξ := by
  unfold a;
  -- By definition of digamma, we know that $\psi(z)$ is real for real $z$.
  have h_digamma_real : ∀ z : ℂ, z.re > 0 → (digamma (starRingEnd ℂ z)).re = (digamma z).re := by
    unfold digamma;
    intro z hz;
    -- By definition of the Gamma function, we know that $\Gamma(\overline{z}) = \overline{\Gamma(z)}$.
    have h_gamma_conj : Complex.Gamma (starRingEnd ℂ z) = starRingEnd ℂ (Complex.Gamma z) := by
      rw [ Complex.Gamma_conj ];
    have h_deriv_conj : deriv Complex.Gamma (starRingEnd ℂ z) = starRingEnd ℂ (deriv Complex.Gamma z) := by
      have h_conj : ∀ f : ℂ → ℂ, DifferentiableAt ℂ f z → deriv (fun z => starRingEnd ℂ (f (starRingEnd ℂ z))) (starRingEnd ℂ z) = starRingEnd ℂ (deriv f z) := by
        intro f hf;
        convert HasDerivAt.deriv ( _ ) using 1;
        rw [ hasDerivAt_iff_tendsto_slope_zero ];
        have := hf.hasDerivAt.tendsto_slope_zero;
        convert Complex.continuous_conj.continuousAt.tendsto.comp ( this.comp ( show Filter.Tendsto ( fun t : ℂ => starRingEnd ℂ t ) ( nhdsWithin 0 { 0 } ᶜ ) ( nhdsWithin 0 { 0 } ᶜ ) from Filter.Tendsto.inf ( Continuous.tendsto' ( by continuity ) _ _ <| by norm_num ) <| by norm_num ) ) using 2 ; norm_num
      convert h_conj Complex.Gamma _ using 1;
      · congr ; ext ; simp +decide [ Complex.ext_iff ];
        have := Complex.Gamma_conj ‹_›; simp_all +decide [ Complex.ext_iff ];
      · exact Complex.differentiableAt_Gamma _ ( by contrapose! hz; aesop );
    simp_all +decide [ Complex.ext_iff, div_eq_mul_inv ];
    simp_all +decide [ Complex.normSq ];
  specialize h_digamma_real ( 1 / 4 + Complex.I * Real.pi * ξ ) ; norm_num [ Complex.ext_iff ] at *;
  -- Apply the hypothesis `h_digamma_real` directly.
  convert h_digamma_real using 1;
  erw [ Complex.conj_ofReal ] ; norm_num

lemma A_0_eq_diff (B : ℝ) (hB : B > 0) :
    A_0 B t_sym_val = (∫ ξ in -B..B, a ξ * Real.exp (-4 * Real.pi^2 * t_sym_val * ξ^2)) -
    (1/B) * (∫ ξ in -B..B, a ξ * |ξ| * Real.exp (-4 * Real.pi^2 * t_sym_val * ξ^2)) := by
  -- The integral of the maximum function can be split into two parts: one over $|ξ| \leq B$ and one over $|ξ| > B$. Since $\xi$ is in the symmetric interval $[-B, B]$, the second integral is zero.
  have h_split : ∫ ξ in (-B)..B, a ξ * max 0 (1 - |ξ| / B) * Real.exp (-4 * Real.pi ^ 2 * t_sym_val * ξ ^ 2) = ∫ ξ in (-B)..B, a ξ * (1 - |ξ| / B) * Real.exp (-4 * Real.pi ^ 2 * t_sym_val * ξ ^ 2) := by
    refine' intervalIntegral.integral_congr fun x hx => _;
    rw [ max_eq_right ( sub_nonneg.2 <| div_le_one_of_le₀ ( by cases abs_cases x <;> cases Set.mem_uIcc.mp hx <;> linarith ) hB.le ) ];
  -- Now use the linearity of the integral to split the integral into two parts.
  have h_split_integral : ∫ ξ in (-B)..B, a ξ * (1 - |ξ| / B) * Real.exp (-4 * Real.pi ^ 2 * t_sym_val * ξ ^ 2) = (∫ ξ in (-B)..B, a ξ * Real.exp (-4 * Real.pi ^ 2 * t_sym_val * ξ ^ 2)) - (∫ ξ in (-B)..B, a ξ * |ξ| / B * Real.exp (-4 * Real.pi ^ 2 * t_sym_val * ξ ^ 2)) := by
    rw [ ← intervalIntegral.integral_sub ] ; congr ; ext ; ring;
    · -- The function $a(\xi)$ is continuous on the interval $[-B, B]$ because it is a composition of continuous functions.
      have h_cont : ContinuousOn (fun ξ => a ξ) (Set.Icc (-B) B) := by
        refine' ContinuousOn.sub _ _;
        · exact continuousOn_const;
        · refine' Complex.continuous_re.comp_continuousOn _;
          refine' ContinuousOn.div _ _ _;
          · refine' ContinuousOn.comp ( show ContinuousOn ( deriv Complex.Gamma ) ( { z : ℂ | 0 < z.re } ) from _ ) _ _;
            · have h_gamma_cont : AnalyticOn ℂ Complex.Gamma {z : ℂ | 0 < z.re} := by
                apply_rules [ DifferentiableOn.analyticOn ];
                · intro z hz;
                  refine' DifferentiableAt.differentiableWithinAt _;
                  apply_rules [ Complex.differentiableAt_Gamma ];
                  exact fun m => ne_of_apply_ne Complex.re <| by norm_num; linarith [ hz.out ];
                · exact isOpen_lt continuous_const Complex.continuous_re;
              have h_gamma_cont : AnalyticOn ℂ (deriv Complex.Gamma) {z : ℂ | 0 < z.re} := by
                apply_rules [ DifferentiableOn.analyticOn, h_gamma_cont.differentiableOn ];
                · apply_rules [ DifferentiableOn.deriv, h_gamma_cont.differentiableOn ];
                  exact isOpen_lt continuous_const Complex.continuous_re;
                · exact isOpen_lt continuous_const Complex.continuous_re;
              exact h_gamma_cont.continuousOn;
            · exact Continuous.continuousOn ( by continuity );
            · norm_num [ Set.MapsTo ];
          · refine' continuousOn_of_forall_continuousAt fun x hx => Complex.differentiableAt_Gamma _ _ |> DifferentiableAt.continuousAt |> ContinuousAt.comp <| Continuous.continuousAt <| by continuity;
            norm_num [ Complex.ext_iff ];
            exact fun m hm => by linarith;
          · intro x hx; rw [ Ne.eq_def, Complex.Gamma_eq_zero_iff ] ; norm_num [ Complex.ext_iff ];
            exact fun n hn => by linarith;
      apply_rules [ ContinuousOn.intervalIntegrable ];
      simpa only [ Set.uIcc_of_le ( neg_le_self hB.le ) ] using h_cont.mul ( Continuous.continuousOn ( by continuity ) );
    · -- The function $a(\xi)$ is continuous on $[-B, B]$ since it is a composition of continuous functions.
      have h_cont : ContinuousOn (fun ξ => a ξ) (Set.Icc (-B) B) := by
        refine' ContinuousOn.sub _ _;
        · exact continuousOn_const;
        · refine' Complex.continuous_re.comp_continuousOn _;
          refine' ContinuousOn.div _ _ _;
          · refine' ContinuousOn.comp ( show ContinuousOn ( deriv Complex.Gamma ) ( { z : ℂ | 0 < z.re } ) from _ ) _ _;
            · have h_gamma_cont : AnalyticOn ℂ Complex.Gamma {z : ℂ | 0 < z.re} := by
                apply_rules [ DifferentiableOn.analyticOn ];
                · intro z hz;
                  refine' DifferentiableAt.differentiableWithinAt _;
                  apply_rules [ Complex.differentiableAt_Gamma ];
                  exact fun m => ne_of_apply_ne Complex.re <| by norm_num; linarith [ hz.out ];
                · exact isOpen_lt continuous_const Complex.continuous_re;
              have h_gamma_cont : AnalyticOn ℂ (deriv Complex.Gamma) {z : ℂ | 0 < z.re} := by
                apply_rules [ DifferentiableOn.analyticOn, h_gamma_cont.differentiableOn ];
                · apply_rules [ DifferentiableOn.deriv, h_gamma_cont.differentiableOn ];
                  exact isOpen_lt continuous_const Complex.continuous_re;
                · exact isOpen_lt continuous_const Complex.continuous_re;
              exact h_gamma_cont.continuousOn;
            · exact Continuous.continuousOn ( by continuity );
            · norm_num [ Set.MapsTo ];
          · refine' continuousOn_of_forall_continuousAt fun x hx => Complex.differentiableAt_Gamma _ _ |> DifferentiableAt.continuousAt |> ContinuousAt.comp <| Continuous.continuousAt <| by continuity;
            norm_num [ Complex.ext_iff ];
            exact fun m hm => by linarith;
          · intro x hx; rw [ Ne.eq_def, Complex.Gamma_eq_zero_iff ] ; norm_num [ Complex.ext_iff ];
            exact fun n hn => by linarith;
      apply_rules [ ContinuousOn.intervalIntegrable ];
      simpa only [ Set.uIcc_of_le ( neg_le_self hB.le ) ] using ContinuousOn.mul ( ContinuousOn.mul ( h_cont.mul ( continuous_abs.continuousOn ) ) continuousOn_const ) ( Continuous.continuousOn ( by continuity ) );
  convert h_split.trans h_split_integral using 1;
  norm_num [ div_eq_inv_mul, mul_assoc, mul_comm, mul_left_comm, ← intervalIntegral.integral_const_mul ]

lemma A_0_deriv (B : ℝ) (hB : B > 0) :
    HasDerivAt (fun x => A_0 x t_sym_val) ((B ^ (-2 : ℤ)) * I_1 B t_sym_val) B := by
  -- Apply the Fundamental Theorem of Calculus to each integral, noting that the derivative of the integral with respect to the upper limit is the integrand evaluated at the upper limit.
  have h_ftc : HasDerivAt (fun x => ∫ ξ in (-x)..x, a ξ * Real.exp (-4 * Real.pi^2 * t_sym_val * ξ^2)) (a B * Real.exp (-4 * Real.pi^2 * t_sym_val * B^2) + a (-B) * Real.exp (-4 * Real.pi^2 * t_sym_val * (-B)^2)) B ∧ HasDerivAt (fun x => ∫ ξ in (-x)..x, a ξ * |ξ| * Real.exp (-4 * Real.pi^2 * t_sym_val * ξ^2)) (a B * |B| * Real.exp (-4 * Real.pi^2 * t_sym_val * B^2) + a (-B) * |-B| * Real.exp (-4 * Real.pi^2 * t_sym_val * (-B)^2)) B := by
    have h_ftc : ∀ f : ℝ → ℝ, Continuous f → HasDerivAt (fun x => ∫ ξ in (-x)..x, f ξ) (f B + f (-B)) B := by
      intro f hf
      have h_ftc : HasDerivAt (fun x => ∫ ξ in (0)..x, f ξ) (f B) B ∧ HasDerivAt (fun x => ∫ ξ in (0)..x, f ξ) (f (-B)) (-B) := by
        constructor <;> apply_rules [ intervalIntegral.integral_hasDerivAt_right, hf.intervalIntegrable ];
        · exact hf.stronglyMeasurable.stronglyMeasurableAtFilter;
        · exact hf.continuousAt;
        · exact hf.stronglyMeasurable.stronglyMeasurableAtFilter;
        · exact hf.continuousAt;
      have h_ftc : HasDerivAt (fun x => (∫ ξ in (0)..x, f ξ) - (∫ ξ in (0)..(-x), f ξ)) (f B + f (-B)) B := by
        convert HasDerivAt.sub h_ftc.1 ( h_ftc.2.comp B ( hasDerivAt_neg B ) ) using 1 ; ring;
      convert h_ftc using 1;
      ext x; rw [ eq_sub_iff_add_eq', intervalIntegral.integral_add_adjacent_intervals ] <;> apply_rules [ Continuous.intervalIntegrable, hf ] ;
    have h_cont_a : Continuous a := by
      -- The digamma function is continuous, and the logarithm of pi is a constant, so their difference is also continuous.
      have h_cont_digamma : Continuous (fun ξ : ℝ => (digamma (1 / 4 + Complex.I * Real.pi * ξ)).re) := by
        -- The digamma function is analytic, hence its real part is continuous. We can use the fact that the derivative of an analytic function is also analytic.
        have h_digamma_analytic : AnalyticOn ℂ (fun z : ℂ => digamma z) {z : ℂ | 0 < z.re} := by
          apply_rules [ DifferentiableOn.analyticOn ];
          · intro z hz;
            refine' DifferentiableAt.differentiableWithinAt _;
            refine' DifferentiableAt.div _ _ _;
            · -- The Gamma function is analytic on the right half-plane, so its derivative is also analytic there.
              have h_gamma_analytic : AnalyticOn ℂ Complex.Gamma {z : ℂ | 0 < z.re} := by
                apply_rules [ DifferentiableOn.analyticOn ];
                · intro z hz;
                  refine' DifferentiableAt.differentiableWithinAt _;
                  apply_rules [ Complex.differentiableAt_Gamma ];
                  exact fun m => ne_of_apply_ne Complex.re <| by norm_num; linarith [ hz.out ];
                · exact isOpen_lt continuous_const Complex.continuous_re;
              apply_rules [ DifferentiableOn.differentiableAt, h_gamma_analytic.differentiableOn ];
              apply_rules [ DifferentiableOn.deriv, h_gamma_analytic.differentiableOn ];
              · exact isOpen_lt continuous_const Complex.continuous_re;
              · exact IsOpen.mem_nhds ( isOpen_lt continuous_const Complex.continuous_re ) hz;
            · refine' Complex.differentiableAt_Gamma _ _;
              exact fun m => ne_of_apply_ne Complex.re <| by norm_num; linarith [ hz.out ];
            · exact Complex.Gamma_ne_zero_of_re_pos hz;
          · exact isOpen_lt continuous_const Complex.continuous_re;
        refine' Complex.continuous_re.comp ( h_digamma_analytic.continuousOn.comp_continuous _ _ );
        · continuity;
        · norm_num;
      exact continuous_const.sub h_cont_digamma
    have h_cont_a_abs : Continuous (fun ξ => a ξ * |ξ|) := by
      exact h_cont_a.mul continuous_abs;
    exact ⟨ h_ftc _ <| h_cont_a.mul <| Real.continuous_exp.comp <| Continuous.mul ( continuous_const ) <| continuous_pow 2, h_ftc _ <| h_cont_a_abs.mul <| Real.continuous_exp.comp <| Continuous.mul ( continuous_const ) <| continuous_pow 2 ⟩;
  -- Substitute the expressions for the derivatives from `h_ftc` into the goal.
  have h_subst : HasDerivAt (fun x => (∫ ξ in (-x)..x, a ξ * Real.exp (-4 * Real.pi^2 * t_sym_val * ξ^2)) - (1/x) * (∫ ξ in (-x)..x, a ξ * |ξ| * Real.exp (-4 * Real.pi^2 * t_sym_val * ξ^2))) (B ^ (-2 : ℝ) * I_1 B t_sym_val) B := by
    convert HasDerivAt.sub h_ftc.1 ( HasDerivAt.mul ( HasDerivAt.div ( hasDerivAt_const _ _ ) ( hasDerivAt_id B ) ( ne_of_gt hB ) ) h_ftc.2 ) using 1 ; norm_cast ; norm_num ; ring;
    unfold I_1; rw [ abs_of_pos hB ] ; ring; norm_num [ hB.ne' ] ; ring;
  convert h_subst.congr_of_eventuallyEq _ using 1;
  · norm_cast;
  · filter_upwards [ lt_mem_nhds hB ] with x hx using A_0_eq_diff x hx ▸ by ring;

lemma Re_digamma_term (x y : ℝ) (n : ℕ) :
    (1 / (n + 1 : ℂ) - 1 / (n + (x + Complex.I * y))).re =
    1 / (n + 1 : ℝ) - (n + x) / ((n + x)^2 + y^2) := by
  norm_num [ Complex.normSq, Complex.div_re ];
  ring

#check Complex.GammaSeq_tendsto_Gamma

lemma deriv_digamma_term (n : ℕ) (z : ℂ) (hz : 0 < z.re) :
    HasDerivAt (fun w => w / (n + 1) - Complex.log (1 + w / (n + 1))) (1 / (n + 1 : ℂ) - 1 / (n + 1 + z)) z := by
  convert HasDerivAt.sub ( HasDerivAt.div_const ( hasDerivAt_id z ) _ ) ( HasDerivAt.clog ( HasDerivAt.add ( hasDerivAt_const _ _ ) ( HasDerivAt.div_const ( hasDerivAt_id z ) _ ) ) _ ) using 1 <;> norm_num;
  · -- By simplifying, we can see that the two expressions are equal.
    field_simp [hz];
  · norm_num [ Complex.slitPlane ];
    norm_num [ div_eq_mul_inv ];
    exact Or.inl ( add_pos_of_pos_of_nonneg zero_lt_one ( mul_nonneg hz.le ( mul_nonneg ( by positivity ) ( inv_nonneg.mpr ( Complex.normSq_nonneg _ ) ) ) ) )

lemma summable_trigamma_series (z : ℂ) (hz : 0 < z.re) :
    Summable (fun n : ℕ => 1 / (n + z) ^ 2) := by
  field_simp;
  have h_summable : Summable (fun n : ℕ => (1 / (n + z.re)^2 : ℝ)) := by
    have h_summable : Summable (fun n : ℕ => (1 : ℝ) / (n : ℝ)^2) := by
      exact Real.summable_one_div_nat_pow.2 one_lt_two;
    rw [ ← summable_nat_add_iff ⌈z.re⌉₊ ] at *;
    exact Summable.of_nonneg_of_le ( fun n => by positivity ) ( fun n => by gcongr ; linarith [ Nat.le_ceil z.re ] ) h_summable;
  -- Since the modulus of the terms is the same, the summability of the real series implies the summability of the complex series.
  have h_norm : ∀ n : ℕ, ‖(1 : ℂ) / ((n + z) ^ 2)‖ ≤ 1 / ((n + z.re) ^ 2) := by
    norm_num [ Complex.normSq, Complex.sq_norm ];
    exact fun n => inv_anti₀ ( by positivity ) ( by nlinarith );
  -- Apply the comparison test with the summable real series and the bound from h_norm.
  have h_summable_complex : Summable (fun n : ℕ => ‖(1 : ℂ) / ((n + z) ^ 2)‖) := by
    exact Summable.of_nonneg_of_le ( fun n => norm_nonneg _ ) h_norm h_summable;
  exact h_summable_complex.of_norm