/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ada58f31-f6fb-4426-99f2-9bb5cf98a3a3
-/

/-
This file formalizes the off-diagonal exponential sum bound. It defines the spectral coordinates `xi_n`, the node set `Nodes`, and the geometric series bound `S_K`. It proves that the node spacing satisfies a minimum distance property (`node_spacing_axiom`) and uses this to bound the off-diagonal exponential sum by `S_K`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def xi_n (n : ℕ) : ℝ := Real.log n / (2 * Real.pi)

def Nodes (K : ℝ) : Set ℕ := {n | |xi_n n| ≤ K ∧ n ≥ 2}

def N_K (K : ℝ) : ℕ := Nat.floor (Real.exp (2 * Real.pi * K))

def delta_K (K : ℝ) : ℝ := 1 / (2 * Real.pi * (N_K K + 1))

def S_K (K t : ℝ) : ℝ :=
  2 * Real.exp (-(delta_K K)^2 / (4 * t)) / (1 - Real.exp (-(delta_K K)^2 / (4 * t)))

/-
The spacing between spectral coordinates of nodes is at least the minimum node spacing times the index distance.
-/
lemma node_spacing_axiom (K : ℝ) (hK : 1 ≤ K) (i j : ℕ) (hi : i ∈ Nodes K) (hj : j ∈ Nodes K) (hij : i ≠ j) :
  |xi_n i - xi_n j| ≥ |(i : ℝ) - j| * delta_K K := by
  -- By the Mean Value Theorem, there exists some $c$ between $i$ and $j$ such that:
  have h_mean_value : ∃ c ∈ Set.Icc (min (i : ℝ) (j : ℝ)) (max (i : ℝ) (j : ℝ)), (Real.log (j : ℝ) / (2 * Real.pi)) - (Real.log (i : ℝ) / (2 * Real.pi)) = (1 / (2 * Real.pi * c)) * ((j : ℝ) - (i : ℝ)) := by
    cases max_cases ( i : ℝ ) ( j : ℝ ) <;> cases min_cases ( i : ℝ ) ( j : ℝ ) <;> aesop;
    · have := exists_deriv_eq_slope ( f := fun x => Real.log x / ( 2 * Real.pi ) ) ( show ( j : ℝ ) < i from mod_cast h_1 ) ; aesop;
      obtain ⟨ c, hc₁, hc₂ ⟩ := this ( by exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.div ( Real.continuousAt_log ( by linarith [ hx.1, show ( j :ℝ ) > 0 from Nat.cast_pos.mpr ( Nat.pos_of_ne_zero ( by rintro rfl; exact absurd hj ( by unfold Nodes; aesop ) ) ) ] ) ) continuousAt_const ( by positivity ) ) ( by exact fun x hx => DifferentiableAt.differentiableWithinAt ( by exact DifferentiableAt.div ( Real.differentiableAt_log ( by linarith [ hx.1, show ( j :ℝ ) > 0 from Nat.cast_pos.mpr ( Nat.pos_of_ne_zero ( by rintro rfl; exact absurd hj ( by unfold Nodes; aesop ) ) ) ] ) ) ( differentiableAt_const _ ) ( by positivity ) ) ) ; exact ⟨ c, ⟨ by linarith, by linarith ⟩, by rw [ eq_div_iff ] at hc₂ <;> ring_nf at * <;> linarith ⟩;
    · have := exists_deriv_eq_slope ( fun x => Real.log x / ( 2 * Real.pi ) ) ( show ( i : ℝ ) < j by norm_cast );
      contrapose! this;
      simp +zetaDelta at *;
      exact ⟨ continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.div ( Real.continuousAt_log ( by linarith [ hx.1, show ( i : ℝ ) ≥ 2 by exact_mod_cast hi.2 ] ) ) continuousAt_const ( by positivity ), fun x hx => DifferentiableAt.differentiableWithinAt ( by exact DifferentiableAt.div ( Real.differentiableAt_log ( by linarith [ hx.1, show ( i : ℝ ) ≥ 2 by exact_mod_cast hi.2 ] ) ) ( differentiableAt_const _ ) ( by positivity ) ), fun x hx₁ hx₂ => fun hx₃ => this x ( by linarith ) ( by linarith ) <| by rw [ eq_div_iff ] at hx₃ <;> ring_nf at * <;> linarith ⟩;
  -- Since $c \leq N_K K$, we have $1 / (2 * \pi * c) \geq 1 / (2 * \pi * (N_K K + 1)) = \delta_K K$.
  obtain ⟨c, hc⟩ := h_mean_value
  have hc_le : c ≤ (N_K K : ℝ) := by
    unfold Nodes at *; aesop;
    · norm_num [ show c = i by linarith ] at *;
      -- Since $|\xi_n i| \leq K$, we have $\frac{\log i}{2\pi} \leq K$, thus $\log i \leq 2\pi K$.
      have h_log_i : Real.log i ≤ 2 * Real.pi * K := by
        unfold xi_n at *; rw [ abs_le ] at *; nlinarith [ Real.pi_pos, mul_div_cancel₀ ( Real.log i ) ( by positivity : ( 2 * Real.pi ) ≠ 0 ) ] ;
      exact Nat.le_floor <| by rw [ ← Real.log_le_log_iff ( by positivity ) ( by positivity ), Real.log_exp ] ; linarith;
    · -- Since $|\xi_j| \leq K$, we have $\frac{\log j}{2\pi} \leq K$, which implies $\log j \leq 2\pi K$.
      have h_log_j : Real.log j ≤ 2 * Real.pi * K := by
        unfold xi_n at *; rw [ abs_le ] at *; nlinarith [ Real.pi_pos, mul_div_cancel₀ ( Real.log j ) ( by positivity : ( 2 * Real.pi ) ≠ 0 ) ] ;
      exact le_trans h_2 ( Nat.cast_le.mpr <| Nat.le_floor <| by rw [ ← Real.log_le_log_iff ( by positivity ) <| by positivity ] ; simpa [ Real.log_le_iff_le_exp ( by positivity : 0 < ( j :ℝ ) ) ] using h_log_j );
    · -- Since $j \leq c \leq i$, we have $i \leq N_K K$.
      have hi_le_NK : (i : ℝ) ≤ Real.exp (2 * Real.pi * K) := by
        unfold xi_n at *;
        rw [ abs_le ] at left ; rw [ div_le_iff₀ ( by positivity ) ] at * ; rw [ ← Real.log_le_iff_le_exp ( by positivity ) ] ; nlinarith [ Real.pi_pos ];
      exact le_trans h ( mod_cast Nat.le_floor <| mod_cast hi_le_NK );
    · refine' le_trans h_2 _;
      unfold xi_n at *; rw [ abs_le ] at *; aesop;
      exact Nat.le_floor <| by rw [ div_le_iff₀ <| by positivity ] at *; rw [ ← Real.log_le_log_iff ( by positivity ) <| by positivity ] ; simpa using by linarith;
  -- Substitute $c \leq N_K K$ into the inequality.
  have h_subst : abs ((Real.log (j : ℝ) / (2 * Real.pi)) - (Real.log (i : ℝ) / (2 * Real.pi))) ≥ (1 / (2 * Real.pi * (N_K K + 1))) * abs ((j : ℝ) - (i : ℝ)) := by
    rw [ hc.2, abs_mul, abs_of_nonneg ( one_div_nonneg.mpr <| mul_nonneg ( by positivity ) <| by linarith [ show ( 0 : ℝ ) ≤ c by cases min_cases ( i : ℝ ) j <;> cases max_cases ( i : ℝ ) j <;> linarith [ hc.1.1, hc.1.2 ] ] ) ];
    gcongr;
    · cases min_cases ( i : ℝ ) j <;> cases max_cases ( i : ℝ ) j <;> nlinarith [ Real.pi_pos, show ( i : ℝ ) ≥ 2 by norm_cast; exact hi.2, show ( j : ℝ ) ≥ 2 by norm_cast; exact hj.2, hc.1.1, hc.1.2 ];
    · linarith;
  convert h_subst using 1 <;> norm_num [ abs_sub_comm, delta_K ] ; ring!;
  ring

/-
The set of nodes is contained in a finite interval.
-/
lemma Nodes_subset_Icc (K : ℝ) : Nodes K ⊆ Set.Icc 2 (N_K K + 1) := by
  intro n hn; aesop;
  · exact hn.2;
  · -- By definition of $N_K$, we know that $n \leq N_K K$ because $|\xi_n| \leq K$ and $n \geq 2$.
    have h_le_NK : n ≤ Nat.floor (Real.exp (2 * Real.pi * K)) := by
      cases hn ; aesop;
      exact Nat.le_floor <| by rw [ ← Real.log_le_iff_le_exp ( by positivity ) ] ; nlinarith [ Real.pi_pos, abs_le.mp left, show ( n :ℝ ) ≥ 2 by norm_cast, show ( xi_n n :ℝ ) = Real.log n / ( 2 * Real.pi ) by rfl, mul_div_cancel₀ ( Real.log n ) ( by positivity : ( 2 * Real.pi :ℝ ) ≠ 0 ) ] ;
    exact Nat.le_succ_of_le h_le_NK

/-
The set of nodes is finite.
-/
lemma Nodes_finite (K : ℝ) : Set.Finite (Nodes K) := by
  apply Set.Finite.subset (Set.finite_Icc 2 (N_K K + 1))
  exact Nodes_subset_Icc K

/-
The set of nodes is a finite type.
-/
noncomputable instance (K : ℝ) : Fintype (Nodes K) := Set.Finite.fintype (Nodes_finite K)

/-
The off-diagonal exponential sum is bounded by S_K.
-/
theorem off_diag_exp_sum_bound (K t : ℝ) (hK : K ≥ 1) (ht : t > 0)
    (i : Nodes K) :
    ∑ j : Nodes K, (if (j : ℕ) ≠ (i : ℕ) then
      Real.exp (-(xi_n i - xi_n j)^2 / (4 * t)) else 0) ≤ S_K K t := by
        -- Let $r = \exp(-\delta_K^2 / (4t))$.
        set r : ℝ := Real.exp (-(delta_K K)^2 / (4 * t));
        -- By Lemma~\ref{lem:node_spacing_axiom}, $|ξ_i - ξ_j| ≥ |i - j| * δ_K$, thus $e^{-(ξ_i - ξ_j)^2 / (4t)} ≤ r^k$ for $k = |i - j|$.
        have h_exp_bound : ∀ j : (Nodes K), (j.val ≠ i.val) → Real.exp (-(xi_n i.val - xi_n j.val) ^ 2 / (4 * t)) ≤ r ^ (Int.natAbs (i.val - j.val)) := by
          -- By Lemma~\ref{lem:node_spacing_axiom}, $|ξ_i - ξ_j| ≥ |i - j| * δ_K$, thus $e^{-(ξ_i - ξ_j)^2 / (4t)} ≤ r^k$ for $k = |i - j|$. Use this fact.
          intros j hj_ne_i
          have h_dist : |xi_n i.val - xi_n j.val| ≥ |(i.val : ℝ) - j.val| * delta_K K := by
            convert node_spacing_axiom K hK i.val j.val i.prop j.prop ( Ne.symm hj_ne_i ) using 1;
          -- Squaring both sides of the distance inequality, we get $(ξ_i - ξ_j)^2 ≥ (|(i : ℝ) - j.val| * δ_K)^2$.
          have h_dist_sq : (xi_n i.val - xi_n j.val) ^ 2 ≥ (Int.natAbs (i.val - j.val)) ^ 2 * (delta_K K) ^ 2 := by
            aesop;
            convert pow_le_pow_left₀ ( mul_nonneg ( abs_nonneg _ ) ( show 0 ≤ delta_K K from div_nonneg zero_le_one ( mul_nonneg ( mul_nonneg zero_le_two ( Real.pi_pos.le ) ) ( Nat.cast_add_one_pos _ |> le_of_lt ) ) ) ) h_dist 2 using 1 <;> norm_num [ mul_pow, abs_mul ];
          rw [ ← Real.exp_nat_mul ];
          field_simp;
          gcongr;
          exact le_trans ( mul_le_mul_of_nonneg_right ( mod_cast Nat.le_self_pow ( by positivity ) _ ) ( sq_nonneg _ ) ) h_dist_sq;
        -- Since $|i-j|$ ranges over positive integers, we can sum over a geometric series with ratio $r$.
        have h_geo_series : ∑ j : (Nodes K), (if j.val ≠ i.val then r ^ (Int.natAbs (i.val - j.val)) else 0) ≤ ∑ k ∈ Finset.Ico 1 (N_K K + 1), r ^ k * 2 := by
          -- Since $|i-j|$ ranges over positive integers, we can sum over a geometric series with ratio $r$ and count the number of terms for each $k$.
          have h_geo_series_count : ∀ k ∈ Finset.Ico 1 (N_K K + 1), (∑ j : (Nodes K), (if j.val ≠ i.val ∧ Int.natAbs (i.val - j.val) = k then r ^ k else 0)) ≤ r ^ k * 2 := by
            intros k hk
            have h_count : Finset.card (Finset.filter (fun j : ℕ => j ≠ i.val ∧ Int.natAbs (i.val - j) = k) (Finset.Icc 2 (N_K K + 1))) ≤ 2 := by
              -- Since $|i-j| = k$, there are at most two values of $j$ for each $k$: $j = i + k$ and $j = i - k$.
              have h_count : Finset.filter (fun j : ℕ => j ≠ i.val ∧ Int.natAbs (i.val - j) = k) (Finset.Icc 2 (N_K K + 1)) ⊆ {i.val + k, i.val - k} := by
                grind;
              exact le_trans ( Finset.card_le_card h_count ) ( Finset.card_insert_le _ _ );
            have h_geo_series_count : (∑ j : (Nodes K), (if j.val ≠ i.val ∧ Int.natAbs (i.val - j.val) = k then r ^ k else 0)) ≤ (∑ j ∈ Finset.filter (fun j : ℕ => j ≠ i.val ∧ Int.natAbs (i.val - j) = k) (Finset.Icc 2 (N_K K + 1)), r ^ k) := by
              rw [ ← Finset.sum_filter ];
              refine' le_trans _ ( Finset.sum_le_sum_of_subset_of_nonneg _ _ );
              rotate_left;
              exact Finset.image ( fun j : Nodes K => j.val ) ( Finset.filter ( fun j : Nodes K => j.val ≠ i.val ∧ Int.natAbs ( i.val - j.val ) = k ) Finset.univ );
              · simp +decide [ Finset.subset_iff ];
                exact fun x hx₁ hx₂ hx₃ => ⟨ ⟨ hx₃.2, by linarith [ Set.mem_Icc.mp ( Nodes_subset_Icc K hx₃ ) ] ⟩, hx₁, hx₂ ⟩;
              · exact fun _ _ _ => by positivity;
              · rw [ Finset.sum_image ] ; aesop;
            simp_all +decide [ mul_comm ];
            exact h_geo_series_count.trans ( by rw [ mul_comm ] ; exact mul_le_mul_of_nonneg_right ( mod_cast h_count ) ( by positivity ) );
          convert Finset.sum_le_sum h_geo_series_count;
          rw [ ← Finset.sum_comm ];
          refine' Finset.sum_congr rfl fun x hx => _;
          split_ifs <;> simp_all +decide [ Finset.sum_ite ];
          intro h; specialize h ( Nat.pos_of_ne_zero ( by omega ) ) ; contrapose! h; aesop;
          cases abs_cases ( val - val_1 : ℤ ) <;> linarith [ Set.mem_Icc.mp ( Nodes_subset_Icc K property ), Set.mem_Icc.mp ( Nodes_subset_Icc K property_1 ) ];
        -- Since $r < 1$, the geometric series converges to $\frac{2r}{1-r}$.
        have h_geo_series_sum : ∑ k ∈ Finset.Ico 1 (N_K K + 1), r ^ k * 2 ≤ 2 * r / (1 - r) := by
          rw [ le_div_iff₀ ];
          · have := geom_sum_mul_neg r ( N_K K );
            rw [ Finset.sum_Ico_eq_sum_range ];
            norm_num [ pow_add, ← Finset.mul_sum _ _ _, ← Finset.sum_mul ] at * ; nlinarith [ Real.exp_pos ( -delta_K K ^ 2 / ( 4 * t ) ), pow_nonneg ( Real.exp_nonneg ( -delta_K K ^ 2 / ( 4 * t ) ) ) ( N_K K ) ];
          · norm_num +zetaDelta at *;
            exact div_neg_of_neg_of_pos ( neg_neg_of_pos ( sq_pos_of_pos ( by exact one_div_pos.mpr ( mul_pos ( by positivity ) ( Nat.cast_add_one_pos _ ) ) ) ) ) ( by positivity );
        refine le_trans ?_ ( h_geo_series.trans h_geo_series_sum );
        exact Finset.sum_le_sum fun j hj => by aesop;