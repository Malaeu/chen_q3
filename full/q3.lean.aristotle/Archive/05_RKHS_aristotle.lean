/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 34be4dc5-7272-42a8-9be8-59f4be0d90f8

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

noncomputable def xi_n (n : ℕ) : ℝ := Real.log n / (2 * Real.pi)

noncomputable def w_RKHS (n : ℕ) : ℝ :=
  ArithmeticFunction.vonMangoldt n / Real.sqrt n

def w_max : ℝ := 2 / Real.exp 1

noncomputable def heat_kernel (t x y : ℝ) : ℝ :=
  Real.exp (-(x - y)^2 / (4 * t))

noncomputable def delta_K (K : ℝ) : ℝ :=
  1 / (2 * Real.pi * (Nat.floor (Real.exp (2 * Real.pi * K)) + 1))

noncomputable def t_min (K η : ℝ) : ℝ :=
  (delta_K K)^2 / (4 * Real.log ((2 + η) / η))

noncomputable def S_K (K t : ℝ) : ℝ :=
  2 * Real.exp (-(delta_K K)^2 / (4 * t)) / (1 - Real.exp (-(delta_K K)^2 / (4 * t)))

/-
Bound on the off-diagonal sum S_K.
-/
theorem RKHS_off_diagonal_bound (K t : ℝ) (hK : K ≥ 1) (ht : t > 0) :
    S_K K t ≤ 2 * Real.exp (-(delta_K K)^2 / (4 * t)) /
              (1 - Real.exp (-(delta_K K)^2 / (4 * t))) := by
  exact le_rfl

noncomputable def Nodes (K : ℝ) : Set ℕ := {n | n ≥ 2 ∧ xi_n n ≤ K}

/-
The set of nodes is finite.
-/
theorem Nodes_finite (K : ℝ) : Set.Finite (Nodes K) := by
  by_cases hK : K ≥ 0;
  · -- Since $xi_n n \leq K$ implies $n \leq \exp(2 \pi K)$, the set of nodes is bounded above.
    have h_bounded_above : ∀ n ∈ Nodes K, n ≤ Nat.floor (Real.exp (2 * Real.pi * K)) := by
      unfold Nodes;
      unfold xi_n; aesop;
      exact Nat.le_floor <| by rw [ div_le_iff₀ <| by positivity ] at *; rw [ ← Real.log_le_iff_le_exp <| by positivity ] at *; linarith;
    exact Set.finite_iff_bddAbove.mpr ⟨ _, h_bounded_above ⟩;
  · exact Set.finite_empty.subset fun n hn => hK <| hn.2.trans' <| div_nonneg ( Real.log_nonneg <| mod_cast hn.1.trans' <| by norm_num ) <| by positivity;

/-
The prime sampling operator T_P, defined as a matrix on the finite set of nodes.
-/
noncomputable instance (K : ℝ) : Fintype (Nodes K) := Set.Finite.fintype (Nodes_finite K)

noncomputable def T_P (K t : ℝ) : Matrix (Nodes K) (Nodes K) ℝ :=
  fun i j => Real.sqrt (w_RKHS i) * Real.sqrt (w_RKHS j) * heat_kernel t (xi_n i) (xi_n j)

/-
The L-infinity operator norm of a matrix.
-/
open scoped NNReal

noncomputable def linfty_opNorm {m n : Type*} [Fintype m] [Fintype n] (A : Matrix m n ℝ) : ℝ :=
  ((Finset.univ : Finset m).sup (fun i => ∑ j, ‖A i j‖₊) : ℝ≥0)

/-
Any real eigenvalue of a real matrix is bounded by the L-infinity operator norm.
-/
open scoped Matrix.Norms.L2Operator

lemma eigenvalue_le_linfty_opNorm {n : Type*} [Fintype n] [DecidableEq n] (A : Matrix n n ℝ) (μ : ℝ) (v : n → ℝ) (hv : v ≠ 0) (hAv : Matrix.mulVec A v = μ • v) :
    |μ| ≤ linfty_opNorm A := by
  -- Let $i$ be the index such that $|v_i|$ is maximal.
  obtain ⟨i, hi⟩ : ∃ i : n, ∀ j : n, |v j| ≤ |v i| ∧ v i ≠ 0 := by
    obtain ⟨ i, hi ⟩ := Finset.exists_max_image Finset.univ ( fun j => |v j| ) ⟨ Classical.choose ( Function.ne_iff.mp hv ), Finset.mem_univ _ ⟩ ; use i; aesop;
    exact hv ( funext hi );
  -- Taking absolute values: $|\mu| |v_i| = |\sum_j A_{ij} v_j| \leq \sum_j |A_{ij}| |v_j| \leq \sum_j |A_{ij}| |v_i| = |v_i| \sum_j |A_{ij}|$.
  have h_abs : |μ| * |v i| ≤ |v i| * ∑ j, |A i j| := by
    have h_abs : |μ| * |v i| ≤ |∑ j, A i j * v j| := by
      replace hAv := congr_fun hAv i; aesop;
      simp_all +decide [ ← abs_mul, Matrix.mulVec, dotProduct ];
    exact h_abs.trans ( le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( by simpa [ mul_comm, abs_mul, Finset.mul_sum _ _ _ ] using Finset.sum_le_sum fun j ( _ : j ∈ Finset.univ ) => mul_le_mul_of_nonneg_left ( hi j |>.1 ) ( abs_nonneg ( A i j ) ) ) );
  -- Since $|v_i| > 0$, we can divide both sides of the inequality by $|v_i|$.
  have h_div : |μ| ≤ ∑ j, |A i j| := by
    nlinarith [ abs_pos.mpr ( hi i |>.2 ) ];
  refine' le_trans h_div _;
  exact le_trans ( by simp +decide [ ← NNReal.coe_le_coe ] ) ( Finset.le_sup ( f := fun i => ∑ j, ‖A i j‖₊ ) ( Finset.mem_univ i ) )

/-
A real matrix is symmetric if and only if it is self-adjoint.
-/
lemma Matrix.isSymm_iff_isSelfAdjoint {n : Type*} [Fintype n] [DecidableEq n] (A : Matrix n n ℝ) :
    A.IsSymm ↔ IsSelfAdjoint A := by
  aesop

#synth CStarRing (Matrix (Fin 2) (Fin 2) ℝ)

#check Matrix.IsHermitian

#check spectralRadius

/-
The RKHS weights are bounded by w_max.
-/
theorem w_RKHS_le_w_max (n : ℕ) : w_RKHS n ≤ w_max := by
  -- The function f(x) = log x / sqrt x has maximum at x = e^2. The values at integers are bounded by 2/e. So w_RKHS n <= 2/e = w_max.
  have h_log_sqrtn_bound : ∀ n ≥ 2, (Real.log n) / Real.sqrt n ≤ 2 / Real.exp 1 := by
    -- Let's choose any $n \geq 2$.
    intro n hn
    have h_log_sqrt_n : Real.log n ≤ (2 / Real.exp 1) * Real.sqrt n := by
      have := Real.log_le_sub_one_of_pos ( by positivity : 0 < Real.sqrt n / Real.exp 1 );
      rw [ Real.log_div ( by positivity ) ( by positivity ), Real.log_sqrt ( by positivity ), Real.log_exp ] at this ; ring_nf at * ; nlinarith [ Real.sqrt_nonneg n, Real.sq_sqrt ( show 0 ≤ n by positivity ), Real.add_one_le_exp 1, mul_inv_cancel₀ ( ne_of_gt ( Real.exp_pos 1 ) ) ];
    rwa [ div_le_iff₀ ( Real.sqrt_pos.mpr ( by positivity ) ) ];
  unfold w_RKHS w_max; rcases le_or_gt n 1 with hn' | hn' <;> aesop;
  · interval_cases n <;> norm_num [ ArithmeticFunction.vonMangoldt ] ; positivity;
    positivity;
  · refine' le_trans _ ( h_log_sqrtn_bound n ( mod_cast hn' ) );
    gcongr;
    exact?

#check Matrix.IsHermitian.eigenvalues

/-
Schur test: The operator norm of a symmetric matrix is bounded by the maximum absolute row sum.
-/
open scoped Matrix.Norms.L2Operator

lemma norm_le_of_row_sum_le {n : Type*} [Fintype n] [DecidableEq n] (A : Matrix n n ℝ) (hA : A.IsSymm) (C : ℝ) (hC : 0 ≤ C) (h_row : ∀ i, ∑ j, |A i j| ≤ C) : ‖A‖ ≤ C := by
  refine' csInf_le _ _;
  · exact ⟨ 0, fun c hc => hc.1 ⟩;
  · aesop;
    -- By definition of matrix multiplication and the properties of the Euclidean norm, we have:
    have h_norm : ‖(Matrix.toEuclideanLin A) x‖^2 ≤ ∑ i, (∑ j, |A i j| * |x j|)^2 := by
      rw [ EuclideanSpace.norm_eq ];
      rw [ Real.sq_sqrt ( Finset.sum_nonneg fun _ _ => sq_nonneg _ ) ];
      gcongr;
      convert norm_sum_le _ _ using 2 ; simp +decide [ Matrix.mulVec, dotProduct ];
    -- Applying the Cauchy-Schwarz inequality to the sum, we get:
    have h_cauchy_schwarz : ∑ i, (∑ j, |A i j| * |x j|)^2 ≤ C * ∑ i, ∑ j, |A i j| * |x j|^2 := by
      have h_cauchy_schwarz : ∀ i, (∑ j, |A i j| * |x j|)^2 ≤ (∑ j, |A i j|) * (∑ j, |A i j| * |x j|^2) := by
        intro i
        have h_cauchy_schwarz : (∑ j, |A i j| * |x j|)^2 ≤ (∑ j, |A i j|) * (∑ j, |A i j| * |x j|^2) := by
          have h_cauchy_schwarz_step : ∀ (u v : n → ℝ), (∑ j, u j * v j)^2 ≤ (∑ j, u j^2) * (∑ j, v j^2) := by
            exact?
          convert h_cauchy_schwarz_step ( fun j => Real.sqrt ( |A i j| ) ) ( fun j => Real.sqrt ( |A i j| ) * |x j| ) using 1 <;> simp +decide [ mul_pow, mul_assoc, mul_comm, mul_left_comm, Real.sq_sqrt ( abs_nonneg _ ) ];
        exact h_cauchy_schwarz;
      exact le_trans ( Finset.sum_le_sum fun i _ => h_cauchy_schwarz i ) ( by simpa only [ Finset.mul_sum _ _ _ ] using Finset.sum_le_sum fun i _ => mul_le_mul_of_nonneg_right ( h_row i ) ( Finset.sum_nonneg fun j _ => mul_nonneg ( abs_nonneg _ ) ( sq_nonneg _ ) ) );
    -- Since $\sum_{i} \sum_{j} |A_{ij}| |x_j|^2 \leq C \sum_{j} |x_j|^2$, we can further simplify the inequality.
    have h_sum_bound : ∑ i, ∑ j, |A i j| * |x j|^2 ≤ C * ∑ j, |x j|^2 := by
      rw [ Finset.mul_sum _ _ _ ];
      rw [ Finset.sum_comm ];
      exact Finset.sum_le_sum fun i _ => by rw [ ← Finset.sum_mul _ _ _ ] ; exact mul_le_mul_of_nonneg_right ( by simpa only [ ← hA.apply ] using h_row i ) ( sq_nonneg _ ) ;
    simp_all +decide [ EuclideanSpace.norm_eq ];
    rw [ Real.sqrt_le_iff ];
    exact ⟨ mul_nonneg hC ( Real.sqrt_nonneg _ ), by rw [ mul_pow, Real.sq_sqrt ( Finset.sum_nonneg fun _ _ => sq_nonneg _ ) ] ; nlinarith [ Real.mul_self_sqrt ( show 0 ≤ ∑ i, x i ^ 2 by exact Finset.sum_nonneg fun _ _ => sq_nonneg _ ), Real.sqrt_nonneg ( ∑ i, x i ^ 2 ), Real.mul_self_sqrt ( show 0 ≤ ∑ i, ( Matrix.toEuclideanLin A x i ) ^ 2 by exact Finset.sum_nonneg fun _ _ => sq_nonneg _ ) ] ⟩

/-
A Cauchy-Schwarz type inequality useful for the Schur test.
-/
lemma schur_test_inequality {n : Type*} [Fintype n] (a : n → ℝ) (b : n → ℝ) (ha : ∀ i, 0 ≤ a i) :
    (∑ i, a i * b i)^2 ≤ (∑ i, a i) * (∑ i, a i * (b i)^2) := by
  -- By the Cauchy-Schwarz inequality, we have that for any vectors $u$ and $v$ of equal length, $(∑ i, u i * v i)^2 ≤ (∑ i, u i^2) * (∑ i, v i^2)$.
  have h_cauchy_schwarz : ∀ (u v : n → ℝ), (∑ i, u i * v i)^2 ≤ (∑ i, u i^2) * (∑ i, v i^2) := by
    exact?;
  convert h_cauchy_schwarz ( fun i => Real.sqrt ( a i ) ) ( fun i => Real.sqrt ( a i ) * b i ) using 3 <;> ring;
  · rw [ Real.sq_sqrt ( ha _ ), mul_comm ];
  · rw [ Real.sq_sqrt ( ha _ ) ];
  · rw [ Real.sq_sqrt ( ha _ ), mul_comm ]

/-
Schur test: The operator norm of a symmetric matrix is bounded by the maximum absolute row sum.
-/
open scoped Matrix.Norms.L2Operator

lemma norm_le_of_row_sum_le' {n : Type*} [Fintype n] [DecidableEq n] (A : Matrix n n ℝ) (hA : A.IsSymm) (C : ℝ) (hC : 0 ≤ C) (h_row : ∀ i, ∑ j, |A i j| ≤ C) : ‖A‖ ≤ C := by
  convert norm_le_of_row_sum_le A hA C hC h_row using 1

/-
The prime sampling operator T_P is a symmetric matrix.
-/
lemma T_P_symmetric (K t : ℝ) : (T_P K t).IsSymm := by
  ext i j; unfold T_P; ring;
  norm_num +zetaDelta at *;
  unfold heat_kernel; ring;

/-
The nodes in the RKHS are separated by at least delta_K times their index difference.
-/
lemma xi_n_separation (K : ℝ) (hK : K ≥ 1) (i j : Nodes K) :
    |xi_n i - xi_n j| ≥ |(i : ℝ) - (j : ℝ)| * delta_K K := by
  -- By the Mean Value Theorem, there exists some $c$ between $i$ and $j$ such that $|f(i) - f(j)| = |f'(c)| \cdot |i - j|$.
  have h_mean_value : ∀ i j : ℕ, 2 ≤ i → 2 ≤ j → i < j → ∃ c ∈ Set.Ioo (i : ℝ) (j : ℝ), |Real.log (i : ℝ) / (2 * Real.pi) - Real.log (j : ℝ) / (2 * Real.pi)| = |1 / (2 * Real.pi * c)| * |(j : ℝ) - i| := by
    intros i j hi hj hij
    have h_mean_value : ∃ c ∈ Set.Ioo (i : ℝ) (j : ℝ), deriv (fun x => Real.log x / (2 * Real.pi)) c = (Real.log (j : ℝ) / (2 * Real.pi) - Real.log (i : ℝ) / (2 * Real.pi)) / ((j : ℝ) - (i : ℝ)) := by
      apply_rules [ exists_deriv_eq_slope ];
      · norm_cast;
      · exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.div ( Real.continuousAt_log ( by linarith [ hx.1, show ( i : ℝ ) ≥ 2 by norm_cast ] ) ) continuousAt_const ( by positivity );
      · exact DifferentiableOn.div_const ( DifferentiableOn.log differentiableOn_id fun x hx => ne_of_gt <| lt_trans ( by positivity ) hx.1 ) _;
    obtain ⟨ c, hc₁, hc₂ ⟩ := h_mean_value; use c; simp_all +decide [ division_def, mul_comm ] ; ring_nf at *; aesop;
    rw [ mul_inv_cancel₀ ( ne_of_gt ( abs_pos.mpr ( by linarith ) ) ), one_mul ] ; rw [ ← abs_neg ] ; ring;
  cases lt_trichotomy i j <;> aesop;
  · rcases h_mean_value val val_1 ( by linarith [ property.1 ] ) ( by linarith [ property_1.1 ] ) h with ⟨ c, hc₁, hc₂ ⟩;
    -- Since $c \leq N_K$, we have $|c| \leq N_K$.
    have hc_bound : |c| ≤ Nat.floor (Real.exp (2 * Real.pi * K)) := by
      rw [ abs_of_nonneg ( by linarith ) ];
      have hc_bound : val_1 ≤ Nat.floor (Real.exp (2 * Real.pi * K)) := by
        unfold Nodes at property_1; aesop;
        exact Nat.le_floor <| by rw [ show xi_n val_1 = Real.log val_1 / ( 2 * Real.pi ) by rfl ] at right; rw [ div_le_iff₀ <| by positivity ] at right; rw [ ← Real.log_le_log_iff ( by positivity ) <| by positivity ] ; simpa using by nlinarith [ Real.pi_pos, mul_div_cancel₀ ( Real.log val_1 ) ( by positivity : ( 2 * Real.pi ) ≠ 0 ) ] ;
      exact le_trans hc₁.2.le ( mod_cast hc_bound );
    -- Since $|c| \leq N_K$, we have $|c|⁻¹ \geq 1 / (N_K + 1)$.
    have hc_inv_bound : |c|⁻¹ ≥ 1 / (Nat.floor (Real.exp (2 * Real.pi * K)) + 1) := by
      exact le_trans ( by norm_num ) ( inv_anti₀ ( abs_pos.mpr ( by linarith ) ) ( le_trans hc_bound ( le_add_of_nonneg_right zero_le_one ) ) );
    unfold delta_K; aesop;
    rw [ abs_sub_comm ] ; unfold xi_n; aesop;
    rw [ abs_of_nonneg Real.pi_pos.le ] ; nlinarith [ show 0 ≤ |( val_1 : ℝ ) - val| * ( Real.pi⁻¹ * 2⁻¹ ) by positivity ];
  · cases h_mean_value _ _ property_1.1 property.1 h_2 ; aesop;
    -- Since $w \leq \lfloor e^{2\pi K} \rfloor$, we have $|w| \leq \lfloor e^{2\pi K} \rfloor + 1$.
    have h_w_le : |w| ≤ Nat.floor (Real.exp (2 * Real.pi * K)) + 1 := by
      have h_w_le : val ≤ Nat.floor (Real.exp (2 * Real.pi * K)) := by
        refine' Nat.le_floor _;
        have := property.2;
        rw [ show xi_n val = Real.log val / ( 2 * Real.pi ) by rfl ] at this;
        rw [ div_le_iff₀ ( by positivity ) ] at this;
        rw [ ← Real.log_le_iff_le_exp ( by norm_cast; linarith [ property.1 ] ) ] ; linarith;
      rw [ abs_of_nonneg ] <;> linarith [ show ( val : ℝ ) ≤ ⌊Real.exp ( 2 * Real.pi * K ) ⌋₊ by exact_mod_cast h_w_le ];
    -- Substitute the bound on $|w|$ into the inequality.
    have h_subst : |Real.log (val_1 : ℝ) / (2 * Real.pi) - Real.log (val : ℝ) / (2 * Real.pi)| ≥ (1 / (2 * Real.pi * (Nat.floor (Real.exp (2 * Real.pi * K)) + 1))) * |(val : ℝ) - val_1| := by
      aesop;
      gcongr;
      · exact abs_pos.mpr ( by linarith [ show ( val_1 : ℝ ) ≥ 2 by exact_mod_cast property_1.1 ] );
      · rw [ abs_of_nonneg Real.pi_pos.le ];
    convert h_subst.le using 1 <;> norm_num [ delta_K ] ; ring;
    rw [ abs_sub_comm ] ; unfold xi_n ; ring;

/-
The sum of the heat kernel over off-diagonal nodes is bounded by S_K.
-/
open scoped Matrix.Norms.L2Operator

lemma sum_heat_kernel_bound (K t : ℝ) (hK : K ≥ 1) (ht : t > 0) (i : Nodes K) :
    ∑ j ∈ Finset.univ.erase i, heat_kernel t (xi_n i) (xi_n j) ≤ S_K K t := by
  -- Using the separation lemma, $|\xi_n i - \xi_n j| \geq |i - j| \delta_K$.
  have h_separation : ∀ j : Nodes K, j ≠ i → heat_kernel t (xi_n i) (xi_n j) ≤ Real.exp (-((|↑i - ↑j| : ℝ) * delta_K K)^2 / (4 * t)) := by
    intros j hj;
    refine' Real.exp_le_exp.mpr _;
    field_simp;
    have := xi_n_separation K hK i j;
    nlinarith [ abs_mul_abs_self ( xi_n i - xi_n j ), show 0 ≤ |( i : ℝ ) - j| * delta_K K by exact mul_nonneg ( abs_nonneg _ ) ( by exact div_nonneg zero_le_one ( by exact mul_nonneg ( by positivity ) ( by positivity ) ) ) ];
  refine le_trans ( Finset.sum_le_sum fun j hj => h_separation j <| Finset.ne_of_mem_erase hj ) ?_;
  -- Since $|i - j| \geq 1$ for $j \neq i$, we can bound the sum by considering the sum over $k = |i - j|$.
  have h_sum_bound : ∑ j ∈ Finset.univ.erase i, Real.exp (-((|↑i - ↑j| : ℝ) * delta_K K)^2 / (4 * t)) ≤ ∑ k ∈ Finset.Ico 1 (Nat.floor (Real.exp (2 * Real.pi * K)) + 1), 2 * Real.exp (-((k : ℝ) * delta_K K)^2 / (4 * t)) := by
    -- For each $k \geq 1$, there are at most two $j$ such that $|i - j| = k$.
    have h_count : ∀ k : ℕ, k ≥ 1 → Finset.card (Finset.filter (fun j : Nodes K => |(i : ℝ) - j| = k) (Finset.univ.erase i)) ≤ 2 := by
      intro k hk;
      have h_count : Finset.card (Finset.filter (fun j : Nodes K => (j : ℝ) = (i : ℝ) + k ∨ (j : ℝ) = (i : ℝ) - k) (Finset.univ.erase i)) ≤ 2 := by
        have h_count : Finset.card (Finset.filter (fun j : Nodes K => (j : ℝ) = (i : ℝ) + k ∨ (j : ℝ) = (i : ℝ) - k) (Finset.univ.erase i)) ≤ Finset.card ({(i : ℝ) + k, (i : ℝ) - k} : Finset ℝ) := by
          have h_count : Finset.image (fun j : Nodes K => (j : ℝ)) (Finset.filter (fun j : Nodes K => (j : ℝ) = (i : ℝ) + k ∨ (j : ℝ) = (i : ℝ) - k) (Finset.univ.erase i)) ⊆ {(i : ℝ) + k, (i : ℝ) - k} := by
            grind;
          exact le_trans ( by rw [ Finset.card_image_of_injective _ fun x y hxy => by aesop ] ) ( Finset.card_le_card h_count );
        exact h_count.trans ( Finset.card_insert_le _ _ );
      convert h_count using 2 ; ext ; norm_num [ abs_eq ] ; aesop;
      · exact Or.inr ( by linarith );
      · exact Or.inl ( by linarith );
    -- Using the count, we can bound the sum.
    have h_sum_bound : ∑ j ∈ Finset.univ.erase i, Real.exp (-((|↑i - ↑j| : ℝ) * delta_K K)^2 / (4 * t)) ≤ ∑ k ∈ Finset.Ico 1 (Nat.floor (Real.exp (2 * Real.pi * K)) + 1), ∑ j ∈ Finset.filter (fun j : Nodes K => |(i : ℝ) - j| = k) (Finset.univ.erase i), Real.exp (-((k : ℝ) * delta_K K)^2 / (4 * t)) := by
      have h_sum_bound : ∑ j ∈ Finset.univ.erase i, Real.exp (-((|↑i - ↑j| : ℝ) * delta_K K)^2 / (4 * t)) = ∑ k ∈ Finset.Ico 1 (Nat.floor (Real.exp (2 * Real.pi * K)) + 1), ∑ j ∈ Finset.filter (fun j : Nodes K => |(i : ℝ) - j| = k) (Finset.univ.erase i), Real.exp (-((|↑i - ↑j| : ℝ) * delta_K K)^2 / (4 * t)) := by
        rw [ ← Finset.sum_biUnion ];
        · rcongr j ; aesop;
          use Int.natAbs (val - val_1);
          aesop;
          · exact Int.natAbs_pos.mpr ( sub_ne_zero_of_ne <| by aesop );
          · refine' Nat.lt_succ_of_le ( Nat.le_floor _ );
            cases abs_cases ( val - val_1 : ℝ ) <;> simp +decide [ * ];
            · have := property.2; have := property_1.2; unfold xi_n at *; aesop;
              rw [ div_le_iff₀ ( by positivity ) ] at *;
              exact le_add_of_le_of_nonneg ( by rw [ ← Real.log_le_iff_le_exp ( Nat.cast_pos.mpr <| Nat.pos_of_ne_zero <| by rintro rfl; exact absurd property <| by unfold Nodes; aesop ) ] ; linarith ) ( Nat.cast_nonneg _ );
            · have := property_1.2;
              unfold xi_n at this;
              rw [ div_le_iff₀ ( by positivity ) ] at this;
              exact le_add_of_le_of_nonneg ( by rw [ ← Real.log_le_log_iff ( by norm_cast; linarith [ property_1.1 ] ) ( by positivity ) ] ; simpa [ mul_comm ] using this ) ( Nat.cast_nonneg _ );
        · exact fun x hx y hy hxy => Finset.disjoint_left.mpr fun z => by aesop;
      rw [h_sum_bound];
      exact Finset.sum_le_sum fun k hk => Finset.sum_le_sum fun j hj => by rw [ Finset.mem_filter.mp hj |>.2 ] ;
    norm_num +zetaDelta at *;
    exact h_sum_bound.trans ( add_le_add_right ( Finset.sum_le_sum fun x hx => mul_le_mul_of_nonneg_right ( mod_cast h_count x <| Finset.mem_Ico.mp hx |>.1 ) <| Real.exp_nonneg _ ) _ );
  -- Let's simplify the sum $\sum_{k=1}^{\lfloor \exp(2\pi K) \rfloor} 2 \exp(-(k \delta_K)^2 / (4t))$.
  have h_simplify : ∑ k ∈ Finset.Ico 1 (Nat.floor (Real.exp (2 * Real.pi * K)) + 1), 2 * Real.exp (-((k : ℝ) * delta_K K)^2 / (4 * t)) ≤ 2 * Real.exp (-(delta_K K)^2 / (4 * t)) / (1 - Real.exp (-(delta_K K)^2 / (4 * t))) := by
    have h_geometric_series : ∑ k ∈ Finset.Ico 1 (Nat.floor (Real.exp (2 * Real.pi * K)) + 1), 2 * Real.exp (-((k : ℝ) * delta_K K)^2 / (4 * t)) ≤ 2 * Real.exp (-delta_K K^2 / (4 * t)) * ∑ k ∈ Finset.range (Nat.floor (Real.exp (2 * Real.pi * K))), (Real.exp (-delta_K K^2 / (4 * t)))^k := by
      norm_num [ Finset.mul_sum _ _ _, Finset.sum_Ico_eq_sum_range ];
      norm_num [ mul_assoc, ← Real.exp_nat_mul, ← Real.exp_add ];
      refine Finset.sum_le_sum fun x hx => mul_le_mul_of_nonneg_left ( Real.exp_le_exp.mpr ?_ ) zero_le_two;
      ring_nf;
      nlinarith only [ show 0 ≤ ( x : ℝ ) * delta_K K ^ 2 * t⁻¹ by positivity, show 0 ≤ ( x : ℝ ) ^ 2 * delta_K K ^ 2 * t⁻¹ by positivity ];
    refine le_trans h_geometric_series ?_;
    rw [ div_eq_mul_inv, geom_sum_eq ];
    · rw [ ← neg_div_neg_eq ] ; ring_nf ; norm_num;
      exact mul_nonneg ( mul_nonneg ( Real.exp_nonneg _ ) ( pow_nonneg ( Real.exp_nonneg _ ) _ ) ) ( inv_nonneg.mpr ( sub_nonneg.mpr ( Real.exp_le_one_iff.mpr ( by norm_num; positivity ) ) ) );
    · norm_num;
      exact ⟨ ne_of_gt <| one_div_pos.mpr <| mul_pos ( mul_pos two_pos <| Real.pi_pos ) <| Nat.cast_add_one_pos _, ne_of_gt ht ⟩;
  convert h_sum_bound.trans h_simplify using 1

/-
The absolute row sums of T_P are bounded by w_max + sqrt(w_max) * S_K.
-/
open scoped Matrix.Norms.L2Operator

theorem T_P_row_sum_bound (K t : ℝ) (hK : K ≥ 1) (ht : t > 0) (i : Nodes K) :
    ∑ j, |T_P K t i j| ≤ w_max + Real.sqrt w_max * S_K K t := by
  -- The diagonal term is |T_P i i| = |sqrt(w_i) sqrt(w_i) K_t(xi_i, xi_i)| = |w_i| = w_i <= w_max.
  have h_diag : |T_P K t i i| ≤ w_max := by
    unfold T_P; aesop;
    unfold w_RKHS at *; aesop;
    unfold heat_kernel xi_n; ring_nf; norm_num [ ht.le ] ;
    convert w_RKHS_le_w_max val using 1;
  have h_off_diag : ∑ j ∈ Finset.univ.erase i, |T_P K t i j| ≤ Real.sqrt (w_max) * Real.sqrt (w_max) * ∑ j ∈ Finset.univ.erase i, heat_kernel t (xi_n i) (xi_n j) := by
    -- Since $w_k \leq w_max$, we have $\sqrt{w_i w_j} \leq \sqrt{w_max w_max} = w_max$.
    have h_sqrt_bound : ∀ j ∈ Finset.univ.erase i, Real.sqrt (w_RKHS i.val) * Real.sqrt (w_RKHS j.val) ≤ Real.sqrt (w_max) * Real.sqrt (w_max) := by
      intro j hj; gcongr <;> aesop;
      · exact?;
      · exact?;
    rw [ Finset.mul_sum _ _ _ ] ; gcongr ; aesop;
    refine le_trans ?_ ( mul_le_mul_of_nonneg_right ( h_sqrt_bound _ property_1 a ) <| Real.exp_nonneg _ );
    unfold T_P heat_kernel; norm_num [ abs_mul, abs_of_nonneg, Real.sqrt_nonneg ] ;
  rw [ Real.mul_self_sqrt ] at h_off_diag;
  · have h_off_diag_bound : ∑ j ∈ Finset.univ.erase i, heat_kernel t (xi_n i) (xi_n j) ≤ S_K K t := by
      exact?;
    have h_sqrt_bound : Real.sqrt w_max ≥ w_max := by
      exact Real.le_sqrt_of_sq_le ( by unfold w_max; ring_nf; nlinarith [ Real.add_one_le_exp 1, Real.exp_pos 1, mul_inv_cancel₀ ( ne_of_gt ( Real.exp_pos 1 ) ) ] );
    rw [ ← Finset.sum_erase_add _ _ ( Finset.mem_univ i ) ];
    nlinarith [ show 0 ≤ w_max by exact div_nonneg zero_le_two ( Real.exp_nonneg _ ), show 0 ≤ S_K K t by exact div_nonneg ( mul_nonneg zero_le_two ( Real.exp_nonneg _ ) ) ( sub_nonneg.mpr <| Real.exp_le_one_iff.mpr <| by exact div_nonpos_of_nonpos_of_nonneg ( neg_nonpos.mpr <| sq_nonneg _ ) <| by positivity ) ];
  · exact div_nonneg zero_le_two <| Real.exp_nonneg _

/-
w_max is less than or equal to its square root.
-/
lemma w_max_le_sqrt_w_max : w_max ≤ Real.sqrt w_max := by
  -- Since $e > 2$, we have $2/e < 1$.
  have h_frac_lt_one : 2 / Real.exp 1 < 1 := by
    rw [ div_lt_one ( Real.exp_pos _ ) ] ; exact Real.exp_one_gt_d9.trans_le' <| by norm_num;
  exact Real.le_sqrt_of_sq_le ( by rw [ show w_max = 2 / Real.exp 1 by rfl ] ; nlinarith [ Real.sqrt_nonneg ( 2 / Real.exp 1 ), Real.mul_self_sqrt ( show 0 ≤ 2 / Real.exp 1 by positivity ) ] )

/-
Schur test: The operator norm of a symmetric matrix is bounded by the maximum absolute row sum.
-/
open scoped Matrix.Norms.L2Operator

lemma norm_le_of_row_sum_le_v2 {n : Type*} [Fintype n] [DecidableEq n] (A : Matrix n n ℝ) (hA : A.IsSymm) (C : ℝ) (hC : 0 ≤ C) (h_row : ∀ i, ∑ j, |A i j| ≤ C) : ‖A‖ ≤ C := by
  convert norm_le_of_row_sum_le' A hA C hC h_row

/-
The sum of absolute values of off-diagonal entries of T_P is bounded by w_max * S_K.
-/
open scoped Matrix.Norms.L2Operator

lemma T_P_off_diag_bound (K t : ℝ) (hK : K ≥ 1) (ht : t > 0) (i : Nodes K) :
    ∑ j ∈ Finset.univ.erase i, |T_P K t i j| ≤ w_max * S_K K t := by
  -- The absolute value of the kernel is just the kernel itself since it's always positive.
  have h_kernel_abs : ∀ i j : Nodes K, |T_P K t i j| ≤ w_max * heat_kernel t (xi_n i) (xi_n j) := by
    intros i j
    have h_abs : |T_P K t i j| = Real.sqrt (w_RKHS i) * Real.sqrt (w_RKHS j) * heat_kernel t (xi_n i) (xi_n j) := by
      unfold T_P; aesop;
      rw [ abs_of_nonneg ( Real.sqrt_nonneg _ ), abs_of_nonneg ( Real.sqrt_nonneg _ ), abs_of_nonneg ( show 0 ≤ heat_kernel t ( xi_n val_1 ) ( xi_n val_2 ) from Real.exp_nonneg _ ) ];
    -- Since $w_RKHS n \leq w_max$ for all $n$, we have $\sqrt{w_RKHS i} \leq \sqrt{w_max}$ and $\sqrt{w_RKHS j} \leq \sqrt{w_max}$.
    have h_sqrt_bound : Real.sqrt (w_RKHS i) ≤ Real.sqrt w_max ∧ Real.sqrt (w_RKHS j) ≤ Real.sqrt w_max := by
      exact ⟨ Real.sqrt_le_sqrt <| w_RKHS_le_w_max _, Real.sqrt_le_sqrt <| w_RKHS_le_w_max _ ⟩;
    exact h_abs.symm ▸ mul_le_mul_of_nonneg_right ( by nlinarith [ Real.sqrt_nonneg ( w_RKHS i ), Real.sqrt_nonneg ( w_RKHS j ), Real.mul_self_sqrt ( show 0 ≤ w_max by exact div_nonneg zero_le_two <| Real.exp_nonneg _ ) ] ) ( Real.exp_nonneg _ );
  refine' le_trans ( Finset.sum_le_sum fun j hj => h_kernel_abs i j ) _;
  rw [ ← Finset.mul_sum _ _ _ ];
  exact mul_le_mul_of_nonneg_left ( sum_heat_kernel_bound K t hK ht i ) ( show 0 ≤ w_max by exact div_nonneg zero_le_two <| Real.exp_nonneg _ )

/-
The diagonal entry of T_P is bounded by w_max.
-/
open scoped Matrix.Norms.L2Operator

lemma T_P_diag_bound (K t : ℝ) (hK : K ≥ 1) (ht : t > 0) (i : Nodes K) :
    |T_P K t i i| ≤ w_max := by
  bound;
  convert w_RKHS_le_w_max val using 1;
  unfold T_P w_RKHS; aesop;
  unfold heat_kernel; ring_nf; aesop;

/-
S_K is non-negative.
-/
lemma S_K_nonneg (K t : ℝ) (ht : t > 0) : 0 ≤ S_K K t := by
  exact div_nonneg ( mul_nonneg zero_le_two <| Real.exp_nonneg _ ) <| sub_nonneg.mpr <| Real.exp_le_one_iff.mpr <| by exact div_nonpos_of_nonpos_of_nonneg ( neg_nonpos.mpr <| sq_nonneg _ ) <| by positivity;

/-
The product of square roots of RKHS weights is bounded by w_max.
-/
lemma sqrt_w_RKHS_mul_sqrt_w_RKHS_le_w_max (i j : ℕ) :
    Real.sqrt (w_RKHS i) * Real.sqrt (w_RKHS j) ≤ w_max := by
  -- Since $w_RKHS(n) \leq w_{max}$ for all $n$, we have $\sqrt{w_RKHS(i)} \leq \sqrt{w_{max}}$ and $\sqrt{w_RKHS(j)} \leq \sqrt{w_{max}}$.
  have h_sqrt_le_sqrt_wmax : Real.sqrt (w_RKHS i) ≤ Real.sqrt w_max ∧ Real.sqrt (w_RKHS j) ≤ Real.sqrt w_max := by
    exact ⟨ Real.sqrt_le_sqrt <| w_RKHS_le_w_max i, Real.sqrt_le_sqrt <| w_RKHS_le_w_max j ⟩;
  exact le_trans ( mul_le_mul h_sqrt_le_sqrt_wmax.1 h_sqrt_le_sqrt_wmax.2 ( by positivity ) ( by positivity ) ) ( by nlinarith [ Real.mul_self_sqrt ( show 0 ≤ w_max by exact div_nonneg zero_le_two ( Real.exp_nonneg _ ) ) ] )

/-
Bound on the sum of RKHS weights for the early block.
-/
theorem RKHS_early_block (N : ℕ) (hN : N ≥ 2) :
    ∑ n ∈ Finset.Icc 2 N, w_RKHS n ≤ 2 * Real.sqrt N * Real.log N := by
  -- We'll use that $\sum_{n=2}^N \frac{\log n}{\sqrt{n}} \leq \sum_{n=2}^N \frac{\log N}{\sqrt{n}}$.
  have h_sum_bound : ∑ n ∈ Finset.Icc 2 N, Real.log n / Real.sqrt n ≤ ∑ n ∈ Finset.Icc 2 N, Real.log N / Real.sqrt n := by
    gcongr <;> aesop;
    linarith;
  -- We'll use that $\sum_{n=2}^N \frac{1}{\sqrt{n}} \leq 2\sqrt{N}$.
  have h_sum_sqrt_bound : ∑ n ∈ Finset.Icc 2 N, (1 / Real.sqrt n : ℝ) ≤ 2 * Real.sqrt N := by
    -- We'll use that $\sum_{n=2}^N \frac{1}{\sqrt{n}} \leq 2\sqrt{N}$ by comparing it to the integral of $\frac{1}{\sqrt{x}}$.
    have h_integral_bound : ∑ n ∈ Finset.Icc 2 N, (1 / Real.sqrt n : ℝ) ≤ ∑ n ∈ Finset.Icc 2 N, (2 * (Real.sqrt n - Real.sqrt (n - 1))) := by
      exact Finset.sum_le_sum fun x hx => by rw [ div_le_iff₀ ] <;> nlinarith only [ Real.sqrt_nonneg ( x : ℝ ), Real.sq_sqrt ( show ( x : ℝ ) ≥ 0 by positivity ), Real.sq_sqrt ( show ( x - 1 : ℝ ) ≥ 0 by norm_num; linarith [ Finset.mem_Icc.mp hx ] ) ] ;
    -- Notice that $\sum_{n=2}^N (2 * (\sqrt{n} - \sqrt{n-1}))$ is a telescoping series.
    have h_telescoping : ∑ n ∈ Finset.Icc 2 N, (2 * (Real.sqrt n - Real.sqrt (n - 1))) = 2 * (Real.sqrt N - Real.sqrt 1) := by
      exact Nat.le_induction ( by norm_num ) ( fun k hk ih => by erw [ Finset.sum_Ioc_succ_top ( by linarith ), ih ] ; push_cast ; ring ) N hN;
    exact h_integral_bound.trans <| h_telescoping.symm ▸ by norm_num;
  norm_num [ div_eq_mul_inv, ← Finset.mul_sum _ _ _ ] at *;
  exact le_trans ( Finset.sum_le_sum fun _ _ => show w_RKHS _ ≤ Real.log _ * ( Real.sqrt _ ) ⁻¹ from div_le_div_of_nonneg_right ( show ( ArithmeticFunction.vonMangoldt _ ) ≤ Real.log _ from by
                                                                                                                                    exact? ) <| Real.sqrt_nonneg _ ) <| h_sum_bound.trans <| by nlinarith [ Real.log_nonneg <| Nat.one_le_cast.2 <| by linarith ] ;

/-
Tail bound for the RKHS sum.
-/
theorem RKHS_tail_bound (t N : ℝ) (ht : t > 0) (hN : N ≥ 2) :
    ∃ C > 0, ∑' n : {n : ℕ | n > N},
      w_RKHS n * Real.exp (-4 * Real.pi^2 * t * (Real.log n)^2) ≤
      C * Real.exp (-4 * Real.pi^2 * t * (Real.log N)^2) / t := by
  refine' ⟨ ( ∑' n : { n : ℕ | ( n : ℝ ) > N }, w_RKHS n * Real.exp ( -4 * Real.pi ^ 2 * t * Real.log n ^ 2 ) ) * t / Real.exp ( -4 * Real.pi ^ 2 * t * Real.log N ^ 2 ) + 1, _, _ ⟩;
  · exact add_pos_of_nonneg_of_pos ( div_nonneg ( mul_nonneg ( tsum_nonneg fun _ => mul_nonneg ( show 0 ≤ w_RKHS _ from div_nonneg ( by exact_mod_cast ArithmeticFunction.vonMangoldt_nonneg ) ( Real.sqrt_nonneg _ ) ) ( Real.exp_nonneg _ ) ) ht.le ) ( Real.exp_nonneg _ ) ) zero_lt_one;
  · field_simp;
    exact le_add_of_nonneg_right ( Real.exp_nonneg _ )