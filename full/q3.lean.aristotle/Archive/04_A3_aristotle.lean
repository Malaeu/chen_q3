/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f62e1767-5adb-4d52-99cc-58831c8201c6

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
-- open scoped Nat  -- commented: conflicts with φ notation
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions of Total Variation, Scaled Mollifier, and Smoothed Symbol.
-/
open Set Function MeasureTheory Filter TopologicalSpace Real


variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]

/-- Total variation of a function on the circle, defined via its periodic extension on [0, 2π]. -/
def totalVariation (a : ℝ → ℝ) : ℝ :=
  (eVariationOn a (Icc 0 (2 * π))).toReal

/-- The scaled mollifier K_t(θ) = t⁻¹ K(θ/t). -/
def scaledMollifier (K : ℝ → ℝ) (t : ℝ) (θ : ℝ) : ℝ :=
  t⁻¹ * K (θ / t)

/-- Smoothed symbol P_A(θ) = (a * K_t)(θ).
    We define this as convolution on ℝ. -/
def smoothedSymbol (a : ℝ → ℝ) (K : ℝ → ℝ) (t : ℝ) (θ : ℝ) : ℝ :=
  ∫ x, a (θ - x) * scaledMollifier K t x

/-
Lemma A3.Sup-Bounds (Uniform Bounds for Smoothed Symbol)
Part 1: $\|P_A\|_{L^\infty} \leq \|a\|_{L^\infty}$
-/
open Set Function MeasureTheory Filter TopologicalSpace Real


/-- L∞ norm of a function on ℝ. -/
def L_infty_norm (f : ℝ → ℝ) : ℝ := sSup (range (fun x => |f x|))

/-- L1 norm of a function on ℝ. -/
def L1_norm (f : ℝ → ℝ) : ℝ := ∫ x, |f x|

lemma A3_sup_bound (a : ℝ → ℝ) (ha_bdd : ∃ M, ∀ x, |a x| ≤ M)
    (K : ℝ → ℝ) (hK_nonneg : ∀ x, 0 ≤ K x) (hK_int : ∫ x, K x = 1)
    (t : ℝ) (ht : t > 0) :
    L_infty_norm (smoothedSymbol a K t) ≤ L_infty_norm a := by
  -- By definition of $L_infty_norm$, we need to show that $|P_A(\theta)| \leq \|a\|_{L^\infty}$ for all $\theta$.
  have h_le : ∀ θ : ℝ, abs (smoothedSymbol a K t θ) ≤ L_infty_norm a * (∫ x, scaledMollifier K t x) := by
    aesop;
    -- By definition of $L_infty_norm$, we know that $|a(y)| \leq L_infty_norm a$ for all $y$.
    have h_le : ∀ y : ℝ, abs (a y) ≤ L_infty_norm a := by
      exact fun x => le_csSup ⟨ w, Set.forall_mem_range.mpr h ⟩ ⟨ x, rfl ⟩;
    rw [ ←MeasureTheory.integral_const_mul ];
    refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm ( _ : ℝ → ℝ ) ) ( MeasureTheory.integral_mono_of_nonneg _ _ _ );
    · exact Filter.Eventually.of_forall fun x => norm_nonneg _;
    · refine' MeasureTheory.Integrable.const_mul _ _;
      refine' MeasureTheory.Integrable.const_mul _ _;
      exact MeasureTheory.Integrable.comp_div ( MeasureTheory.integrable_of_integral_eq_one hK_int ) ht.ne';
    · filter_upwards [ ] with x using by simpa only [ Real.norm_eq_abs, abs_mul, abs_of_nonneg ( show 0 ≤ scaledMollifier K t x from mul_nonneg ( inv_nonneg.2 ht.le ) ( hK_nonneg _ ) ) ] using mul_le_mul_of_nonneg_right ( h_le _ ) ( mul_nonneg ( inv_nonneg.2 ht.le ) ( hK_nonneg _ ) ) ;
  -- Since $\int K_t = 1$, we have $\int x, scaledMollifier K t x = 1$.
  have h_int : ∫ x, scaledMollifier K t x = 1 := by
    bound;
    simp_all +decide [ MeasureTheory.integral_const_mul, MeasureTheory.integral_mul_const, ht.ne.symm, scaledMollifier ];
    rw [ inv_mul_eq_div, div_eq_iff ht.ne', MeasureTheory.Measure.integral_comp_div ] ; aesop;
  rw [ L_infty_norm ] at * ; aesop;
  exact csSup_le ( Set.range_nonempty _ ) ( Set.forall_mem_range.mpr h_le )

/-
Helper lemma: $\|K\|_\infty \le \|K'\|_{L^1}$.
-/
open Set Function MeasureTheory Filter TopologicalSpace Real


lemma L_infty_norm_le_L1_norm_deriv (K : ℝ → ℝ) (hK_diff : Differentiable ℝ K)
    (hK_vanish : Tendsto K (cocompact ℝ) (nhds 0))
    (hK_deriv_int : Integrable (deriv K)) :
    L_infty_norm K ≤ L1_norm (deriv K) := by
  refine' csSup_le _ _ <;> aesop;
  · exact ⟨ _, ⟨ 0, rfl ⟩ ⟩;
  · -- Since $K$ is differentiable and its derivative is integrable, we can apply the fundamental theorem of calculus to get $K(w) = \int_{-\infty}^w K'(x) \, dx$.
    have hK_integral : ∀ w, K w = ∫ x in Set.Iic w, deriv K x := by
      intro w
      have hK_integral : Filter.Tendsto (fun b => ∫ x in b..w, deriv K x) Filter.atBot (nhds (K w)) := by
        have hK_integral : ∀ b w, ∫ x in b..w, deriv K x = K w - K b := by
          intro b w; rw [ intervalIntegral.integral_deriv_eq_sub ] ; aesop;
          exact hK_deriv_int.intervalIntegrable ..;
        simpa [ hK_integral ] using left.const_sub ( K w );
      refine' tendsto_nhds_unique hK_integral _;
      apply_rules [ MeasureTheory.intervalIntegral_tendsto_integral_Iic ];
      · exact hK_deriv_int.integrableOn;
      · exact Filter.tendsto_id;
    rw [ hK_integral, ← Real.norm_eq_abs ];
    refine' MeasureTheory.norm_integral_le_integral_norm _ |> le_trans <| MeasureTheory.setIntegral_le_integral _ _;
    · exact hK_deriv_int.norm;
    · exact Filter.Eventually.of_forall fun x => norm_nonneg _

/-
Helper lemma: $\|K_t\|_\infty \le t^{-1} \|K'\|_{L^1}$.
-/
open Set Function MeasureTheory Filter TopologicalSpace Real


lemma L_infty_norm_scaledMollifier_le (K : ℝ → ℝ) (hK_diff : Differentiable ℝ K)
    (hK_vanish : Tendsto K (cocompact ℝ) (nhds 0))
    (hK_deriv_int : Integrable (deriv K))
    (t : ℝ) (ht : t > 0) :
    L_infty_norm (scaledMollifier K t) ≤ t⁻¹ * L1_norm (deriv K) := by
  convert mul_le_mul_of_nonneg_left ( L_infty_norm_le_L1_norm_deriv ( K ∘ fun x => x / t ) ?_ ?_ ?_ ) ( inv_nonneg.2 ht.le ) using 1;
  · unfold L_infty_norm; aesop;
    unfold scaledMollifier; norm_num [ abs_mul, abs_inv, ht.ne' ] ; rw [ ← smul_eq_mul, ← Real.sSup_smul_of_nonneg ] ; ring ;
    · norm_num [ mul_comm, abs_of_pos ht, Set.smul_set_range ];
    · positivity;
  · norm_num [ L1_norm, Function.comp ];
    -- By definition of composition of functions, we have $\frac{d}{dx}(K(x/t)) = \frac{1}{t} K'(x/t)$.
    have h_comp : ∀ x, deriv (K ∘ (fun x => x / t)) x = (1 / t) * deriv K (x / t) := by
      intro x; erw [ deriv_comp ] <;> norm_num [ hK_diff.differentiableAt, ht.ne' ] ; ring;
    simp +decide [ h_comp, abs_mul, abs_inv, ht.ne' ];
    rw [ MeasureTheory.integral_const_mul, MeasureTheory.Measure.integral_comp_div ( fun x => |deriv K x| ) ] ; norm_num [ abs_of_pos ht, ht.ne' ];
  · exact hK_diff.comp ( differentiable_id.div_const _ );
  · simp +zetaDelta at *;
    exact ⟨ hK_vanish.1.comp <| Filter.tendsto_id.atBot_mul_const <| by positivity, hK_vanish.2.comp <| Filter.tendsto_id.atTop_mul_const <| by positivity ⟩;
  · -- The derivative of $K \circ (x / t)$ is $(deriv K) \circ (x / t) * (1 / t)$.
    have h_deriv_comp : deriv (K ∘ (fun x => x / t)) = fun x => (deriv K) (x / t) * (1 / t) := by
      ext x; erw [ deriv_comp ] <;> aesop;
    aesop;
    exact MeasureTheory.Integrable.mul_const ( hK_deriv_int.comp_div ( by positivity ) ) _

/-
Derivative of scaled mollifier.
-/
lemma deriv_scaledMollifier (K : ℝ → ℝ) (hK_diff : Differentiable ℝ K) (t : ℝ) (ht : t ≠ 0) :
    deriv (scaledMollifier K t) = fun x => t⁻¹ * scaledMollifier (deriv K) t x := by
  unfold scaledMollifier; aesop;
  ext x; erw [ deriv_comp ] <;> norm_num [ hK_diff.differentiableAt, ht ] ; ring;

/-
L1 norm of scaled mollifier is invariant.
-/
open Set Function MeasureTheory Filter TopologicalSpace Real


lemma L1_norm_scaledMollifier (f : ℝ → ℝ) (t : ℝ) (ht : t > 0) :
    L1_norm (scaledMollifier f t) = L1_norm f := by
  -- By definition of scaledMollifier, we have $t^{-1} f(x/t) = f(x/t) / t$.
  unfold L1_norm scaledMollifier;
  simp +decide [ abs_mul, ht.ne', MeasureTheory.integral_const_mul ];
  rw [ MeasureTheory.Measure.integral_comp_div ( fun x => |f x| ) ] ; norm_num [ ht.ne' ]

/-
The integral over one period of the periodized absolute value of a function equals the L1 norm of the function.
-/
open Set Function MeasureTheory Filter TopologicalSpace Real


/-- Periodization of a function f with period T. -/
def periodize (f : ℝ → ℝ) (T : ℝ) (x : ℝ) : ℝ := ∑' k : ℤ, f (x - k * T)

lemma integral_sum_periodize_abs_eq_L1_norm (f : ℝ → ℝ) (T : ℝ) (hT : T > 0) (hf : Integrable f) :
    ∫ x in (0)..T, ∑' k : ℤ, |f (x - k * T)| = L1_norm f := by
  -- Applying the periodicity property of the integral, we can split the integral into a sum of integrals over each period.
  have h_split : ∫ x in (0 : ℝ)..T, ∑' k : ℤ, |f (x - k * T)| = ∑' k : ℤ, ∫ x in (0 : ℝ)..T, |f (x - k * T)| := by
    rw [ intervalIntegral.integral_of_le hT.le, MeasureTheory.integral_tsum ];
    · simp +decide only [intervalIntegral.integral_of_le hT.le];
    · exact fun i => MeasureTheory.Integrable.aestronglyMeasurable ( hf.norm.comp_sub_right _ ) |> fun h => h.mono_measure <| MeasureTheory.Measure.restrict_le_self;
    · -- The series $\sum_{k=-\infty}^{\infty} \int_{0}^{T} |f(x - kT)| \, dx$ is absolutely convergent because $|f(x - kT)|$ is integrable.
      have h_abs_conv : Summable (fun k : ℤ => ∫ x in (Set.Ioc 0 T), |f (x - k * T)|) := by
        -- We'll use the fact that if the function $|f|$ is integrable, then the series $\sum_{k=-\infty}^{\infty} \int_0^T |f(x - kT)| \, dx$ converges.
        have h_integrable : Summable (fun k : ℤ => ∫ x in (k * T)..((k + 1) * T), |f x|) := by
          have h_integrable : ∫ x, |f x| = ∑' k : ℤ, ∫ x in (k * T)..((k + 1) * T), |f x| := by
            have h_sum : ∫ x, |f x| = ∑' k : ℤ, ∫ x in Set.Ico (k * T) ((k + 1) * T), |f x| := by
              rw [ ← MeasureTheory.integral_iUnion ] <;> norm_num [ add_mul ];
              · rw [ MeasureTheory.Measure.restrict_eq_self_of_ae_mem ] ; aesop;
                exact Filter.Eventually.of_forall fun x => ⟨ ⌊x / T⌋, by nlinarith [ Int.floor_le ( x / T ), mul_div_cancel₀ x hT.ne' ], by nlinarith [ Int.lt_floor_add_one ( x / T ), mul_div_cancel₀ x hT.ne' ] ⟩;
              · exact fun i j hij => Set.disjoint_left.mpr fun x hx₁ hx₂ => hij <| Int.le_antisymm ( Int.le_of_lt_add_one <| by rw [ ← @Int.cast_lt ℝ ] ; push_cast; nlinarith [ hx₁.1, hx₁.2, hx₂.1, hx₂.2 ] ) ( Int.le_of_lt_add_one <| by rw [ ← @Int.cast_lt ℝ ] ; push_cast; nlinarith [ hx₁.1, hx₁.2, hx₂.1, hx₂.2 ] );
              · exact hf.abs.integrableOn;
            exact h_sum.trans ( tsum_congr fun k => by rw [ ← MeasureTheory.integral_Icc_eq_integral_Ico, MeasureTheory.integral_Icc_eq_integral_Ioc, intervalIntegral.integral_of_le ] ; linarith );
          contrapose! h_integrable;
          rw [ tsum_eq_zero_of_not_summable h_integrable ] ; norm_num;
          rw [ MeasureTheory.integral_eq_zero_iff_of_nonneg ];
          · intro H; simp_all +decide [ Filter.EventuallyEq, MeasureTheory.integral_eq_zero_of_ae ] ;
            exact h_integrable <| ⟨ _, hasSum_single 0 fun k hk => by rw [ intervalIntegral.integral_congr_ae <| by filter_upwards [ H ] with x hx; aesop ] ; norm_num ⟩;
          · exact fun x => abs_nonneg _;
          · exact hf.abs;
        convert h_integrable.comp_injective ( show Function.Injective ( fun k : ℤ => -k ) from neg_injective ) using 2 ; aesop;
        rw [ ← intervalIntegral.integral_of_le ( by linarith ) ] ; convert intervalIntegral.integral_comp_sub_right _ ( x * T ) using 2 <;> ring;
      refine' ne_of_lt ( lt_of_le_of_lt ( ENNReal.tsum_le_tsum fun k => _ ) _ );
      use fun k => ENNReal.ofReal ( ∫ x in Set.Ioc 0 T, |f ( x - k * T )| );
      · rw [ MeasureTheory.ofReal_integral_eq_lintegral_ofReal ];
        · norm_num [ ENNReal.ofReal ];
          norm_cast;
        · exact MeasureTheory.Integrable.abs ( hf.comp_sub_right _ |> MeasureTheory.Integrable.integrableOn );
        · exact Filter.Eventually.of_forall fun x => abs_nonneg _;
      · rw [ ← ENNReal.ofReal_tsum_of_nonneg ] <;> aesop;
        exact MeasureTheory.integral_nonneg fun x => abs_nonneg _;
  -- We can express the integral over the entire real line as the sum of integrals over each period.
  have h_periodic : ∫ x in Set.univ, |f x| = ∑' k : ℤ, ∫ x in (k * T)..((k + 1) * T), |f x| := by
    have h_periodic : ∫ x in Set.univ, |f x| = ∑' k : ℤ, ∫ x in Set.Ico (k * T) ((k + 1) * T), |f x| := by
      rw [ ← MeasureTheory.integral_iUnion ];
      · rw [ show ( ⋃ n : ℤ, Set.Ico ( n * T ) ( ( n + 1 ) * T ) ) = Set.univ from Set.eq_univ_of_forall fun x => by exact Set.mem_iUnion.2 ⟨ ⌊x / T⌋, ⟨ by nlinarith [ Int.floor_le ( x / T ), mul_div_cancel₀ x hT.ne' ], by nlinarith [ Int.lt_floor_add_one ( x / T ), mul_div_cancel₀ x hT.ne' ] ⟩ ⟩ ];
      · exact fun k => measurableSet_Ico;
      · exact fun i j hij => Set.disjoint_left.mpr fun x hx₁ hx₂ => hij <| Int.le_antisymm ( Int.le_of_lt_add_one <| by { rw [ ← @Int.cast_lt ℝ ] ; push_cast; nlinarith [ hx₁.1, hx₁.2, hx₂.1, hx₂.2 ] } ) ( Int.le_of_lt_add_one <| by { rw [ ← @Int.cast_lt ℝ ] ; push_cast; nlinarith [ hx₁.1, hx₁.2, hx₂.1, hx₂.2 ] } );
      · exact hf.abs.integrableOn;
    exact h_periodic.trans ( tsum_congr fun k => by rw [ ← MeasureTheory.integral_Icc_eq_integral_Ico, MeasureTheory.integral_Icc_eq_integral_Ioc, intervalIntegral.integral_of_le ] ; linarith );
  -- By substitution using $ u = x - kT $, we can transform the integral over $[kT, (k+1)T]$ to an integral over $[0, T]$.
  have h_subst : ∀ k : ℤ, ∫ x in (k * T)..((k + 1) * T), |f x| = ∫ x in (0 : ℝ)..T, |f (x + k * T)| := by
    intro k; rw [ intervalIntegral.integral_comp_add_right fun x => |f x| ] ; ring;
  aesop;
  convert h_periodic using 1;
  rw [ ← Equiv.tsum_eq ( Equiv.neg ( ℤ ) ) ] ; aesop

/-
Integral of shifted function over period equals integral of function over shifted period.
-/
open Set Function MeasureTheory Filter TopologicalSpace Real


lemma integral_shift_period (f : ℝ → ℝ) (T : ℝ) (k : ℤ) :
    ∫ x in (0)..T, |f (x - k * T)| = ∫ x in (-k * T)..(T - k * T), |f x| := by
  convert intervalIntegral.integral_comp_sub_right _ ( k * T ) using 2 <;> ring

/-
L1 norm of periodization is bounded by L1 norm of original function.
-/
open Set Function MeasureTheory Filter TopologicalSpace Real


lemma periodize_L1_le (f : ℝ → ℝ) (T : ℝ) (hT : T > 0) (hf : Integrable f) :
    ∫ x in (0)..T, |periodize f T x| ≤ L1_norm f := by
  rw [ intervalIntegral.integral_of_le hT.le ];
  -- Applying the triangle inequality to the integral, we get:
  have h_triangle : ∫ x in Set.Ioc 0 T, |∑' k : ℤ, f (x - k * T)| ≤ ∫ x in Set.Ioc 0 T, ∑' k : ℤ, |f (x - k * T)| := by
    refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
    · exact Filter.Eventually.of_forall fun x => abs_nonneg _;
    · have h_integrable : ∫ x in Set.Ioc 0 T, ∑' k : ℤ, |f (x - k * T)| = ∫ x, |f x| := by
        convert integral_sum_periodize_abs_eq_L1_norm f T hT hf using 1;
        rw [ intervalIntegral.integral_of_le hT.le ];
      contrapose! h_integrable;
      rw [ MeasureTheory.integral_undef h_integrable ] ; norm_num;
      rw [ eq_comm, MeasureTheory.integral_eq_zero_iff_of_nonneg ];
      · rw [ Filter.EventuallyEq, MeasureTheory.ae_iff ] ; aesop;
        -- Since $f$ is zero almost everywhere, the sum $\sum' k : ℤ, |f (x - k * T)|$ is also zero almost everywhere.
        have h_sum_zero_ae : ∀ᵐ x ∂MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc 0 T), ∑' k : ℤ, |f (x - k * T)| = 0 := by
          rw [ MeasureTheory.ae_restrict_iff' ] <;> aesop;
          -- Since $f$ is zero almost everywhere, the set of $x$ where $f(x - kT) \neq 0$ for some $k$ has measure zero.
          have h_zero_ae : ∀ k : ℤ, MeasureTheory.volume {x : ℝ | f (x - k * T) ≠ 0} = 0 := by
            intro k;
            rw [ show { x : ℝ | ¬f ( x - k * T ) = 0 } = ( fun x => x - k * T ) ⁻¹' { x : ℝ | ¬f x = 0 } by ext; simp +decide ];
            exact?;
          filter_upwards [ MeasureTheory.measure_eq_zero_iff_ae_notMem.mp ( MeasureTheory.measure_iUnion_null fun k : ℤ => h_zero_ae k ) ] with x hx using by aesop;
        exact h_integrable <| MeasureTheory.Integrable.congr ( MeasureTheory.integrable_zero _ _ _ ) <| by filter_upwards [ h_sum_zero_ae ] with x hx; aesop;
      · exact fun x => abs_nonneg _;
      · exact hf.norm;
    · refine' Filter.Eventually.of_forall fun x => _;
      by_cases h : Summable ( fun k : ℤ => f ( x - k * T ) );
      · simpa using norm_tsum_le_tsum_norm ( h.norm );
      · simp_all +decide [ tsum_eq_zero_of_not_summable ];
        exact tsum_nonneg fun _ => abs_nonneg _;
  exact h_triangle.trans ( by simpa only [ intervalIntegral.integral_of_le hT.le ] using le_of_eq ( integral_sum_periodize_abs_eq_L1_norm f T hT hf ) )

/-
Periodization can be written with plus or minus.
-/
open Set Function MeasureTheory Filter TopologicalSpace Real


lemma periodize_eq_sum_add (f : ℝ → ℝ) (T : ℝ) (x : ℝ) :
    periodize f T x = ∑' k : ℤ, f (x + k * T) := by
  rw [ ← Equiv.tsum_eq ( Equiv.neg ( ℤ ) ) ] ; aesop

/-
Integral over R equals sum of integrals over shifted periods.
-/
open Set Function MeasureTheory Filter TopologicalSpace Real


lemma integral_eq_sum_integral_shift (f : ℝ → ℝ) (T : ℝ) (hT : T > 0) (hf : Integrable f) :
    ∫ x, f x = ∑' k : ℤ, ∫ x in (0)..T, f (x + k * T) := by
  -- We'll use the fact that the integral of a function over the entire real line is the sum of its integrals over each period.
  have h_integral_period : ∫ x, f x = ∑' k : ℤ, ∫ x in Set.Ico (k * T) ((k + 1) * T), f x := by
    rw [ ← MeasureTheory.integral_iUnion ];
    · rw [ MeasureTheory.Measure.restrict_eq_self_of_ae_mem ];
      filter_upwards [ ] with x using Set.mem_iUnion.2 ⟨ ⌊x / T⌋, ⟨ by nlinarith [ Int.floor_le ( x / T ), mul_div_cancel₀ x hT.ne' ], by nlinarith [ Int.lt_floor_add_one ( x / T ), mul_div_cancel₀ x hT.ne' ] ⟩ ⟩;
    · exact fun i => measurableSet_Ico;
    · exact fun i j hij => Set.disjoint_left.mpr fun x hx₁ hx₂ => hij <| Int.le_antisymm ( Int.le_of_lt_add_one <| by rw [ ← @Int.cast_lt ℝ ] ; push_cast; nlinarith [ hx₁.1, hx₁.2, hx₂.1, hx₂.2 ] ) ( Int.le_of_lt_add_one <| by rw [ ← @Int.cast_lt ℝ ] ; push_cast; nlinarith [ hx₁.1, hx₁.2, hx₂.1, hx₂.2 ] );
    · exact hf.integrableOn;
  simp_all +decide [ add_mul, ← MeasureTheory.integral_Icc_eq_integral_Ico, MeasureTheory.integral_Icc_eq_integral_Ioc, intervalIntegral.integral_of_le, le_of_lt hT ];
  exact tsum_congr fun k => by rw [ ← intervalIntegral.integral_of_le ( by linarith ), ← intervalIntegral.integral_of_le ( by linarith ) ] ; rw [ intervalIntegral.integral_comp_add_right ] ; ring;