/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f3991944-86d5-4667-93d4-d7d19dc15dab

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
-- open scoped Nat  -- commented: conflicts with φ notation
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of W_K: the cone of even, nonnegative continuous functions supported in [-K, K].
-/
open Set Filter Topology

noncomputable def norm_inf (f : ℝ → ℝ) : ℝ := ⨆ x, |f x|

def W_K (K : ℝ) : Set (ℝ → ℝ) :=
  {Φ | ContinuousOn Φ (Set.Icc (-K) K) ∧
       (∀ x, Φ x = Φ (-x)) ∧
       (∀ x, 0 ≤ Φ x) ∧
       (∀ x, |x| > K → Φ x = 0)}

/-
Definition of W: the union of all W_K.
-/
def W : Set (ℝ → ℝ) := ⋃ K : ℕ, W_K K

/-
Metric structure on W_K induced by the uniform norm.
-/
noncomputable instance (K : ℕ) : PseudoMetricSpace (W_K K) where
  dist f g := norm_inf (f.1 - g.1)
  dist_self := by
    -- The norm of the zero function is zero because the supremum of the absolute values of zero is zero.
    simp [norm_inf]
  dist_comm := by
    -- By definition of norm_inf, we have that for any two functions $f$ and $g$, $|f - g| = |g - f|$.
    simp [norm_inf];
    norm_num [ abs_sub_comm ]
  dist_triangle := by
    bound;
    refine' ciSup_le fun x => _;
    refine' le_trans _ ( add_le_add ( le_ciSup _ x ) ( le_ciSup _ x ) );
    · exact abs_sub_le _ _ _;
    · -- Since $val$ and $val_1$ are continuous on the compact interval $[-K, K]$, they are bounded.
      have h_bdd : ∃ M, ∀ x ∈ Set.Icc (-K : ℝ) K, |val x| ≤ M ∧ |val_1 x| ≤ M := by
        obtain ⟨ M, hM ⟩ := IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) property.1
        obtain ⟨ M', hM' ⟩ := IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) property_1.1
        use max M M'
        intro x hx
        aesop;
      obtain ⟨ M, hM ⟩ := h_bdd; use Max.max ( 2 * M ) 1; rintro _ ⟨ x, rfl ⟩ ; by_cases hx : |x| ≤ K <;> aesop;
      · exact Or.inl ( by linarith [ abs_sub ( val x ) ( val_1 x ), hM x ( by linarith [ abs_le.mp hx ] ) ( by linarith [ abs_le.mp hx ] ) ] );
      · have := property.2.2.2 x; have := property_1.2.2.2 x; aesop;
    · -- Since $val_1$ and $val_2$ are continuous on a compact interval $[-K, K]$, their difference is also continuous and thus bounded.
      have h_diff_bounded : ∃ M, ∀ x ∈ Set.Icc (-K : ℝ) K, |val_1 x - val_2 x| ≤ M := by
        have h_diff_bounded : ContinuousOn (fun x => val_1 x - val_2 x) (Set.Icc (-K : ℝ) K) := by
          exact ContinuousOn.sub property_1.1 property_2.1;
        exact IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) h_diff_bounded;
      obtain ⟨ M, hM ⟩ := h_diff_bounded; use Max.max M 0; rintro x ⟨ y, rfl ⟩ ; by_cases hy : |y| ≤ K <;> aesop;
      · exact Or.inl <| hM y ( neg_le_of_abs_le hy ) ( le_of_abs_le hy );
      · have := property_1.2.2.2 y; have := property_2.2.2.2 y; aesop;
  edist_dist := by
    all_goals generalize_proofs at *;
    exact?

/-
Definition of WeilClass as a subtype, equipped with the inductive limit topology from W_K.
-/
def WeilClass := { f : ℝ → ℝ // f ∈ W }

instance : TopologicalSpace WeilClass :=
  ⨆ K : ℕ, TopologicalSpace.coinduced (fun (f : W_K K) => (⟨f.1, Set.mem_iUnion.mpr ⟨K, f.2⟩⟩ : WeilClass)) inferInstance

/-
Opaque constants representing the Archimedean margin, the prime contraction norm, and the Lipschitz property of Q.
-/
opaque c_arch : ℕ → ℝ
opaque T_P_norm : ℕ → ℝ
opaque Lipschitz_Q (K : ℕ) : Prop

/-
Redefining W_K spaces with explicit uniform topology and WeilClass as their inductive limit.
-/
structure W_K_Struct (K : ℕ) where
  val : ℝ → ℝ
  property : val ∈ W_K K

noncomputable instance (K : ℕ) : PseudoMetricSpace (W_K_Struct K) where
  dist f g := norm_inf (f.val - g.val)
  dist_self := by
    intros x
    simp [norm_inf]
  dist_comm := by
    intros x y
    simp [norm_inf]
    congr; funext z
    exact abs_sub_comm _ _
  dist_triangle := by
    intros x y z
    simp [norm_inf]
    -- We need to show ⨆ a, |x a - z a| ≤ (⨆ a, |x a - y a|) + (⨆ a, |y a - z a|)
    -- This follows from triangle inequality and properties of sup
    refine' ciSup_le _;
    intro a;
    refine' le_trans _ ( add_le_add ( le_ciSup _ a ) ( le_ciSup _ a ) );
    · exact abs_sub_le _ _ _;
    · -- Since $x$ and $y$ are continuous on the compact interval $[-K, K]$, their difference $x - y$ is also continuous on $[-K, K]$.
      have h_cont : ContinuousOn (fun x_1 => x.val x_1 - y.val x_1) (Set.Icc (-K : ℝ) K) := by
        exact ContinuousOn.sub x.2.1 y.2.1;
      obtain ⟨ M, hM ⟩ := IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) h_cont;
      refine' ⟨ Max.max M 1, Set.forall_mem_range.2 fun x_1 => _ ⟩;
      by_cases hx : |x_1| ≤ K <;> aesop;
      · exact Or.inl <| hM x_1 ( neg_le_of_abs_le hx ) ( le_of_abs_le hx );
      · exact Or.inr ( by rw [ x.2.2.2.2 x_1 ( by linarith ), y.2.2.2.2 x_1 ( by linarith ) ] ; norm_num );
    · -- Since $y$ and $z$ are continuous functions on a compact interval, their difference is also continuous and hence bounded.
      have h_cont : ContinuousOn (fun x => y.val x - z.val x) (Set.Icc (-K : ℝ) K) := by
        exact ContinuousOn.sub y.2.1 z.2.1;
      obtain ⟨ M, hM ⟩ := IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) h_cont;
      refine' ⟨ Max.max M 1, Set.forall_mem_range.2 fun x => _ ⟩;
      by_cases hx : |x| ≤ K;
      · exact le_trans ( hM x ⟨ by linarith [ abs_le.mp hx ], by linarith [ abs_le.mp hx ] ⟩ ) ( le_max_left _ _ );
      · have := y.2.2.2.2 x; have := z.2.2.2.2 x; aesop
  edist_dist := by
    intros x y
    exact (ENNReal.ofReal_eq_coe_nnreal _).symm

instance (K : ℕ) : TopologicalSpace (W_K_Struct K) :=
  PseudoMetricSpace.toUniformSpace.toTopologicalSpace

def WeilClass_Uniform := { f : ℝ → ℝ // f ∈ W }

instance : TopologicalSpace WeilClass_Uniform :=
  ⨆ K : ℕ, TopologicalSpace.coinduced (fun (f : W_K_Struct K) => (⟨f.val, Set.mem_iUnion.mpr ⟨K, f.property⟩⟩ : WeilClass_Uniform)) inferInstance

/-
If Q is Lipschitz on each W_K, then it is continuous on the Weil class.
-/
theorem T5_continuous_suffices (Q : (ℝ → ℝ) → ℝ)
    (hLip : ∀ K : ℕ, ∃ L_K > 0, ∀ Φ₁ Φ₂ : W_K_Struct K,
      |Q Φ₁.val - Q Φ₂.val| ≤ L_K * dist Φ₁ Φ₂) :
    Continuous (fun (w : WeilClass_Uniform) => Q w.1) := by
      -- By definition of WeilClass_Uniform, it is the inductive limit of the spaces W_K_Struct K.
      have h_inductive_limit : ∀ K : ℕ, Continuous (fun (f : W_K_Struct K) => Q (f.val)) := by
        refine' fun K => Metric.continuous_iff.mpr _;
        exact fun f ε hε => by rcases hLip K with ⟨ L, hL₀, hL ⟩ ; exact ⟨ ε / L, div_pos hε hL₀, fun g hg => by rw [ lt_div_iff₀' hL₀ ] at hg; exact lt_of_le_of_lt ( hL g f ) hg ⟩ ;
      rw [ continuous_iSup_dom ] ; aesop;
      exact?

#check LipschitzWith.continuous
#check LipschitzWith

/-
If Q is Lipschitz on each W_K, then it is continuous on the Weil class.
-/
theorem T5_continuous_suffices_v2 (Q : (ℝ → ℝ) → ℝ)
    (hLip : ∀ K : ℕ, ∃ L_K > 0, ∀ Φ₁ Φ₂ : W_K_Struct K,
      |Q Φ₁.val - Q Φ₂.val| ≤ L_K * dist Φ₁ Φ₂) :
    Continuous (fun (w : WeilClass_Uniform) => Q w.1) := by
      -- The topology on WeilClass_Uniform is the inductive limit of the topologies on W_K_Struct.
      apply T5_continuous_suffices Q hLip

/-
If Q is Lipschitz on each W_K, then it is continuous on the Weil class.
-/
theorem T5_continuous_suffices_v3 (Q : (ℝ → ℝ) → ℝ)
    (hLip : ∀ K : ℕ, ∃ L_K > 0, ∀ Φ₁ Φ₂ : W_K_Struct K,
      |Q Φ₁.val - Q Φ₂.val| ≤ L_K * dist Φ₁ Φ₂) :
    Continuous (fun (w : WeilClass_Uniform) => Q w.1) := by
  rw [continuous_iSup_dom]
  intro K
  rw [continuous_coinduced_dom]
  obtain ⟨L, hL_pos, hLip_K⟩ := hLip K
  have h_lip_with : LipschitzWith ⟨L, hL_pos.le⟩ (fun (w : W_K_Struct K) => Q w.val) := by
    rw [lipschitzWith_iff_dist_le_mul]
    intro x y
    specialize hLip_K x y
    exact hLip_K
  exact h_lip_with.continuous

/-
If Q is non-negative on every W_K, then it is non-negative on W.
-/
theorem T5_transfer (Q : (ℝ → ℝ) → ℝ)
    (hPos : ∀ K : ℕ, ∀ Φ : W_K_Struct K, Q Φ.val ≥ 0)
    (hCompat : ∀ K : ℕ, ∀ Φ : W_K_Struct K, ∀ Φ' : W_K_Struct (K + 1),
      Φ.val = Φ'.val → Q Φ.val = Q Φ'.val) :
    ∀ w : WeilClass_Uniform, Q w.1 ≥ 0 := by
  intro w
  obtain ⟨K, hK⟩ := Set.mem_iUnion.mp w.2
  -- We need to construct an element of W_K_Struct K
  let Φ : W_K_Struct K := ⟨w.1, hK⟩
  exact hPos K Φ

/-
If a continuous function is non-negative on a dense set, it is non-negative everywhere.
-/
theorem continuous_nonneg_of_dense_subset_nonneg {X : Type*} [TopologicalSpace X]
    (f : X → ℝ) (hf_cont : Continuous f) (s : Set X) (hs_dense : Dense s)
    (hs_nonneg : ∀ x ∈ s, f x ≥ 0) :
    ∀ x, f x ≥ 0 := by
  intro x
  by_contra h_neg
  push_neg at h_neg
  let U := {y | f y < 0}
  have hU_open : IsOpen U := isOpen_lt hf_cont continuous_const
  have hx_in_U : x ∈ U := h_neg
  have h_inter : (U ∩ s).Nonempty := hs_dense.inter_open_nonempty U hU_open ⟨x, hx_in_U⟩
  obtain ⟨y, hy_U, hy_s⟩ := h_inter
  have h_y_neg : f y < 0 := hy_U
  have h_y_nonneg : f y ≥ 0 := hs_nonneg y hy_s
  linarith

/-
Q is non-negative on the full Weil class W, assuming T5-Compact and properties of the constants.
-/
def T5_compact_Hypothesis (Q : (ℝ → ℝ) → ℝ) : Prop :=
  ∀ K : ℕ, K ≥ 1 →
    c_arch K > 0 →
    T_P_norm K ≤ c_arch K / 4 →
    Lipschitz_Q K →
    ∀ Φ ∈ W_K K, Q Φ ≥ 0

theorem T5_full (Q : (ℝ → ℝ) → ℝ)
    (h_compact : T5_compact_Hypothesis Q)
    (h_zero : ∀ Φ ∈ W_K 0, Q Φ ≥ 0)
    (h_arch_pos : ∀ K, K ≥ 1 → c_arch K > 0)
    (h_prime_bound : ∀ K, K ≥ 1 → T_P_norm K ≤ c_arch K / 4)
    (h_lip_holds : ∀ K, K ≥ 1 → Lipschitz_Q K)
    (h_compat : ∀ K : ℕ, ∀ Φ : W_K_Struct K, ∀ Φ' : W_K_Struct (K + 1),
      Φ.val = Φ'.val → Q Φ.val = Q Φ'.val) :
    ∀ w : WeilClass_Uniform, Q w.1 ≥ 0 := by
      -- Let's choose any $w \in W$.
      intro w
      obtain ⟨K, hK⟩ : ∃ K : ℕ, w.1 ∈ W_K K := by
        exact w.2 |> Set.mem_iUnion.mp |> fun ⟨ K, hK ⟩ => ⟨ K, hK ⟩;
      by_cases hK1 : 1 ≤ K <;> aesop

/-
Q is non-negative on the full Weil class W, assuming T5-Compact and properties of the constants.
-/
theorem T5_full_v2 (Q : (ℝ → ℝ) → ℝ)
    (h_compact : T5_compact_Hypothesis Q)
    (h_zero : ∀ Φ : W_K_Struct 0, Q Φ.val ≥ 0)
    (h_arch_pos : ∀ K, K ≥ 1 → c_arch K > 0)
    (h_prime_bound : ∀ K, K ≥ 1 → T_P_norm K ≤ c_arch K / 4)
    (h_lip_holds : ∀ K, K ≥ 1 → Lipschitz_Q K)
    (h_compat : ∀ K : ℕ, ∀ Φ : W_K_Struct K, ∀ Φ' : W_K_Struct (K + 1),
      Φ.val = Φ'.val → Q Φ.val = Q Φ'.val) :
    ∀ w : WeilClass_Uniform, Q w.1 ≥ 0 := by
      -- Apply the transfer principle `T5_transfer`.
      apply T5_transfer;
      · intro K Φ;
        by_cases hK : 1 ≤ K;
        · exact h_compact K hK ( h_arch_pos K hK ) ( h_prime_bound K hK ) ( h_lip_holds K hK ) Φ.val Φ.property;
        · aesop;
      · assumption