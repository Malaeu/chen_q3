/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 098c51d6-908e-4a65-a15a-65e9060e6358

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
-- open scoped Nat  -- commented: conflicts with φ notation
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions of Fejér kernel, heat kernel, and Fejér-heat atom.
-/
noncomputable def Fejer_kernel (B : ℝ) (x : ℝ) : ℝ :=
  max 0 (1 - |x| / B)

noncomputable def heat_kernel (t : ℝ) (x : ℝ) : ℝ :=
  1 / Real.sqrt (4 * Real.pi * t) * Real.exp (-x^2 / (4 * t))

noncomputable def Fejer_heat_atom (B t τ : ℝ) (ξ : ℝ) : ℝ :=
  Fejer_kernel B (ξ - τ) * heat_kernel t (ξ - τ) +
  Fejer_kernel B (ξ + τ) * heat_kernel t (ξ + τ)

/-
Lemma: For fixed t and τ, the Fejér-heat atom converges uniformly to the symmetrized heat kernel on [-R, R] as B → ∞.
-/
lemma fejer_heat_approx_heat (R t τ : ℝ) (hR : R > 0) (ht : t > 0) (hτ : |τ| ≤ R) (ε : ℝ) (hε : ε > 0) :
    ∃ B > 0, ∀ ξ ∈ Set.Icc (-R) R,
      |Fejer_heat_atom B t τ ξ - (heat_kernel t (ξ - τ) + heat_kernel t (ξ + τ))| < ε := by
        -- Let $M$ be an upper bound for $|heat_kernel t (ξ ± τ)|$ on $[-R, R]$.
        obtain ⟨M, hM⟩ : ∃ M > 0, ∀ ξ ∈ Set.Icc (-R) R, abs (heat_kernel t (ξ - τ)) ≤ M ∧ abs (heat_kernel t (ξ + τ)) ≤ M := by
          -- Since the exponential function is bounded and the denominator is bounded away from zero, the heat kernel is bounded.
          have h_heat_kernel_bounded : ∃ M > 0, ∀ x ∈ Set.Icc (-R - R) (R + R), abs (1 / Real.sqrt (4 * Real.pi * t) * Real.exp (-x^2 / (4 * t))) ≤ M := by
            exact ⟨ 1 / Real.sqrt ( 4 * Real.pi * t ), by positivity, fun x hx => by rw [ abs_of_nonneg ( by positivity ) ] ; exact mul_le_of_le_one_right ( by positivity ) ( Real.exp_le_one_iff.mpr <| by rw [ div_le_iff₀ <| by positivity ] ; nlinarith ) ⟩;
          obtain ⟨ M, hM₀, hM ⟩ := h_heat_kernel_bounded; exact ⟨ M, hM₀, fun ξ hξ => ⟨ by exact hM ( ξ - τ ) ⟨ by linarith [ hξ.1, abs_le.mp hτ ], by linarith [ hξ.2, abs_le.mp hτ ] ⟩, by exact hM ( ξ + τ ) ⟨ by linarith [ hξ.1, abs_le.mp hτ ], by linarith [ hξ.2, abs_le.mp hτ ] ⟩ ⟩ ⟩ ;
        -- For any ξ, τ in [-R, R], the arguments to the Fejér kernel are in [-2R, 2R].
        -- Since Fejer_kernel B x = max(0, 1 - |x|/B), for B large enough (specifically B > 2R), Fejer_kernel B x = 1 - |x|/B on this range.
        obtain ⟨B₀, hB₀⟩ : ∃ B₀ > 0, ∀ B ≥ B₀, ∀ ξ ∈ Set.Icc (-R) R, abs ((Fejer_kernel B (ξ - τ)) - 1) ≤ (2 * R) / B ∧ abs ((Fejer_kernel B (ξ + τ)) - 1) ≤ (2 * R) / B := by
          norm_num +zetaDelta at *;
          use 2 * R + 1, by linarith, fun B hB ξ hξ₁ hξ₂ => ⟨ ?_, ?_ ⟩ <;> unfold Fejer_kernel <;> ring_nf;
          · cases max_cases ( 0 : ℝ ) ( 1 - |ξ - τ| * B⁻¹ ) <;> cases abs_cases ( ξ - τ ) <;> cases abs_cases ( -1 + Max.max 0 ( 1 - |ξ - τ| * B⁻¹ ) ) <;> nlinarith [ inv_pos.mpr ( show 0 < B by linarith ), mul_inv_cancel₀ ( ne_of_gt ( show 0 < B by linarith ) ), abs_le.mp hτ ];
          · cases max_cases ( 0 : ℝ ) ( 1 - |ξ + τ| * B⁻¹ ) <;> cases abs_cases ( ξ + τ ) <;> cases abs_cases ( -1 + Max.max 0 ( 1 - |ξ + τ| * B⁻¹ ) ) <;> nlinarith [ inv_mul_cancel₀ ( by linarith : B ≠ 0 ), abs_le.mp hτ ];
        -- Choose B such that (2 * R) / B * (2 * M) < ε.
        obtain ⟨B₁, hB₁⟩ : ∃ B₁ > 0, ∀ B ≥ B₁, (2 * R) / B * (2 * M) < ε := by
          exact ⟨ 2 * R * ( 2 * M ) / ε + 1, by nlinarith [ mul_div_cancel₀ ( 2 * R * ( 2 * M ) ) hε.ne' ], fun B hB => by rw [ div_mul_eq_mul_div, div_lt_iff₀ ] <;> nlinarith [ mul_div_cancel₀ ( 2 * R * ( 2 * M ) ) hε.ne', mul_pos hR hM.1 ] ⟩;
        refine' ⟨ Max.max B₀ B₁, _, _ ⟩ <;> aesop;
        -- Using the bounds from `right_1` and `right_2`, we can show that the difference is less than ε.
        have h_diff : abs ((Fejer_kernel (Max.max B₀ B₁) (ξ - τ)) * (heat_kernel t (ξ - τ)) + (Fejer_kernel (Max.max B₀ B₁) (ξ + τ)) * (heat_kernel t (ξ + τ)) - ((heat_kernel t (ξ - τ)) + (heat_kernel t (ξ + τ)))) ≤ (2 * R) / (Max.max B₀ B₁) * (2 * M) := by
          refine' abs_le.mpr ⟨ _, _ ⟩ <;> nlinarith [ abs_le.mp ( right_1 ( Max.max B₀ B₁ ) ( le_max_left _ _ ) ξ left_3 right_3 |>.1 ), abs_le.mp ( right_1 ( Max.max B₀ B₁ ) ( le_max_left _ _ ) ξ left_3 right_3 |>.2 ), abs_le.mp ( right ξ left_3 right_3 |>.1 ), abs_le.mp ( right ξ left_3 right_3 |>.2 ), show 0 ≤ 2 * R / Max.max B₀ B₁ by positivity ];
        exact lt_of_le_of_lt h_diff ( right_2 _ ( le_max_right _ _ ) )

/-
Lemma: Any even nonnegative continuous function on [-R, R] can be extended to a continuous even nonnegative function with compact support on ℝ.
-/
lemma extend_continuous_even_nonneg (R : ℝ) (hR : R > 0) (f : ℝ → ℝ)
    (hf_cont : ContinuousOn f (Set.Icc (-R) R))
    (hf_even : ∀ x, f x = f (-x))
    (hf_nonneg : ∀ x ∈ Set.Icc (-R) R, 0 ≤ f x) :
    ∃ (f_tilde : ℝ → ℝ),
      Continuous f_tilde ∧ HasCompactSupport f_tilde ∧
      (∀ x, f_tilde x = f_tilde (-x)) ∧ (∀ x, 0 ≤ f_tilde x) ∧
      ∀ x ∈ Set.Icc (-R) R, f_tilde x = f x := by
        -- Define f_tilde(x) = f(x) for |x| <= R, and extend continuously to |x| > R such that f_tilde(x) = 0 for |x| > 2R.
        obtain ⟨f_tilde, hf_tilde⟩ : ∃ f_tilde : ℝ → ℝ,
          (∀ x, f_tilde x = if abs x ≤ R then f x else if abs x ≤ 2 * R then f R * (2 * R - abs x) / R else 0) ∧
          Continuous f_tilde := by
            refine' ⟨ _, fun x => rfl, _ ⟩;
            have h_cont : ContinuousOn (fun x => if abs x ≤ R then f x else if abs x ≤ 2 * R then f R * (2 * R - abs x) / R else 0) (Set.univ : Set ℝ) := by
              refine' ContinuousOn.if _ _ _;
              · erw [ show { a : ℝ | |a| ≤ R } = Set.Icc ( -R ) R by ext; simp +decide [ abs_le ] ] ; erw [ frontier_Icc ] <;> norm_num [ hR.le ];
                norm_num [ abs_of_pos hR, hR.ne', mul_div_cancel_left₀ ];
                grind;
              · norm_num [ abs_le ];
                simpa only [ Set.Icc_def, closure_Icc ] using hf_cont;
              · refine' ContinuousOn.if _ _ _;
                · erw [ show { a : ℝ | |a| ≤ 2 * R } = Set.Icc ( -2 * R ) ( 2 * R ) by ext; norm_num [ abs_le, neg_mul ] ] ; norm_num [ frontier_Icc, hR.le ];
                  rintro a ha ( rfl | rfl ) <;> norm_num [ abs_of_pos, hR ];
                · exact ContinuousOn.div_const ( ContinuousOn.mul continuousOn_const ( continuousOn_const.sub ( continuousOn_id.abs ) ) ) _;
                · exact continuousOn_const;
            exact?;
        refine' ⟨ f_tilde, hf_tilde.2, _, _, _, _ ⟩;
        · rw [ hasCompactSupport_iff_eventuallyEq ];
          norm_num [ Filter.EventuallyEq ];
          exact ⟨ ⟨ -2 * R - 1, fun x hx => hf_tilde.1 x ▸ by split_ifs <;> cases abs_cases x <;> linarith ⟩, ⟨ 2 * R + 1, fun x hx => hf_tilde.1 x ▸ by split_ifs <;> cases abs_cases x <;> linarith ⟩ ⟩;
        · intro x; rw [ hf_tilde.1, hf_tilde.1 ] ; norm_num [ abs_neg, hf_even x ] ;
        · intro x; specialize hf_even x; rw [ hf_tilde.1 ] ; split_ifs <;> try positivity;
          · exact hf_nonneg x ⟨ by linarith [ abs_le.mp ‹_› ], by linarith [ abs_le.mp ‹_› ] ⟩;
          · exact div_nonneg ( mul_nonneg ( hf_nonneg R ⟨ by linarith, by linarith ⟩ ) ( by linarith ) ) hR.le;
        · exact fun x hx => hf_tilde.1 x ▸ if_pos ( abs_le.mpr hx )

/-
Definition of the convolution of two functions f and g at a point x as the integral of f(y) * g(x - y) over all y.
-/
noncomputable def convolution_explicit (f g : ℝ → ℝ) (x : ℝ) : ℝ :=
  ∫ y, f y * g (x - y)

/-
Lemma: Convolution with the heat kernel preserves evenness and nonnegativity.
-/
lemma heat_convolution_properties (f : ℝ → ℝ) (t : ℝ) (ht : t > 0)
    (hf_even : ∀ x, f x = f (-x)) (hf_nonneg : ∀ x, 0 ≤ f x) :
    (∀ x, convolution_explicit f (heat_kernel t) x = convolution_explicit f (heat_kernel t) (-x)) ∧
    (∀ x, 0 ≤ convolution_explicit f (heat_kernel t) x) := by
      refine' ⟨ fun x => _, fun x => _ ⟩;
      · unfold convolution_explicit;
        rw [ ← MeasureTheory.integral_neg_eq_self ] ; congr ; ext y ; rw [ hf_even y ] ; ring;
        unfold heat_kernel; ring;
      · exact MeasureTheory.integral_nonneg fun y => mul_nonneg ( hf_nonneg _ ) ( by unfold heat_kernel; positivity )

/-
Lemma: The integral of the heat kernel over the entire real line is 1.
-/
lemma heat_kernel_integral_one (t : ℝ) (ht : t > 0) :
    ∫ x, heat_kernel t x = 1 := by
      -- The integral of the Gaussian function $\int_{-\infty}^\infty e^{-x^2/(4t)} dx$ is $\sqrt{4\pi t}$.
      have h_gauss_integral : ∫ x, Real.exp (-x^2 / (4 * t)) = Real.sqrt (4 * Real.pi * t) := by
        convert integral_gaussian ( 1 / ( 4 * t ) ) using 1 <;> norm_num [ div_eq_inv_mul ] ; ring;
      unfold heat_kernel;
      rw [ MeasureTheory.integral_const_mul, h_gauss_integral, div_mul_cancel₀ _ ( by positivity ) ]

/-
Lemma: The integral of the heat kernel over the region |x| ≥ δ tends to 0 as t → 0.
-/
lemma heat_kernel_tail_decay (δ : ℝ) (hδ : δ > 0) :
    Filter.Tendsto (fun t => ∫ x in {y | |y| ≥ δ}, heat_kernel t x) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
      -- By definition of the heat kernel, we have:
      suffices h_integral : Filter.Tendsto (fun t => ∫ x in {y : ℝ | abs y ≥ δ}, (1 / Real.sqrt (4 * Real.pi * t)) * Real.exp (-x ^ 2 / (4 * t))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) by
        convert h_integral using 1;
      -- We'll use the fact that the integral of the heat kernel over the region $|x| \geq \delta$ tends to 0 as $t \to 0$.
      have h_integral_zero : Filter.Tendsto (fun t => ∫ x in Set.Ioi δ, (Real.exp (-x ^ 2 / (4 * t))) / Real.sqrt (4 * Real.pi * t)) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
        -- We'll use the fact that $\int_{\delta}^{\infty} e^{-x^2 / (4t)} \, dx$ is bounded above by $\int_{\delta}^{\infty} e^{-x^2 / (4t)} \, dx$.
        have h_bound : ∀ t > 0, ∫ x in Set.Ioi δ, Real.exp (-x ^ 2 / (4 * t)) ≤ Real.exp (-δ ^ 2 / (4 * t)) * ∫ x in Set.Ioi 0, Real.exp (-x ^ 2 / (4 * t)) := by
          intro t ht
          have h_bound : ∫ x in Set.Ioi δ, Real.exp (-x^2 / (4 * t)) ≤ ∫ x in Set.Ioi δ, Real.exp (-δ^2 / (4 * t)) * Real.exp (-(x - δ)^2 / (4 * t)) := by
            refine' MeasureTheory.setIntegral_mono_on _ _ _ _ <;> norm_num;
            · exact MeasureTheory.Integrable.integrableOn ( by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) );
            · -- The integral of the Gaussian function is finite.
              have h_gauss_integrable : MeasureTheory.IntegrableOn (fun x => Real.exp (-(x - δ)^2 / (4 * t))) Set.univ := by
                simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) |> ( fun h => h.comp_sub_right δ );
              exact MeasureTheory.IntegrableOn.mono_set ( h_gauss_integrable.const_mul _ ) ( Set.subset_univ _ );
            · intro x hx; rw [ ← Real.exp_add ] ; exact Real.exp_le_exp.mpr ( by rw [ ← add_div, div_le_div_iff_of_pos_right ] <;> nlinarith ) ;
          convert h_bound using 1 <;> norm_num [ div_eq_mul_inv, MeasureTheory.integral_const_mul ];
          rw [ ← MeasureTheory.integral_indicator ( measurableSet_Ioi ), ← MeasureTheory.integral_indicator ( measurableSet_Ioi ) ] ; rw [ ← MeasureTheory.integral_sub_right_eq_self _ δ ] ; norm_num [ Set.indicator ] ;
        -- We'll use the fact that $\int_{0}^{\infty} e^{-x^2 / (4t)} \, dx = \sqrt{4\pi t}$.
        have h_gauss_integral : ∀ t > 0, ∫ x in Set.Ioi 0, Real.exp (-x ^ 2 / (4 * t)) = Real.sqrt (4 * Real.pi * t) / 2 := by
          intro t ht; convert integral_gaussian_Ioi ( 1 / ( 4 * t ) ) using 1 <;> norm_num [ div_eq_inv_mul ] ; ring;
        -- Substitute the bound and the Gaussian integral result into our expression.
        have h_subst : ∀ t > 0, ∫ x in Set.Ioi δ, Real.exp (-x ^ 2 / (4 * t)) / Real.sqrt (4 * Real.pi * t) ≤ Real.exp (-δ ^ 2 / (4 * t)) / 2 := by
          intro t ht; rw [ MeasureTheory.integral_div ] ; rw [ div_le_iff₀ ( by positivity ) ] ; convert h_bound t ht using 1 ; rw [ h_gauss_integral t ht ] ; ring;
        -- We'll use the fact that $\exp(-δ^2 / (4t)) / 2$ tends to $0$ as $t \to 0$.
        have h_exp_zero : Filter.Tendsto (fun t => Real.exp (-δ ^ 2 / (4 * t)) / 2) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
          -- We'll use the fact that $\exp(-δ^2 / (4t))$ tends to $0$ as $t \to 0$.
          have h_exp_zero : Filter.Tendsto (fun t => Real.exp (-δ ^ 2 / (4 * t))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
            norm_num [ div_eq_mul_inv ];
            exact Filter.Tendsto.const_mul_atTop ( by positivity ) ( Filter.Tendsto.atTop_mul_const ( by positivity ) ( tendsto_inv_nhdsGT_zero ) );
          simpa using h_exp_zero.div_const 2;
        exact squeeze_zero_norm' ( Filter.eventually_of_mem self_mem_nhdsWithin fun t ht => by rw [ Real.norm_of_nonneg ( MeasureTheory.integral_nonneg fun x => by positivity ) ] ; exact h_subst t ht ) h_exp_zero;
      -- Since the integral over $|x| \geq \delta$ is twice the integral over $x \geq \delta$, we can conclude the proof.
      have h_integral_double : ∀ t > 0, ∫ x in {y : ℝ | abs y ≥ δ}, (Real.exp (-x ^ 2 / (4 * t))) / Real.sqrt (4 * Real.pi * t) = 2 * ∫ x in Set.Ioi δ, (Real.exp (-x ^ 2 / (4 * t))) / Real.sqrt (4 * Real.pi * t) := by
        intro t ht; rw [ show { y : ℝ | |y| ≥ δ } = Set.Ici δ ∪ Set.Iic ( -δ ) by ext; norm_num; exact ⟨ fun h => by cases abs_cases ‹_› <;> first | left; exact le_of_not_gt fun h' => by linarith | right; exact le_of_not_gt fun h' => by linarith, fun h => by cases h <;> cases abs_cases ‹_› <;> linarith ⟩ ] ; rw [ MeasureTheory.setIntegral_union ] <;> norm_num;
        · rw [ two_mul, MeasureTheory.integral_Ici_eq_integral_Ioi, ← neg_neg δ, ← integral_comp_neg_Iic ] ; norm_num;
        · positivity;
        · -- The Gaussian function is integrable over the entire real line.
          have h_gauss_integrable : MeasureTheory.IntegrableOn (fun x => Real.exp (-x ^ 2 / (4 * t))) Set.univ := by
            simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) );
          exact MeasureTheory.IntegrableOn.mono_set ( h_gauss_integrable.div_const _ ) ( Set.subset_univ _ );
        · -- The integral of the Gaussian function over the entire real line is finite.
          have h_gauss_integrable : MeasureTheory.IntegrableOn (fun x => Real.exp (-x ^ 2 / (4 * t))) Set.univ := by
            simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) );
          exact MeasureTheory.IntegrableOn.mono_set ( h_gauss_integrable.div_const _ ) ( Set.subset_univ _ );
      simpa using h_integral_zero.const_mul 2 |> Filter.Tendsto.congr' ( Filter.eventuallyEq_of_mem self_mem_nhdsWithin fun t ht => by rw [ ← h_integral_double t ht ] ; congr ; ext ; ring )

/-
Lemma: The convolution of a continuous compactly supported function with the heat kernel converges uniformly to the function as t → 0.
-/
lemma heat_convolution_uniform_limit (f : ℝ → ℝ) (hf_cont : Continuous f) (hf_compact : HasCompactSupport f) (ε : ℝ) (hε : ε > 0) :
    ∃ t₀ > 0, ∀ t ∈ Set.Ioo 0 t₀, ∀ x, |convolution_explicit f (heat_kernel t) x - f x| < ε := by
      -- Since f is continuous and compactly supported, it is uniformly continuous. Choose δ such that |y| < δ implies |f(x-y) - f(x)| < ε/2 for all x.
      obtain ⟨δ, hδ_pos, hδ⟩ : ∃ δ > 0, ∀ x y, |x - y| < δ → |f x - f y| < ε / 2 := by
        -- Since $f$ is continuous on a compact set, it is uniformly continuous.
        have h_unif_cont : UniformContinuous f := by
          exact?;
        exact Metric.uniformContinuous_iff.mp h_unif_cont ( ε / 2 ) ( half_pos hε );
      -- Using the triangle inequality, we can bound the integral.
      have h_triangle : ∀ t > 0, ∀ x, |convolution_explicit f (heat_kernel t) x - f x| ≤ ∫ y, |f (x - y) - f x| * heat_kernel t y := by
        intro t ht x
        have h_convolution_split : convolution_explicit f (heat_kernel t) x - f x = ∫ y, (f (x - y) - f x) * heat_kernel t y := by
          simp +decide only [sub_mul];
          rw [ MeasureTheory.integral_sub ];
          · rw [ MeasureTheory.integral_const_mul ];
            rw [ show ∫ a, f ( x - a ) * heat_kernel t a = ∫ a, f a * heat_kernel t ( x - a ) by rw [ ← MeasureTheory.integral_sub_left_eq_self ] ; congr; ext; ring ];
            rw [ show ∫ a, heat_kernel t a = 1 by exact? ] ; norm_num;
            exact?;
          · refine' MeasureTheory.Integrable.mono' _ _ _;
            refine' fun y => ( SupSet.sSup ( Set.image ( fun z => |f z| ) ( Set.univ ) ) ) * heat_kernel t y;
            · refine' MeasureTheory.Integrable.const_mul _ _;
              exact MeasureTheory.Integrable.const_mul ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) _;
            · exact MeasureTheory.AEStronglyMeasurable.mul ( hf_cont.comp ( continuous_const.sub continuous_id' ) |> Continuous.aestronglyMeasurable ) ( by exact Continuous.aestronglyMeasurable ( by exact Continuous.mul ( continuous_const ) ( Real.continuous_exp.comp ( by continuity ) ) ) );
            · simp +zetaDelta at *;
              filter_upwards [ ] with y using by rw [ abs_of_nonneg ( show 0 ≤ heat_kernel t y by exact mul_nonneg ( by positivity ) ( Real.exp_nonneg _ ) ) ] ; exact mul_le_mul_of_nonneg_right ( le_csSup ( show BddAbove ( Set.range fun z => |f z| ) from by exact IsCompact.bddAbove ( hf_compact.abs.isCompact_range hf_cont.abs ) ) ( Set.mem_range_self _ ) ) ( show 0 ≤ heat_kernel t y by exact mul_nonneg ( by positivity ) ( Real.exp_nonneg _ ) ) ;
          · refine' MeasureTheory.Integrable.const_mul _ _;
            exact MeasureTheory.Integrable.const_mul ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) _;
        rw [ h_convolution_split ];
        convert MeasureTheory.norm_integral_le_integral_norm ( _ : ℝ → ℝ ) using 1;
        norm_num [ abs_mul, abs_of_nonneg ( show 0 ≤ heat_kernel t _ from by unfold heat_kernel; positivity ) ];
      -- Split the integral into |y| < δ and |y| ≥ δ.
      have h_split_integral : ∀ t > 0, ∀ x, ∫ y, |f (x - y) - f x| * heat_kernel t y ≤ (∫ y in {y | |y| < δ}, |f (x - y) - f x| * heat_kernel t y) + (∫ y in {y | |y| ≥ δ}, |f (x - y) - f x| * heat_kernel t y) := by
        intro t ht x; rw [ ← MeasureTheory.setIntegral_union ] <;> norm_num;
        · rw [ show { y : ℝ | |y| < δ } ∪ { y : ℝ | δ ≤ |y| } = Set.univ by ext y; by_cases hy : |y| < δ <;> aesop ] ; norm_num;
        · exact Set.disjoint_left.mpr fun y hy₁ hy₂ => hy₁.out.not_le hy₂.out;
        · exact measurableSet_Ici.mem.comp measurable_norm;
        · refine' MeasureTheory.Integrable.mono' _ _ _;
          refine' fun y => ( ε / 2 ) * heat_kernel t y;
          · refine' MeasureTheory.Integrable.const_mul _ _;
            exact MeasureTheory.Integrable.mono_measure ( by exact MeasureTheory.integrable_of_integral_eq_one ( by rw [ show ∫ x, heat_kernel t x = 1 from by exact? ] ) ) ( MeasureTheory.Measure.restrict_le_self );
          · exact MeasureTheory.AEStronglyMeasurable.mul ( Continuous.aestronglyMeasurable ( by continuity ) ) ( Continuous.aestronglyMeasurable ( by exact Continuous.mul ( continuous_const ) ( Real.continuous_exp.comp ( by continuity ) ) ) );
          · filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_lt ( continuous_abs.measurable ) measurable_const ] with y hy using by rw [ Real.norm_of_nonneg <| mul_nonneg ( abs_nonneg _ ) <| by exact mul_nonneg ( one_div_nonneg.mpr <| Real.sqrt_nonneg _ ) <| Real.exp_nonneg _ ] ; exact mul_le_mul_of_nonneg_right ( le_of_lt <| hδ _ _ <| by simpa using hy ) <| by exact mul_nonneg ( one_div_nonneg.mpr <| Real.sqrt_nonneg _ ) <| Real.exp_nonneg _;
        · refine' MeasureTheory.Integrable.integrableOn _;
          -- The product of an integrable function and a bounded function is integrable.
          have h_integrable : MeasureTheory.Integrable (fun y => |f (x - y) - f x| * Real.exp (-y^2 / (4 * t))) MeasureTheory.MeasureSpace.volume := by
            refine' MeasureTheory.Integrable.mono' _ _ _;
            refine' fun y => ( SupSet.sSup ( Set.image ( fun z => |f z - f x| ) ( Set.univ ) ) ) * Real.exp ( -y ^ 2 / ( 4 * t ) );
            · exact MeasureTheory.Integrable.const_mul ( by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) ) _;
            · exact MeasureTheory.AEStronglyMeasurable.mul ( Continuous.aestronglyMeasurable ( by continuity ) ) ( Continuous.aestronglyMeasurable ( by continuity ) );
            · simp +zetaDelta at *;
              filter_upwards [ ] with y using mul_le_mul_of_nonneg_right ( le_csSup ( show BddAbove ( Set.range fun z => |f z - f x| ) from by
                                                                                        have := hf_compact.exists_bound_of_continuous hf_cont;
                                                                                        exact ⟨ this.choose + |f x|, Set.forall_mem_range.mpr fun z => by simpa using abs_sub ( f z ) ( f x ) |> le_trans <| add_le_add ( this.choose_spec z ) le_rfl ⟩ ) ( Set.mem_range_self _ ) ) ( Real.exp_nonneg _ );
          convert h_integrable.mul_const ( 1 / Real.sqrt ( 4 * Real.pi * t ) ) using 2 ; unfold heat_kernel ; ring;
      -- For |y| < δ, the integrand is bounded by (ε/2) * ρ_t(y). The integral is bounded by ε/2 * ∫ ρ_t = ε/2.
      have h_small_integral : ∀ t > 0, ∀ x, ∫ y in {y | |y| < δ}, |f (x - y) - f x| * heat_kernel t y ≤ (ε / 2) * ∫ y, heat_kernel t y := by
        intros t ht x
        have h_small_integral : ∫ y in {y | |y| < δ}, |f (x - y) - f x| * heat_kernel t y ≤ ∫ y in {y | |y| < δ}, (ε / 2) * heat_kernel t y := by
          refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
          · exact Filter.Eventually.of_forall fun y => mul_nonneg ( abs_nonneg _ ) ( by unfold heat_kernel; positivity );
          · refine' MeasureTheory.Integrable.const_mul _ _;
            refine' MeasureTheory.Integrable.integrableOn _;
            exact MeasureTheory.Integrable.const_mul ( by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) ) _;
          · filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_lt ( continuous_abs.measurable ) measurable_const ] with y hy using mul_le_mul_of_nonneg_right ( le_of_lt <| hδ _ _ <| by simpa using hy ) <| by unfold heat_kernel; positivity;
        refine le_trans h_small_integral ?_;
        rw [ MeasureTheory.integral_const_mul ];
        refine' mul_le_mul_of_nonneg_left ( MeasureTheory.setIntegral_le_integral _ _ ) ( by positivity );
        · exact MeasureTheory.Integrable.const_mul ( by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) ) _;
        · exact Filter.Eventually.of_forall fun y => by unfold heat_kernel; positivity;
      -- For |y| ≥ δ, |f(x-y) - f(x)| is bounded by 2 * ||f||_∞.
      have h_large_integral_bound : ∃ C > 0, ∀ t > 0, ∀ x, ∫ y in {y | |y| ≥ δ}, |f (x - y) - f x| * heat_kernel t y ≤ C * ∫ y in {y | |y| ≥ δ}, heat_kernel t y := by
        -- Since $f$ is continuous and compactly supported, it is bounded. Let $M = \sup_{x \in \mathbb{R}} |f(x)|$.
        obtain ⟨M, hM⟩ : ∃ M > 0, ∀ x, |f x| ≤ M := by
          obtain ⟨ M, hM ⟩ := hf_compact.exists_bound_of_continuous hf_cont; use Max.max M 1; aesop;
        refine' ⟨ 2 * M, by linarith, fun t ht x => _ ⟩;
        rw [ ← MeasureTheory.integral_const_mul ];
        refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
        · exact Filter.Eventually.of_forall fun y => mul_nonneg ( abs_nonneg _ ) ( by unfold heat_kernel; positivity );
        · refine' MeasureTheory.Integrable.const_mul _ _;
          refine' MeasureTheory.Integrable.integrableOn _;
          exact MeasureTheory.integrable_of_integral_eq_one ( heat_kernel_integral_one t ht );
        · filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_Ici.preimage <| measurable_norm ] with y hy using mul_le_mul_of_nonneg_right ( abs_sub_le_iff.mpr ⟨ by linarith [ abs_le.mp ( hM.2 ( x - y ) ), abs_le.mp ( hM.2 x ) ], by linarith [ abs_le.mp ( hM.2 ( x - y ) ), abs_le.mp ( hM.2 x ) ] ⟩ ) <| by unfold heat_kernel; positivity;
      -- By `heat_kernel_tail_decay`, there exists t₀ such that for t < t₀, ∫_{|y|≥δ} ρ_t(y) is small enough (specifically < ε / (4 * C)).
      obtain ⟨C, hC_pos, hC_bound⟩ := h_large_integral_bound
      obtain ⟨t₀, ht₀_pos, ht₀⟩ : ∃ t₀ > 0, ∀ t ∈ Set.Ioo 0 t₀, ∫ y in {y | |y| ≥ δ}, heat_kernel t y < ε / (4 * C) := by
        have := Metric.tendsto_nhdsWithin_nhds.mp ( heat_kernel_tail_decay δ hδ_pos );
        exact Exists.elim ( this ( ε / ( 4 * C ) ) ( by positivity ) ) fun δ hδ => ⟨ δ, hδ.1, fun t ht => by linarith [ abs_lt.mp ( hδ.2 ht.1 ( by simpa [ abs_of_pos ht.1 ] using ht.2 ) ) ] ⟩;
      use t₀, ht₀_pos;
      intro t ht x; specialize h_triangle t ht.1 x; specialize h_split_integral t ht.1 x; specialize h_small_integral t ht.1 x; specialize hC_bound t ht.1 x; specialize ht₀ t ht; aesop;
      rw [ lt_div_iff₀ ] at ht₀ <;> nlinarith [ show 0 ≤ ∫ y, heat_kernel t y from MeasureTheory.integral_nonneg fun _ => by exact mul_nonneg ( by positivity ) ( Real.exp_nonneg _ ), show ∫ y, heat_kernel t y = 1 from by exact? ]

/-
Step 1: There exists a continuous, compactly supported, even, nonnegative extension of f, and a time t, such that the convolution of the extension with the heat kernel approximates f on [-R, R].
-/
lemma step1_mollification (R : ℝ) (hR : R > 0) (f : ℝ → ℝ)
    (hf_cont : ContinuousOn f (Set.Icc (-R) R))
    (hf_even : ∀ x, f x = f (-x))
    (hf_nonneg : ∀ x ∈ Set.Icc (-R) R, 0 ≤ f x)
    (ε : ℝ) (hε : ε > 0) :
    ∃ (f_tilde : ℝ → ℝ) (t : ℝ),
      Continuous f_tilde ∧ HasCompactSupport f_tilde ∧
      (∀ x, f_tilde x = f_tilde (-x)) ∧ (∀ x, 0 ≤ f_tilde x) ∧
      t > 0 ∧
      ∀ x ∈ Set.Icc (-R) R, |convolution_explicit f_tilde (heat_kernel t) x - f x| < ε := by
        -- Apply the heat_convolution_uniform_limit lemma to f_tilde with error ε to find such a t.
        obtain ⟨f_tilde, hf_tilde_cont, hf_tilde_compact, hf_tilde_even, hf_tilde_nonneg, hf_tilde_eq⟩ : ∃ f_tilde : ℝ → ℝ,
          Continuous f_tilde ∧ HasCompactSupport f_tilde ∧ (∀ x, f_tilde x = f_tilde (-x)) ∧ (∀ x, 0 ≤ f_tilde x) ∧ ∀ x ∈ Set.Icc (-R) R, f_tilde x = f x := by
            apply extend_continuous_even_nonneg R hR f hf_cont hf_even hf_nonneg;
        obtain ⟨t₀, ht₀⟩ : ∃ t₀ > 0, ∀ t ∈ Set.Ioo 0 t₀, ∀ x, |convolution_explicit f_tilde (heat_kernel t) x - f_tilde x| < ε := by
          exact?;
        exact ⟨ f_tilde, t₀ / 2, hf_tilde_cont, hf_tilde_compact, hf_tilde_even, hf_tilde_nonneg, half_pos ht₀.1, fun x hx => by simpa only [ hf_tilde_eq x hx ] using ht₀.2 ( t₀ / 2 ) ⟨ half_pos ht₀.1, half_lt_self ht₀.1 ⟩ x ⟩

/-
Lemma: The sum of two adjacent Fejér kernels of width B is 1 if and only if x lies between their centers.
-/
lemma fejer_partition_of_unity (B : ℝ) (hB : B > 0) (x : ℝ) (k : ℤ) :
    Fejer_kernel B (x - k * B) + Fejer_kernel B (x - (k + 1) * B) = 1 ↔ k * B ≤ x ∧ x ≤ (k + 1) * B := by
      unfold Fejer_kernel;
      aesop?;
      · contrapose! a;
        cases max_cases ( 0 : ℝ ) ( 1 - |x - k * B| / B ) <;> cases max_cases ( 0 : ℝ ) ( 1 - |x - ( k + 1 ) * B| / B ) <;> nlinarith [ abs_of_neg ( by linarith : x - k * B < 0 ), abs_of_neg ( by linarith : x - ( k + 1 ) * B < 0 ), mul_div_cancel₀ ( |x - k * B| ) hB.ne', mul_div_cancel₀ ( |x - ( k + 1 ) * B| ) hB.ne' ];
      · cases max_cases ( 0 : ℝ ) ( 1 - |x - ( k : ℝ ) * B| / B ) <;> cases max_cases ( 0 : ℝ ) ( 1 - |x - ( ( k : ℝ ) + 1 ) * B| / B ) <;> aesop;
        · linarith;
        · linarith;
        · cases abs_cases ( x - ( k : ℝ ) * B ) <;> cases abs_cases ( x - ( ( k : ℝ ) + 1 ) * B ) <;> nlinarith [ mul_div_cancel₀ ( |x - ( k : ℝ ) * B| ) hB.ne', mul_div_cancel₀ ( |x - ( ( k : ℝ ) + 1 ) * B| ) hB.ne' ];
      · rw [ max_eq_right, max_eq_right ] <;> cases abs_cases ( x - ( k : ℝ ) * B ) <;> cases abs_cases ( x - ( ( k : ℝ ) + 1 ) * B ) <;> nlinarith [ mul_div_cancel₀ ( |x - ( k : ℝ ) * B| ) hB.ne', mul_div_cancel₀ ( |x - ( ( k : ℝ ) + 1 ) * B| ) hB.ne' ]

/-
Lemma: The local linear spline approximates f uniformly on [-K, K].
-/
noncomputable def local_spline (f : ℝ → ℝ) (B : ℝ) (x : ℝ) : ℝ :=
  let k := Int.floor (x / B)
  f (k * B) * Fejer_kernel B (x - k * B) + f ((k + 1) * B) * Fejer_kernel B (x - (k + 1) * B)

lemma local_spline_approx (K : ℝ) (hK : K > 0) (f : ℝ → ℝ)
    (hf_cont : ContinuousOn f (Set.Icc (-K - 1) (K + 1)))
    (ε : ℝ) (hε : ε > 0) :
    ∃ B > 0, ∀ x ∈ Set.Icc (-K) K, |f x - local_spline f B x| < ε := by
      -- Fix an arbitrary ε > 0.
      obtain ⟨δ, hδ⟩ : ∃ δ > 0, ∀ x y : ℝ, abs (x - y) < δ → x ∈ Set.Icc (-K - 1) (K + 1) → y ∈ Set.Icc (-K - 1) (K + 1) → abs (f x - f y) < ε / 2 := by
        have := Metric.uniformContinuousOn_iff.mp ( isCompact_Icc.uniformContinuousOn_of_continuous hf_cont ) ( ε / 2 ) ( half_pos hε ) ; aesop;
      refine' ⟨ Min.min δ 1 / 2, _, _ ⟩ <;> aesop;
      -- For any x in [-K, K], let k = floor(x/B). Then kB <= x < (k+1)B.
      obtain ⟨k, hk⟩ : ∃ k : ℤ, k * (min δ 1 / 2) ≤ x ∧ x < (k + 1) * (min δ 1 / 2) := by
        exact ⟨ ⌊x / ( Min.min δ 1 / 2 ) ⌋, by nlinarith [ Int.floor_le ( x / ( Min.min δ 1 / 2 ) ), show 0 < Min.min δ 1 / 2 by positivity, mul_div_cancel₀ x ( show ( Min.min δ 1 / 2 ) ≠ 0 by positivity ) ], by nlinarith [ Int.lt_floor_add_one ( x / ( Min.min δ 1 / 2 ) ), show 0 < Min.min δ 1 / 2 by positivity, mul_div_cancel₀ x ( show ( Min.min δ 1 / 2 ) ≠ 0 by positivity ) ] ⟩;
      -- By definition of local_spline, we have:
      have h_local_spline : local_spline f (min δ 1 / 2) x = f (k * (min δ 1 / 2)) * (1 - abs (x - k * (min δ 1 / 2)) / (min δ 1 / 2)) + f ((k + 1) * (min δ 1 / 2)) * (1 - abs (x - (k + 1) * (min δ 1 / 2)) / (min δ 1 / 2)) := by
        unfold local_spline ; aesop;
        rw [ show ⌊x / ( Min.min δ 1 / 2 ) ⌋ = k from Int.floor_eq_iff.mpr ⟨ by rw [ le_div_iff₀ <| by positivity ] ; linarith, by rw [ div_lt_iff₀ <| by positivity ] ; linarith ⟩ ] ; norm_num [ Fejer_kernel ] ;
        rw [ max_eq_right ( sub_nonneg.mpr <| div_le_one_of_le₀ ( by cases abs_cases ( x - ( k : ℝ ) * ( Min.min δ 1 / 2 ) ) <;> linarith ) <| by positivity ), max_eq_right ( sub_nonneg.mpr <| div_le_one_of_le₀ ( by cases abs_cases ( x - ( ( k : ℝ ) + 1 ) * ( Min.min δ 1 / 2 ) ) <;> linarith ) <| by positivity ) ];
      -- By definition of local_spline, we have |f x - local_spline f (min δ 1 / 2) x| ≤ |f x - f (k * (min δ 1 / 2))| + |f x - f ((k + 1) * (min δ 1 / 2))|.
      have h_diff : abs (f x - local_spline f (min δ 1 / 2) x) ≤ abs (f x - f (k * (min δ 1 / 2))) + abs (f x - f ((k + 1) * (min δ 1 / 2))) := by
        cases abs_cases ( x - ( k : ℝ ) * ( Min.min δ 1 / 2 ) ) <;> cases abs_cases ( x - ( ( k : ℝ ) + 1 ) * ( Min.min δ 1 / 2 ) ) <;> simp +decide [ * ];
        · linarith;
        · field_simp;
          rw [ abs_div, abs_of_nonneg ( by positivity : 0 ≤ Min.min δ 1 ) ];
          rw [ div_le_iff₀ ( by positivity ) ];
          rw [ abs_le ];
          constructor <;> cases abs_cases ( f x - f ( ( k : ℝ ) * Min.min δ 1 / 2 ) ) <;> cases abs_cases ( f x - f ( Min.min δ 1 * ( ( k : ℝ ) + 1 ) / 2 ) ) <;> nlinarith [ show 0 < Min.min δ 1 by positivity ];
        · grind;
        · linarith;
      exact h_diff.trans_lt ( by linarith [ right x ( k * ( Min.min δ 1 / 2 ) ) ( by rw [ abs_lt ] ; constructor <;> nlinarith [ show ( 0 : ℝ ) < Min.min δ 1 by positivity, min_le_left δ 1, min_le_right δ 1 ] ) ( by linarith ) ( by linarith ) ( by nlinarith [ show ( 0 : ℝ ) < Min.min δ 1 by positivity, min_le_left δ 1, min_le_right δ 1 ] ) ( by nlinarith [ show ( 0 : ℝ ) < Min.min δ 1 by positivity, min_le_left δ 1, min_le_right δ 1 ] ), right x ( ( k + 1 ) * ( Min.min δ 1 / 2 ) ) ( by rw [ abs_lt ] ; constructor <;> nlinarith [ show ( 0 : ℝ ) < Min.min δ 1 by positivity, min_le_left δ 1, min_le_right δ 1 ] ) ( by linarith ) ( by linarith ) ( by nlinarith [ show ( 0 : ℝ ) < Min.min δ 1 by positivity, min_le_left δ 1, min_le_right δ 1 ] ) ( by nlinarith [ show ( 0 : ℝ ) < Min.min δ 1 by positivity, min_le_left δ 1, min_le_right δ 1 ] ) ] )

/-
Definition of a symmetrized sum of Fejér kernels.
-/
noncomputable def symmetrized_fejer_sum (n : ℕ) (c τ : Fin n → ℝ) (B : ℝ) (x : ℝ) : ℝ :=
  ∑ i, c i * (Fejer_kernel B (x - τ i) + Fejer_kernel B (x + τ i))

/-
Lemma: On [-K, K], the finite spline sum (over grid points in [-K, K]) is equal to the local spline.
-/
noncomputable def finite_spline (f : ℝ → ℝ) (K : ℝ) (N : ℕ) (x : ℝ) : ℝ :=
  let B := K / N
  ∑ k ∈ Finset.Icc (-N : ℤ) N, f (k * B) * Fejer_kernel B (x - k * B)

lemma finite_spline_eq_local_spline (K : ℝ) (hK : K > 0) (N : ℕ) (hN : N > 0) (f : ℝ → ℝ) (x : ℝ) (hx : x ∈ Set.Icc (-K) K) :
    finite_spline f K N x = local_spline f (K / N) x := by
      unfold finite_spline local_spline;
      rw [ Finset.sum_eq_add ( ⌊x / ( K / N ) ⌋ : ℤ ) ( ⌊x / ( K / N ) ⌋ + 1 : ℤ ) ];
      · norm_num;
      · norm_num;
      · intro c hc hne; unfold Fejer_kernel; aesop;
        contrapose! left_2; contrapose! right_2; simp_all +decide [ abs_div, abs_mul, abs_of_pos, div_lt_iff₀, lt_div_iff₀ ] ;
        -- Since $c \neq \lfloor x / (K / N) \rfloor$, we have $c = \lfloor x / (K / N) \rfloor + 1$.
        have h_floor : ⌊x / (K / N)⌋ ≤ c ∧ c ≤ ⌊x / (K / N)⌋ + 1 := by
          aesop;
          · exact Int.le_of_lt_add_one <| Int.floor_lt.2 <| by rw [ div_lt_iff₀ <| by positivity ] ; norm_num; nlinarith [ abs_lt.mp <| show |x - ( c : ℝ ) * ( K / N )| < K / N from by rw [ lt_div_iff₀ <| by positivity ] ; nlinarith [ abs_nonneg <| x - ( c : ℝ ) * ( K / N ) ] ] ;
          · exact Int.le_of_lt_add_one ( by rw [ ← @Int.cast_lt ℝ ] ; push_cast; nlinarith [ abs_lt.mp ( show |x - ( c : ℝ ) * ( K / N )| < K / N by rw [ lt_div_iff₀ ( by positivity ) ] ; linarith ), Int.lt_floor_add_one ( x / ( K / N ) ), mul_div_cancel₀ x ( by positivity : ( K / N : ℝ ) ≠ 0 ), mul_div_cancel₀ ( K : ℝ ) ( by positivity : ( N : ℝ ) ≠ 0 ) ] );
        omega;
      · aesop;
        contrapose! a;
        exact ⟨ Int.le_floor.2 <| by push_cast; rw [ le_div_iff₀ <| by positivity ] ; nlinarith [ mul_div_cancel₀ K ( by positivity : ( N : ℝ ) ≠ 0 ) ], Int.le_of_lt_add_one <| Int.floor_lt.2 <| by push_cast; rw [ div_lt_iff₀ <| by positivity ] ; nlinarith [ mul_div_cancel₀ K ( by positivity : ( N : ℝ ) ≠ 0 ) ] ⟩;
      · aesop;
        contrapose! a;
        aesop;
        · exact Int.le_of_lt_add_one ( by rw [ ← @Int.cast_lt ℝ ] ; push_cast; nlinarith [ Int.lt_floor_add_one ( x / ( K / N ) ), show ( N : ℝ ) ≥ 1 by norm_cast, mul_div_cancel₀ x ( by positivity : ( K / N : ℝ ) ≠ 0 ), mul_div_cancel₀ ( K : ℝ ) ( by positivity : ( N : ℝ ) ≠ 0 ) ] );
        · unfold Fejer_kernel at right_1 ; aesop;
          exact Int.le_of_lt_add_one ( by rw [ ← @Int.cast_lt ℝ ] ; push_cast; nlinarith [ abs_lt.mp ( show |x - ( ⌊x / ( K / N ) ⌋ + 1 ) * ( K / N )| < K / N from by rw [ div_lt_iff₀ ( by positivity ) ] at *; linarith ), show ( N : ℝ ) ≥ 1 by norm_cast, mul_div_cancel₀ K ( by positivity : ( N : ℝ ) ≠ 0 ), Int.floor_le ( x / ( K / N ) ), Int.lt_floor_add_one ( x / ( K / N ) ), mul_div_cancel₀ x ( by positivity : ( K / N : ℝ ) ≠ 0 ) ] )

/-
Lemma: A sum over {-N, ..., N} can be rewritten as the term at 0 plus the sum of symmetric pairs (k, -k) for k from 1 to N.
-/
lemma sum_Icc_symmetric {M : Type*} [AddCommMonoid M] (N : ℕ) (g : ℤ → M) :
    ∑ k ∈ Finset.Icc (-N : ℤ) N, g k = g 0 + ∑ k ∈ Finset.Icc 1 N, (g k + g (-k)) := by
      erw [ show ( Finset.Icc ( - ( N : ℤ ) ) N : Finset ℤ ) = Finset.image ( fun i : ℕ => ↑i ) ( Finset.Icc 0 N ) ∪ Finset.image ( fun i : ℕ => - ( ↑i : ℤ ) ) ( Finset.Icc 1 N ) from ?_, Finset.sum_union ];
      · norm_num [ Finset.sum_add_distrib ];
        erw [ Finset.Icc_eq_cons_Ioc, Finset.sum_cons ] <;> aesop;
        rw [ add_assoc, Nat.Icc_succ_left ];
      · rw [ Finset.disjoint_left ] ; aesop;
      · ext ; aesop;
        exact if h : a ≥ 0 then Or.inl ⟨ Int.toNat a, by linarith [ Int.toNat_of_nonneg h ], by rw [ Int.toNat_of_nonneg h ] ⟩ else Or.inr ⟨ Int.toNat ( -a ), ⟨ by linarith [ Int.toNat_of_nonneg ( by linarith : 0 ≤ -a ) ], by linarith [ Int.toNat_of_nonneg ( by linarith : 0 ≤ -a ) ] ⟩, by rw [ Int.toNat_of_nonneg ( by linarith : 0 ≤ -a ) ] ; ring ⟩

/-
Lemma: If f is even and nonnegative, the finite spline can be written as a symmetrized Fejér sum with nonnegative coefficients.
-/
lemma finite_spline_symmetric_form (K : ℝ) (hK : K > 0) (N : ℕ) (hN : N > 0) (f : ℝ → ℝ)
    (hf_even : ∀ x, f x = f (-x)) (hf_nonneg : ∀ x, 0 ≤ f x) :
    ∃ (n : ℕ) (c τ : Fin n → ℝ),
      (∀ i, 0 ≤ c i) ∧
      (∀ i, |τ i| ≤ K) ∧
      (∀ i, c i = if τ i = 0 then f 0 / 2 else f (τ i)) ∧
      ∀ x, finite_spline f K N x = symmetrized_fejer_sum n c τ (K / N) x := by
        -- Let's choose $n = N + 1$, $c_i = f(iB)$ for $i = 1, \ldots, N$, and $c_0 = \frac{f(0)}{2}$.
        use N + 1, fun i => if i.val = 0 then f 0 / 2 else f (i.val * (K / N)), fun i => if i.val = 0 then 0 else i.val * (K / N);
        refine' ⟨ _, _, _, _ ⟩;
        · exact fun i => by split_ifs <;> linarith [ hf_nonneg 0, hf_nonneg ( i * ( K / N ) ) ] ;
        · intro i; rw [ abs_le ] ; constructor <;> norm_num;
          · split_ifs <;> nlinarith [ show ( 0 : ℝ ) ≤ K / N by positivity ];
          · split_ifs <;> nlinarith [ show ( i : ℝ ) ≤ N by norm_cast; linarith [ Fin.is_le i ], show ( N : ℝ ) ≥ 1 by norm_cast, div_mul_cancel₀ K ( by positivity : ( N : ℝ ) ≠ 0 ) ];
        · simp ( config := { decide := Bool.true } ) [ Fin.forall_fin_succ ];
          exact fun i hi => absurd ( hi.resolve_left hK.ne' ) hN.ne';
        · -- By definition of `finite_spline`, we can split the sum into the term at 0 and the sum over `1` to `N` of `f(kB)Fejer(x-kB) + f(-kB)Fejer(x+kB)`.
          have h_split : ∀ x, finite_spline f K N x = f 0 * Fejer_kernel (K / N) (x - 0) + ∑ k ∈ Finset.Icc 1 N, f (k * (K / N)) * (Fejer_kernel (K / N) (x - k * (K / N)) + Fejer_kernel (K / N) (x + k * (K / N))) := by
            -- Apply the lemma `sum_Icc_symmetric` to split the sum.
            have h_split : ∀ x, finite_spline f K N x = f 0 * Fejer_kernel (K / N) (x - 0) + ∑ k ∈ Finset.Icc 1 N, (f (k * (K / N)) * Fejer_kernel (K / N) (x - k * (K / N)) + f ((-k) * (K / N)) * Fejer_kernel (K / N) (x + k * (K / N))) := by
              intro x
              simp [finite_spline, sum_Icc_symmetric];
            intro x; rw [ h_split x ] ; congr; ext k; rw [ hf_even ( k * ( K / N ) ) ] ; ring;
          unfold symmetrized_fejer_sum; simp +decide [ ← hf_even, ← Finset.sum_add_distrib, Finset.sum_range, Fin.sum_univ_succ ] ;
          intro x; rw [ h_split x ] ; erw [ Finset.sum_Ico_eq_sum_range ] ; norm_num [ add_comm, add_left_comm, Finset.sum_range ] ; ring;

/-
Lemma: The finite spline can be written as a sum over 0..N of symmetrized terms.
-/
noncomputable def spline_coeff (f : ℝ → ℝ) (B : ℝ) (k : ℕ) : ℝ :=
  if k = 0 then f 0 / 2 else f (k * B)

noncomputable def spline_center (B : ℝ) (k : ℕ) : ℝ := k * B

lemma finite_spline_eq_sum_range (K : ℝ) (hK : K > 0) (N : ℕ) (hN : N > 0) (f : ℝ → ℝ)
    (hf_even : ∀ x, f x = f (-x)) :
    ∀ x, finite_spline f K N x = ∑ k ∈ Finset.range (N + 1), spline_coeff f (K / N) k * (Fejer_kernel (K / N) (x - spline_center (K / N) k) + Fejer_kernel (K / N) (x + spline_center (K / N) k)) := by
      -- Apply the lemma `sum_Icc_symmetric` to rewrite the finite spline as a sum over symmetric pairs.
      have h_sum_symmetric : ∀ x, finite_spline f K N x = f 0 * Fejer_kernel (K / N) x + ∑ k ∈ Finset.Icc 1 N, (f (k * (K / N)) * Fejer_kernel (K / N) (x - k * (K / N)) + f (-k * (K / N)) * Fejer_kernel (K / N) (x + k * (K / N))) := by
        intro x; unfold finite_spline; rw [ sum_Icc_symmetric ] ; norm_num [ add_comm ] ;
      norm_num [ h_sum_symmetric, Finset.sum_range_succ' ];
      intro x; erw [ Finset.sum_Ico_eq_sum_range ] ; norm_num [ Finset.sum_add_distrib, mul_add, add_comm, add_left_comm, add_assoc, ← hf_even ] ;
      unfold spline_coeff spline_center; norm_num [ hf_even 0 ] ; ring;

/-
Lemma: For fixed t, as B → 0, the scaled Fejér-heat atom converges uniformly to the symmetrized Fejér kernel.
-/
lemma fejer_heat_approx_fejer (K : ℝ) (hK : K > 0) (t : ℝ) (ht : t > 0) (ε : ℝ) (hε : ε > 0) :
    ∃ B₀ > 0, ∀ B ∈ Set.Ioo 0 B₀, ∀ τ ∈ Set.Icc (-K) K, ∀ x ∈ Set.Icc (-K) K,
      |Fejer_heat_atom B t τ x / heat_kernel t 0 - (Fejer_kernel B (x - τ) + Fejer_kernel B (x + τ))| < ε := by
        -- We want to compare this / Heat(0) with Fejer(x-τ) + Fejer(x+τ).
        -- Difference = Fejer(x-τ) * [Heat(x-τ)/Heat(0) - 1] + Fejer(x+τ) * [Heat(x+τ)/Heat(0) - 1].
        have h_diff : ∀ B > 0, ∀ τ ∈ Set.Icc (-K) K, ∀ x ∈ Set.Icc (-K) K, (Fejer_heat_atom B t τ x / heat_kernel t 0 - (Fejer_kernel B (x - τ) + Fejer_kernel B (x + τ))) = Fejer_kernel B (x - τ) * (heat_kernel t (x - τ) / heat_kernel t 0 - 1) + Fejer_kernel B (x + τ) * (heat_kernel t (x + τ) / heat_kernel t 0 - 1) := by
          unfold Fejer_heat_atom; ring;
          tauto;
        -- We need |Heat(y)/Heat(0) - 1| < ε/2 for y in support of Fejer.
        have h_bound : ∃ δ > 0, ∀ y, |y| < δ → |heat_kernel t y / heat_kernel t 0 - 1| < ε / 2 := by
          have h_cont : ContinuousAt (fun y => heat_kernel t y / heat_kernel t 0) 0 := by
            exact ContinuousAt.div ( ContinuousAt.mul ( continuousAt_const ) ( Real.continuous_exp.continuousAt.comp <| ContinuousAt.div ( ContinuousAt.neg <| continuousAt_id.pow 2 ) ( continuousAt_const.mul continuousAt_const ) <| by positivity ) ) continuousAt_const <| ne_of_gt <| by unfold heat_kernel; positivity;
          have := Metric.continuousAt_iff.mp h_cont ( ε / 2 ) ( half_pos hε ) ; aesop;
          exact ⟨ w, left, fun y hy => by rw [ div_self <| ne_of_gt <| show 0 < heat_kernel t 0 from by unfold heat_kernel; positivity ] at right; exact right hy ⟩;
        obtain ⟨δ, hδ_pos, hδ⟩ : ∃ δ > 0, ∀ y, |y| < δ → |heat_kernel t y / heat_kernel t 0 - 1| < ε / 2 := h_bound
        use δ
        aesop
        generalize_proofs at *;
        -- Since $B < \delta$, we have $|x - \tau| < \delta$ and $|x + \tau| < \delta$, thus we can apply the bound from $hδ$.
        have h_bound_x_minus_tau : |x - τ| < δ ∨ Fejer_kernel B (x - τ) = 0 := by
          unfold Fejer_kernel; aesop;
          exact Classical.or_iff_not_imp_left.2 fun h => by rw [ le_div_iff₀ a ] ; cases abs_cases ( x - τ ) <;> linarith;
        have h_bound_x_plus_tau : |x + τ| < δ ∨ Fejer_kernel B (x + τ) = 0 := by
          unfold Fejer_kernel; aesop;
          · exact Classical.or_iff_not_imp_left.2 fun h' => by rw [ le_div_iff₀ a ] ; cases abs_cases ( x + τ ) <;> linarith;
          · contrapose! h_1; unfold Fejer_kernel at *; aesop;
            rw [ div_lt_iff₀ ] at * <;> cases abs_cases ( x + τ ) <;> cases abs_cases ( x - τ ) <;> linarith
        generalize_proofs at *; (
        cases h_bound_x_minus_tau <;> cases h_bound_x_plus_tau <;> simp_all +decide [ abs_mul ];
        · exact abs_lt.mpr ⟨ by nlinarith [ abs_lt.mp ( hδ ( x - τ ) ‹_› ), abs_lt.mp ( hδ ( x + τ ) ‹_› ), show 0 ≤ Fejer_kernel B ( x - τ ) from by exact le_max_left _ _, show 0 ≤ Fejer_kernel B ( x + τ ) from by exact le_max_left _ _, show Fejer_kernel B ( x - τ ) ≤ 1 from by exact max_le ( by linarith ) ( sub_le_iff_le_add'.mpr <| by linarith [ abs_nonneg ( x - τ ), show |x - τ| / B ≥ 0 by positivity ] ), show Fejer_kernel B ( x + τ ) ≤ 1 from by exact max_le ( by linarith ) ( sub_le_iff_le_add'.mpr <| by linarith [ abs_nonneg ( x + τ ), show |x + τ| / B ≥ 0 by positivity ] ) ], by nlinarith [ abs_lt.mp ( hδ ( x - τ ) ‹_› ), abs_lt.mp ( hδ ( x + τ ) ‹_› ), show 0 ≤ Fejer_kernel B ( x - τ ) from by exact le_max_left _ _, show 0 ≤ Fejer_kernel B ( x + τ ) from by exact le_max_left _ _, show Fejer_kernel B ( x - τ ) ≤ 1 from by exact max_le ( by linarith ) ( sub_le_iff_le_add'.mpr <| by linarith [ abs_nonneg ( x - τ ), show |x - τ| / B ≥ 0 by positivity ] ), show Fejer_kernel B ( x + τ ) ≤ 1 from by exact max_le ( by linarith ) ( sub_le_iff_le_add'.mpr <| by linarith [ abs_nonneg ( x + τ ), show |x + τ| / B ≥ 0 by positivity ] ) ] ⟩;
        · refine' lt_of_le_of_lt ( mul_le_of_le_one_left ( abs_nonneg _ ) _ ) ( by linarith [ hδ ( x - τ ) ‹_› ] );
          exact abs_le.mpr ⟨ by unfold Fejer_kernel; exact le_max_of_le_left ( by linarith [ abs_nonneg ( x - τ ), div_nonneg ( abs_nonneg ( x - τ ) ) a.le ] ), by unfold Fejer_kernel; exact max_le_iff.mpr ⟨ by linarith [ abs_nonneg ( x - τ ), div_nonneg ( abs_nonneg ( x - τ ) ) a.le ], by linarith [ abs_nonneg ( x - τ ), div_nonneg ( abs_nonneg ( x - τ ) ) a.le ] ⟩ ⟩;
        · refine' lt_of_le_of_lt ( mul_le_of_le_one_left ( abs_nonneg _ ) _ ) ( lt_of_lt_of_le ( hδ _ ‹_› ) ( by linarith ) );
          unfold Fejer_kernel; aesop;
          rw [ abs_of_nonneg ( by positivity ) ] ; exact max_le ( by norm_num ) ( sub_le_self _ ( by positivity ) ) ;)

/-
Lemma: The ratio of the heat kernel at y to the heat kernel at 0 converges to 1 as y approaches 0.
-/
lemma heat_kernel_ratio_bound (t : ℝ) (ht : t > 0) (ε : ℝ) (hε : ε > 0) :
    ∃ δ > 0, ∀ y, |y| < δ → |heat_kernel t y / heat_kernel t 0 - 1| < ε := by
      have := Metric.continuousAt_iff.mp ( show ContinuousAt ( fun y => Real.exp ( -y ^ 2 / ( 4 * t ) ) / Real.exp ( -0 ^ 2 / ( 4 * t ) ) ) 0 by exact Continuous.continuousAt ( by continuity ) ) ε hε ; aesop;
      unfold heat_kernel; use w; aesop;
      rw [ mul_right_comm ] ; norm_num [ ne_of_gt ( Real.sqrt_pos.mpr ( show 0 < 4 * Real.pi * t by positivity ) ) ] ; exact right a;