/-
Q3 Formalization: Q_Lipschitz Proof
====================================

This file contains the proof that Q is Lipschitz on W_K.
Proof generated by Aristotle, adapted to use Q3 definitions.
-/

import Mathlib
import Q3.Basic.Defs

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

noncomputable section

namespace Q3.Proofs

-- Use definitions from Q3.Basic.Defs
open Q3

-- Additional definitions needed for proof
noncomputable def a_star_const (ξ : ℝ) : ℝ := 1

lemma a_star_const_continuous : Continuous a_star_const := continuous_const

lemma a_star_const_pos (ξ : ℝ) : 0 < a_star_const ξ := zero_lt_one

noncomputable def arch_term_const (Φ : ℝ → ℝ) : ℝ := ∫ ξ, a_star_const ξ * Φ ξ

noncomputable def prime_term_local (Φ : ℝ → ℝ) : ℝ := ∑' n, w_Q n * Φ (xi_n n)

noncomputable def Q_local (Φ : ℝ → ℝ) : ℝ := arch_term_const Φ - prime_term_local Φ

def W_K_local (K : ℝ) : Set (ℝ → ℝ) :=
  {Φ | ContinuousOn Φ (Set.Icc (-K) K) ∧
       Function.support Φ ⊆ Set.Icc (-K) K ∧
       (∀ x, Φ (-x) = Φ x) ∧
       (∀ x, 0 ≤ Φ x)}

def ActiveNodes_local (K : ℝ) : Set ℕ := {n | |xi_n n| ≤ K ∧ n ≥ 2}

noncomputable def W_sum_local (K : ℝ) : ℝ := ∑' n, if n ∈ ActiveNodes_local K then w_Q n else 0

noncomputable def M_a_local (K : ℝ) : ℝ := sSup (a_star_const '' Set.Icc (-K) K)

noncomputable def L_Q_local (K : ℝ) : ℝ := 2 * K * M_a_local K + W_sum_local K

theorem Q_Lipschitz_local (K : ℝ) (hK : K > 0) :
    ∃ L > 0, ∀ Φ₁ ∈ W_K_local K, ∀ Φ₂ ∈ W_K_local K,
      |Q_local Φ₁ - Q_local Φ₂| ≤ L * sSup {|Φ₁ x - Φ₂ x| | x ∈ Set.Icc (-K) K} := by
  use L_Q_local K
  constructor
  · -- Show L_Q_local K > 0
    refine' add_pos_of_pos_of_nonneg _ _ <;> norm_num [ hK, M_a_local, W_sum_local ];
    · exact lt_of_lt_of_le ( by norm_num [ a_star_const ] ) ( le_csSup ⟨ 1, Set.forall_mem_image.2 fun x hx => by norm_num [ a_star_const ] ⟩ ⟨ -K, ⟨ by linarith, by linarith ⟩, rfl ⟩ );
    · refine' tsum_nonneg _ ; aesop;
      exact div_nonneg ( mul_nonneg zero_le_two ( ArithmeticFunction.vonMangoldt_nonneg ) ) ( Real.sqrt_nonneg _ )
  · intro Φ₁ hΦ₁ Φ₂ hΦ₂
    have hQ : Q_local Φ₁ - Q_local Φ₂ = (∫ x, a_star_const x * (Φ₁ x - Φ₂ x)) - (∑' n, w_Q n * (Φ₁ (xi_n n) - Φ₂ (xi_n n))) := by
      unfold Q_local
      simp [mul_sub];
      unfold arch_term_const prime_term_local; rw [ MeasureTheory.integral_sub ] ; rw [ Summable.tsum_sub ] ; ring;
      · have h_finite : Set.Finite {n : ℕ | w_Q n * Φ₁ (xi_n n) ≠ 0} := by
          have h_support : ∀ n, n ∈ {n : ℕ | w_Q n * Φ₁ (xi_n n) ≠ 0} → |xi_n n| ≤ K := by
            cases hΦ₁ ; aesop;
            exact abs_le.mpr ( left_1 _ right_1 );
          refine Set.finite_iff_bddAbove.mpr ⟨ ⌊Real.exp ( K * ( 2 * Real.pi ) ) ⌋₊, fun n hn => ?_ ⟩ ; specialize h_support n hn ; contrapose! h_support ; aesop;
          rw [ abs_of_nonneg ];
          · rw [ show xi_n n = Real.log n / ( 2 * Real.pi ) by rfl, lt_div_iff₀ ] <;> nlinarith [ Nat.lt_of_floor_lt h_support, Real.pi_pos, Real.log_exp ( K * ( 2 * Real.pi ) ), Real.log_lt_log ( by positivity ) ( show n > Real.exp ( K * ( 2 * Real.pi ) ) by exact Nat.lt_of_floor_lt h_support ) ];
          · exact div_nonneg ( Real.log_natCast_nonneg _ ) ( by positivity );
        refine' summable_of_ne_finset_zero _;
        exacts [ h_finite.toFinset, fun n hn => Classical.not_not.1 fun hnn => hn <| h_finite.mem_toFinset.2 hnn ];
      · have h_finite : Set.Finite {n : ℕ | w_Q n * Φ₂ (xi_n n) ≠ 0} := by
          have h_finite : Set.Finite {n : ℕ | |xi_n n| ≤ K ∧ n ≥ 2} := by
            refine Set.finite_iff_bddAbove.mpr ⟨ ⌊Real.exp ( K * ( 2 * Real.pi ) ) ⌋₊, fun n hn => ?_ ⟩ ; aesop;
            refine Nat.le_floor ?_;
            rw [ abs_le ] at left;
            unfold xi_n at *;
            rw [ div_le_iff₀ ( by positivity ) ] at *;
            rw [ ← Real.log_le_iff_le_exp ( by positivity ) ] ; linarith;
          refine h_finite.subset fun n hn => ?_ ; contrapose! hn ; aesop;
          have := hΦ₂.2.1; aesop;
          exact Classical.not_not.1 fun h => by have := this _ h; exact absurd ( hn <| abs_le.2 ⟨ by linarith, by linarith ⟩ ) ( by linarith [ show n ≥ 2 from Nat.le_of_not_lt fun h' => a <| by interval_cases n <;> unfold w_Q <;> norm_num [ ArithmeticFunction.vonMangoldt ] ] ) ;
        refine' summable_of_ne_finset_zero _;
        exacts [ h_finite.toFinset, fun n hn => Classical.not_not.1 fun hnn => hn <| h_finite.mem_toFinset.2 hnn ];
      · have h_integrable : MeasureTheory.IntegrableOn (fun x => Φ₁ x) (Set.Icc (-K) K) := by
          exact ContinuousOn.integrableOn_Icc hΦ₁.1;
        rw [ MeasureTheory.integrableOn_iff_integrable_of_support_subset ] at h_integrable;
        · convert h_integrable using 1;
          exact funext fun x => by unfold a_star_const; norm_num;
        · exact hΦ₁.2.1;
      · unfold W_K_local at * ; aesop;
        have h_integrable : MeasureTheory.IntegrableOn Φ₂ (Set.Icc (-K) K) := by
          exact left_1.integrableOn_Icc;
        rw [ MeasureTheory.integrableOn_iff_integrable_of_support_subset ] at h_integrable;
        · exact MeasureTheory.Integrable.const_mul h_integrable _;
        · exact fun x hx => left_3 x hx;
    have h_triangle : |∫ x, a_star_const x * (Φ₁ x - Φ₂ x)| ≤ (∫ x in Set.Icc (-K) K, a_star_const x) * (sSup { |Φ₁ x - Φ₂ x| | x ∈ Set.Icc (-K) K }) ∧ |∑' n, w_Q n * (Φ₁ (xi_n n) - Φ₂ (xi_n n))| ≤ (∑' n, if n ∈ ActiveNodes_local K then w_Q n else 0) * (sSup { |Φ₁ x - Φ₂ x| | x ∈ Set.Icc (-K) K }) := by
      constructor;
      · have h_integral_bound : ∫ x, a_star_const x * (Φ₁ x - Φ₂ x) = ∫ x in Set.Icc (-K) K, a_star_const x * (Φ₁ x - Φ₂ x) := by
          rw [ MeasureTheory.setIntegral_eq_integral_of_forall_compl_eq_zero ] ; aesop;
          have := hΦ₁.2.1; have := hΦ₂.2.1; aesop;
          contrapose! a;
          cases eq_or_ne ( Φ₁ x ) 0 <;> cases eq_or_ne ( Φ₂ x ) 0 <;> simp_all +decide [ sub_eq_iff_eq_add ];
        rw [ h_integral_bound, ← MeasureTheory.integral_mul_const ];
        refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm ( _ : ℝ → ℝ ) ) ( MeasureTheory.integral_mono_of_nonneg _ _ _ );
        · exact Filter.Eventually.of_forall fun x => norm_nonneg _;
        · exact Continuous.integrableOn_Icc ( by exact Continuous.mul ( by exact continuous_const ) continuous_const );
        · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with x hx;
          rw [ Real.norm_eq_abs, abs_mul, abs_of_nonneg ( show 0 ≤ a_star_const x from by exact le_of_lt ( a_star_const_pos x ) ) ];
          exact mul_le_mul_of_nonneg_left ( le_csSup ( by exact IsCompact.bddAbove ( isCompact_Icc.image_of_continuousOn ( show ContinuousOn ( fun x => |Φ₁ x - Φ₂ x| ) ( Set.Icc ( -K ) K ) from ContinuousOn.abs ( hΦ₁.1.sub hΦ₂.1 ) ) ) ) ⟨ x, hx, rfl ⟩ ) ( by exact le_of_lt ( a_star_const_pos x ) );
      · have h_triangle_sum : ∀ n, |w_Q n * (Φ₁ (xi_n n) - Φ₂ (xi_n n))| ≤ (if n ∈ ActiveNodes_local K then w_Q n else 0) * (sSup { |Φ₁ x - Φ₂ x| | x ∈ Set.Icc (-K) K }) := by
          intro n; split_ifs <;> simp_all +decide [ abs_mul ] ;
          · rw [ abs_of_nonneg ];
            · bound;
              · exact le_csSup ( by exact IsCompact.bddAbove ( isCompact_Icc.image_of_continuousOn ( ContinuousOn.abs ( hΦ₁.1.sub hΦ₂.1 ) ) ) ) ⟨ _, ⟨ by linarith [ abs_le.mp ( show |xi_n n| ≤ K from h.1 ) ], by linarith [ abs_le.mp ( show |xi_n n| ≤ K from h.1 ) ] ⟩, rfl ⟩;
              · exact div_nonneg ( mul_nonneg zero_le_two ( ArithmeticFunction.vonMangoldt_nonneg ) ) ( Real.sqrt_nonneg _ );
            · exact div_nonneg ( mul_nonneg zero_le_two ( ArithmeticFunction.vonMangoldt_nonneg ) ) ( Real.sqrt_nonneg _ );
          · unfold ActiveNodes_local at * ; aesop;
            contrapose! h;
            aesop;
            · have := hΦ₁.2.1;
              have := hΦ₂.2.1;
              by_cases h₁ : Φ₁ ( xi_n n ) = 0 <;> by_cases h₂ : Φ₂ ( xi_n n ) = 0 <;> simp_all +decide [ abs_le ];
            · rcases n with ( _ | _ | n ) <;> norm_num [ xi_n ] at *;
              · unfold w_Q at h ; aesop;
              · unfold w_Q at h ; norm_num at h;
        by_cases h_summable : Summable (fun n : ℕ => |w_Q n * (Φ₁ (xi_n n) - Φ₂ (xi_n n))|);
        · refine' le_trans ( le_of_eq ( by rw [ ← Real.norm_eq_abs ] ) ) ( le_trans ( norm_tsum_le_tsum_norm _ ) _ );
          · exact h_summable;
          · rw [ ← tsum_mul_right ];
            refine' tsum_le_tsum h_triangle_sum _ _;
            · convert h_summable using 1;
            · refine' summable_of_ne_finset_zero _;
              exact Finset.filter ( fun n => |Real.log n / ( 2 * Real.pi )| ≤ K ∧ 2 ≤ n ) ( Finset.range ( Nat.ceil ( Real.exp ( 2 * Real.pi * K ) ) + 1 ) );
              intro n hn; contrapose! hn; aesop;
              have := left.1;
              unfold xi_n at this;
              rw [ abs_le ] at this;
              exact Nat.lt_succ_of_le ( Nat.le_of_not_lt fun h => by rw [ div_le_iff₀ ( by positivity ) ] at this; linarith [ Real.log_exp ( 2 * Real.pi * K ), Real.log_lt_log ( by positivity ) ( show ( n : ℝ ) > Real.exp ( 2 * Real.pi * K ) by exact lt_of_lt_of_le ( Nat.lt_of_ceil_lt h ) ( mod_cast Nat.le_refl _ ) ) ] );
        · rw [ tsum_eq_zero_of_not_summable ];
          · norm_num;
            refine' mul_nonneg _ ( by apply_rules [ Real.sSup_nonneg ] ; aesop );
            refine' tsum_nonneg _;
            aesop;
            exact div_nonneg ( mul_nonneg zero_le_two ( by exact_mod_cast ArithmeticFunction.vonMangoldt_nonneg ) ) ( Real.sqrt_nonneg _ );
          · exact fun h => h_summable <| h.abs;
    have h_LQ : L_Q_local K = (∫ x in Set.Icc (-K) K, a_star_const x) + (∑' n, if n ∈ ActiveNodes_local K then w_Q n else 0) := by
      unfold L_Q_local;
      unfold M_a_local W_sum_local; aesop;
      unfold a_star_const; norm_num [ hK.le ] ; ring;
    exact hQ.symm ▸ abs_le.mpr ⟨ by nlinarith [ abs_le.mp h_triangle.1, abs_le.mp h_triangle.2, show 0 ≤ SupSet.sSup { x : ℝ | ∃ x_1 ∈ Set.Icc ( -K ) K, |Φ₁ x_1 - Φ₂ x_1| = x } by apply_rules [ Real.sSup_nonneg ] ; rintro x ⟨ y, hy, rfl ⟩ ; exact abs_nonneg _ ], by nlinarith [ abs_le.mp h_triangle.1, abs_le.mp h_triangle.2, show 0 ≤ SupSet.sSup { x : ℝ | ∃ x_1 ∈ Set.Icc ( -K ) K, |Φ₁ x_1 - Φ₂ x_1| = x } by apply_rules [ Real.sSup_nonneg ] ; rintro x ⟨ y, hy, rfl ⟩ ; exact abs_nonneg _ ] ⟩

end Q3.Proofs

end
