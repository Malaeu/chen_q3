/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 0d0aac0b-1e59-4355-84e7-3dfe01f60be1
-/

/-
Formalized and proved the A3 Toeplitz-Symbol Bridge Theorem.
The theorem establishes a lower bound on the minimal eigenvalue of the difference between the Toeplitz operator T_M[P_A] and the compressed prime operator T_P^{(M)}.
The proof follows the provided structure:
1. Using the Szegő limit theorem (formalized as an assumption `h_szego`) to bound the Toeplitz form from below by `c_0(K)`.
2. Using the RKHS contraction (formalized as an assumption `h_prime_bound`) to bound the Prime form from above by `c_0(K)/4`.
3. Combining these estimates to show the difference is at least `3/4 * c_0(K)`, which is strictly greater than `c_0(K)/4`.
Definitions for the Fejér-heat window, prime weights, and prime nodes were also implemented.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check LaurentPolynomial
#check Complex.normSq
#check AddMonoidAlgebra

/-
For K ≥ 1, there exist M₀ and t > 0 such that for all M ≥ M₀, the minimal eigenvalue of T_M[P_A] - T_P^{(M)} is at least c_0(K)/4.
-/
open Real Complex MeasureTheory Filter Topology
open scoped BigOperators

noncomputable def FejerHeatWindow (B t : ℝ) (ξ : ℝ) : ℝ :=
  max 0 (1 - |ξ| / B) * Real.exp (-4 * Real.pi^2 * t * ξ^2)

noncomputable def PrimeWeight (n : ℕ) : ℝ := 2 * ArithmeticFunction.vonMangoldt n / Real.sqrt n

noncomputable def PrimeNode (n : ℕ) : ℝ := Real.log n / (2 * Real.pi)

noncomputable def evalTrig (p : LaurentPolynomial ℂ) (θ : ℝ) : ℂ :=
  p.sum (fun k c => c * Complex.exp (I * (k : ℂ) * (θ : ℂ)))

noncomputable def ToeplitzForm (P_A : ℝ → ℝ) (p : LaurentPolynomial ℂ) : ℝ :=
  (∫ θ in (0)..(2*Real.pi), P_A θ * Complex.normSq (evalTrig p θ)) / (2 * Real.pi)

noncomputable def PrimeForm (B t : ℝ) (p : LaurentPolynomial ℂ) : ℝ :=
  ∑' (n : ℕ), PrimeWeight n * FejerHeatWindow B t (PrimeNode n) * Complex.normSq (evalTrig p (PrimeNode n))

noncomputable def L2NormSq (p : LaurentPolynomial ℂ) : ℝ :=
  (∫ θ in (0)..(2*Real.pi), Complex.normSq (evalTrig p θ)) / (2 * Real.pi)

def IsTrigPoly (M : ℕ) (p : LaurentPolynomial ℂ) : Prop :=
  ∀ k ∈ p.support, |k| ≤ M

theorem A3_Bridge_Theorem
  (P_A : ℝ → ℝ)
  (c_0 : ℝ → ℝ)
  (B : ℝ)
  (K : ℝ)
  (hK : K ≥ 1)
  (h_c0_pos : c_0 K > 0)
  (h_inf_PA : sInf (Set.range P_A) ≥ c_0 K)
  (h_szego : Filter.Tendsto (fun M => sInf ((fun p => (ToeplitzForm P_A p) / (L2NormSq p)) '' { p : LaurentPolynomial ℂ | IsTrigPoly M p ∧ p ≠ 0 })) Filter.atTop (nhds (sInf (Set.range P_A))))
  (h_prime_bound : ∀ ε > 0, ∃ t > 0, ∀ M, ∀ p, IsTrigPoly M p → p ≠ 0 → PrimeForm B t p / L2NormSq p ≤ ε)
  : ∃ M₀ : ℕ, ∃ t > 0, ∀ M ≥ M₀, ∀ p : LaurentPolynomial ℂ, IsTrigPoly M p → p ≠ 0 →
    (ToeplitzForm P_A p - PrimeForm B t p) / (L2NormSq p) ≥ c_0 K / 4 := by
  -- By combining the results from h_szego and h_prime_bound, we can choose M₀ and t such that the difference between T_M[P_A] and T_P^{(M)} is bounded below by c_0(K)/4.
  obtain ⟨M₀, hM₀⟩ : ∃ M₀, ∀ M ≥ M₀, sInf (Set.image (fun p => (ToeplitzForm P_A p) / (L2NormSq p)) {p : LaurentPolynomial ℂ | (IsTrigPoly M p) ∧ p ≠ 0}) ≥ (3 * c_0 K) / 4 := by
    exact Filter.eventually_atTop.mp ( h_szego.eventually ( le_mem_nhds ( by linarith ) ) );
  obtain ⟨ t, ht₀, ht ⟩ := h_prime_bound ( c_0 K / 4 ) ( by positivity );
  refine' ⟨ M₀, t, ht₀, fun M hM p hp hp' => _ ⟩;
  have := hM₀ M hM;
  -- Since $p$ is a trigonometric polynomial of degree $M$, we can apply the definition of the infimum to get that $(ToeplitzForm P_A p) / (L2NormSq p) ≥ 3 * c_0 K / 4$.
  have h_inf_P_A : (ToeplitzForm P_A p) / (L2NormSq p) ≥ 3 * c_0 K / 4 := by
    refine' le_trans this ( csInf_le _ _ );
    · exact ( by contrapose! this; rw [ Real.sInf_of_not_bddBelow this ] ; linarith );
    · exact ⟨ p, ⟨ hp, hp' ⟩, rfl ⟩;
  rw [ sub_div ] ; linarith [ ht M p hp hp' ]