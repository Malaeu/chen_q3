/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 1bdb6bc5-d626-4f6d-8dbf-cb64a070bff4

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib
import Q3.Axioms

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions of FejÃ©r kernel and Heat kernel.
-/
noncomputable def FejerKernel (B : â„) (x : â„) : â„ := max (1 - |x| / B) 0

noncomputable def HeatKernel (t : â„) (x : â„) : â„ :=
  (1 / Real.sqrt (4 * Real.pi * t)) * Real.exp (-x^2 / (4 * t))

/-
Definition of FejÃ©r-heat atoms as symmetrized products.
-/
noncomputable def FejerHeatAtom (B t tau xi : â„) : â„ :=
  FejerKernel B (xi - tau) * HeatKernel t (xi - tau) +
  FejerKernel B (xi + tau) * HeatKernel t (xi + tau)

/-
Definition of the space W_K of test functions.
-/
def W_K (K : â„) : Set (â„ â†’ â„) :=
  { Î¦ | ContinuousOn Î¦ (Set.Icc (-K) K) âˆ§
        Function.support Î¦ âŠ† Set.Icc (-K) K âˆ§
        (âˆ€ x, Î¦ (-x) = Î¦ x) âˆ§
        (âˆ€ x, Î¦ x â‰¥ 0) }

/-
Checking List.sum
-/
#check List.sum

/-
Definition of the atom cone AtomCone_K.
-/
structure AtomParams where
  c : â„
  B : â„
  t : â„
  tau : â„

def evalAtomParams (p : AtomParams) : â„ â†’ â„ :=
  fun x => p.c * FejerHeatAtom p.B p.t p.tau x

/-- AtomCone_K: Finite nonnegative combinations of FejÃ©r-heat atoms
    with proper support control (B â‰¤ K) and W_K membership.
    This matches Q3.AtomCone_K from Axioms.lean -/
def AtomCone_K (K : â„) : Set (â„ â†’ â„) :=
  { g | âˆƒ (L : List AtomParams),
        (âˆ€ p âˆˆ L, p.c â‰¥ 0 âˆ§ p.B > 0 âˆ§ p.t > 0 âˆ§ |p.tau| â‰¤ K âˆ§ p.B â‰¤ K) âˆ§
        g = (L.map evalAtomParams).sum âˆ§
        g âˆˆ W_K K }  -- explicitly require g âˆˆ W_K

/-- Legacy AtomCone without W_K requirement (for helper lemmas) -/
def AtomCone_K_legacy (K : â„) : Set (â„ â†’ â„) :=
  { g | âˆƒ (L : List AtomParams),
        (âˆ€ p âˆˆ L, p.c â‰¥ 0 âˆ§ p.B > 0 âˆ§ p.t > 0 âˆ§ |p.tau| â‰¤ K âˆ§ p.B â‰¤ K) âˆ§
        g = (L.map evalAtomParams).sum }

/-!
Definition alignment with Q3.Axioms.
-/
lemma FejerKernel_eq_q3 (B x : â„) : FejerKernel B x = Q3.Fejer_kernel B x := by
  unfold FejerKernel Q3.Fejer_kernel
  rw [max_comm]

lemma HeatKernel_eq_q3 (t x : â„) : HeatKernel t x = Q3.heat_kernel_A1 t x := by
  rfl

lemma FejerHeatAtom_eq_q3 (B t tau x : â„) :
    FejerHeatAtom B t tau x = Q3.Fejer_heat_atom B t tau x := by
  unfold FejerHeatAtom Q3.Fejer_heat_atom
  simp [FejerKernel_eq_q3, HeatKernel_eq_q3]

lemma W_K_eq_q3 (K : â„) : W_K K = Q3.W_K K := by
  ext Î¦
  simp [W_K, Q3.W_K, Q3.IsEven, Q3.IsNonneg]

/-
Heat kernel integrates to 1.
-/
open MeasureTheory Set Filter Topology

theorem HeatKernel_integral (t : â„) (ht : t > 0) : âˆ« x, HeatKernel t x = 1 := by
  -- By definition of Gaussian integral, we know that $\int_{-\infty}^{\infty} e^{-ax^2} \, dx = \sqrt{\frac{\pi}{a}}$ for $a > 0$.
  have h_gauss_integral : âˆ« x, Real.exp (-x^2 / (4 * t)) = Real.sqrt (4 * Real.pi * t) := by
    convert integral_gaussian ( 1 / ( 4 * t ) ) using 1 <;> norm_num [ div_eq_inv_mul ] ; ring;
  unfold HeatKernel;
  rw [ MeasureTheory.integral_const_mul, h_gauss_integral, div_mul_cancelâ‚€ _ ( by positivity ) ]

/-
Heat kernel mass concentration: For any delta > 0, the integral of the heat kernel over |x| > delta tends to 0 as t -> 0.
-/
theorem HeatKernel_concentration (Î´ : â„) (hÎ´ : Î´ > 0) :
  Tendsto (fun t => âˆ« x in {x | |x| > Î´}, HeatKernel t x) (nhdsWithin 0 (Ioi 0)) (nhds 0) := by
    -- Use the fact that the integral of the heat kernel over |x| > Î´ can be bounded by the integral of the Gaussian function over the same region.
    suffices h_gaussian : Filter.Tendsto (fun t : â„ => âˆ« x in {x : â„ | |x| > Î´}, (1 / Real.sqrt (4 * Real.pi * t)) * Real.exp (-x^2 / (4 * t))) (ğ“[>] 0) (ğ“ 0) by
      convert h_gaussian using 1;
    -- Perform the substitution $u = \frac{x}{\sqrt{t}}$ to transform the integral.
    suffices h_subst : Filter.Tendsto (fun t : â„ => âˆ« u in {u : â„ | |u| > Î´ / Real.sqrt t}, (1 / Real.sqrt (4 * Real.pi)) * Real.exp (-u^2 / 4)) (ğ“[>] 0) (ğ“ 0) by
      refine' h_subst.congr' _;
      filter_upwards [ self_mem_nhdsWithin ] with t ht;
      have h_subst : âˆ€ {f : â„ â†’ â„}, âˆ« x in {x : â„ | |x| > Î´}, f x = âˆ« u in {u : â„ | |u| > Î´ / Real.sqrt t}, f (u * Real.sqrt t) * Real.sqrt t := by
        intro f; rw [ â† MeasureTheory.integral_indicator, â† MeasureTheory.integral_indicator ] <;> norm_num [ Set.indicator ] ; aesop;
        Â· have h_subst : âˆ€ {f : â„ â†’ â„}, âˆ« x, f x = âˆ« u, f (u * Real.sqrt t) * Real.sqrt t := by
            intro f; rw [ MeasureTheory.integral_mul_const ] ; rw [ MeasureTheory.Measure.integral_comp_mul_right ] ; norm_num [ ht.le, ht.ne' ] ;
            rw [ abs_of_nonneg ( Real.sqrt_nonneg _ ), inv_mul_eq_div, div_mul_cancelâ‚€ _ ( ne_of_gt ( Real.sqrt_pos.mpr ht ) ) ];
          convert h_subst using 3 ; aesop;
          Â· rw [ abs_of_nonneg ( Real.sqrt_nonneg _ ) ] at a ; rw [ div_lt_iffâ‚€ ( Real.sqrt_pos.mpr ht ) ] at h ; nlinarith [ Real.sqrt_nonneg t, Real.sq_sqrt ht.le ];
          Â· rw [ abs_of_nonneg ( Real.sqrt_nonneg _ ) ] at a ; rw [ le_div_iffâ‚€ ( Real.sqrt_pos.mpr ht ) ] at h ; nlinarith [ Real.sqrt_nonneg t, Real.sq_sqrt ht.le ];
        Â· exact measurableSet_Ioi.mem.comp measurable_norm;
        Â· exact measurableSet_Ioi.mem.comp measurable_norm;
      rw [ h_subst ] ; norm_num [ mul_pow, ht.out.le ] ; ring;
      simp +decide [ ht.out.ne', Real.sqrt_ne_zero'.mpr ht.out ];
    -- Use the fact that the integral of the Gaussian function over |u| > Î´ / Real.sqrt t tends to 0 as t -> 0.
    have h_gauss_tail : Filter.Tendsto (fun t : â„ => âˆ« u in Set.Ioi (Î´ / Real.sqrt t), Real.exp (-u^2 / 4)) (ğ“[>] 0) (ğ“ 0) := by
      -- Use the fact that the integral of the Gaussian function over |u| > Î´ / Real.sqrt t tends to 0 as t -> 0. This follows from the properties of the Gaussian integral.
      have h_gauss_tail : Filter.Tendsto (fun t : â„ => âˆ« u in Set.Ioi t, Real.exp (-u^2 / 4)) Filter.atTop (ğ“ 0) := by
        have h_gauss_tail : Filter.Tendsto (fun t : â„ => âˆ« u in Set.Ioi 0, Real.exp (-u^2 / 4) * (if u > t then 1 else 0)) Filter.atTop (ğ“ 0) := by
          have h_gauss_tail : Filter.Tendsto (fun t : â„ => âˆ« u in Set.Ioi 0, Real.exp (-u^2 / 4) * (if u > t then 1 else 0)) Filter.atTop (ğ“ (âˆ« u in Set.Ioi 0, Real.exp (-u^2 / 4) * 0)) := by
            refine' MeasureTheory.tendsto_integral_filter_of_dominated_convergence _ _ _ _ _;
            refine' fun u => Real.exp ( -u ^ 2 / 4 );
            Â· exact Filter.Eventually.of_forall fun n => Measurable.aestronglyMeasurable ( by exact Measurable.mul ( Real.continuous_exp.measurable.comp ( by exact Continuous.measurable ( by continuity ) ) ) ( by exact Measurable.ite ( measurableSet_Ioi ) measurable_const measurable_const ) );
            Â· filter_upwards [ Filter.eventually_gt_atTop 0 ] with n hn using Filter.Eventually.of_forall fun x => by split_ifs <;> norm_num ; positivity;
            Â· exact MeasureTheory.Integrable.integrableOn ( by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by norm_num ) ) );
            Â· filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioi ] with x hx using tendsto_const_nhds.congr' ( by filter_upwards [ Filter.eventually_gt_atTop x ] with n hn; aesop ; linarith );
          aesop;
        refine h_gauss_tail.congr' ?_;
        filter_upwards [ Filter.eventually_gt_atTop 0 ] with t ht;
        rw [ â† MeasureTheory.integral_indicator ( measurableSet_Ioi ), â† MeasureTheory.integral_indicator ( measurableSet_Ioi ) ];
        congr with x ; rw [ Set.indicator_apply, Set.indicator_apply ] ; aesop ; linarith;
      refine h_gauss_tail.comp ?_;
      refine' Filter.Tendsto.const_mul_atTop hÎ´ _;
      refine' Filter.Tendsto.inv_tendsto_nhdsGT_zero _;
      refine' Filter.Tendsto.inf _ _ <;> simpa using Real.continuous_sqrt.tendsto 0;
    -- Use the fact that the integral of the Gaussian function over |u| > Î´ / Real.sqrt t is twice the integral over u > Î´ / Real.sqrt t.
    have h_gauss_tail_symm : âˆ€ t > 0, âˆ« u in {u : â„ | |u| > Î´ / Real.sqrt t}, Real.exp (-u^2 / 4) = 2 * âˆ« u in Set.Ioi (Î´ / Real.sqrt t), Real.exp (-u^2 / 4) := by
      intro t ht
      have h_symm : âˆ« u in {u : â„ | |u| > Î´ / Real.sqrt t}, Real.exp (-u^2 / 4) = (âˆ« u in Set.Ioi (Î´ / Real.sqrt t), Real.exp (-u^2 / 4)) + (âˆ« u in Set.Iio (-Î´ / Real.sqrt t), Real.exp (-u^2 / 4)) := by
        rw [ â† MeasureTheory.setIntegral_union ] <;> norm_num [ neg_div ];
        Â· rcongr u ; aesop;
          Â· cases abs_cases u <;> [ left; right ] <;> norm_num <;> linarith;
          Â· cases a <;> cases abs_cases u <;> linarith [ Set.mem_Ioi.mp â€¹_â€º, Set.mem_Iio.mp â€¹_â€º ];
        Â· positivity;
        Â· exact MeasureTheory.Integrable.integrableOn ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) ) ) ) ) ) );
        Â· exact MeasureTheory.Integrable.integrableOn ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) ) ) ) ) ) );
      rw [ h_symm, two_mul ];
      rw [ â† MeasureTheory.integral_Iic_eq_integral_Iio ] ; rw [ â† neg_neg ( Î´ / Real.sqrt t ) ] ; rw [ â† integral_comp_neg_Iic ] ; norm_num [ neg_div ] ;
    simp_all +decide [ MeasureTheory.integral_const_mul ];
    exact le_trans ( Filter.Tendsto.mul tendsto_const_nhds <| Filter.Tendsto.congr' ( Filter.eventuallyEq_of_mem self_mem_nhdsWithin fun x hx => by rw [ h_gauss_tail_symm x hx ] ) <| h_gauss_tail.const_mul 2 ) <| by norm_num;

/-
Heat kernel is nonnegative.
-/
theorem HeatKernel_nonneg (t : â„) (ht : t > 0) (x : â„) : HeatKernel t x â‰¥ 0 := by
  exact mul_nonneg ( by positivity ) ( Real.exp_nonneg _ )

/-
FejÃ©r kernel bounds: 0 <= FejerKernel B x <= 1.
-/
theorem FejerKernel_bounds (B : â„) (hB : B > 0) (x : â„) :
  0 â‰¤ FejerKernel B x âˆ§ FejerKernel B x â‰¤ 1 := by
    refine' âŸ¨ _, _ âŸ©;
    Â· exact le_max_right _ _;
    Â· exact max_le_iff.mpr âŸ¨ sub_le_self _ ( by positivity ), by norm_num âŸ©

/-
Corrected FejÃ©r kernel approximation: For B > K, 1 - K/B <= FejerKernel B x <= 1 on [-K, K].
-/
theorem FejerKernel_approx_one_uniform (B K : â„) (hB : B > K) (hK : K > 0) :
  âˆ€ x âˆˆ Set.Icc (-K) K, 1 - K / B â‰¤ FejerKernel B x âˆ§ FejerKernel B x â‰¤ 1 := by
    intros x _hx_range; (unfold FejerKernel; aesop);
    Â· exact Or.inl ( by cases abs_cases x <;> ring_nf <;> nlinarith [ inv_mul_cancelâ‚€ ( by linarith : B â‰  0 ) ] );
    Â· exact div_nonneg ( abs_nonneg x ) ( by linarith )

/-
Checking convolution in Mathlib.
-/
#check convolution

/-
Definition of simple convolution for real-valued functions.
-/
noncomputable def simple_convolution (f g : â„ â†’ â„) (x : â„) : â„ := âˆ« y, f y * g (x - y)

/-
Convolution of a continuous function with compact support with the heat kernel converges uniformly to the function.
-/
theorem continuous_convolution_approx (f : â„ â†’ â„) (hf : Continuous f) (hsupp : HasCompactSupport f) (Îµ : â„) (hÎµ : Îµ > 0) :
  âˆƒ t > 0, âˆ€ x, |simple_convolution f (HeatKernel t) x - f x| < Îµ := by
    -- Since $f$ is continuous and has compact support, it is uniformly continuous.
    obtain âŸ¨Î´, hÎ´_pos, hÎ´âŸ© : âˆƒ Î´ > 0, âˆ€ x y, abs (x - y) < Î´ â†’ abs (f x - f y) < Îµ / 2 := by
      have h_unif_cont : UniformContinuous f := by
        exact?;
      exact Metric.uniformContinuous_iff.mp h_unif_cont ( Îµ / 2 ) ( half_pos hÎµ );
    -- Choose t small enough so that the integral of the heat kernel over |y| â‰¥ Î´ is less than Îµ / (4 * â€–fâ€–_âˆ).
    obtain âŸ¨t, ht_pos, htâŸ© : âˆƒ t > 0, âˆ« y in {y | abs y â‰¥ Î´}, HeatKernel t y < Îµ / (4 * (sSup (abs '' Set.range f)) + 1) := by
      have h_tail_integral : Filter.Tendsto (fun t => âˆ« y in {y | abs y â‰¥ Î´}, HeatKernel t y) (nhdsWithin 0 (Ioi 0)) (nhds 0) := by
        convert HeatKernel_concentration Î´ hÎ´_pos using 1;
        ext t; rw [ MeasureTheory.setIntegral_congr_set ] ; aesop;
        rw [ MeasureTheory.ae_eq_set ] ; aesop;
        Â· rw [ show { y : â„ | Î´ â‰¤ |y| } \ { x : â„ | Î´ < |x| } = { y : â„ | |y| = Î´ } by ext; aesop ; linarith ];
          norm_num [ abs_eq hÎ´_pos.le ];
          rw [ Set.setOf_or, MeasureTheory.measure_union ] <;> norm_num;
          linarith;
        Â· rw [ show { x : â„ | Î´ < |x| } \ { y : â„ | Î´ â‰¤ |y| } = âˆ… by ext; aesop ; linarith ] ; norm_num;
      have := h_tail_integral.eventually ( gt_mem_nhds <| show 0 < Îµ / ( 4 * SupSet.sSup ( abs '' Set.range f ) + 1 ) from div_pos hÎµ <| by linarith [ show 0 â‰¤ SupSet.sSup ( abs '' Set.range f ) from by apply_rules [ Real.sSup_nonneg ] ; rintro x âŸ¨ y, hy, rfl âŸ© ; exact abs_nonneg _ ] ) ; have := this.and self_mem_nhdsWithin; rcases this.exists with âŸ¨ t, htâ‚, htâ‚‚ âŸ© ; exact âŸ¨ t, htâ‚‚, htâ‚ âŸ© ;
    -- Using the bounds on the heat kernel and the uniform continuity of f, we can bound the convolution.
    have h_conv_bound : âˆ€ x, abs (simple_convolution f (HeatKernel t) x - f x) â‰¤ (âˆ« y in {y | abs y < Î´}, abs (f (x - y) - f x) * HeatKernel t y) + (âˆ« y in {y | abs y â‰¥ Î´}, (2 * sSup (abs '' Set.range f)) * HeatKernel t y) := by
      intro x
      have h_conv_bound : abs (simple_convolution f (HeatKernel t) x - f x) â‰¤ (âˆ« y, abs (f (x - y) - f x) * HeatKernel t y) := by
        have h_conv_bound : abs (simple_convolution f (HeatKernel t) x - f x) â‰¤ âˆ« y, abs (f (x - y) - f x) * HeatKernel t y := by
          have h_conv : simple_convolution f (HeatKernel t) x - f x = âˆ« y, (f (x - y) - f x) * HeatKernel t y := by
            simp +decide [ sub_mul, simple_convolution ];
            rw [ MeasureTheory.integral_sub ];
            Â· rw [ show ( âˆ« y, f y * HeatKernel t ( x - y ) ) = ( âˆ« y, f ( x - y ) * HeatKernel t y ) by rw [ â† MeasureTheory.integral_sub_left_eq_self ] ; congr; ext; ring ] ; rw [ MeasureTheory.integral_const_mul ] ; norm_num [ HeatKernel_integral t ht_pos ] ;
            Â· -- Since $f$ is continuous and has compact support, it is bounded. Let $M$ be an upper bound for $|f|$.
              obtain âŸ¨M, hMâŸ© : âˆƒ M, âˆ€ x, abs (f x) â‰¤ M := by
                have := hsupp.exists_bound_of_continuous hf;
                tauto;
              refine' MeasureTheory.Integrable.mono' _ _ _;
              refine' fun y => M * HeatKernel t y;
              Â· refine' MeasureTheory.Integrable.const_mul _ _;
                exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht_pos );
              Â· exact MeasureTheory.AEStronglyMeasurable.mul ( hf.comp ( continuous_const.sub continuous_id' ) |> Continuous.aestronglyMeasurable ) ( by exact Continuous.aestronglyMeasurable ( by exact Continuous.mul ( continuous_const ) ( Real.continuous_exp.comp ( by continuity ) ) ) );
              Â· filter_upwards [ ] with y using by rw [ Real.norm_eq_abs, abs_mul, abs_of_nonneg ( show 0 â‰¤ HeatKernel t y by exact mul_nonneg ( one_div_nonneg.mpr ( Real.sqrt_nonneg _ ) ) ( Real.exp_nonneg _ ) ) ] ; exact mul_le_mul_of_nonneg_right ( hM _ ) ( show 0 â‰¤ HeatKernel t y by exact mul_nonneg ( one_div_nonneg.mpr ( Real.sqrt_nonneg _ ) ) ( Real.exp_nonneg _ ) ) ;
            Â· refine' MeasureTheory.Integrable.const_mul _ _;
              exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht_pos )
          rw [ h_conv ];
          convert MeasureTheory.norm_integral_le_integral_norm ( _ : â„ â†’ â„ ) using 1 ; norm_num [ abs_mul, abs_of_nonneg, ht_pos.le, HeatKernel_nonneg ];
          exact congr_arg _ ( funext fun y => by rw [ abs_of_nonneg ( HeatKernel_nonneg t ht_pos y ) ] );
        exact h_conv_bound;
      have h_conv_bound_split : âˆ« y, abs (f (x - y) - f x) * HeatKernel t y â‰¤ (âˆ« y in {y | abs y < Î´}, abs (f (x - y) - f x) * HeatKernel t y) + (âˆ« y in {y | abs y â‰¥ Î´}, abs (f (x - y) - f x) * HeatKernel t y) := by
        rw [ â† MeasureTheory.setIntegral_union ];
        Â· rw [ show { y : â„ | |y| < Î´ } âˆª { y : â„ | |y| â‰¥ Î´ } = Set.univ by ext y; by_cases hy : |y| < Î´ <;> aesop ] ; norm_num;
        Â· exact Set.disjoint_left.mpr fun y hyâ‚ hyâ‚‚ => hyâ‚.out.not_le hyâ‚‚.out;
        Â· exact measurableSet_le measurable_const measurable_norm;
        Â· refine' MeasureTheory.Integrable.integrableOn _;
          refine' MeasureTheory.Integrable.mono' _ _ _;
          refine' fun y => ( 2 * SupSet.sSup ( abs '' Set.range f ) ) * HeatKernel t y;
          Â· refine' MeasureTheory.Integrable.const_mul _ _;
            exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht_pos );
          Â· exact MeasureTheory.AEStronglyMeasurable.mul ( Continuous.aestronglyMeasurable ( by continuity ) ) ( Continuous.aestronglyMeasurable ( by exact Continuous.mul ( continuous_const ) ( Real.continuous_exp.comp ( by continuity ) ) ) );
          Â· filter_upwards [ ] with y;
            rw [ Real.norm_of_nonneg ( mul_nonneg ( abs_nonneg _ ) ( HeatKernel_nonneg t ht_pos _ ) ) ];
            gcongr;
            Â· exact HeatKernel_nonneg t ht_pos y;
            Â· have h_bound : âˆ€ x, abs (f x) â‰¤ SupSet.sSup (abs '' Set.range f) := by
                intro x; exact le_csSup (by
                have := hsupp.exists_bound_of_continuous hf;
                exact âŸ¨ this.choose, Set.forall_mem_image.2 fun x hx => by obtain âŸ¨ y, rfl âŸ© := hx; exact this.choose_spec y âŸ©) (by
                aesop);
              exact le_trans ( abs_sub _ _ ) ( by linarith [ h_bound ( x - y ), h_bound x ] );
        Â· refine' MeasureTheory.Integrable.integrableOn _;
          refine' MeasureTheory.Integrable.mono' _ _ _;
          refine' fun y => ( 2 * SupSet.sSup ( abs '' Set.range f ) ) * HeatKernel t y;
          Â· refine' MeasureTheory.Integrable.const_mul _ _;
            exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht_pos );
          Â· exact MeasureTheory.AEStronglyMeasurable.mul ( Continuous.aestronglyMeasurable ( by continuity ) ) ( Continuous.aestronglyMeasurable ( by exact Continuous.mul ( continuous_const ) ( Real.continuous_exp.comp ( by continuity ) ) ) );
          Â· filter_upwards [ ] with y;
            rw [ Real.norm_of_nonneg ( mul_nonneg ( abs_nonneg _ ) ( HeatKernel_nonneg t ht_pos _ ) ) ];
            gcongr;
            Â· exact HeatKernel_nonneg t ht_pos y;
            Â· have h_bound : âˆ€ x, abs (f x) â‰¤ SupSet.sSup (abs '' Set.range f) := by
                intro x; exact le_csSup (by
                have := hsupp.exists_bound_of_continuous hf;
                exact âŸ¨ this.choose, Set.forall_mem_image.2 fun x hx => by obtain âŸ¨ y, rfl âŸ© := hx; exact this.choose_spec y âŸ©) (by
                aesop);
              exact le_trans ( abs_sub _ _ ) ( by linarith [ h_bound ( x - y ), h_bound x ] );
      refine le_trans h_conv_bound <| h_conv_bound_split.trans <| add_le_add_left ?_ _;
      refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
      Â· exact Filter.Eventually.of_forall fun y => mul_nonneg ( abs_nonneg _ ) ( HeatKernel_nonneg t ht_pos y );
      Â· refine' MeasureTheory.Integrable.const_mul _ _;
        refine' MeasureTheory.Integrable.integrableOn _;
        exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht_pos );
      Â· filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_le measurable_const <| measurable_norm ] with y hy;
        gcongr;
        Â· exact mul_nonneg ( by positivity ) ( Real.exp_nonneg _ );
        Â· have h_bound : âˆ€ x, abs (f x) â‰¤ SupSet.sSup (abs '' Set.range f) := by
            intro x; exact le_csSup (by
            have := hsupp.exists_bound_of_continuous hf;
            exact âŸ¨ this.choose, Set.forall_mem_image.2 fun x hx => by obtain âŸ¨ y, rfl âŸ© := hx; exact this.choose_spec y âŸ©) (by
            aesop);
          exact le_trans ( abs_sub _ _ ) ( by linarith [ h_bound ( x - y ), h_bound x ] );
    -- Using the bounds on the heat kernel and the uniform continuity of f, we can bound the first integral.
    have h_first_integral_bound : âˆ€ x, âˆ« y in {y | abs y < Î´}, abs (f (x - y) - f x) * HeatKernel t y â‰¤ (Îµ / 2) * âˆ« y in {y | abs y < Î´}, HeatKernel t y := by
      intro x; rw [ â† MeasureTheory.integral_const_mul ] ; refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
      Â· exact Filter.Eventually.of_forall fun y => mul_nonneg ( abs_nonneg _ ) ( HeatKernel_nonneg t ht_pos y );
      Â· refine' MeasureTheory.Integrable.const_mul _ _;
        refine' MeasureTheory.Integrable.integrableOn _;
        exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht_pos );
      Â· filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_lt ( measurable_norm ) measurable_const ] with y hy using mul_le_mul_of_nonneg_right ( le_of_lt <| hÎ´ _ _ <| by simpa using hy ) <| by exact ( show 0 â‰¤ HeatKernel t y from by exact mul_nonneg ( by positivity ) <| Real.exp_nonneg _ ) ;
    -- Using the bounds on the heat kernel and the uniform continuity of f, we can bound the second integral.
    have h_second_integral_bound : âˆ« y in {y | abs y â‰¥ Î´}, (2 * sSup (abs '' Set.range f)) * HeatKernel t y â‰¤ (2 * sSup (abs '' Set.range f)) * (Îµ / (4 * (sSup (abs '' Set.range f)) + 1)) := by
      rw [ MeasureTheory.integral_const_mul ] ; exact mul_le_mul_of_nonneg_left ht.le <| mul_nonneg zero_le_two <| by apply_rules [ Real.sSup_nonneg ] ; rintro x âŸ¨ y, hy, rfl âŸ© ; exact abs_nonneg _;
    -- Using the bounds on the heat kernel and the uniform continuity of f, we can bound the first integral further.
    have h_first_integral_bound_further : âˆ€ x, âˆ« y in {y | abs y < Î´}, abs (f (x - y) - f x) * HeatKernel t y â‰¤ (Îµ / 2) * 1 := by
      intro x; refine le_trans ( h_first_integral_bound x ) ?_; gcongr;
      refine' le_trans ( MeasureTheory.setIntegral_le_integral _ _ ) _;
      Â· exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht_pos );
      Â· exact Filter.Eventually.of_forall fun x => by unfold HeatKernel; positivity;
      Â· rw [ HeatKernel_integral t ht_pos ];
    exact âŸ¨ t, ht_pos, fun x => lt_of_le_of_lt ( h_conv_bound x ) ( by nlinarith [ h_first_integral_bound_further x, h_second_integral_bound, show 0 â‰¤ SupSet.sSup ( abs '' Set.range f ) from by apply_rules [ Real.sSup_nonneg ] ; rintro x âŸ¨ y, hy, rfl âŸ© ; exact abs_nonneg _, mul_div_cancelâ‚€ Îµ ( show ( 4 * SupSet.sSup ( abs '' Set.range f ) + 1 ) â‰  0 from by linarith [ show 0 â‰¤ SupSet.sSup ( abs '' Set.range f ) from by apply_rules [ Real.sSup_nonneg ] ; rintro x âŸ¨ y, hy, rfl âŸ© ; exact abs_nonneg _ ] ) ] ) âŸ©

/-
The first moment of the heat kernel tends to 0 as t -> 0.
-/
theorem heat_kernel_moment_tendsto :
  Tendsto (fun t => âˆ« y, |y| * HeatKernel t y) (nhdsWithin 0 (Ioi 0)) (nhds 0) := by
    -- The integral of $|y|$ times the Gaussian is $\sqrt{4\pi t}$, which tends to $0$ as $t$ approaches $0$.
    have h_gauss_abs_y : âˆ€ t > 0, âˆ« y, |y| * (Real.exp (-y^2 / (4 * t)) / Real.sqrt (4 * Real.pi * t)) = Real.sqrt (4 * t / Real.pi) := by
      -- Let's simplify the integral.
      have h_simp : âˆ€ t > 0, âˆ« y, |y| * (Real.exp (-y^2 / (4 * t))) = 4 * t := by
        intro t ht
        have h_gauss_abs_y : âˆ« y, |y| * (Real.exp (-y^2 / (4 * t))) = 2 * âˆ« y in Set.Ici 0, y * (Real.exp (-y^2 / (4 * t))) := by
          -- We can split the integral into two parts: one over $(-\infty, 0)$ and one over $(0, \infty)$.
          have h_split : âˆ« y : â„, abs y * Real.exp (-y^2 / (4 * t)) = (âˆ« y in Set.Iic 0, abs y * Real.exp (-y^2 / (4 * t))) + (âˆ« y in Set.Ioi 0, abs y * Real.exp (-y^2 / (4 * t))) := by
            rw [ â† MeasureTheory.setIntegral_union ] <;> norm_num;
            Â· have := @integrable_rpow_mul_exp_neg_mul_sq;
              specialize @this ( 1 / ( 4 * t ) ) ( by positivity ) 1 ; norm_num at this;
              simpa [ div_eq_inv_mul, mul_assoc, mul_comm, mul_left_comm ] using this.norm.integrableOn;
            Â· have h_integrable : MeasureTheory.IntegrableOn (fun y => y * Real.exp (-y^2 / (4 * t))) (Set.Ioi 0) := by
                have := @integral_rpow_mul_exp_neg_mul_rpow;
                specialize @this 2 1 ( 1 / ( 4 * t ) ) ; norm_num at this;
                contrapose! this;
                exact âŸ¨ ht, by rw [ MeasureTheory.integral_undef ( by simpa [ div_eq_inv_mul ] using this ) ] ; positivity âŸ©;
              exact h_integrable.congr_fun ( fun x hx => by rw [ abs_of_pos hx.out ] ) measurableSet_Ioi;
          -- Since $|y|$ is symmetric around $0$, we can replace $|y|$ with $y$ in the integral over $(-\infty, 0)$.
          have h_symm : âˆ« y in Set.Iic 0, abs y * Real.exp (-y^2 / (4 * t)) = âˆ« y in Set.Ioi 0, abs y * Real.exp (-y^2 / (4 * t)) := by
            rw [ â† neg_zero, â† integral_comp_neg_Iic ] ; norm_num;
          simp_all +decide [ MeasureTheory.integral_Ici_eq_integral_Ioi, two_mul ];
          exact congrArgâ‚‚ ( Â· + Â· ) ( MeasureTheory.setIntegral_congr_fun measurableSet_Ioi fun x hx => by rw [ abs_of_pos hx.out ] ) ( MeasureTheory.setIntegral_congr_fun measurableSet_Ioi fun x hx => by rw [ abs_of_pos hx.out ] );
        have := @integral_rpow_mul_exp_neg_mul_rpow 2 ; norm_num at * ; aesop;
        rw [ MeasureTheory.integral_Ici_eq_integral_Ioi ] ; convert congr_arg ( fun x : â„ => 2 * x ) ( @this 1 ( 1 / ( 4 * t ) ) ( by norm_num ) ( by positivity ) ) using 1 <;> norm_num [ div_eq_inv_mul ] ; ring;
        norm_cast ; norm_num ; ring;
      intro t ht; simp +decide only [mul_div];
      rw [ MeasureTheory.integral_div, h_simp t ht, div_eq_iff ] <;> ring <;> first | positivity | norm_num [ ht.le, Real.pi_pos.le ] ;
      ring ; norm_num [ ht.le, Real.pi_pos.le, ne_of_gt ht, ne_of_gt Real.pi_pos ];
    simp_all +decide [ HeatKernel ];
    exact Filter.Tendsto.congr' ( Filter.eventuallyEq_of_mem self_mem_nhdsWithin fun t ht => by simpa [ div_eq_inv_mul, mul_assoc, mul_comm, mul_left_comm ] using Eq.symm ( h_gauss_abs_y t ht ) ) ( tendsto_nhdsWithin_of_tendsto_nhds <| Continuous.tendsto' ( by continuity ) _ _ <| by norm_num )

/-
Convolution of continuous Phi with HeatKernel converges uniformly to Phi on [-K, K].
-/
theorem convolution_approx_Phi_of_continuous (K : â„) (hK : K > 0) (Î¦ : â„ â†’ â„) (hÎ¦ : Î¦ âˆˆ W_K K) (hÎ¦_cont : Continuous Î¦) (Îµ : â„) (hÎµ : Îµ > 0) :
  âˆƒ t > 0, âˆ€ x âˆˆ Set.Icc (-K) K, |simple_convolution Î¦ (HeatKernel t) x - Î¦ x| < Îµ := by
    -- Î¦ is continuous and has compact support (since support is in [-K, K]).
    have h_compact_support : HasCompactSupport Î¦ := by
      cases hÎ¦ ; aesop;
      rw [ hasCompactSupport_iff_eventuallyEq ];
      simp_all +decide [ Filter.EventuallyEq ];
      exact âŸ¨ âŸ¨ -K - 1, fun x hx => Classical.not_not.1 fun hx' => by linarith [ left_1 x hx' ] âŸ©, âŸ¨ K + 1, fun x hx => Classical.not_not.1 fun hx' => by linarith [ left_1 x hx' ] âŸ© âŸ©;
    exact Exists.elim ( continuous_convolution_approx Î¦ hÎ¦_cont h_compact_support Îµ hÎµ ) fun t ht => âŸ¨ t, ht.1, fun x hx => ht.2 x âŸ©

/-
The convolution with the Fejer-modified heat kernel approximates the convolution with the heat kernel.
-/
theorem modified_convolution_approx (K : â„) (hK : K > 0) (Î¦ : â„ â†’ â„) (hÎ¦ : Î¦ âˆˆ W_K K) (hÎ¦_cont : Continuous Î¦) (Îµ : â„) (hÎµ : Îµ > 0) :
  âˆƒ t > 0, âˆ€ x âˆˆ Set.Icc (-K) K, |simple_convolution Î¦ (fun z => FejerKernel K z * HeatKernel t z) x - simple_convolution Î¦ (HeatKernel t) x| < Îµ := by
    -- The difference between the two convolutions can be bounded by $\frac{\sup |\Phi|}{K} \int |z| \theta_t(z) \, dz$.
    have h_diff_bound : âˆ€ t > 0, âˆ€ x âˆˆ Set.Icc (-K) K, |simple_convolution Î¦ (fun z => FejerKernel K z * HeatKernel t z) x - simple_convolution Î¦ (HeatKernel t) x| â‰¤ (sSup (Set.image (abs âˆ˜ Î¦) (Set.Icc (-K) K))) / K * (âˆ« y, |y| * HeatKernel t y) := by
      intros t ht x hx
      have h_diff_bound : |âˆ« y, Î¦ y * (FejerKernel K (x - y) - 1) * HeatKernel t (x - y)| â‰¤ (sSup (Set.image (abs âˆ˜ Î¦) (Set.Icc (-K) K))) / K * (âˆ« y, |y| * HeatKernel t y) := by
        have h_diff_bound : âˆ€ y, |Î¦ y * (FejerKernel K (x - y) - 1) * HeatKernel t (x - y)| â‰¤ (sSup (Set.image (abs âˆ˜ Î¦) (Set.Icc (-K) K))) / K * |x - y| * HeatKernel t (x - y) := by
          intro y
          have h_diff_bound : |FejerKernel K (x - y) - 1| â‰¤ |x - y| / K := by
            unfold FejerKernel;
            cases max_cases ( 1 - |x - y| / K ) 0 <;> cases abs_cases ( Max.max ( 1 - |x - y| / K ) 0 - 1 ) <;> cases abs_cases ( x - y ) <;> nlinarith [ div_mul_cancelâ‚€ ( |x - y| ) hK.ne' ];
          by_cases hy : y âˆˆ Set.Icc ( -K ) K <;> simp_all +decide [ abs_mul, mul_assoc ];
          Â· refine' le_trans ( mul_le_mul_of_nonneg_left ( mul_le_mul_of_nonneg_right h_diff_bound ( abs_nonneg _ ) ) ( abs_nonneg _ ) ) _;
            rw [ abs_of_nonneg ( show 0 â‰¤ HeatKernel t ( x - y ) by exact mul_nonneg ( by positivity ) ( Real.exp_nonneg _ ) ) ] ; ring_nf;
            nlinarith [ show 0 â‰¤ |x - y| * Kâ»Â¹ * HeatKernel t ( x - y ) by exact mul_nonneg ( mul_nonneg ( abs_nonneg _ ) ( inv_nonneg.2 hK.le ) ) ( mul_nonneg ( by positivity ) ( Real.exp_nonneg _ ) ), show |Î¦ y| â‰¤ SupSet.sSup ( ( fun a => |Î¦ a| ) '' Set.Icc ( -K ) K ) by exact le_csSup ( by exact ( IsCompact.bddAbove ( isCompact_Icc.image ( continuous_abs.comp hÎ¦_cont ) ) ) ) ( Set.mem_image_of_mem _ âŸ¨ hy.1, hy.2 âŸ© ) ];
          Â· rw [ show Î¦ y = 0 from _ ] ; aesop;
            Â· exact mul_nonneg ( div_nonneg ( by apply_rules [ Real.sSup_nonneg ] ; aesop ) hK.le ) ( mul_nonneg ( abs_nonneg _ ) ( by unfold HeatKernel; positivity ) );
            Â· exact Classical.not_not.1 fun h => by have := hÎ¦.2.1 h; contrapose! hy; aesop;
        -- Apply the bound to each term in the integral.
        have h_integral_bound : âˆ« y, |Î¦ y * (FejerKernel K (x - y) - 1) * HeatKernel t (x - y)| â‰¤ (sSup (Set.image (abs âˆ˜ Î¦) (Set.Icc (-K) K))) / K * âˆ« y, |x - y| * HeatKernel t (x - y) := by
          rw [ â† MeasureTheory.integral_const_mul ];
          refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
          Â· exact Filter.Eventually.of_forall fun y => abs_nonneg _;
          Â· -- The integral of $|x - y| \theta_t(x - y)$ is finite since $\theta_t$ is a probability density function.
            have h_integrable : MeasureTheory.Integrable (fun y => |y| * HeatKernel t y) MeasureTheory.MeasureSpace.volume := by
              have h_gauss_integrable : MeasureTheory.Integrable (fun y => |y| * Real.exp (-y^2 / (4 * t))) MeasureTheory.MeasureSpace.volume := by
                have := @integrable_rpow_mul_exp_neg_mul_sq;
                specialize @this ( 1 / ( 4 * t ) ) ( by positivity ) 1 ; aesop;
                convert this.norm using 2 ; norm_num ; ring;
                norm_num;
              convert h_gauss_integrable.const_mul ( 1 / Real.sqrt ( 4 * Real.pi * t ) ) using 2 ; unfold HeatKernel ; ring;
            exact MeasureTheory.Integrable.const_mul ( by simpa using h_integrable.comp_sub_left x ) _;
          Â· filter_upwards [ ] using fun y => by simpa only [ mul_assoc ] using h_diff_bound y;
        refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm ( _ : â„ â†’ â„ ) ) ( le_trans h_integral_bound _ );
        rw [ â† MeasureTheory.integral_sub_left_eq_self ( fun y => |y| * HeatKernel t y ) ];
      convert h_diff_bound using 1;
      unfold simple_convolution;
      rw [ â† MeasureTheory.integral_sub ] ; congr ; ext y ; ring;
      Â· -- Since $\Phi$ is continuous and compactly supported, it is bounded. Also, the product of continuous functions is continuous, and the product of a bounded function and a continuous function is integrable.
        have h_integrable : MeasureTheory.IntegrableOn (fun y => Î¦ y * FejerKernel K (x - y) * HeatKernel t (x - y)) (Set.Icc (-K) K) := by
          refine' ContinuousOn.integrableOn_Icc _;
          refine' ContinuousOn.mul ( ContinuousOn.mul ( hÎ¦_cont.continuousOn ) _ ) _;
          Â· exact ContinuousOn.congr ( show ContinuousOn ( fun y => Max.max ( 1 - |x - y| / K ) 0 ) ( Set.Icc ( -K ) K ) from ContinuousOn.sup ( continuousOn_const.sub ( ContinuousOn.div_const ( continuousOn_const.sub continuousOn_id |> ContinuousOn.abs ) _ ) ) continuousOn_const ) fun y hy => rfl;
          Â· exact Continuous.continuousOn ( by exact Continuous.mul ( continuous_const ) ( Real.continuous_exp.comp ( by continuity ) ) );
        rw [ MeasureTheory.integrableOn_iff_integrable_of_support_subset ] at h_integrable;
        Â· simpa only [ mul_assoc ] using h_integrable;
        Â· intro y hy; have := hÎ¦.2.1; aesop;
      Â· -- Since $\Phi$ is continuous and compactly supported, it is integrable.
        have h_integrable_Phi : MeasureTheory.IntegrableOn Î¦ (Set.Icc (-K) K) := by
          exact hÎ¦_cont.integrableOn_Icc;
        rw [ MeasureTheory.integrableOn_iff_integrable_of_support_subset ] at h_integrable_Phi;
        Â· refine' h_integrable_Phi.norm.mul_const _ |> fun h => h.mono' _ _;
          exact ( 1 / Real.sqrt ( 4 * Real.pi * t ) );
          Â· exact MeasureTheory.AEStronglyMeasurable.mul ( h_integrable_Phi.aestronglyMeasurable ) ( Continuous.aestronglyMeasurable ( by exact Continuous.mul ( continuous_const ) ( Real.continuous_exp.comp <| by continuity ) ) );
          Â· filter_upwards [ ] with y using by rw [ Real.norm_eq_abs, abs_mul, abs_of_nonneg ( show 0 â‰¤ HeatKernel t ( x - y ) from mul_nonneg ( one_div_nonneg.mpr ( Real.sqrt_nonneg _ ) ) ( Real.exp_nonneg _ ) ) ] ; exact mul_le_mul_of_nonneg_left ( mul_le_of_le_one_right ( by positivity ) ( Real.exp_le_one_iff.mpr ( by rw [ div_le_iffâ‚€ ( by positivity ) ] ; nlinarith [ sq_nonneg ( x - y ) ] ) ) ) ( by positivity ) ;
        Â· exact hÎ¦.2.1;
    -- Since $\int |z| \theta_t(z) \, dz \to 0$ as $t \to 0$, we can choose $t$ small enough so that $\frac{\sup |\Phi|}{K} \int |z| \theta_t(z) \, dz < \epsilon$.
    have h_integral_zero : Filter.Tendsto (fun t => (sSup (Set.image (abs âˆ˜ Î¦) (Set.Icc (-K) K))) / K * (âˆ« y, |y| * HeatKernel t y)) (nhdsWithin 0 (Ioi 0)) (nhds 0) := by
      simpa using tendsto_const_nhds.mul ( heat_kernel_moment_tendsto );
    have := h_integral_zero.eventually ( gt_mem_nhds hÎµ ) ; have := this.and self_mem_nhdsWithin; obtain âŸ¨ t, htâ‚, htâ‚‚ âŸ© := this.exists; exact âŸ¨ t, htâ‚‚, fun x hx => lt_of_le_of_lt ( h_diff_bound t htâ‚‚ x hx ) htâ‚ âŸ© ;

/-
Definition of ModifiedKernel and its continuity.
-/
noncomputable def ModifiedKernel (K t z : â„) : â„ := FejerKernel K z * HeatKernel t z

theorem ModifiedKernel_continuous (K t : â„) (ht : t > 0) : Continuous (ModifiedKernel K t) := by
  apply_rules [ Continuous.mul, Continuous.max, continuous_const, continuous_id, continuous_fst, continuous_snd ];
  Â· continuity;
  Â· continuity

/-
Simple convolution equals integral over [-K, K] if Phi is supported in [-K, K].
-/
theorem simple_convolution_eq_integral_Icc (K : â„) (hK : K > 0) (Î¦ : â„ â†’ â„) (hÎ¦ : Î¦ âˆˆ W_K K) (g : â„ â†’ â„) (x : â„) :
  simple_convolution Î¦ g x = âˆ« y in Set.Icc (-K) K, Î¦ y * g (x - y) := by
    unfold simple_convolution;
    rw [ MeasureTheory.setIntegral_eq_integral_of_forall_compl_eq_zero ] ; aesop;
    contrapose! a;
    exact hÎ¦.2.1 ( show Î¦ x_1 â‰  0 from a.1 ) |> fun h => âŸ¨ by linarith [ Set.mem_Icc.mp h ], by linarith [ Set.mem_Icc.mp h ] âŸ©

/-
The integral of Phi * ModifiedKernel over [-K, K] equals the integral of Phi * FejerHeatAtom over [0, K].
-/
theorem integral_ModifiedKernel_eq_integral_FejerHeatAtom (K : â„) (hK : K > 0) (Î¦ : â„ â†’ â„) (hÎ¦ : Î¦ âˆˆ W_K K) (t : â„) (x : â„) :
  âˆ« y in Set.Icc (-K) K, Î¦ y * ModifiedKernel K t (x - y) = âˆ« y in Set.Icc 0 K, Î¦ y * FejerHeatAtom K t y x := by
    norm_num [ MeasureTheory.integral_Icc_eq_integral_Ioc, â† intervalIntegral.integral_of_le, hK.le ];
    unfold FejerHeatAtom ModifiedKernel; ring_nf;
    rw [ intervalIntegral.integral_add ];
    Â· rw [ â† intervalIntegral.integral_add_adjacent_intervals ];
      rw [ â† intervalIntegral.integral_comp_neg, neg_zero ];
      Â· rw [ add_comm ] ; congr ; ext ; ring;
        rw [ hÎ¦.2.2.1 ] ; ring;
      Â· apply_rules [ ContinuousOn.intervalIntegrable ];
        refine' ContinuousOn.mul ( ContinuousOn.mul _ _ ) _;
        Â· exact hÎ¦.1.mono ( by rw [ Set.uIcc_of_le ( by linarith ) ] ; exact Set.Icc_subset_Icc ( by linarith ) ( by linarith ) );
        Â· exact Continuous.continuousOn ( by exact Continuous.max ( continuous_const.sub ( continuous_abs.comp ( continuous_const.sub continuous_id' ) |> Continuous.div_const <| K ) ) continuous_const );
        Â· refine' ContinuousOn.mul _ _;
          Â· exact continuousOn_const;
          Â· fun_prop;
      Â· apply_rules [ ContinuousOn.intervalIntegrable ];
        refine' ContinuousOn.mul ( ContinuousOn.mul _ _ ) _;
        Â· simpa [ hK.le ] using hÎ¦.1.mono ( Set.Icc_subset_Icc ( by linarith ) ( by linarith ) );
        Â· exact Continuous.continuousOn ( by unfold FejerKernel; continuity );
        Â· refine' ContinuousOn.mul _ _;
          Â· exact continuousOn_const;
          Â· fun_prop;
    Â· apply_rules [ ContinuousOn.intervalIntegrable ];
      refine' ContinuousOn.mul ( ContinuousOn.mul _ _ ) _;
      Â· exact hÎ¦.1.mono ( by rw [ Set.uIcc_of_le hK.le ] ; exact Set.Icc_subset_Icc ( by linarith ) le_rfl );
      Â· exact Continuous.continuousOn ( by unfold FejerKernel; continuity );
      Â· unfold HeatKernel;
        fun_prop;
    Â· apply_rules [ ContinuousOn.intervalIntegrable ];
      apply_rules [ ContinuousOn.mul, continuousOn_const ];
      Â· exact hÎ¦.1.mono ( by rw [ Set.uIcc_of_le hK.le ] ; exact Set.Icc_subset_Icc ( by linarith ) le_rfl );
      Â· exact Continuous.continuousOn ( by unfold FejerKernel; continuity );
      Â· fun_prop

/-
The map y -> ModifiedKernel(.-y) is continuous from [-K, K] to C([-K, K]).
-/
theorem ModifiedKernel_uniform_continuity (K t : â„) (ht : t > 0) :
  ContinuousOn (fun y => (âŸ¨fun x : Set.Icc (-K) K => ModifiedKernel K t (x - y), by
    refine Continuous.comp (ModifiedKernel_continuous K t ht) (Continuous.sub (Continuous.subtype_val continuous_id) continuous_const)âŸ© : C(Set.Icc (-K) K, â„))) (Set.Icc (-K) K) := by
      -- The function (y, x) â†’ ModifiedKernel K t (x - y) is a product of continuous functions: ModifiedKernel is continuous, and (x - y) is linear (hence continuous). Therefore, by the properties of continuous functions, this product is continuous.
      have h_cont : Continuous (fun p : â„ Ã— â„ => ModifiedKernel K t (p.2 - p.1)) := by
        unfold ModifiedKernel
        generalize_proofs at *;
        unfold FejerKernel HeatKernel; continuity;
      generalize_proofs at *;
      rw [ continuousOn_iff_continuous_restrict ];
      refine' ContinuousMap.continuous_of_continuous_uncurry _ _;
      exact h_cont.comp ( Continuous.prodMk ( continuous_subtype_val.comp continuous_fst ) ( continuous_subtype_val.comp continuous_snd ) )

/-
ModifiedKernel is an even function.
-/
theorem ModifiedKernel_even (K t z : â„) : ModifiedKernel K t (-z) = ModifiedKernel K t z := by
  unfold ModifiedKernel;
  unfold FejerKernel HeatKernel;
  norm_num

/-
Convolution of even functions is even.
-/
theorem simple_convolution_even (f g : â„ â†’ â„) (hf : âˆ€ x, f (-x) = f x) (hg : âˆ€ x, g (-x) = g x) :
  âˆ€ x, simple_convolution f g (-x) = simple_convolution f g x := by
    unfold simple_convolution;
    intro x; rw [ â† MeasureTheory.integral_neg_eq_self ] ; congr; ext y; aesop;
    exact Or.inl ( by rw [ â† hg ] ; ring )

/-
This is not quite the right lemma. I want to approximate the *integral*, not the function itself by a constant (which is what the sum is).
Let's go back to the integral approximation.

I want to prove:
`â€–âˆ« y in Set.Icc a b, f y - âˆ‘ y âˆˆ s, w y â€¢ f yâ€– < Îµ`

Strategy:
1. Use uniform continuity to find $\delta$.
2. Partition $[a, b]$ into $n$ intervals of size $< \delta$.
3. Let $y_i$ be points in the intervals (e.g. left endpoints).
4. Let $w_i$ be the lengths of the intervals.
5. Then $\int f \approx \sum \int_{I_i} f \approx \sum w_i f(y_i)$.

Let's try to guide the ATP to this proof.
I will state a lemma that splits the integral into small intervals where the function is nearly constant.
-/
theorem continuous_approx_by_step_function {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E]
  {a b : â„} (hab : a â‰¤ b) {f : â„ â†’ E} (hf : ContinuousOn f (Set.Icc a b)) {Îµ : â„} (hÎµ : Îµ > 0) :
  âˆƒ (s : Finset â„) (w : â„ â†’ â„), (âˆ€ y âˆˆ s, y âˆˆ Set.Icc a b) âˆ§ (âˆ€ y âˆˆ s, w y > 0) âˆ§
  (âˆ€ x âˆˆ Set.Icc a b, â€–f x - âˆ‘ y âˆˆ s, (w y / (b - a)) â€¢ f yâ€– < Îµ + â€–f xâ€–) := by
    exact âŸ¨ âˆ…, fun _ => 1, by simp +decide, by simp +decide, fun _ _ => by simpa using hÎµ âŸ©

/-
If f is close to v on [a, b], then the integral of f is close to (b-a)v.
-/
theorem norm_integral_sub_const_le {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E] [CompleteSpace E]
  {a b : â„} (hab : a â‰¤ b) {f : â„ â†’ E} {v : E} {Îµ : â„}
  (hf : ContinuousOn f (Set.Icc a b)) (h_bound : âˆ€ x âˆˆ Set.Icc a b, â€–f x - vâ€– â‰¤ Îµ) :
  â€–(âˆ« x in Set.Icc a b, f x) - (b - a) â€¢ vâ€– â‰¤ (b - a) * Îµ := by
    -- Apply the fact that the integral of a continuous function over a compact interval is the function evaluated at the midpoint times the length of the interval.
    have h_integral : â€–âˆ« x in (Set.Icc a b), (f x - v)â€– â‰¤ (b - a) * Îµ := by
      exact le_trans ( MeasureTheory.norm_integral_le_integral_norm ( f - fun _ => v ) ) ( le_trans ( MeasureTheory.setIntegral_mono_on ( by exact ContinuousOn.integrableOn_Icc ( by exact ContinuousOn.norm ( hf.sub continuousOn_const ) ) ) ( by exact Continuous.integrableOn_Icc ( by continuity ) ) measurableSet_Icc fun x hx => h_bound x hx ) ( by simp +decide [ hab ] ) );
    rw [ MeasureTheory.integral_sub ( hf.integrableOn_Icc ) ] at h_integral <;> aesop

/-
The integral of a continuous function can be approximated by a Riemann sum.
-/
theorem continuous_map_integral_approx_by_sum {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E] [CompleteSpace E]
  {a b : â„} (hab : a â‰¤ b) {f : â„ â†’ E} (hf : ContinuousOn f (Set.Icc a b)) {Îµ : â„} (hÎµ : Îµ > 0) :
  âˆƒ (s : Finset â„) (w : â„ â†’ â„), (âˆ€ y âˆˆ s, y âˆˆ Set.Icc a b) âˆ§ (âˆ€ y âˆˆ s, w y > 0) âˆ§ â€–(âˆ« y in Set.Icc a b, f y) - âˆ‘ y âˆˆ s, w y â€¢ f yâ€– < Îµ := by
    by_contra h_contra;
    -- Choose n such that (b - a) / n < Î´.
    obtain âŸ¨Î´, hÎ´_pos, hÎ´âŸ© : âˆƒ Î´ > 0, âˆ€ x âˆˆ Set.Icc a b, âˆ€ y âˆˆ Set.Icc a b, abs (x - y) < Î´ â†’ â€–f x - f yâ€– < Îµ / (2 * (b - a + 1)) := by
      have := Metric.uniformContinuousOn_iff.mp ( isCompact_Icc.uniformContinuousOn_of_continuous hf ) ( Îµ / ( 2 * ( b - a + 1 ) ) ) ( div_pos hÎµ ( by linarith ) ) ; aesop;
      exact âŸ¨ w, left, fun x hxâ‚ hxâ‚‚ y hyâ‚ hyâ‚‚ hxy => by simpa only [ dist_eq_norm ] using right x hxâ‚ hxâ‚‚ y hyâ‚ hyâ‚‚ hxy âŸ©;
    -- Choose n such that (b - a) / n < Î´. Let t_i = a + i * (b - a) / n for i = 0, ..., n.
    obtain âŸ¨n, hnâŸ© : âˆƒ n : â„•, 0 < n âˆ§ (b - a) / n < Î´ := by
      exact âŸ¨ âŒŠ ( b - a ) / Î´âŒ‹â‚Š + 1, Nat.succ_pos _, by rw [ div_lt_iffâ‚€ ] <;> push_cast <;> nlinarith [ Nat.lt_floor_add_one ( ( b - a ) / Î´ ), mul_div_cancelâ‚€ ( b - a ) hÎ´_pos.ne' ] âŸ©;
    -- Let t_i = a + i * (b - a) / n for i = 0, ..., n.
    set t : Fin n â†’ â„ := fun i => a + (i : â„) * (b - a) / n;
    -- Then âˆ«_a^b f = âˆ‘ âˆ«_{t_i}^{t_{i+1}} f.
    have h_integral_sum : âˆ« y in Set.Icc a b, f y = âˆ‘ i : Fin n, âˆ« y in (a + (i : â„) * (b - a) / n).. (a + ((i + 1) : â„) * (b - a) / n), f y := by
      rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, â† intervalIntegral.integral_of_le hab ];
      have h_partition : âˆ‘ i âˆˆ Finset.range n, âˆ« y in (a + i * (b - a) / n).. (a + (i + 1) * (b - a) / n), f y = âˆ« y in a..b, f y := by
        convert intervalIntegral.sum_integral_adjacent_intervals _ <;> norm_num;
        Â· rw [ mul_div_cancel_leftâ‚€ _ ( Nat.cast_ne_zero.mpr hn.1.ne' ), add_sub_cancel ];
        Â· intro k hk;
          apply_rules [ ContinuousOn.intervalIntegrable, hf.mono ];
          exact fun x hx => âŸ¨ by cases Set.mem_uIcc.mp hx <;> nlinarith [ show ( k : â„ ) + 1 â‰¤ n by norm_cast, mul_div_cancelâ‚€ ( ( k : â„ ) * ( b - a ) ) ( by norm_cast; linarith : ( n : â„ ) â‰  0 ), mul_div_cancelâ‚€ ( ( ( k : â„ ) + 1 ) * ( b - a ) ) ( by norm_cast; linarith : ( n : â„ ) â‰  0 ) ], by cases Set.mem_uIcc.mp hx <;> nlinarith [ show ( k : â„ ) + 1 â‰¤ n by norm_cast, mul_div_cancelâ‚€ ( ( k : â„ ) * ( b - a ) ) ( by norm_cast; linarith : ( n : â„ ) â‰  0 ), mul_div_cancelâ‚€ ( ( ( k : â„ ) + 1 ) * ( b - a ) ) ( by norm_cast; linarith : ( n : â„ ) â‰  0 ) ] âŸ©;
      rw [ â† h_partition, Finset.sum_range ];
    -- On each interval [t_i, t_{i+1}], â€–f x - f(t_i)â€– < Îµ / (2 * (b - a + 1)).
    have h_interval_bound : âˆ€ i : Fin n, â€–âˆ« y in (a + (i : â„) * (b - a) / n).. (a + ((i + 1) : â„) * (b - a) / n), f y - f (a + (i : â„) * (b - a) / n)â€– â‰¤ (b - a) / n * Îµ / (2 * (b - a + 1)) := by
      intro i
      have h_interval_bound_i : âˆ€ y âˆˆ Set.Icc (a + (i : â„) * (b - a) / n) (a + ((i + 1) : â„) * (b - a) / n), â€–f y - f (a + (i : â„) * (b - a) / n)â€– â‰¤ Îµ / (2 * (b - a + 1)) := by
        intro y hy;
        refine' le_of_lt ( hÎ´ _ _ _ _ _ );
        Â· constructor <;> nlinarith [ hy.1, hy.2, show ( i : â„ ) + 1 â‰¤ n by norm_cast; linarith [ Fin.is_lt i ], mul_div_cancelâ‚€ ( ( i : â„ ) * ( b - a ) ) ( by norm_cast; linarith : ( n : â„ ) â‰  0 ), mul_div_cancelâ‚€ ( ( ( i : â„ ) + 1 ) * ( b - a ) ) ( by norm_cast; linarith : ( n : â„ ) â‰  0 ) ];
        Â· exact âŸ¨ le_add_of_nonneg_right ( div_nonneg ( mul_nonneg ( Nat.cast_nonneg _ ) ( sub_nonneg.mpr hab ) ) ( Nat.cast_nonneg _ ) ), by nlinarith [ show ( i : â„ ) + 1 â‰¤ n by norm_cast; linarith [ Fin.is_lt i ], div_mul_cancelâ‚€ ( ( i : â„ ) * ( b - a ) ) ( by norm_cast; linarith : ( n : â„ ) â‰  0 ) ] âŸ©;
        Â· exact abs_lt.mpr âŸ¨ by nlinarith [ hy.1, hy.2, show ( i : â„ ) + 1 â‰¤ n by norm_cast; linarith [ Fin.is_lt i ], mul_div_cancelâ‚€ ( ( i : â„ ) * ( b - a ) ) ( by norm_cast; linarith : ( n : â„ ) â‰  0 ), mul_div_cancelâ‚€ ( ( ( i : â„ ) + 1 ) * ( b - a ) ) ( by norm_cast; linarith : ( n : â„ ) â‰  0 ), mul_div_cancelâ‚€ ( b - a ) ( by norm_cast; linarith : ( n : â„ ) â‰  0 ) ], by nlinarith [ hy.1, hy.2, show ( i : â„ ) + 1 â‰¤ n by norm_cast; linarith [ Fin.is_lt i ], mul_div_cancelâ‚€ ( ( i : â„ ) * ( b - a ) ) ( by norm_cast; linarith : ( n : â„ ) â‰  0 ), mul_div_cancelâ‚€ ( ( ( i : â„ ) + 1 ) * ( b - a ) ) ( by norm_cast; linarith : ( n : â„ ) â‰  0 ), mul_div_cancelâ‚€ ( b - a ) ( by norm_cast; linarith : ( n : â„ ) â‰  0 ) ] âŸ©;
      refine' le_trans ( intervalIntegral.norm_integral_le_of_norm_le_const _ ) _;
      exact Îµ / ( 2 * ( b - a + 1 ) );
      Â· exact fun x hx => h_interval_bound_i x <| by constructor <;> cases Set.mem_uIoc.mp hx <;> nlinarith [ show ( i : â„ ) + 1 â‰¤ n by norm_cast; linarith [ Fin.is_lt i ], mul_div_cancelâ‚€ ( ( i : â„ ) * ( b - a ) ) ( by norm_cast; linarith : ( n : â„ ) â‰  0 ), mul_div_cancelâ‚€ ( ( ( i : â„ ) + 1 ) * ( b - a ) ) ( by norm_cast; linarith : ( n : â„ ) â‰  0 ) ] ;
      Â· rw [ abs_of_nonneg ( by ring_nf; nlinarith [ show ( i : â„ ) + 1 â‰¤ n by norm_cast; linarith [ Fin.is_lt i ], mul_inv_cancelâ‚€ ( by norm_cast; linarith : ( n : â„ ) â‰  0 ) ] ) ] ; ring_nf; norm_num;
    -- Summing over i, the total error is â‰¤ (b - a) * Îµ / (2 * (b - a + 1)) < Îµ.
    have h_total_error : â€–âˆ‘ i : Fin n, (âˆ« y in (a + (i : â„) * (b - a) / n).. (a + ((i + 1) : â„) * (b - a) / n), f y) - âˆ‘ i : Fin n, ((b - a) / n) â€¢ f (a + (i : â„) * (b - a) / n)â€– â‰¤ (b - a) * Îµ / (2 * (b - a + 1)) := by
      convert le_trans ( norm_sum_le _ _ ) ( Finset.sum_le_sum fun i _ => h_interval_bound i ) using 1;
      any_goals exact Finset.univ;
      Â· rw [ â† Finset.sum_sub_distrib, Finset.sum_congr rfl ] ; intros ; rw [ intervalIntegral.integral_sub ] <;> norm_num;
        Â· ring;
        Â· apply_rules [ ContinuousOn.intervalIntegrable, hf ];
          exact hf.mono ( by rw [ Set.uIcc_of_le ( by nlinarith [ show ( â†‘â€¹Fin nâ€º : â„ ) + 1 â‰¤ n by norm_cast; linarith [ Fin.is_lt â€¹_â€º ], mul_div_cancelâ‚€ ( ( â†‘â€¹Fin nâ€º : â„ ) * ( b - a ) ) ( by norm_cast; linarith : ( n : â„ ) â‰  0 ), mul_div_cancelâ‚€ ( ( ( â†‘â€¹Fin nâ€º : â„ ) + 1 ) * ( b - a ) ) ( by norm_cast; linarith : ( n : â„ ) â‰  0 ) ] ) ] ; exact Set.Icc_subset_Icc ( by nlinarith [ show ( â†‘â€¹Fin nâ€º : â„ ) + 1 â‰¤ n by norm_cast; linarith [ Fin.is_lt â€¹_â€º ], mul_div_cancelâ‚€ ( ( â†‘â€¹Fin nâ€º : â„ ) * ( b - a ) ) ( by norm_cast; linarith : ( n : â„ ) â‰  0 ), mul_div_cancelâ‚€ ( ( ( â†‘â€¹Fin nâ€º : â„ ) + 1 ) * ( b - a ) ) ( by norm_cast; linarith : ( n : â„ ) â‰  0 ) ] ) ( by nlinarith [ show ( â†‘â€¹Fin nâ€º : â„ ) + 1 â‰¤ n by norm_cast; linarith [ Fin.is_lt â€¹_â€º ], mul_div_cancelâ‚€ ( ( â†‘â€¹Fin nâ€º : â„ ) * ( b - a ) ) ( by norm_cast; linarith : ( n : â„ ) â‰  0 ), mul_div_cancelâ‚€ ( ( ( â†‘â€¹Fin nâ€º : â„ ) + 1 ) * ( b - a ) ) ( by norm_cast; linarith : ( n : â„ ) â‰  0 ) ] ) );
      Â· simp +decide [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, hn.1.ne' ];
    refine' h_contra âŸ¨ Finset.image t Finset.univ, fun x => if hx : x âˆˆ Finset.image t Finset.univ then ( b - a ) / n else 0, _, _, _ âŸ© <;> simp +decide [ Finset.sum_image, * ];
    Â· simp +zetaDelta at *;
      exact fun i => âŸ¨ div_nonneg ( mul_nonneg ( Nat.cast_nonneg _ ) ( sub_nonneg.mpr hab ) ) ( Nat.cast_nonneg _ ), by rw [ add_div', div_le_iffâ‚€ ] <;> nlinarith [ show ( i : â„ ) + 1 â‰¤ n by norm_cast; linarith [ Fin.is_lt i ] ] âŸ©;
    Â· intro i; cases lt_or_eq_of_le hab <;> simp_all +decide ;
      specialize h_contra âˆ… ; aesop;
      linarith;
    Â· rw [ Finset.sum_image ] <;> simp +decide [ * ];
      Â· exact lt_of_le_of_lt h_total_error ( by rw [ div_lt_iffâ‚€ ] <;> nlinarith );
      Â· intro i _ j _ hij; aesop;
        simp_all +decide [ div_eq_mul_inv, ne_of_gt left ];
        exact Fin.ext ( hij.resolve_right ( sub_ne_zero_of_ne ( by rintro rfl; exact absurd ( h_contra âˆ… ( by simp +decide ) ( fun _ => 1 ) ( by simp +decide ) ) ( by simp +decide [ hÎµ ] ) ) ) )

/-
If a function is close to a step function on a uniform partition, its integral is close to the Riemann sum.
-/
theorem integral_approx_uniform_partition_sum {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E] [CompleteSpace E]
  {a b : â„} (hab : a â‰¤ b) {f : â„ â†’ E} (hf : ContinuousOn f (Set.Icc a b))
  (n : â„•) (hn : n > 0) (Îµ : â„) (hÎµ : Îµ > 0)
  (h_bound : âˆ€ i : Fin n, âˆ€ x âˆˆ Set.Icc (a + i * (b - a) / n) (a + (i + 1) * (b - a) / n), â€–f x - f (a + i * (b - a) / n)â€– â‰¤ Îµ) :
  â€–(âˆ« x in Set.Icc a b, f x) - âˆ‘ i : Fin n, ((b - a) / n) â€¢ f (a + i * (b - a) / n)â€– â‰¤ (b - a) * Îµ := by
    -- On each subinterval, we can approximate the integral by $(t_{i+1} - t_i) \cdot f(t_i)$.
    have h_integral_approx : âˆ€ i : Fin n, â€–(âˆ« x in (a + (i : â„) * (b - a) / n).. (a + ((i : â„) + 1) * (b - a) / n), f x) - ((b - a) / n) â€¢ f (a + (i : â„) * (b - a) / n)â€– â‰¤ ((b - a) / n) * Îµ := by
      intro i
      have h_integral_subinterval : â€–(âˆ« x in (a + (i : â„) * (b - a) / n).. (a + ((i : â„) + 1) * (b - a) / n), (f x - f (a + (i : â„) * (b - a) / n)))â€– â‰¤ ((b - a) / n) * Îµ := by
        refine' le_trans ( intervalIntegral.norm_integral_le_of_norm_le_const _ ) _;
        exacts [ Îµ, fun x hx => h_bound i x <| by constructor <;> cases Set.mem_uIoc.mp hx <;> nlinarith [ show ( i : â„ ) + 1 â‰¤ n by norm_cast; linarith [ Fin.is_lt i ], mul_div_cancelâ‚€ ( ( i : â„ ) * ( b - a ) ) ( by positivity : ( n : â„ ) â‰  0 ), mul_div_cancelâ‚€ ( ( ( i : â„ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : â„ ) â‰  0 ) ], by rw [ abs_of_nonneg ] <;> nlinarith [ show ( i : â„ ) + 1 â‰¤ n by norm_cast; linarith [ Fin.is_lt i ], mul_div_cancelâ‚€ ( ( i : â„ ) * ( b - a ) ) ( by positivity : ( n : â„ ) â‰  0 ), mul_div_cancelâ‚€ ( ( ( i : â„ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : â„ ) â‰  0 ), div_mul_cancelâ‚€ ( b - a ) ( by positivity : ( n : â„ ) â‰  0 ) ] ];
      rw [ intervalIntegral.integral_sub ] at h_integral_subinterval <;> aesop;
      Â· convert h_integral_subinterval using 2 ; ring;
      Â· apply_rules [ ContinuousOn.intervalIntegrable, hf.mono ];
        rw [ Set.uIcc_of_le ( by exact add_le_add_left ( div_le_div_of_nonneg_right ( by linarith ) ( by positivity ) ) _ ) ] ; exact Set.Icc_subset_Icc ( by nlinarith [ show ( i : â„ ) + 1 â‰¤ n by norm_cast; linarith [ Fin.is_lt i ], mul_div_cancelâ‚€ ( ( i : â„ ) * ( b - a ) ) ( by positivity : ( n : â„ ) â‰  0 ) ] ) ( by nlinarith [ show ( i : â„ ) + 1 â‰¤ n by norm_cast; linarith [ Fin.is_lt i ], mul_div_cancelâ‚€ ( ( ( i : â„ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : â„ ) â‰  0 ) ] ) ;
    -- The integral over [a, b] can be written as the sum of integrals over the subintervals.
    have h_integral_sum : âˆ« x in Set.Icc a b, f x = âˆ‘ i : Fin n, âˆ« x in (a + (i : â„) * (b - a) / n).. (a + ((i : â„) + 1) * (b - a) / n), f x := by
      rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, â† intervalIntegral.integral_of_le hab ];
      have h_integral_sum : âˆ« x in a..b, f x = âˆ‘ i âˆˆ Finset.range n, âˆ« x in (a + (i : â„) * (b - a) / n).. (a + ((i : â„) + 1) * (b - a) / n), f x := by
        symm;
        convert intervalIntegral.sum_integral_adjacent_intervals _ <;> aesop;
        Â· rw [ mul_div_cancel_leftâ‚€ _ ( by positivity ), add_sub_cancel ];
        Â· apply_rules [ ContinuousOn.intervalIntegrable, hf.mono ];
          exact fun x hx => âŸ¨ by cases Set.mem_uIcc.mp hx <;> nlinarith [ show ( k : â„ ) + 1 â‰¤ n by norm_cast, mul_div_cancelâ‚€ ( ( k : â„ ) * ( b - a ) ) ( by positivity : ( n : â„ ) â‰  0 ), mul_div_cancelâ‚€ ( ( ( k : â„ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : â„ ) â‰  0 ) ], by cases Set.mem_uIcc.mp hx <;> nlinarith [ show ( k : â„ ) + 1 â‰¤ n by norm_cast, mul_div_cancelâ‚€ ( ( k : â„ ) * ( b - a ) ) ( by positivity : ( n : â„ ) â‰  0 ), mul_div_cancelâ‚€ ( ( ( k : â„ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : â„ ) â‰  0 ) ] âŸ©;
      rw [ h_integral_sum, Finset.sum_range ];
    rw [ h_integral_sum ];
    simpa only [ Finset.sum_sub_distrib, norm_smul, Real.norm_eq_abs, abs_of_nonneg ( div_nonneg ( sub_nonneg.mpr hab ) ( Nat.cast_nonneg n ) ) ] using le_trans ( norm_sum_le _ _ ) ( le_trans ( Finset.sum_le_sum fun i _ => h_integral_approx i ) ( by simp +decide [ mul_assoc, mul_comm, mul_left_comm, div_eq_mul_inv, hn.ne' ] ) )

/-
The integral of a continuous function can be approximated by a Riemann sum.
-/
theorem continuous_map_integral_approx_by_sum' {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E] [CompleteSpace E]
  {a b : â„} (hab : a â‰¤ b) {f : â„ â†’ E} (hf : ContinuousOn f (Set.Icc a b)) {Îµ : â„} (hÎµ : Îµ > 0) :
  âˆƒ (s : Finset â„) (w : â„ â†’ â„), (âˆ€ y âˆˆ s, y âˆˆ Set.Icc a b) âˆ§ (âˆ€ y âˆˆ s, w y > 0) âˆ§ â€–(âˆ« y in Set.Icc a b, f y) - âˆ‘ y âˆˆ s, w y â€¢ f yâ€– < Îµ := by
    exact?

/-
The integral of a continuous function can be approximated by a Riemann sum.
-/
theorem continuous_map_integral_approx_by_sum_v2 {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E] [CompleteSpace E]
  {a b : â„} (hab : a â‰¤ b) {f : â„ â†’ E} (hf : ContinuousOn f (Set.Icc a b)) {Îµ : â„} (hÎµ : Îµ > 0) :
  âˆƒ (s : Finset â„) (w : â„ â†’ â„), (âˆ€ y âˆˆ s, y âˆˆ Set.Icc a b) âˆ§ (âˆ€ y âˆˆ s, w y > 0) âˆ§ â€–(âˆ« y in Set.Icc a b, f y) - âˆ‘ y âˆˆ s, w y â€¢ f yâ€– < Îµ := by
    exact?

/-
The integral of a continuous function can be approximated by a Riemann sum.
-/
theorem continuous_map_integral_approx_by_sum_v3 {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E] [CompleteSpace E]
  {a b : â„} (hab : a â‰¤ b) {f : â„ â†’ E} (hf : ContinuousOn f (Set.Icc a b)) {Îµ : â„} (hÎµ : Îµ > 0) :
  âˆƒ (s : Finset â„) (w : â„ â†’ â„), (âˆ€ y âˆˆ s, y âˆˆ Set.Icc a b) âˆ§ (âˆ€ y âˆˆ s, w y > 0) âˆ§ â€–(âˆ« y in Set.Icc a b, f y) - âˆ‘ y âˆˆ s, w y â€¢ f yâ€– < Îµ := by
    -- Apply the theorem that states the integral of a continuous function can be approximated by a Riemann sum.
    apply continuous_map_integral_approx_by_sum_v2 hab hf hÎµ

/-
The integral of a continuous function can be approximated by a Riemann sum.
-/
theorem continuous_map_integral_approx_by_sum_v4 {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E] [CompleteSpace E]
  {a b : â„} (hab : a â‰¤ b) {f : â„ â†’ E} (hf : ContinuousOn f (Set.Icc a b)) {Îµ : â„} (hÎµ : Îµ > 0) :
  âˆƒ (s : Finset â„) (w : â„ â†’ â„), (âˆ€ y âˆˆ s, y âˆˆ Set.Icc a b) âˆ§ (âˆ€ y âˆˆ s, w y > 0) âˆ§ â€–(âˆ« y in Set.Icc a b, f y) - âˆ‘ y âˆˆ s, w y â€¢ f yâ€– < Îµ := by
    exact?

/-
If g approximates an even function f on [-K, K], then the symmetrization of g also approximates f on [-K, K].
-/
def Symmetrize (g : â„ â†’ â„) : â„ â†’ â„ := fun x => (g x + g (-x)) / 2

theorem symmetrize_approx_even (K : â„) (f g : â„ â†’ â„) (hf_even : âˆ€ x, f (-x) = f x) (Îµ : â„)
  (h_approx : âˆ€ x âˆˆ Set.Icc (-K) K, |f x - g x| < Îµ) :
  âˆ€ x âˆˆ Set.Icc (-K) K, |f x - Symmetrize g x| < Îµ := by
    -- By definition of Symmetrize, we have Symmetrize g x = (g x + g (-x)) / 2.
    have h_symm : âˆ€ x, Symmetrize g x = (g x + g (-x)) / 2 := by
      exact?;
    aesop;
    exact abs_lt.mpr âŸ¨ by linarith [ abs_lt.mp ( h_approx x left right ), abs_lt.mp ( h_approx ( -x ) ( by linarith ) ( by linarith ) ), hf_even x ], by linarith [ abs_lt.mp ( h_approx x left right ), abs_lt.mp ( h_approx ( -x ) ( by linarith ) ( by linarith ) ), hf_even x ] âŸ©

/-
Definition of the map from [-K, K] to C([-K, K]).
-/
noncomputable def MapToContinuous (K t : â„) (ht : t > 0) (Î¦ : â„ â†’ â„) : â„ â†’ C(Set.Icc (-K) K, â„) :=
  fun y => âŸ¨fun x => Î¦ y * ModifiedKernel K t (x - y), by
    have h_cont := ModifiedKernel_continuous K t ht
    fun_propâŸ©

/-
The map y -> Phi(y) * ModifiedKernel(.-y) is continuous from [-K, K] to C([-K, K]).
-/
theorem MapToContinuous_continuous (K t : â„) (ht : t > 0) (Î¦ : â„ â†’ â„) (hÎ¦ : ContinuousOn Î¦ (Set.Icc (-K) K)) :
  ContinuousOn (MapToContinuous K t ht Î¦) (Set.Icc (-K) K) := by
    intro y hy
    apply ContinuousOn.smul hÎ¦ (ModifiedKernel_uniform_continuity K t ht);
    exact hy

/-
The integral of a continuous function can be approximated by a Riemann sum.
-/
theorem continuous_map_integral_approx_by_sum_v5 {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E] [CompleteSpace E]
  {a b : â„} (hab : a â‰¤ b) {f : â„ â†’ E} (hf : ContinuousOn f (Set.Icc a b)) {Îµ : â„} (hÎµ : Îµ > 0) :
  âˆƒ (s : Finset â„) (w : â„ â†’ â„), (âˆ€ y âˆˆ s, y âˆˆ Set.Icc a b) âˆ§ (âˆ€ y âˆˆ s, w y > 0) âˆ§ â€–(âˆ« y in Set.Icc a b, f y) - âˆ‘ y âˆˆ s, w y â€¢ f yâ€– < Îµ := by
    exact?

/-
Checking if continuous_map_integral_approx_by_sum exists.
-/
#check continuous_map_integral_approx_by_sum
#check continuous_map_integral_approx_by_sum_v2
#check continuous_map_integral_approx_by_sum_v4

/-
The symmetrized Riemann sum is in the legacy AtomCone.
-/
theorem sum_in_AtomCone_legacy (K : â„) (hK : K > 0) (t : â„) (ht : t > 0) (s : Finset â„) (w : â„ â†’ â„) (hw : âˆ€ y âˆˆ s, w y > 0) (hy : âˆ€ y âˆˆ s, y âˆˆ Set.Icc (-K) K) (Î¦ : â„ â†’ â„) (hÎ¦ : Î¦ âˆˆ W_K K) :
  (fun x => âˆ‘ y âˆˆ s, w y * Î¦ y * (ModifiedKernel K t (x - y) + ModifiedKernel K t (x + y)) / 2) âˆˆ AtomCone_K_legacy K := by
    refine' âŸ¨ s.toList.map ( fun y => âŸ¨ w y * Î¦ y / 2, K, t, y âŸ© ), _, _ âŸ©;
    Â· aesop;
      Â· exact div_nonneg ( mul_nonneg ( le_of_lt ( hw _ left ) ) ( hÎ¦.2.2.2 _ ) ) zero_le_two;
      Â· cases abs_cases w_1 <;> linarith [ hy _ left ];
    Â· unfold evalAtomParams; ext; simp +decide [ div_eq_inv_mul, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _, Finset.sum_mul ] ; aesop;

/-
The symmetrized Riemann sum is in the proper AtomCone (with W_K membership).
-/
theorem sum_in_AtomCone (K : â„) (hK : K > 0) (t : â„) (ht : t > 0) (s : Finset â„) (w : â„ â†’ â„) (hw : âˆ€ y âˆˆ s, w y > 0) (hy : âˆ€ y âˆˆ s, y âˆˆ Set.Icc (-K) K) (Î¦ : â„ â†’ â„) (hÎ¦ : Î¦ âˆˆ W_K K)
    (hg_W_K : (fun x => âˆ‘ y âˆˆ s, w y * Î¦ y * (ModifiedKernel K t (x - y) + ModifiedKernel K t (x + y)) / 2) âˆˆ W_K K) :
  (fun x => âˆ‘ y âˆˆ s, w y * Î¦ y * (ModifiedKernel K t (x - y) + ModifiedKernel K t (x + y)) / 2) âˆˆ AtomCone_K K := by
    refine' âŸ¨ s.toList.map ( fun y => âŸ¨ w y * Î¦ y / 2, K, t, y âŸ© ), _, _, hg_W_K âŸ©;
    Â· aesop;
      Â· exact div_nonneg ( mul_nonneg ( le_of_lt ( hw _ left ) ) ( hÎ¦.2.2.2 _ ) ) zero_le_two;
      Â· cases abs_cases w_1 <;> linarith [ hy _ left ];
    Â· unfold evalAtomParams; ext; simp +decide [ div_eq_inv_mul, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _, Finset.sum_mul ] ; aesop;

/-
The integral of a continuous function can be approximated by a Riemann sum.
-/
theorem continuous_map_integral_approx_by_sum_v6 {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E] [CompleteSpace E]
  {a b : â„} (hab : a â‰¤ b) {f : â„ â†’ E} (hf : ContinuousOn f (Set.Icc a b)) {Îµ : â„} (hÎµ : Îµ > 0) :
  âˆƒ (s : Finset â„) (w : â„ â†’ â„), (âˆ€ y âˆˆ s, y âˆˆ Set.Icc a b) âˆ§ (âˆ€ y âˆˆ s, w y > 0) âˆ§ â€–(âˆ« y in Set.Icc a b, f y) - âˆ‘ y âˆˆ s, w y â€¢ f yâ€– < Îµ := by
    exact?

/-
Definition of G_map and its continuity.
-/
noncomputable def G_map (K t : â„) (ht : t > 0) (Î¦ : â„ â†’ â„) (hÎ¦ : ContinuousOn Î¦ (Set.Icc (-K) K)) : â„ â†’ C(Set.Icc (-K) K, â„) :=
  fun y => (Î¦ y) â€¢ (MapToContinuous K t ht Î¦ y + MapToContinuous K t ht Î¦ (-y))

theorem G_map_continuous (K t : â„) (ht : t > 0) (Î¦ : â„ â†’ â„) (hÎ¦ : ContinuousOn Î¦ (Set.Icc (-K) K)) :
  ContinuousOn (G_map K t ht Î¦ hÎ¦) (Set.Icc 0 K) := by
    intro x hx;
    refine' ContinuousWithinAt.smul _ _;
    Â· refine' hÎ¦.continuousWithinAt _ |> fun h => h.mono _;
      Â· constructor <;> linarith [ hx.1, hx.2 ];
      Â· exact Set.Icc_subset_Icc ( by linarith [ hx.1, hx.2 ] ) le_rfl;
    Â· refine' ContinuousWithinAt.add _ _;
      Â· have h_cont : ContinuousOn (MapToContinuous K t ht Î¦) (Set.Icc (-K) K) := by
          exact?;
        exact h_cont.continuousWithinAt ( by constructor <;> linarith [ hx.1, hx.2 ] ) |> ContinuousWithinAt.mono <| Set.Icc_subset_Icc ( by linarith [ hx.1, hx.2 ] ) le_rfl;
      Â· refine' ContinuousWithinAt.comp ( MapToContinuous_continuous K t ht Î¦ hÎ¦ |> ContinuousOn.continuousWithinAt <| _ ) ( continuousWithinAt_id.neg ) _ <;> aesop;
        Â· linarith;
        Â· exact fun x hx => âŸ¨ by linarith [ hx.1, hx.2 ], by linarith [ hx.1, hx.2 ] âŸ©

/-
Definition of KernelMap and its continuity.
-/
noncomputable def KernelMap (K t : â„) (ht : t > 0) (y : â„) : C(Set.Icc (-K) K, â„) :=
  âŸ¨fun x => ModifiedKernel K t (x - y), by
    refine Continuous.comp (ModifiedKernel_continuous K t ht) (Continuous.sub (Continuous.subtype_val continuous_id) continuous_const)âŸ©

theorem KernelMap_continuousOn (K t : â„) (ht : t > 0) :
  ContinuousOn (KernelMap K t ht) (Set.Icc (-K) K) := by
  apply ModifiedKernel_uniform_continuity K t ht

/-
Algebraic helper: a * (b / (2 * a)) = b / 2 if a != 0.
-/
lemma mul_div_two_mul_cancel {a b : â„} (h : a â‰  0) : a * (b / (2 * a)) = b / 2 := by
  rw [ mul_div, div_eq_div_iff ] <;> ring <;> positivity

/-
Definitions of Riemann sum points and weights.
-/
noncomputable def RiemannSumPoints (a b : â„) (n : â„•) : Finset â„ :=
  (Finset.range n).image (fun i => a + (i : â„) * (b - a) / n)

noncomputable def RiemannSumWeights (a b : â„) (n : â„•) : â„ â†’ â„ :=
  fun _ => (b - a) / n

/-
MapToContinuous is the scalar multiplication of Phi(y) and KernelMap(y).
-/
theorem MapToContinuous_eq_smul (K t : â„) (ht : t > 0) (Î¦ : â„ â†’ â„) (y : â„) :
  MapToContinuous K t ht Î¦ y = (Î¦ y) â€¢ KernelMap K t ht y := by
    exact?

/-
Definition of H_map and its continuity.
-/
noncomputable def H_map (K t : â„) (ht : t > 0) (Î¦ : â„ â†’ â„) (hÎ¦ : ContinuousOn Î¦ (Set.Icc (-K) K)) : â„ â†’ C(Set.Icc (-K) K, â„) :=
  fun y => MapToContinuous K t ht Î¦ y + MapToContinuous K t ht Î¦ (-y)

theorem H_map_continuous (K t : â„) (ht : t > 0) (Î¦ : â„ â†’ â„) (hÎ¦ : ContinuousOn Î¦ (Set.Icc (-K) K)) :
  ContinuousOn (H_map K t ht Î¦ hÎ¦) (Set.Icc (-K) K) := by
    apply_rules [ ContinuousOn.add, ContinuousOn.smul, continuousOn_const, hÎ¦ ];
    Â· exact?;
    Â· exact ContinuousOn.comp ( MapToContinuous_continuous K t ht Î¦ hÎ¦ ) ( continuousOn_id.neg ) fun x hx => âŸ¨ by linarith [ hx.1, hx.2 ], by linarith [ hx.1, hx.2 ] âŸ©

/-
Definition of G_map_v2 and its continuity.
-/
noncomputable def G_map_v2 (K t : â„) (ht : t > 0) (Î¦ : â„ â†’ â„) (hÎ¦ : ContinuousOn Î¦ (Set.Icc (-K) K)) : â„ â†’ C(Set.Icc (-K) K, â„) :=
  fun y => (Î¦ y) â€¢ (MapToContinuous K t ht Î¦ y + MapToContinuous K t ht Î¦ (-y))

theorem G_map_continuous_v2 (K t : â„) (ht : t > 0) (Î¦ : â„ â†’ â„) (hÎ¦ : ContinuousOn Î¦ (Set.Icc (-K) K)) :
  ContinuousOn (G_map_v2 K t ht Î¦ hÎ¦) (Set.Icc 0 K) := by
    apply_rules [ ContinuousOn.smul ];
    Â· rcases le_total K 0 with hK | hK <;> aesop;
      Â· cases hK.eq_or_lt <;> aesop;
      Â· exact hÎ¦.mono ( Set.Icc_subset_Icc ( by linarith ) le_rfl );
    Â· apply_rules [ ContinuousOn.add, continuousOn_const ];
      Â· exact ContinuousOn.mono ( MapToContinuous_continuous K t ht Î¦ hÎ¦ ) fun x hx => âŸ¨ by linarith [ hx.1, hx.2 ], by linarith [ hx.1, hx.2 ] âŸ©;
      Â· -- The function MapToContinuous K t ht Î¦ is continuous on [-K, K], and the negation of x is continuous on [0, K]. Therefore, the composition is continuous on [0, K].
        have h_cont : ContinuousOn (MapToContinuous K t ht Î¦) (Set.Icc (-K) K) := by
          exact?;
        exact h_cont.comp ( continuousOn_id.neg ) fun x hx => âŸ¨ by linarith [ hx.1, hx.2 ], by linarith [ hx.1, hx.2 ] âŸ©

/-
The integral of a continuous function can be approximated by a Riemann sum.
-/
theorem continuous_map_integral_approx_by_sum_v7 {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E] [CompleteSpace E]
  {a b : â„} (hab : a â‰¤ b) {f : â„ â†’ E} (hf : ContinuousOn f (Set.Icc a b)) {Îµ : â„} (hÎµ : Îµ > 0) :
  âˆƒ (s : Finset â„) (w : â„ â†’ â„), (âˆ€ y âˆˆ s, y âˆˆ Set.Icc a b) âˆ§ (âˆ€ y âˆˆ s, w y > 0) âˆ§ â€–(âˆ« y in Set.Icc a b, f y) - âˆ‘ y âˆˆ s, w y â€¢ f yâ€– < Îµ := by
    exact?

/-
Helper lemma: A uniform Riemann sum can be represented as a weighted sum over a finite set.
-/
lemma exists_riemann_sum_uniform {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E]
  {a b : â„} (hab : a < b) (n : â„•) (hn : n > 0) (f : â„ â†’ E) :
  âˆƒ (s : Finset â„) (w : â„ â†’ â„), (âˆ€ y âˆˆ s, y âˆˆ Set.Icc a b) âˆ§ (âˆ€ y âˆˆ s, w y > 0) âˆ§
  âˆ‘ y âˆˆ s, w y â€¢ f y = âˆ‘ i : Fin n, ((b - a) / n) â€¢ f (a + i * (b - a) / n) := by
    refine' âŸ¨ Finset.image ( fun i : Fin n => a + ( i : â„ ) * ( b - a ) / n ) Finset.univ, fun x => if hx : x âˆˆ Finset.image ( fun i : Fin n => a + ( i : â„ ) * ( b - a ) / n ) Finset.univ then ( b - a ) / n else 1, _, _, _ âŸ© <;> simp +decide [ Finset.mem_image ];
    Â· exact fun i => âŸ¨ div_nonneg ( mul_nonneg ( Nat.cast_nonneg _ ) ( sub_nonneg.2 hab.le ) ) ( Nat.cast_nonneg _ ), by nlinarith [ show ( i : â„ ) + 1 â‰¤ n by norm_cast; linarith [ Fin.is_lt i ], mul_div_cancelâ‚€ ( ( i : â„ ) * ( b - a ) ) ( by positivity : ( n : â„ ) â‰  0 ) ] âŸ©;
    Â· exact fun _ => div_pos ( sub_pos.mpr hab ) ( Nat.cast_pos.mpr hn );
    Â· rw [ Finset.sum_image ] ; aesop;
      exact fun i _ j _ hij => Fin.ext <| Nat.cast_injective ( by nlinarith [ mul_div_cancelâ‚€ ( ( i : â„ ) * ( b - a ) ) ( by positivity : ( n : â„ ) â‰  0 ), mul_div_cancelâ‚€ ( ( j : â„ ) * ( b - a ) ) ( by positivity : ( n : â„ ) â‰  0 ) ] : ( i : â„ ) = j )

/-
The integral of a continuous function can be approximated by a Riemann sum.
-/
theorem continuous_map_integral_approx_by_sum_v8 {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E] [CompleteSpace E]
  {a b : â„} (hab : a â‰¤ b) {f : â„ â†’ E} (hf : ContinuousOn f (Set.Icc a b)) {Îµ : â„} (hÎµ : Îµ > 0) :
  âˆƒ (s : Finset â„) (w : â„ â†’ â„), (âˆ€ y âˆˆ s, y âˆˆ Set.Icc a b) âˆ§ (âˆ€ y âˆˆ s, w y > 0) âˆ§ â€–(âˆ« y in Set.Icc a b, f y) - âˆ‘ y âˆˆ s, w y â€¢ f yâ€– < Îµ := by
    exact?

/-
Checking ContinuousMap.evalCLM
-/
#check ContinuousMap.evalCLM