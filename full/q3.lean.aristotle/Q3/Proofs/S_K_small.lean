/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e4a93701-387d-4d80-8140-d000a959e37a
-/

/-
We define the parameters $N_K$, $\delta_K$, $t_{\min}$, and the function $S_K$ as requested. We then prove the theorem `S_K_small`, which states that for $K \ge 1$, $\eta > 0$, and $t \le t_{\min}(K, \eta)$, we have $S_K(K, t) \le \eta$. The proof follows the strategy of bounding $r = \exp(-\delta_K^2/(4t))$ and then using the monotonicity of $x \mapsto 2x/(1-x)$.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def N_K (K : ℝ) : ℕ := Nat.floor (Real.exp (2 * Real.pi * K))

def delta_K (K : ℝ) : ℝ := 1 / (2 * Real.pi * (N_K K + 1))

def t_min (K η : ℝ) : ℝ := (delta_K K)^2 / (4 * Real.log (2/η + 1))

def S_K (K t : ℝ) : ℝ :=
  2 * Real.exp (-(delta_K K)^2 / (4 * t)) / (1 - Real.exp (-(delta_K K)^2 / (4 * t)))

/-
For small enough t, S_K can be made arbitrarily small. Specifically, if t ≤ t_min, then S_K ≤ η.
-/
theorem S_K_small (K t η : ℝ) (hK : K ≥ 1) (hη : η > 0) (ht : t ≤ t_min K η) :
    S_K K t ≤ η := by
      unfold t_min S_K at *;
      by_cases h_cases : 0 < t;
      · -- From $t \leq t_{\min}$, we have $Real.exp (- (delta_K K) ^ 2 / (4 * t)) \leq Real.exp (- Real.log (2 / η + 1))$.
        have h_exp : Real.exp (- (delta_K K) ^ 2 / (4 * t)) ≤ Real.exp (- Real.log (2 / η + 1)) := by
          rw [ le_div_iff₀ ] at ht;
          · exact Real.exp_le_exp.mpr ( by rw [ div_le_iff₀ ] <;> linarith );
          · exact mul_pos zero_lt_four ( Real.log_pos <| by norm_num; positivity );
        norm_num [ Real.exp_neg, Real.exp_log ( show 0 < 2 / η + 1 by positivity ) ] at *;
        rw [ div_le_iff₀ ] <;> nlinarith [ Real.exp_pos ( -delta_K K ^ 2 / ( 4 * t ) ), mul_inv_cancel₀ ( show ( 2 / η + 1 ) ≠ 0 by positivity ), div_mul_cancel₀ 2 hη.ne' ];
      · rcases eq_or_lt_of_le ( le_of_not_gt h_cases ) with rfl | h_cases' <;> aesop;
        · positivity;
        · exact le_trans ( div_nonpos_of_nonneg_of_nonpos ( by positivity ) ( sub_nonpos.mpr ( Real.one_le_exp ( by exact div_nonneg_of_nonpos ( by nlinarith ) ( mul_nonpos_of_nonneg_of_nonpos zero_le_four h_cases'.le ) ) ) ) ) hη.le