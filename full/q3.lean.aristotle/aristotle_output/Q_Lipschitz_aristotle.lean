/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 70f872fe-6eef-43e9-8ab7-a8ff6c71a862
-/

/-
This module defines the Q functional related to the explicit formula for the Riemann zeta function (or similar L-functions) and proves that it is Lipschitz continuous on the space W_K of test functions supported in [-K, K].

The main components are:
- `xi_n`: Spectral coordinates.
- `w_Q`: Prime weights involving the von Mangoldt function.
- `a_star`: Archimedean kernel (modeled as a constant function 1 for concreteness, satisfying continuity and positivity).
- `Q`: The functional defined as the difference between the Archimedean term and the prime term.
- `W_K`: The space of continuous, even, nonnegative test functions supported in [-K, K].
- `Q_Lipschitz_on_W_K`: The main theorem stating that Q is Lipschitz on W_K.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

noncomputable def xi_n (n : ℕ) : ℝ := Real.log n / (2 * Real.pi)

noncomputable def w_Q (n : ℕ) : ℝ := 2 * ArithmeticFunction.vonMangoldt n / Real.sqrt n

noncomputable def a_star (ξ : ℝ) : ℝ := 1

lemma a_star_continuous : Continuous a_star := continuous_const

lemma a_star_pos (ξ : ℝ) : 0 < a_star ξ := zero_lt_one

noncomputable def arch_term (Φ : ℝ → ℝ) : ℝ := ∫ ξ, a_star ξ * Φ ξ

noncomputable def prime_term (Φ : ℝ → ℝ) : ℝ := ∑' n, w_Q n * Φ (xi_n n)

noncomputable def Q (Φ : ℝ → ℝ) : ℝ := arch_term Φ - prime_term Φ

def W_K (K : ℝ) : Set (ℝ → ℝ) :=
  {Φ | ContinuousOn Φ (Set.Icc (-K) K) ∧
       Function.support Φ ⊆ Set.Icc (-K) K ∧
       (∀ x, Φ (-x) = Φ x) ∧
       (∀ x, 0 ≤ Φ x)}

def ActiveNodes (K : ℝ) : Set ℕ := {n | |xi_n n| ≤ K ∧ n ≥ 2}

noncomputable def W_sum (K : ℝ) : ℝ := ∑' n, if n ∈ ActiveNodes K then w_Q n else 0

noncomputable def M_a (K : ℝ) : ℝ := sSup (a_star '' Set.Icc (-K) K)

noncomputable def L_Q (K : ℝ) : ℝ := 2 * K * M_a K + W_sum K

theorem Q_Lipschitz_on_W_K (K : ℝ) (hK : K > 0) :
    ∃ L > 0, ∀ Φ₁ ∈ W_K K, ∀ Φ₂ ∈ W_K K,
      |Q Φ₁ - Q Φ₂| ≤ L * sSup {|Φ₁ x - Φ₂ x| | x ∈ Set.Icc (-K) K} := by
  use L_Q K
  constructor
  · -- Show L_Q K > 0
    refine' add_pos_of_pos_of_nonneg _ _ <;> norm_num [ hK, M_a, W_sum ];
    · exact lt_of_lt_of_le ( by norm_num [ a_star ] ) ( le_csSup ⟨ 1, Set.forall_mem_image.2 fun x hx => by norm_num [ a_star ] ⟩ ⟨ -K, ⟨ by linarith, by linarith ⟩, rfl ⟩ );
    · refine' tsum_nonneg _ ; aesop;
      exact div_nonneg ( mul_nonneg zero_le_two ( ArithmeticFunction.vonMangoldt_nonneg ) ) ( Real.sqrt_nonneg _ )
  · intro Φ₁ hΦ₁ Φ₂ hΦ₂
    -- Show Lipschitz condition
    -- By definition of $Q$, we can write
    have hQ : Q Φ₁ - Q Φ₂ = (∫ x, a_star x * (Φ₁ x - Φ₂ x)) - (∑' n, w_Q n * (Φ₁ (xi_n n) - Φ₂ (xi_n n))) := by
      unfold Q
      simp [mul_sub];
      unfold arch_term prime_term; rw [ MeasureTheory.integral_sub ] ; rw [ Summable.tsum_sub ] ; ring;
      · -- By definition of $W_K$, we know that $\Phi_1$ is zero outside $[-K, K]$, so the sum is finite.
        have h_finite : Set.Finite {n : ℕ | w_Q n * Φ₁ (xi_n n) ≠ 0} := by
          have h_support : ∀ n, n ∈ {n : ℕ | w_Q n * Φ₁ (xi_n n) ≠ 0} → |xi_n n| ≤ K := by
            cases hΦ₁ ; aesop;
            exact abs_le.mpr ( left_1 _ right_1 );
          refine Set.finite_iff_bddAbove.mpr ⟨ ⌊Real.exp ( K * ( 2 * Real.pi ) ) ⌋₊, fun n hn => ?_ ⟩ ; specialize h_support n hn ; contrapose! h_support ; aesop;
          rw [ abs_of_nonneg ];
          · rw [ show xi_n n = Real.log n / ( 2 * Real.pi ) by rfl, lt_div_iff₀ ] <;> nlinarith [ Nat.lt_of_floor_lt h_support, Real.pi_pos, Real.log_exp ( K * ( 2 * Real.pi ) ), Real.log_lt_log ( by positivity ) ( show n > Real.exp ( K * ( 2 * Real.pi ) ) by exact Nat.lt_of_floor_lt h_support ) ];
          · exact div_nonneg ( Real.log_natCast_nonneg _ ) ( by positivity );
        refine' summable_of_ne_finset_zero _;
        exacts [ h_finite.toFinset, fun n hn => Classical.not_not.1 fun hnn => hn <| h_finite.mem_toFinset.2 hnn ];
      · -- Since $\Phi_2$ is in $W_K$, it is zero outside $[-K, K]$, so the sum is finite.
        have h_finite : Set.Finite {n : ℕ | w_Q n * Φ₂ (xi_n n) ≠ 0} := by
          have h_finite : Set.Finite {n : ℕ | |xi_n n| ≤ K ∧ n ≥ 2} := by
            refine Set.finite_iff_bddAbove.mpr ⟨ ⌊Real.exp ( K * ( 2 * Real.pi ) ) ⌋₊, fun n hn => ?_ ⟩ ; aesop;
            refine Nat.le_floor ?_;
            rw [ abs_le ] at left;
            unfold xi_n at *;
            rw [ div_le_iff₀ ( by positivity ) ] at *;
            rw [ ← Real.log_le_iff_le_exp ( by positivity ) ] ; linarith;
          refine h_finite.subset fun n hn => ?_ ; contrapose! hn ; aesop;
          have := hΦ₂.2.1; aesop;
          exact Classical.not_not.1 fun h => by have := this _ h; exact absurd ( hn <| abs_le.2 ⟨ by linarith, by linarith ⟩ ) ( by linarith [ show n ≥ 2 from Nat.le_of_not_lt fun h' => a <| by interval_cases n <;> unfold w_Q <;> norm_num [ ArithmeticFunction.vonMangoldt ] ] ) ;
        refine' summable_of_ne_finset_zero _;
        exacts [ h_finite.toFinset, fun n hn => Classical.not_not.1 fun hnn => hn <| h_finite.mem_toFinset.2 hnn ];
      · -- Since $\Phi_1$ is continuous on the compact interval $[-K, K]$ and zero outside, it is integrable.
        have h_integrable : MeasureTheory.IntegrableOn (fun x => Φ₁ x) (Set.Icc (-K) K) := by
          exact ContinuousOn.integrableOn_Icc hΦ₁.1;
        rw [ MeasureTheory.integrableOn_iff_integrable_of_support_subset ] at h_integrable;
        · convert h_integrable using 1;
          exact funext fun x => by unfold a_star; norm_num;
        · exact hΦ₁.2.1;
      · unfold W_K at * ; aesop;
        -- Since $\Phi_2$ is continuous on the compact interval $[-K, K]$, it is integrable on this interval.
        have h_integrable : MeasureTheory.IntegrableOn Φ₂ (Set.Icc (-K) K) := by
          exact left_1.integrableOn_Icc;
        rw [ MeasureTheory.integrableOn_iff_integrable_of_support_subset ] at h_integrable;
        · exact MeasureTheory.Integrable.const_mul h_integrable _;
        · exact fun x hx => left_3 x hx;
    -- Apply the triangle inequality to the integral and the sum.
    have h_triangle : |∫ x, a_star x * (Φ₁ x - Φ₂ x)| ≤ (∫ x in Set.Icc (-K) K, a_star x) * (sSup { |Φ₁ x - Φ₂ x| | x ∈ Set.Icc (-K) K }) ∧ |∑' n, w_Q n * (Φ₁ (xi_n n) - Φ₂ (xi_n n))| ≤ (∑' n, if n ∈ ActiveNodes K then w_Q n else 0) * (sSup { |Φ₁ x - Φ₂ x| | x ∈ Set.Icc (-K) K }) := by
      constructor;
      · -- Since $a^*$ is continuous and positive on $[-K, K]$, we can bound the integral.
        have h_integral_bound : ∫ x, a_star x * (Φ₁ x - Φ₂ x) = ∫ x in Set.Icc (-K) K, a_star x * (Φ₁ x - Φ₂ x) := by
          rw [ MeasureTheory.setIntegral_eq_integral_of_forall_compl_eq_zero ] ; aesop;
          have := hΦ₁.2.1; have := hΦ₂.2.1; aesop;
          contrapose! a;
          cases eq_or_ne ( Φ₁ x ) 0 <;> cases eq_or_ne ( Φ₂ x ) 0 <;> simp_all +decide [ sub_eq_iff_eq_add ];
        rw [ h_integral_bound, ← MeasureTheory.integral_mul_const ];
        refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm ( _ : ℝ → ℝ ) ) ( MeasureTheory.integral_mono_of_nonneg _ _ _ );
        · exact Filter.Eventually.of_forall fun x => norm_nonneg _;
        · exact Continuous.integrableOn_Icc ( by exact Continuous.mul ( by exact continuous_const ) continuous_const );
        · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with x hx;
          rw [ Real.norm_eq_abs, abs_mul, abs_of_nonneg ( show 0 ≤ a_star x from by exact le_of_lt ( a_star_pos x ) ) ];
          exact mul_le_mul_of_nonneg_left ( le_csSup ( by exact IsCompact.bddAbove ( isCompact_Icc.image_of_continuousOn ( show ContinuousOn ( fun x => |Φ₁ x - Φ₂ x| ) ( Set.Icc ( -K ) K ) from ContinuousOn.abs ( hΦ₁.1.sub hΦ₂.1 ) ) ) ) ⟨ x, hx, rfl ⟩ ) ( by exact le_of_lt ( a_star_pos x ) );
      · -- Apply the triangle inequality to the sum.
        have h_triangle_sum : ∀ n, |w_Q n * (Φ₁ (xi_n n) - Φ₂ (xi_n n))| ≤ (if n ∈ ActiveNodes K then w_Q n else 0) * (sSup { |Φ₁ x - Φ₂ x| | x ∈ Set.Icc (-K) K }) := by
          intro n; split_ifs <;> simp_all +decide [ abs_mul ] ;
          · rw [ abs_of_nonneg ];
            · bound;
              · exact le_csSup ( by exact IsCompact.bddAbove ( isCompact_Icc.image_of_continuousOn ( ContinuousOn.abs ( hΦ₁.1.sub hΦ₂.1 ) ) ) ) ⟨ _, ⟨ by linarith [ abs_le.mp ( show |xi_n n| ≤ K from h.1 ) ], by linarith [ abs_le.mp ( show |xi_n n| ≤ K from h.1 ) ] ⟩, rfl ⟩;
              · exact div_nonneg ( mul_nonneg zero_le_two ( ArithmeticFunction.vonMangoldt_nonneg ) ) ( Real.sqrt_nonneg _ );
            · exact div_nonneg ( mul_nonneg zero_le_two ( ArithmeticFunction.vonMangoldt_nonneg ) ) ( Real.sqrt_nonneg _ );
          · unfold ActiveNodes at * ; aesop;
            contrapose! h;
            aesop;
            · have := hΦ₁.2.1;
              have := hΦ₂.2.1;
              by_cases h₁ : Φ₁ ( xi_n n ) = 0 <;> by_cases h₂ : Φ₂ ( xi_n n ) = 0 <;> simp_all +decide [ abs_le ];
            · rcases n with ( _ | _ | n ) <;> norm_num [ xi_n ] at *;
              · unfold w_Q at h ; aesop;
              · unfold w_Q at h ; norm_num at h;
        by_cases h_summable : Summable (fun n : ℕ => |w_Q n * (Φ₁ (xi_n n) - Φ₂ (xi_n n))|);
        · refine' le_trans ( le_of_eq ( by rw [ ← Real.norm_eq_abs ] ) ) ( le_trans ( norm_tsum_le_tsum_norm _ ) _ );
          · exact h_summable;
          · rw [ ← tsum_mul_right ];
            refine' tsum_le_tsum h_triangle_sum _ _;
            · convert h_summable using 1;
            · refine' summable_of_ne_finset_zero _;
              exact Finset.filter ( fun n => |Real.log n / ( 2 * Real.pi )| ≤ K ∧ 2 ≤ n ) ( Finset.range ( Nat.ceil ( Real.exp ( 2 * Real.pi * K ) ) + 1 ) );
              intro n hn; contrapose! hn; aesop;
              have := left.1;
              unfold xi_n at this;
              rw [ abs_le ] at this;
              exact Nat.lt_succ_of_le ( Nat.le_of_not_lt fun h => by rw [ div_le_iff₀ ( by positivity ) ] at this; linarith [ Real.log_exp ( 2 * Real.pi * K ), Real.log_lt_log ( by positivity ) ( show ( n : ℝ ) > Real.exp ( 2 * Real.pi * K ) by exact lt_of_lt_of_le ( Nat.lt_of_ceil_lt h ) ( mod_cast Nat.le_refl _ ) ) ] );
        · rw [ tsum_eq_zero_of_not_summable ];
          · norm_num;
            refine' mul_nonneg _ ( by apply_rules [ Real.sSup_nonneg ] ; aesop );
            refine' tsum_nonneg _;
            aesop;
            exact div_nonneg ( mul_nonneg zero_le_two ( by exact_mod_cast ArithmeticFunction.vonMangoldt_nonneg ) ) ( Real.sqrt_nonneg _ );
          · exact fun h => h_summable <| h.abs;
    -- Apply the definition of $L_Q K$.
    have h_LQ : L_Q K = (∫ x in Set.Icc (-K) K, a_star x) + (∑' n, if n ∈ ActiveNodes K then w_Q n else 0) := by
      unfold L_Q;
      unfold M_a W_sum; aesop;
      unfold a_star; norm_num [ hK.le ] ; ring;
    exact hQ.symm ▸ abs_le.mpr ⟨ by nlinarith [ abs_le.mp h_triangle.1, abs_le.mp h_triangle.2, show 0 ≤ SupSet.sSup { x : ℝ | ∃ x_1 ∈ Set.Icc ( -K ) K, |Φ₁ x_1 - Φ₂ x_1| = x } by apply_rules [ Real.sSup_nonneg ] ; rintro x ⟨ y, hy, rfl ⟩ ; exact abs_nonneg _ ], by nlinarith [ abs_le.mp h_triangle.1, abs_le.mp h_triangle.2, show 0 ≤ SupSet.sSup { x : ℝ | ∃ x_1 ∈ Set.Icc ( -K ) K, |Φ₁ x_1 - Φ₂ x_1| = x } by apply_rules [ Real.sSup_nonneg ] ; rintro x ⟨ y, hy, rfl ⟩ ; exact abs_nonneg _ ] ⟩