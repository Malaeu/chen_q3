/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 3e034667-473a-4789-81cc-86dddade1c88

Sorry, Aristotle crashed (error code: 9). Please try again.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions for HeatKernel, FejerKernel, Atom, W_K, AtomSet, diff_set, real_convolution, and AtomCone_K.
-/
noncomputable def HeatKernel (t : ℝ) (x : ℝ) : ℝ :=
  (4 * Real.pi * t) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / (4 * t))

noncomputable def FejerKernel (B : ℝ) (x : ℝ) : ℝ := max 0 (1 - |x| / B)

noncomputable def Atom (B t τ : ℝ) (x : ℝ) : ℝ :=
  FejerKernel B (x - τ) * HeatKernel t (x - τ) +
  FejerKernel B (x + τ) * HeatKernel t (x + τ)

def W_K (K : ℝ) : Set (ℝ → ℝ) :=
  { f | ContinuousOn f (Set.Icc (-K) K) ∧ (∀ x, f (-x) = f x) ∧ (∀ x ∈ Set.Icc (-K) K, f x ≥ 0) }

def AtomSet (K : ℝ) : Set (ℝ → ℝ) :=
  { f | ∃ B t τ, B > 0 ∧ t > 0 ∧ τ ∈ Set.Icc (-K) K ∧ f = Atom B t τ }

def diff_set (Φ : ℝ → ℝ) (g : ℝ → ℝ) (K : ℝ) : Set ℝ :=
  (fun x ↦ |Φ x - g x|) '' Set.Icc (-K) K

noncomputable def real_convolution (f g : ℝ → ℝ) (x : ℝ) : ℝ := ∫ y, f y * g (x - y)

def AtomCone_K (K : ℝ) : Set (ℝ → ℝ) :=
  (Convex.toCone (convexHull ℝ (AtomSet K)) (convex_convexHull ℝ (AtomSet K)) : Set (ℝ → ℝ))

/-
The integral of the Heat Kernel over the real line is 1.
-/
lemma HeatKernel_integral (t : ℝ) (ht : t > 0) : ∫ x, HeatKernel t x = 1 := by
  unfold HeatKernel;
  rw [ MeasureTheory.integral_const_mul ];
  rw [ show ∫ x : ℝ, Real.exp ( -x ^ 2 / ( 4 * t ) ) = Real.sqrt ( 4 * Real.pi * t ) by simpa [ div_eq_inv_mul, mul_assoc, mul_comm, mul_left_comm ] using integral_gaussian ( 1 / ( 4 * t ) ) ] ; rw [ Real.sqrt_eq_rpow, ← Real.rpow_add ( by positivity ) ] ; norm_num

/-
As t goes to 0, the mass of the Heat Kernel outside any fixed interval [-δ, δ] goes to 0.
-/
lemma HeatKernel_mass_concentration (δ : ℝ) (hδ : δ > 0) :
  Filter.Tendsto (fun t => ∫ x in {y | |y| > δ}, HeatKernel t x)
    (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
      -- We can use the fact that the Gaussian function decays exponentially to bound the integral.
      have h_gauss_integral : ∀ t > 0, ∫ x in {y : ℝ | abs y > δ}, Real.exp (-x^2 / (4 * t)) ≤ 2 * Real.exp (-δ^2 / (8 * t)) * ∫ x in Set.Ici 0, Real.exp (-x^2 / (8 * t)) := by
        intro t ht
        have h_gauss_integral : ∫ x in {y : ℝ | abs y > δ}, Real.exp (-x^2 / (4 * t)) ≤ 2 * ∫ x in Set.Ioi δ, Real.exp (-x^2 / (4 * t)) := by
          have h_gauss_integral : ∫ x in {y : ℝ | abs y > δ}, Real.exp (-x^2 / (4 * t)) = (∫ x in Set.Ioi δ, Real.exp (-x^2 / (4 * t))) + (∫ x in Set.Iio (-δ), Real.exp (-x^2 / (4 * t))) := by
            rw [ ← MeasureTheory.setIntegral_union ] <;> norm_num;
            · rcongr x ; aesop;
              · cases abs_cases x <;> [ left; right ] <;> norm_num <;> linarith;
              · cases a <;> cases abs_cases x <;> linarith [ Set.mem_Ioi.mp ‹_›, Set.mem_Iio.mp ‹_› ];
            · positivity;
            · exact MeasureTheory.Integrable.integrableOn ( by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) );
            · exact MeasureTheory.Integrable.integrableOn ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) ) ) ) ) ) );
          rw [ h_gauss_integral, two_mul ];
          rw [ ← MeasureTheory.integral_Iic_eq_integral_Iio ] ; rw [ ← neg_neg δ, ← integral_comp_neg_Iic ] ; norm_num;
        have h_gauss_integral : ∫ x in Set.Ioi δ, Real.exp (-x^2 / (4 * t)) ≤ Real.exp (-δ^2 / (8 * t)) * ∫ x in Set.Ioi δ, Real.exp (-x^2 / (8 * t)) := by
          rw [ ← MeasureTheory.integral_const_mul ];
          refine' MeasureTheory.setIntegral_mono_on _ _ _ _ <;> norm_num;
          · exact MeasureTheory.Integrable.integrableOn ( by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) );
          · exact MeasureTheory.Integrable.const_mul ( by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) |> MeasureTheory.Integrable.integrableOn ) _;
          · intro x hx; rw [ ← Real.exp_add ] ; exact Real.exp_le_exp.mpr ( by ring_nf; nlinarith [ inv_pos.mpr ht, mul_inv_cancel₀ ht.ne', sq_nonneg ( x - δ ) ] ) ;
        have h_gauss_integral : ∫ x in Set.Ioi δ, Real.exp (-x^2 / (8 * t)) ≤ ∫ x in Set.Ioi 0, Real.exp (-x^2 / (8 * t)) := by
          refine' MeasureTheory.setIntegral_mono_set _ _ _;
          · simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ).integrableOn;
          · exact Filter.Eventually.of_forall fun x => Real.exp_nonneg _;
          · exact MeasureTheory.ae_of_all _ fun x hx => lt_trans hδ hx;
        rw [ MeasureTheory.integral_Ici_eq_integral_Ioi ] ; nlinarith [ Real.exp_pos ( -δ ^ 2 / ( 8 * t ) ) ];
      -- Using the bound on the Gaussian integral, we can show that the expression tends to 0 as $t \to 0$.
      have h_bound : ∀ t > 0, (4 * Real.pi * t) ^ (-(1 : ℝ) / 2) * ∫ x in {y : ℝ | abs y > δ}, Real.exp (-x^2 / (4 * t)) ≤ 2 * Real.exp (-δ^2 / (8 * t)) * (4 * Real.pi * t) ^ (-(1 : ℝ) / 2) * Real.sqrt (8 * Real.pi * t) := by
        intros t ht
        have h_gauss_integral_bound : ∫ x in Set.Ici 0, Real.exp (-x^2 / (8 * t)) ≤ Real.sqrt (8 * Real.pi * t) / 2 := by
          have := integral_gaussian_Ioi ( 1 / ( 8 * t ) ) ; simp_all +decide [ div_eq_inv_mul, MeasureTheory.integral_Ici_eq_integral_Ioi ] ; ring_nf at * ; aesop;
        refine le_trans ( mul_le_mul_of_nonneg_left ( h_gauss_integral t ht ) ( by positivity ) ) ?_;
        nlinarith [ show 0 < ( 4 * Real.pi * t ) ^ ( -1 / 2 : ℝ ) * Real.exp ( -δ ^ 2 / ( 8 * t ) ) by positivity, show 0 < ( 4 * Real.pi * t ) ^ ( -1 / 2 : ℝ ) by positivity, show 0 < Real.exp ( -δ ^ 2 / ( 8 * t ) ) by positivity, Real.sqrt_nonneg ( 8 * Real.pi * t ), Real.mul_self_sqrt ( show 0 ≤ 8 * Real.pi * t by positivity ) ];
      -- Simplify the expression inside the limit.
      have h_simplify : Filter.Tendsto (fun t => 2 * Real.exp (-δ^2 / (8 * t)) * (4 * Real.pi * t) ^ (-(1 : ℝ) / 2) * Real.sqrt (8 * Real.pi * t)) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
        -- We can simplify the expression inside the limit.
        suffices h_simplify : Filter.Tendsto (fun t => 2 * Real.exp (-δ^2 / (8 * t)) * Real.sqrt (8 * Real.pi / (4 * Real.pi))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) by
          refine h_simplify.congr' ?_;
          filter_upwards [ self_mem_nhdsWithin ] with t ht ; rw [ show ( 8 * Real.pi / ( 4 * Real.pi ) ) = ( 8 * Real.pi * t ) / ( 4 * Real.pi * t ) by rw [ div_eq_div_iff ] <;> nlinarith [ Real.pi_pos, ht.out ] ] ; rw [ Real.sqrt_div ( by nlinarith [ Real.pi_pos, ht.out ] ) ] ; ring;
          norm_num [ Real.sqrt_eq_rpow, Real.rpow_neg ( by nlinarith [ Real.pi_pos, ht.out ] : 0 ≤ t * Real.pi * 4 ) ];
        ring_nf;
        norm_num [ Real.pi_pos.ne' ];
        simpa using Filter.Tendsto.mul ( Filter.Tendsto.mul ( Real.tendsto_exp_atBot.comp <| Filter.tendsto_neg_atTop_atBot.comp <| Filter.Tendsto.atTop_mul_const ( by positivity ) <| Filter.Tendsto.const_mul_atTop ( by positivity ) <| tendsto_inv_nhdsGT_zero ) tendsto_const_nhds ) tendsto_const_nhds;
      refine' squeeze_zero_norm' _ h_simplify;
      filter_upwards [ self_mem_nhdsWithin ] with t ht using by rw [ Real.norm_of_nonneg ( MeasureTheory.integral_nonneg fun _ => by exact mul_nonneg ( Real.rpow_nonneg ( by nlinarith [ Real.pi_pos, ht.out ] ) _ ) ( Real.exp_nonneg _ ) ) ] ; exact le_trans ( by unfold HeatKernel; norm_num [ mul_assoc, mul_comm, mul_left_comm, MeasureTheory.integral_const_mul ] ) ( h_bound t ht ) ;

/-
The Heat Kernel is non-negative for t > 0.
-/
lemma HeatKernel_nonneg (t : ℝ) (ht : t > 0) (x : ℝ) : 0 ≤ HeatKernel t x := by
  exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ )

/-
The Fejer Kernel is bounded between 0 and 1.
-/
lemma FejerKernel_bounds (B : ℝ) (hB : B > 0) (x : ℝ) :
  0 ≤ FejerKernel B x ∧ FejerKernel B x ≤ 1 := by
    exact ⟨ by unfold FejerKernel; positivity, by unfold FejerKernel; exact max_le ( by norm_num ) ( sub_le_self _ ( by positivity ) ) ⟩

/-
Any continuous function on [-K, K] can be extended to a continuous function with compact support on the whole real line.
-/
lemma exists_compact_extension (K : ℝ) (hK : K > 0) (Φ : ℝ → ℝ)
    (hΦ_cont : ContinuousOn Φ (Set.Icc (-K) K)) :
  ∃ Ψ : ℝ → ℝ, Continuous Ψ ∧ HasCompactSupport Ψ ∧ ∀ x ∈ Set.Icc (-K) K, Ψ x = Φ x := by
    -- Extend Φ to a continuous function with compact support on the whole real line.
    obtain ⟨Ψ, hΨ⟩ : ∃ Ψ : ℝ → ℝ, Continuous Ψ ∧ HasCompactSupport Ψ ∧ ∀ x ∈ Set.Icc (-K) K, Ψ x = Φ x := by
      have h_ext : ∃ Ψ : ℝ → ℝ, Continuous Ψ ∧ ∀ x ∈ Set.Icc (-K) K, Ψ x = Φ x := by
        have := @ContinuousMap.exists_restrict_eq;
        specialize this ( isClosed_Icc ) ( ContinuousMap.mk ( fun x : Set.Icc ( -K ) K => Φ x ) <| by exact hΦ_cont.comp_continuous ( continuous_subtype_val ) fun x => x.2 );
        obtain ⟨ g, hg ⟩ := this; exact ⟨ g, g.continuous, fun x hx => by simpa using congr_fun ( congr_arg ContinuousMap.toFun hg ) ⟨ x, hx ⟩ ⟩ ;
      obtain ⟨Ψ, hΨ⟩ := h_ext;
      -- Let's choose another continuous function $\chi$ such that $\chi(x) = 1$ for $x \in [-K, K]$ and $\chi(x) = 0$ for $|x| \geq K + 1$.
      obtain ⟨χ, hχ⟩ : ∃ χ : ℝ → ℝ, Continuous χ ∧ (∀ x ∈ Set.Icc (-K) K, χ x = 1) ∧ (∀ x, |x| ≥ K + 1 → χ x = 0) := by
        use fun x => max 0 (min 1 (1 - (|x| - K)));
        aesop;
        · fun_prop;
        · cases abs_cases x <;> cases min_cases ( 1 : ℝ ) ( 1 - ( |x| - K ) ) <;> cases max_cases ( 0 : ℝ ) ( Min.min 1 ( 1 - ( |x| - K ) ) ) <;> linarith;
        · exact Or.inr ( by linarith );
      refine' ⟨ fun x => Ψ x * χ x, hΨ.1.mul hχ.1, _, _ ⟩ <;> aesop;
      rw [ hasCompactSupport_iff_eventuallyEq ];
      norm_num [ Filter.EventuallyEq ];
      exact ⟨ ⟨ -K - 1, fun x hx => Or.inr <| right_1 x <| by cases abs_cases x <;> linarith ⟩, ⟨ K + 1, fun x hx => Or.inr <| right_1 x <| by cases abs_cases x <;> linarith ⟩ ⟩;
    use Ψ

/-
The convolution of a continuous function with compact support with the Heat Kernel converges uniformly to the function as t goes to 0.
-/
lemma HeatKernel_approx_identity_uniform (f : ℝ → ℝ) (hf_cont : Continuous f)
    (hf_supp : HasCompactSupport f) (ε : ℝ) (hε : ε > 0) :
  ∃ t₀ > 0, ∀ t ∈ Set.Ioo 0 t₀, ∀ x, |real_convolution f (HeatKernel t) x - f x| < ε := by
    have := @HeatKernel_mass_concentration;
    -- Since $f$ is continuous and has compact support, it is uniformly continuous on $\mathbb{R}$.
    have h_unif_cont : UniformContinuous f := by
      exact?;
    obtain ⟨δ, hδ_pos, hδ⟩ : ∃ δ > 0, ∀ x y, |x - y| < δ → |f x - f y| < ε / 2 := by
      exact Metric.uniformContinuous_iff.mp h_unif_cont ( ε / 2 ) ( half_pos hε );
    -- Using the uniform continuity of $f$ and the concentration of the Heat Kernel, we can bound the convolution.
    have h_conv_bound : ∀ t > 0, ∀ x, |real_convolution f (HeatKernel t) x - f x| ≤ (∫ y, |f (x - y) - f x| * HeatKernel t y) := by
      intros t ht x
      have h_conv_bound : |real_convolution f (HeatKernel t) x - f x| = |∫ y, (f (x - y) - f x) * HeatKernel t y| := by
        simp +decide [ sub_mul, MeasureTheory.integral_sub, MeasureTheory.integral_mul_const, real_convolution ];
        rw [ MeasureTheory.integral_sub ];
        · rw [ ← MeasureTheory.integral_sub_left_eq_self ];
          rw [ MeasureTheory.integral_const_mul ];
          rw [ show ∫ a : ℝ, HeatKernel t a = 1 from ?_ ] ; ring;
          exact?;
        · refine' MeasureTheory.Integrable.mono' _ _ _;
          refine' fun y => ( SupSet.sSup ( Set.image ( fun z => |f z| ) ( Set.univ ) ) ) * HeatKernel t y;
          · refine' MeasureTheory.Integrable.const_mul _ _;
            exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht );
          · exact MeasureTheory.AEStronglyMeasurable.mul ( Continuous.aestronglyMeasurable ( hf_cont.comp ( continuous_const.sub continuous_id' ) ) ) ( Continuous.aestronglyMeasurable ( by exact Continuous.mul ( Continuous.rpow ( continuous_const.mul continuous_const |> Continuous.mul <| continuous_const ) continuous_const <| by continuity ) <| Real.continuous_exp.comp <| by continuity ) );
          · filter_upwards [ ] with y using by rw [ Real.norm_eq_abs, abs_mul, abs_of_nonneg ( show 0 ≤ HeatKernel t y by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ] ; exact mul_le_mul_of_nonneg_right ( le_csSup ( show BddAbove ( Set.image ( fun z => |f z| ) Set.univ ) from by
                                                                                                                                                                                                                                                                have := hf_supp.exists_bound_of_continuous hf_cont;
                                                                                                                                                                                                                                                                exact ⟨ this.choose, Set.forall_mem_image.2 fun x _ => this.choose_spec x ⟩ ) ( Set.mem_image_of_mem _ ( Set.mem_univ _ ) ) ) ( show 0 ≤ HeatKernel t y by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ;
        · refine' MeasureTheory.Integrable.const_mul _ _;
          have := @HeatKernel_integral t ht;
          exact MeasureTheory.integrable_of_integral_eq_one this;
      convert MeasureTheory.norm_integral_le_integral_norm ( fun y => ( f ( x - y ) - f x ) * HeatKernel t y ) using 1;
      norm_num [ abs_mul, abs_of_nonneg ( show 0 ≤ HeatKernel t _ from by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ];
    -- Using the concentration of the Heat Kernel, we can bound the integral.
    have h_integral_bound : ∀ t > 0, ∀ x, ∫ y, |f (x - y) - f x| * HeatKernel t y ≤ (∫ y in {y | |y| ≤ δ}, |f (x - y) - f x| * HeatKernel t y) + (∫ y in {y | |y| > δ}, 2 * (sSup (Set.image (fun y => |f y|) (Set.univ))) * HeatKernel t y) := by
      intros t ht x
      have h_integral_split : ∫ y, |f (x - y) - f x| * HeatKernel t y = (∫ y in {y | |y| ≤ δ}, |f (x - y) - f x| * HeatKernel t y) + (∫ y in {y | |y| > δ}, |f (x - y) - f x| * HeatKernel t y) := by
        rw [ ← MeasureTheory.setIntegral_union ] <;> norm_num;
        · rw [ show { y : ℝ | |y| ≤ δ } ∪ { y : ℝ | δ < |y| } = Set.univ by ext y; by_cases hy : |y| ≤ δ <;> aesop ] ; norm_num;
        · exact Set.disjoint_left.mpr fun y hy₁ hy₂ => hy₁.out.not_lt hy₂.out;
        · exact measurableSet_Ioi.mem.comp measurable_norm;
        · refine' ContinuousOn.integrableOn_compact _ _;
          · simpa only [ abs_le ] using CompactIccSpace.isCompact_Icc;
          · refine' ContinuousOn.mul _ _;
            · exact ContinuousOn.abs ( ContinuousOn.sub ( hf_cont.comp_continuousOn ( continuousOn_const.sub continuousOn_id ) ) continuousOn_const );
            · exact Continuous.continuousOn ( by exact Continuous.mul ( continuous_const ) ( Real.continuous_exp.comp ( by exact Continuous.div_const ( by continuity ) _ ) ) );
        · refine' MeasureTheory.Integrable.integrableOn _;
          refine' MeasureTheory.Integrable.mono' _ _ _;
          refine' fun y => ( SupSet.sSup ( Set.image ( fun y => |f y| ) ( Set.univ ) ) + |f x| ) * HeatKernel t y;
          · refine' MeasureTheory.Integrable.const_mul _ _;
            exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht );
          · exact MeasureTheory.AEStronglyMeasurable.mul ( Continuous.aestronglyMeasurable ( by continuity ) ) ( Continuous.aestronglyMeasurable ( by exact Continuous.mul ( by exact Continuous.rpow ( by continuity ) ( by continuity ) <| by intro y; exact Or.inl <| by positivity ) <| by exact Real.continuous_exp.comp <| by continuity ) );
          · field_simp;
            filter_upwards [ ] with y using by rw [ Real.norm_of_nonneg ( mul_nonneg ( abs_nonneg _ ) ( by unfold HeatKernel; positivity ) ) ] ; rw [ mul_comm ] ; exact mul_le_mul_of_nonneg_left ( show |f ( x - y ) - f x| ≤ SupSet.sSup ( ( fun y => |f y| ) '' Set.univ ) + |f x| from le_trans ( abs_sub _ _ ) ( add_le_add ( le_csSup ( show BddAbove ( ( fun y => |f y| ) '' Set.univ ) from by
                                                                                                                                                                                                                                                                                                                                                have := hf_supp.exists_bound_of_continuous hf_cont;
                                                                                                                                                                                                                                                                                                                                                exact ⟨ this.choose, Set.forall_mem_image.2 fun x _ => this.choose_spec x ⟩ ) ( Set.mem_image_of_mem _ ( Set.mem_univ _ ) ) ) le_rfl ) ) ( by unfold HeatKernel; positivity ) ;
      refine' h_integral_split.le.trans ( add_le_add_left ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _ );
      · exact Filter.Eventually.of_forall fun y => mul_nonneg ( abs_nonneg _ ) ( by unfold HeatKernel; positivity );
      · refine' MeasureTheory.Integrable.const_mul _ _;
        refine' MeasureTheory.Integrable.integrableOn _;
        exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht );
      · filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_lt measurable_const <| measurable_norm ] with y hy;
        gcongr;
        · exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ );
        · have h_bound : ∀ y, |f y| ≤ sSup (Set.image (fun y => |f y|) (Set.univ)) := by
            intro y; exact le_csSup (by
            have := hf_supp.exists_bound_of_continuous hf_cont;
            exact ⟨ this.choose, Set.forall_mem_image.2 fun x _ => this.choose_spec x ⟩) (by
            simp +zetaDelta at *);
          exact le_trans ( abs_sub _ _ ) ( by linarith [ h_bound ( x - y ), h_bound x ] );
    -- Using the concentration of the Heat Kernel, we can bound the integral further.
    have h_integral_bound_further : ∀ t > 0, ∀ x, ∫ y in {y | |y| ≤ δ}, |f (x - y) - f x| * HeatKernel t y ≤ (ε / 2) * (∫ y in {y | |y| ≤ δ}, HeatKernel t y) := by
      intros t ht x
      have h_integral_bound_further : ∀ y ∈ {y | |y| ≤ δ}, |f (x - y) - f x| ≤ ε / 2 := by
        intros y hy;
        by_cases hy_eq : y = δ ∨ y = -δ;
        · rcases hy_eq with ( rfl | rfl ) <;> norm_num;
          · have h_lim : Filter.Tendsto (fun δ' => |f (x - δ') - f x|) (nhdsWithin y (Set.Iio y)) (nhds (|f (x - y) - f x|)) := by
              exact Filter.Tendsto.abs ( Filter.Tendsto.sub ( hf_cont.continuousAt.tendsto.comp ( tendsto_const_nhds.sub ( Filter.tendsto_id.mono_left inf_le_left ) ) ) tendsto_const_nhds );
            exact le_of_tendsto h_lim ( Filter.eventually_of_mem ( Ioo_mem_nhdsLT hδ_pos ) fun δ' hδ' => le_of_lt ( hδ _ _ <| by rw [ abs_of_nonpos ] <;> linarith [ hδ'.1, hδ'.2 ] ) );
          · have h_lim : Filter.Tendsto (fun y => |f (x + y) - f x|) (nhdsWithin δ (Set.Iio δ)) (nhds (|f (x + δ) - f x|)) := by
              exact tendsto_nhdsWithin_of_tendsto_nhds ( Continuous.tendsto' ( by continuity ) _ _ ( by norm_num ) );
            exact le_of_tendsto h_lim ( Filter.eventually_of_mem ( Ioo_mem_nhdsLT hδ_pos ) fun y hy => le_of_lt ( hδ ( x + y ) x ( by simpa [ abs_of_pos hy.1 ] using hy.2 ) ) );
        · exact le_of_lt ( hδ _ _ ( abs_lt.mpr ⟨ by cases abs_cases y <;> cases lt_or_gt_of_ne ( mt Or.inl hy_eq ) <;> cases lt_or_gt_of_ne ( mt Or.inr hy_eq ) <;> linarith [ hy.out ], by cases abs_cases y <;> cases lt_or_gt_of_ne ( mt Or.inl hy_eq ) <;> cases lt_or_gt_of_ne ( mt Or.inr hy_eq ) <;> linarith [ hy.out ] ⟩ ) );
      rw [ ← MeasureTheory.integral_const_mul ];
      refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
      · exact Filter.Eventually.of_forall fun y => mul_nonneg ( abs_nonneg _ ) ( by unfold HeatKernel; positivity );
      · exact MeasureTheory.Integrable.const_mul ( by exact MeasureTheory.Integrable.mono_measure ( by exact MeasureTheory.integrable_of_integral_eq_one ( by rw [ HeatKernel_integral t ht ] ) ) MeasureTheory.Measure.restrict_le_self ) _;
      · filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_le ( continuous_abs.measurable ) measurable_const ] with y hy using mul_le_mul_of_nonneg_right ( h_integral_bound_further y hy ) <| by exact ( by unfold HeatKernel; positivity ) ;
    -- Using the concentration of the Heat Kernel, we can bound the integral further and conclude the proof.
    have h_final_bound : ∀ t > 0, ∀ x, ∫ y, |f (x - y) - f x| * HeatKernel t y ≤ (ε / 2) + (2 * (sSup (Set.image (fun y => |f y|) (Set.univ)))) * (∫ y in {y | |y| > δ}, HeatKernel t y) := by
      intro t ht x; specialize h_integral_bound t ht x; specialize h_integral_bound_further t ht x; aesop;
      refine le_trans h_integral_bound <| add_le_add ?_ ?_;
      · refine le_trans h_integral_bound_further ?_;
        refine' mul_le_of_le_one_right ( by positivity ) _;
        refine' le_trans ( MeasureTheory.setIntegral_le_integral _ _ ) _;
        · exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht );
        · exact Filter.Eventually.of_forall fun x => by unfold HeatKernel; positivity;
        · rw [ HeatKernel_integral t ht ];
      · rw [ MeasureTheory.integral_const_mul ];
    have := this δ hδ_pos;
    have := this.const_mul ( 2 * SupSet.sSup ( ( fun y => |f y| ) '' Set.univ ) );
    have := Metric.tendsto_nhdsWithin_nhds.mp this ( ε / 2 ) ( half_pos hε );
    obtain ⟨ t₀, ht₀_pos, ht₀ ⟩ := this; exact ⟨ t₀, ht₀_pos, fun t ht x => lt_of_le_of_lt ( h_conv_bound t ht.1 x ) ( lt_of_le_of_lt ( h_final_bound t ht.1 x ) ( by linarith [ abs_lt.mp ( ht₀ ht.1 ( by simpa [ abs_of_pos ht.1 ] using ht.2 ) ) ] ) ) ⟩ ;

/-
We can approximate the sum of Heat Kernels by a sum of Atoms (which are Fejer Kernel * Heat Kernel) by choosing B large enough.
-/
lemma fejer_sum_approx (K : ℝ) (hK : K > 0) (t : ℝ) (ht : t > 0) (s : Finset ℝ)
    (w : ℝ → ℝ) (hw_nonneg : ∀ y ∈ s, 0 ≤ w y) (hs_subset : ∀ y ∈ s, y ∈ Set.Icc (-K) K)
    (ε : ℝ) (hε : ε > 0) :
  ∃ B > 0, ∀ x ∈ Set.Icc (-K) K,
    |∑ y ∈ s, w y * Atom B t y x - (∑ y ∈ s, w y * HeatKernel t (x - y) +
      ∑ y ∈ s, w y * HeatKernel t (x + y))| < ε := by
        -- Choose $B$ large enough such that $\sum_{y \in s} w(y) \left( \text{FejerKernel}(B, x - y) - 1 \right) \text{HeatKernel}(t, x - y)$ and $\sum_{y \in s} w(y) \left( \text{FejerKernel}(B, x + y) - 1 \right) \text{HeatKernel}(t, x + y)$ are both less than $\epsilon / 2$.
        obtain ⟨B₀, hB₀_pos, hB₀⟩ : ∃ B₀ > 0, ∀ y ∈ s, ∀ x ∈ Set.Icc (-K) K, |(FejerKernel B₀ (x - y) - 1) * HeatKernel t (x - y)| < ε / (2 * (∑ y ∈ s, |w y|) + 1) ∧ |(FejerKernel B₀ (x + y) - 1) * HeatKernel t (x + y)| < ε / (2 * (∑ y ∈ s, |w y|) + 1) := by
          -- By definition of FejerKernel, we know that |FejerKernel B₀ x - 1| ≤ 0 for all x when B₀ is sufficiently large.
          have h_fejerKernel_approx : ∀ δ > 0, ∃ B₀ > 0, ∀ x ∈ Set.Icc (-2 * K - δ) (2 * K + δ), |FejerKernel B₀ x - 1| < ε / (2 * (∑ y ∈ s, |w y|) + 1) * (1 / (HeatKernel t 0)) := by
            intros δ δ_pos;
            -- Choose $B₀$ large enough such that $\frac{|x|}{B₀} < \frac{\epsilon}{2 \sum_{y \in s} |w(y)| + 1} \cdot \frac{1}{\text{HeatKernel}(t, 0)}$ for all $x \in [-2K - \delta, 2K + \delta]$.
            obtain ⟨B₀, hB₀_pos, hB₀⟩ : ∃ B₀ > 0, ∀ x ∈ Set.Icc (-2 * K - δ) (2 * K + δ), |x| / B₀ < ε / (2 * (∑ y ∈ s, |w y|) + 1) * (1 / HeatKernel t 0) := by
              have h_fejerKernel_approx : ∃ B₀ > 0, ∀ x ∈ Set.Icc (-2 * K - δ) (2 * K + δ), |x| < B₀ * (ε / (2 * (∑ y ∈ s, |w y|) + 1) * (1 / HeatKernel t 0)) := by
                have h_fejerKernel_approx : ∃ B₀ > 0, ∀ x ∈ Set.Icc (-2 * K - δ) (2 * K + δ), |x| < B₀ := by
                  exact ⟨ 2 * K + δ + 1, by linarith, fun x hx => abs_lt.mpr ⟨ by linarith [ hx.1 ], by linarith [ hx.2 ] ⟩ ⟩;
                obtain ⟨ B₀, hB₀_pos, hB₀ ⟩ := h_fejerKernel_approx;
                refine' ⟨ B₀ / ( ε / ( 2 * ∑ y ∈ s, |w y| + 1 ) * ( 1 / HeatKernel t 0 ) ), _, _ ⟩;
                · exact div_pos hB₀_pos ( mul_pos ( div_pos hε ( by exact add_pos_of_nonneg_of_pos ( mul_nonneg zero_le_two ( Finset.sum_nonneg fun _ _ => abs_nonneg _ ) ) zero_lt_one ) ) ( one_div_pos.mpr ( HeatKernel_nonneg t ht 0 |> lt_of_le_of_ne <| Ne.symm <| by exact ne_of_gt <| by exact mul_pos ( Real.rpow_pos_of_pos ( by positivity ) _ ) ( Real.exp_pos _ ) ) ) );
                · intro x hx; rw [ div_mul_cancel₀ _ ( ne_of_gt ( mul_pos ( div_pos hε ( by linarith [ show 0 ≤ ∑ y ∈ s, |w y| by exact Finset.sum_nonneg fun _ _ => abs_nonneg _ ] ) ) ( one_div_pos.mpr ( show 0 < HeatKernel t 0 by exact mul_pos ( Real.rpow_pos_of_pos ( by positivity ) _ ) ( Real.exp_pos _ ) ) ) ) ) ] ; exact hB₀ x hx;
              exact ⟨ h_fejerKernel_approx.choose, h_fejerKernel_approx.choose_spec.1, fun x hx => by rw [ div_lt_iff₀' h_fejerKernel_approx.choose_spec.1 ] ; exact h_fejerKernel_approx.choose_spec.2 x hx ⟩;
            refine' ⟨ B₀, hB₀_pos, fun x hx => _ ⟩;
            unfold FejerKernel;
            cases max_cases ( 0 : ℝ ) ( 1 - |x| / B₀ ) <;> cases abs_cases ( Max.max 0 ( 1 - |x| / B₀ ) - 1 ) <;> linarith [ hB₀ x hx, show 0 ≤ |x| / B₀ by positivity ];
          obtain ⟨ B₀, hB₀₁, hB₀₂ ⟩ := h_fejerKernel_approx 1 zero_lt_one; use B₀; aesop;
          · refine' lt_of_le_of_lt ( mul_le_mul_of_nonneg_left ( show |HeatKernel t ( x - y )| ≤ HeatKernel t 0 from _ ) ( abs_nonneg _ ) ) _;
            · unfold HeatKernel; norm_num [ abs_mul, abs_inv, abs_of_pos ht ] ; ring_nf; norm_num [ ht.le ] ;
              rw [ abs_of_nonneg ( by positivity ) ] ; exact mul_le_of_le_one_right ( by positivity ) ( Real.exp_le_one_iff.mpr <| by nlinarith [ sq_nonneg ( x - y ), mul_inv_cancel₀ ht.ne' ] ) ;
            · refine' lt_of_lt_of_le ( mul_lt_mul_of_pos_right ( hB₀₂ ( x - y ) ( by linarith [ hs_subset y a ] ) ( by linarith [ hs_subset y a ] ) ) ( show 0 < HeatKernel t 0 from _ ) ) _;
              · exact mul_pos ( Real.rpow_pos_of_pos ( by positivity ) _ ) ( Real.exp_pos _ );
              · rw [ mul_assoc, inv_mul_cancel₀ ( ne_of_gt ( show 0 < HeatKernel t 0 from by exact mul_pos ( Real.rpow_pos_of_pos ( by positivity ) _ ) ( Real.exp_pos _ ) ) ), mul_one ];
          · refine' lt_of_le_of_lt ( mul_le_mul_of_nonneg_left ( show |HeatKernel t ( x + y )| ≤ HeatKernel t 0 from _ ) ( abs_nonneg _ ) ) _;
            · unfold HeatKernel; norm_num [ Real.exp_pos ] ; ring_nf; norm_num [ ht.le ] ;
              rw [ abs_of_nonneg ( by positivity ) ] ; exact mul_le_of_le_one_right ( by positivity ) ( Real.exp_le_one_iff.mpr <| by nlinarith [ inv_pos.mpr ht, mul_inv_cancel₀ ht.ne', sq_nonneg ( x + y ), mul_nonneg ( sq_nonneg x ) ( inv_nonneg.mpr ht.le ), mul_nonneg ( sq_nonneg y ) ( inv_nonneg.mpr ht.le ) ] ) ;
            · have := hB₀₂ ( x + y ) ( by linarith [ hs_subset y a ] ) ( by linarith [ hs_subset y a ] ) ; rw [ lt_iff_not_ge ] at this ; aesop;
              exact lt_of_lt_of_le ( mul_lt_mul_of_pos_right this ( show 0 < HeatKernel t 0 from by exact mul_pos ( Real.rpow_pos_of_pos ( by positivity ) _ ) ( Real.exp_pos _ ) ) ) ( by rw [ mul_assoc, inv_mul_cancel₀ ( ne_of_gt ( show 0 < HeatKernel t 0 from by exact mul_pos ( Real.rpow_pos_of_pos ( by positivity ) _ ) ( Real.exp_pos _ ) ) ), mul_one ] );
        use B₀;
        -- Apply the triangle inequality to the sum.
        have h_triangle : ∀ x ∈ Set.Icc (-K) K, |∑ y ∈ s, w y * Atom B₀ t y x - (∑ y ∈ s, w y * HeatKernel t (x - y) + ∑ y ∈ s, w y * HeatKernel t (x + y))| ≤ ∑ y ∈ s, |w y| * |(FejerKernel B₀ (x - y) - 1) * HeatKernel t (x - y)| + ∑ y ∈ s, |w y| * |(FejerKernel B₀ (x + y) - 1) * HeatKernel t (x + y)| := by
          simp +decide [ ← abs_mul, ← Finset.sum_add_distrib, Atom ];
          intro x hx₁ hx₂; rw [ ← Finset.sum_sub_distrib ] ; refine' le_trans ( Finset.abs_sum_le_sum_abs _ _ ) _ ; gcongr ; ring_nf ; aesop;
          exact abs_le.mpr ⟨ by cases abs_cases ( w i * FejerKernel B₀ ( x - i ) * HeatKernel t ( x - i ) - w i * HeatKernel t ( x - i ) ) <;> cases abs_cases ( w i * FejerKernel B₀ ( x + i ) * HeatKernel t ( x + i ) - w i * HeatKernel t ( x + i ) ) <;> linarith, by cases abs_cases ( w i * FejerKernel B₀ ( x - i ) * HeatKernel t ( x - i ) - w i * HeatKernel t ( x - i ) ) <;> cases abs_cases ( w i * FejerKernel B₀ ( x + i ) * HeatKernel t ( x + i ) - w i * HeatKernel t ( x + i ) ) <;> linarith ⟩;
        refine' ⟨ hB₀_pos, fun x hx => lt_of_le_of_lt ( h_triangle x hx ) _ ⟩;
        refine' lt_of_le_of_lt ( add_le_add ( Finset.sum_le_sum fun y hy => mul_le_mul_of_nonneg_left ( le_of_lt ( hB₀ y hy x hx |>.1 ) ) ( abs_nonneg _ ) ) ( Finset.sum_le_sum fun y hy => mul_le_mul_of_nonneg_left ( le_of_lt ( hB₀ y hy x hx |>.2 ) ) ( abs_nonneg _ ) ) ) _;
        norm_num [ ← Finset.sum_mul _ _ _ ];
        rw [ mul_div, ← add_div, div_lt_iff₀ ] <;> nlinarith [ show 0 ≤ ∑ y ∈ s, |w y| from Finset.sum_nonneg fun _ _ => abs_nonneg _ ]

/-
A weighted sum of Atoms with non-negative weights is in the AtomCone_K, provided the sum of weights is positive.
-/
lemma sum_atoms_in_cone (K : ℝ) (s : Finset ℝ) (w : ℝ → ℝ) (hw : ∀ y ∈ s, 0 ≤ w y)
    (B : ℝ) (hB : B > 0) (t : ℝ) (ht : t > 0) (hs : ∀ y ∈ s, y ∈ Set.Icc (-K) K)
    (h_sum_pos : ∑ y ∈ s, w y > 0) :
  (fun x => ∑ y ∈ s, w y * Atom B t y x) ∈ AtomCone_K K := by
    -- By definition of AtomSet, each term in the sum is in AtomSet K.
    have h_atom_in_atomSet : ∀ y ∈ s, Atom B t y ∈ AtomSet K := by
      exact fun y hy => ⟨ B, t, y, hB, ht, hs y hy, rfl ⟩;
    unfold AtomCone_K;
    simp_all +decide [ convexHull_eq ];
    refine' ⟨ _, _, _ ⟩;
    exact ⋃ ( _ : 0 < ∑ y ∈ s, w y ), ( ∑ y ∈ s, w y ) • { x : ℝ → ℝ | ∃ ( ι : Type ) ( t : Finset ι ) ( w : ι → ℝ ), ( ∀ i ∈ t, 0 ≤ w i ) ∧ ∑ i ∈ t, w i = 1 ∧ ∃ ( x_1 : ι → ℝ → ℝ ), ( ∀ i ∈ t, x_1 i ∈ AtomSet K ) ∧ t.centerMass w x_1 = x };
    · exact ⟨ _, rfl ⟩;
    · refine' Set.mem_iUnion.mpr ⟨ h_sum_pos, _ ⟩;
      refine' ⟨ fun x => ∑ y ∈ s, ( w y / ∑ y ∈ s, w y ) * Atom B t y x, _, _ ⟩;
      · refine' ⟨ ℝ, s, fun y => w y / ∑ y ∈ s, w y, _, _, _ ⟩ <;> simp_all +decide [ Finset.centerMass ];
        · exact fun y hy => div_nonneg ( hw y hy ) h_sum_pos.le;
        · rw [ ← Finset.sum_div, div_self h_sum_pos.ne' ];
        · refine' ⟨ fun y x => Atom B t y x, _, _ ⟩ <;> aesop;
          simp +decide [ div_eq_inv_mul, Finset.mul_sum _ _ _, mul_assoc, mul_left_comm, Finset.sum_mul, h_sum_pos.ne' ];
          simp +decide [ ← Finset.mul_sum _ _ _, ← Finset.sum_mul, mul_assoc, mul_comm, mul_left_comm, h_sum_pos.ne' ];
          exact funext fun x => by simp +decide [ mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _ ] ;
      · ext; simp +decide [ div_eq_inv_mul, mul_assoc, mul_left_comm, Finset.mul_sum _ _ _, h_sum_pos.ne' ] ;

/-
Any even continuous function on [-K, K] can be extended to an even continuous function with compact support on the whole real line.
-/
lemma exists_even_compact_extension (K : ℝ) (hK : K > 0) (Φ : ℝ → ℝ)
    (hΦ_cont : ContinuousOn Φ (Set.Icc (-K) K)) (hΦ_even : Even Φ) :
  ∃ Ψ : ℝ → ℝ, Continuous Ψ ∧ HasCompactSupport Ψ ∧ Even Ψ ∧ ∀ x ∈ Set.Icc (-K) K, Ψ x = Φ x := by
    cases' hΦ_even with g hg;
    -- Let's define the even extension of g to the entire real line.
    obtain ⟨g_ext, hg_ext⟩ : ∃ g_ext : ℝ → ℝ, Continuous g_ext ∧ HasCompactSupport g_ext ∧ ∀ x ∈ Set.Icc (-K) K, g_ext x = g x := by
      apply exists_compact_extension K hK g;
      aesop;
      simpa using hΦ_cont.div_const 2;
    refine' ⟨ g_ext + g_ext, hg_ext.1.add hg_ext.1, _, _, _ ⟩ <;> aesop;
    exact HasCompactSupport.add left_1 left_1

/-
The Heat Kernel is an even function.
-/
lemma HeatKernel_even (t : ℝ) : Even (HeatKernel t) := by
  exact ⟨ fun x => HeatKernel t x / 2, by ext x; simp [ mul_div_cancel_left₀ ] ⟩

/-
The convolution of two even functions is even.
-/
lemma even_convolution (f g : ℝ → ℝ) (hf : Even f) (hg : Even g) : Even (real_convolution f g) := by
  unfold Even at *; aesop;
  use fun x => (real_convolution (w + w) (w_1 + w_1) x) / 2;
  ext; rw [ Pi.add_apply ] ; ring

/-
If a continuous function on a compact set is strictly less than ε everywhere, then its supremum is strictly less than ε.
-/
lemma sSup_lt_of_compact_image_lt (K : Set ℝ) (hK : IsCompact K) (hK_nonempty : K.Nonempty) (f : ℝ → ℝ) (hf_cont : ContinuousOn f K) (ε : ℝ) (h : ∀ x ∈ K, f x < ε) : sSup (f '' K) < ε := by
  obtain ⟨ x, hx ⟩ := hK.exists_isMaxOn hK_nonempty hf_cont;
  exact lt_of_le_of_lt ( csSup_le ( Set.Nonempty.image _ hK_nonempty ) ( Set.forall_mem_image.2 fun y hy => hx.2 hy ) ) ( h x hx.1 )

/-
We can approximate the integral of a continuous function F(x, y) over y in [a, b] uniformly in x by a Riemann sum.
-/
lemma uniform_riemann_sum (a b : ℝ) (hab : a < b) (X : Set ℝ) (hX : IsCompact X)
    (F : ℝ → ℝ → ℝ) (hF : ContinuousOn (Function.uncurry F) (X ×ˢ Set.Icc a b))
    (ε : ℝ) (hε : ε > 0) :
  ∃ (s : Finset ℝ) (w : ℝ → ℝ), (∀ y ∈ s, w y > 0) ∧ (∀ y ∈ s, y ∈ Set.Icc a b) ∧
  ∀ x ∈ X, |(∫ y in Set.Icc a b, F x y) - ∑ y ∈ s, w y * F x y| < ε := by
    -- First, use the fact that a continuous function on a compact set K is uniformly continuous on K.
    have h_unif_cont : UniformContinuousOn (fun p : ℝ × ℝ => F p.1 p.2) (X ×ˢ Set.Icc a b) := by
      exact ( hX.prod ( CompactIccSpace.isCompact_Icc ) ) |> fun h => h.uniformContinuousOn_of_continuous hF;
    -- Given any δ > 0, we can use the uniform continuity of F to find a δ' > 0 such that |F(x, y) - F(x, z)| < δ for all x ∈ X and |y - z| < δ'.
    obtain ⟨δ', hδ'_pos, hδ'_cont⟩ : ∃ δ' > 0, ∀ x ∈ X, ∀ y ∈ Set.Icc a b, ∀ z ∈ Set.Icc a b, abs (y - z) < δ' → abs (F x y - F x z) < ε / (4 * (b - a)) := by
      have := Metric.uniformContinuousOn_iff.mp h_unif_cont ( ε / ( 4 * ( b - a ) ) ) ( div_pos hε ( by linarith ) ) ; aesop;
    -- Divide the interval [a, b] into subintervals of length less than δ'.
    obtain ⟨n, hn⟩ : ∃ n : ℕ, n > 0 ∧ (b - a) / n < δ' := by
      exact ⟨ ⌊ ( b - a ) / δ'⌋₊ + 1, Nat.succ_pos _, by rw [ div_lt_iff₀ ] <;> push_cast <;> nlinarith [ Nat.lt_floor_add_one ( ( b - a ) / δ' ), mul_div_cancel₀ ( b - a ) hδ'_pos.ne' ] ⟩;
    refine' ⟨ Finset.image ( fun i : ℕ => a + ( i + 1 ) * ( b - a ) / n ) ( Finset.range n ), fun y => ( b - a ) / n, _, _, _ ⟩ <;> aesop;
    · exact div_nonneg ( mul_nonneg ( by positivity ) ( by linarith ) ) ( by positivity );
    · rw [ add_div', div_le_iff₀ ] <;> nlinarith [ show ( w : ℝ ) + 1 ≤ n by norm_cast ];
    · -- By the properties of the integral, we can bound the difference between the integral and the Riemann sum.
      have h_integral_bound : |(∫ y in Set.Icc a b, F x y) - (∑ i ∈ Finset.range n, (b - a) / n * F x (a + (i + 1) * (b - a) / n))| ≤ ∑ i ∈ Finset.range n, ∫ y in (a + i * (b - a) / n).. (a + (i + 1) * (b - a) / n), |F x y - F x (a + (i + 1) * (b - a) / n)| := by
        have h_integral_bound : |(∫ y in Set.Icc a b, F x y) - (∑ i ∈ Finset.range n, (b - a) / n * F x (a + (i + 1) * (b - a) / n))| ≤ ∑ i ∈ Finset.range n, ∫ y in (a + i * (b - a) / n).. (a + (i + 1) * (b - a) / n), |F x y - F x (a + (i + 1) * (b - a) / n)| := by
          have h_integral_split : ∫ y in Set.Icc a b, F x y = ∑ i ∈ Finset.range n, ∫ y in (a + i * (b - a) / n).. (a + (i + 1) * (b - a) / n), F x y := by
            rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le hab.le ];
            symm;
            convert intervalIntegral.sum_integral_adjacent_intervals _ <;> norm_num;
            · rw [ mul_div_cancel_left₀ _ ( by positivity ), add_sub_cancel ];
            · field_simp;
              intro k hk; apply_rules [ ContinuousOn.intervalIntegrable ];
              refine' hF.comp ( continuousOn_const.prodMk ( continuousOn_id ) ) fun y hy => _;
              aesop;
              · cases Set.mem_uIcc.mp hy <;> nlinarith [ show ( k : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( a * n + ( k : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( a * n + ( b - a ) * ( k + 1 ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ];
              · cases Set.mem_uIcc.mp hy <;> nlinarith [ show ( k : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( a * n + ( k : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( a * n + ( b - a ) * ( k + 1 ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ]
          rw [ h_integral_split, ← Finset.sum_sub_distrib ];
          refine' le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( Finset.sum_le_sum fun i hi => _ );
          convert intervalIntegral.abs_integral_le_integral_abs _ using 2;
          · rw [ intervalIntegral.integral_sub ] <;> norm_num;
            · exact Or.inl <| by ring;
            · field_simp;
              apply_rules [ ContinuousOn.intervalIntegrable ];
              refine' hF.comp ( continuousOn_const.prodMk continuousOn_id ) fun y hy => _;
              aesop;
              · cases Set.mem_uIcc.mp hy <;> nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( a * n + ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( a * n + ( b - a ) * ( i + 1 ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ];
              · cases Set.mem_uIcc.mp hy <;> nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( a * n + ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( a * n + ( b - a ) * ( i + 1 ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ];
          · bound;
        convert h_integral_bound using 1;
      -- By the properties of the integral, we can bound the integral of the absolute difference.
      have h_integral_abs_diff : ∀ i ∈ Finset.range n, ∫ y in (a + i * (b - a) / n).. (a + (i + 1) * (b - a) / n), |F x y - F x (a + (i + 1) * (b - a) / n)| ≤ (b - a) / n * (ε / (4 * (b - a))) := by
        intro i hi; rw [ intervalIntegral.integral_of_le ( by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], mul_div_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( i + 1 : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ] ; aesop;
        refine' le_trans ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _;
        use fun y => ε / ( 4 * ( b - a ) );
        · exact Filter.Eventually.of_forall fun _ => abs_nonneg _;
        · norm_num;
        · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with y hy;
          refine' le_of_lt ( hδ'_cont x a_1 y _ _ _ _ _ _ );
          · exact le_trans ( by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) hy.1.le;
          · nlinarith [ hy.2, show ( i : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( i : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ];
          · exact le_add_of_nonneg_right ( div_nonneg ( mul_nonneg ( by positivity ) ( by linarith ) ) ( by positivity ) );
          · rw [ add_div', div_le_iff₀ ] <;> nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast ];
          · exact abs_lt.mpr ⟨ by nlinarith [ hy.1, hy.2, show ( i : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( i + 1 : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), div_mul_cancel₀ ( b - a ) ( by positivity : ( n : ℝ ) ≠ 0 ) ], by nlinarith [ hy.1, hy.2, show ( i : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( i + 1 : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), div_mul_cancel₀ ( b - a ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ⟩;
        · norm_num [ add_mul, div_eq_mul_inv ];
          rw [ max_eq_left ( by exact mul_nonneg ( sub_nonneg.2 hab.le ) ( inv_nonneg.2 ( Nat.cast_nonneg _ ) ) ) ];
      rw [ Finset.sum_image ];
      · refine' lt_of_le_of_lt h_integral_bound ( lt_of_le_of_lt ( Finset.sum_le_sum h_integral_abs_diff ) _ );
        norm_num [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, left.ne', ne_of_gt ( sub_pos.mpr hab ) ];
        linarith;
      · simp +contextual [ div_eq_mul_inv, ne_of_gt ( show 0 < n by linarith ), ne_of_gt ( show 0 < b - a by linarith ) ]

#print Even