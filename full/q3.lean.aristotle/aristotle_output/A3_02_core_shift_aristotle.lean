/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 5fcd433d-b39c-40ff-8802-95c18ae93de1
-/

/-
This module proves the "Shift-Robust Core Mass" lemma for the Fejér hat function.
It defines the Fejér hat function `FejerHat` and the `shifted_core_integral`.
The main result is `core_shift_mass`, which establishes that the integral of the Fejér hat function over any interval of length 2r contained within its support is at least 2r²/B.
Additionally, `gaussian_core_shift` proves a lower bound for the Gaussian-weighted integral of the Fejér hat function.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

noncomputable def FejerHat (B : ℝ) (x : ℝ) : ℝ := max 0 (1 - |x| / B)

noncomputable def shifted_core_integral (B r τ : ℝ) : ℝ :=
  ∫ x in Set.Icc (τ - r) (τ + r), FejerHat B x

noncomputable def gaussian_shifted_integral (B t τ : ℝ) : ℝ :=
  ∫ x, FejerHat B (x - τ) * Real.exp (-4 * Real.pi^2 * t * (x - τ)^2)

/-
The integral of the Fejér hat function (with width parameter B) over an interval of length 2r centered at τ is at least 2r²/B, provided r ≤ B/2 and the interval is within the support.
-/
/-- Shift-robust core mass: Fejér hat has minimum mass 2r²/B over any interval of length 2r.
Note: We require r ≤ B/2 for this bound to hold. -/
lemma core_shift_mass (B r τ : ℝ) (hB : B > 0) (hr : 0 < r) (hrB : r ≤ B / 2)
    (hτ : |τ| ≤ B - r) :
    shifted_core_integral B r τ ≥ 2 * r^2 / B := by
  -- Since $|τ| \le B - r$, the interval $[τ-r, τ+r]$ is contained within $[-B, B]$.
  have h_interval : ∀ x ∈ Set.Icc (τ - r) (τ + r), |x| ≤ B := by
    exact fun x hx => abs_le.mpr ⟨ by linarith [ abs_le.mp hτ, hx.1 ], by linarith [ abs_le.mp hτ, hx.2 ] ⟩;
  -- The integral of the Fejér hat function over the interval $[τ-r, τ+r]$ is at least $2r²/B$.
  have h_integral : ∫ x in Set.Icc (τ - r) (τ + r), (1 - |x| / B) ≥ (2 * r ^ 2) / B := by
    -- Consider the function $g(x) = 1 - |x|/B$. We can split the integral into two parts: the integral over $[τ-r, 0]$ and the integral over $[0, τ+r]$.
    by_cases h_case : τ + r ≤ 0;
    · -- Since $τ + r ≤ 0$, we have $|x| = -x$ for $x \in [τ - r, τ + r]$.
      have h_abs_neg : ∀ x ∈ Set.Icc (τ - r) (τ + r), |x| = -x := by
        exact fun x hx => abs_of_nonpos <| by linarith [ hx.1, hx.2 ] ;
      rw [ MeasureTheory.setIntegral_congr_fun measurableSet_Icc fun x hx => by rw [ h_abs_neg x hx ] ] ; rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le ] <;> norm_num <;> ring <;> norm_num [ hB.ne', hr.ne' ];
      · norm_num [ add_comm ] ; ring_nf ; norm_num [ hB.ne' ];
        field_simp;
        linarith [ abs_le.mp hτ ];
      · linarith;
    · by_cases h_case2 : τ - r ≥ 0;
      · rw [ MeasureTheory.setIntegral_congr_fun measurableSet_Icc fun x hx => by rw [ abs_of_nonneg ] ; linarith [ hx.1 ] ];
        rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le ] <;> norm_num <;> ring_nf <;> try linarith;
        nlinarith [ inv_mul_cancel_left₀ hB.ne' r, abs_le.mp hτ ];
      · -- Since $\tau - r < 0$ and $\tau + r > 0$, we can split the integral into two parts: the integral over $[τ-r, 0]$ and the integral over $[0, τ+r]$.
        have h_split : ∫ x in Set.Icc (τ - r) (τ + r), (1 - |x| / B) = (∫ x in Set.Icc (τ - r) 0, (1 - (-x) / B)) + (∫ x in Set.Icc 0 (τ + r), (1 - x / B)) := by
          have h_split : ∫ x in Set.Icc (τ - r) (τ + r), (1 - |x| / B) = (∫ x in Set.Icc (τ - r) 0, (1 - |x| / B)) + (∫ x in Set.Icc 0 (τ + r), (1 - |x| / B)) := by
            norm_num [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le, h_case, h_case2 ];
            rw [ ← MeasureTheory.setIntegral_union ] <;> norm_num;
            · rw [ Set.Ioc_union_Ioc_eq_Ioc ] <;> linarith;
            · exact Continuous.integrableOn_Ioc ( by continuity );
            · exact Continuous.integrableOn_Ioc ( by continuity );
          exact h_split.trans ( congrArg₂ _ ( MeasureTheory.setIntegral_congr_fun measurableSet_Icc fun x hx => by rw [ abs_of_nonpos hx.2 ] ) ( MeasureTheory.setIntegral_congr_fun measurableSet_Icc fun x hx => by rw [ abs_of_nonneg hx.1 ] ) );
        rw [ h_split, MeasureTheory.integral_Icc_eq_integral_Ioc, MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le, ← intervalIntegral.integral_of_le ] <;> norm_num [ neg_div ] <;> try linarith;
        ring_nf;
        nlinarith [ inv_pos.2 hB, mul_inv_cancel₀ hB.ne', abs_le.mp hτ, sq_nonneg ( τ + r ), sq_nonneg ( τ - r ) ];
  refine' le_trans h_integral _;
  exact le_of_eq <| MeasureTheory.setIntegral_congr_fun measurableSet_Icc fun x hx => by rw [ FejerHat ] ; rw [ max_eq_right ] ; exact sub_nonneg_of_le <| div_le_one_of_le₀ ( h_interval x hx ) hB.le;

/-
On the interval [τ-r, τ+r], the Gaussian weight is bounded below by its value at the endpoints.
-/
lemma gaussian_lower_bound (t τ r : ℝ) (ht : t > 0) (x : ℝ) (hx : x ∈ Set.Icc (τ - r) (τ + r)) :
    Real.exp (-4 * Real.pi^2 * t * (x - τ)^2) ≥ Real.exp (-4 * Real.pi^2 * t * r^2) := by
  exact Real.exp_le_exp.mpr ( by nlinarith [ show ( 0 : ℝ ) ≤ 4 * Real.pi ^ 2 * t by positivity, show ( x - τ ) ^ 2 ≤ r ^ 2 by nlinarith [ hx.1, hx.2 ] ] )

/-
The Gaussian-weighted integral is bounded below by the minimum mass of the Fejér hat times the minimum Gaussian weight on the core interval.
-/
lemma gaussian_core_shift (B t τ r : ℝ) (hB : B > 0) (ht : t > 0) (hr : 0 < r) (hrB : r ≤ B / 2)
    (hτ : |τ| ≤ B - r) :
    gaussian_shifted_integral B t τ ≥ (2 * r^2 / B) * Real.exp (-4 * Real.pi^2 * t * r^2) := by
  -- Apply the lower bound to the integral:
  have h_lower_bound : gaussian_shifted_integral B t τ ≥ (∫ x in Set.Icc (τ - r) (τ + r), FejerHat B (x - τ)) * (Real.exp (-4 * Real.pi^2 * t * r^2)) := by
    -- Factor out the constant exponential term.
    suffices h_lower_bound' : ∫ x in Set.Icc (τ - r) (τ + r), FejerHat B (x - τ) * Real.exp (-4 * Real.pi^2 * t * (x - τ)^2) ≥ (∫ x in Set.Icc (τ - r) (τ + r), FejerHat B (x - τ)) * Real.exp (-4 * Real.pi^2 * t * r^2) by
      refine' le_trans h_lower_bound' ( MeasureTheory.setIntegral_le_integral _ _ );
      · refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun x => ( 1 : ℝ ) * Real.exp ( -4 * Real.pi ^ 2 * t * ( x - τ ) ^ 2 );
        · simpa using ( integrable_exp_neg_mul_sq ( by positivity ) ) |> fun h => h.comp_sub_right τ;
        · exact Continuous.aestronglyMeasurable ( by exact Continuous.mul ( by exact Continuous.max continuous_const <| by continuity ) <| Real.continuous_exp.comp <| by continuity );
        · filter_upwards [ ] with x using by rw [ Real.norm_eq_abs, abs_of_nonneg ( mul_nonneg ( by unfold FejerHat; positivity ) ( Real.exp_nonneg _ ) ) ] ; exact mul_le_mul_of_nonneg_right ( show FejerHat B ( x - τ ) ≤ 1 from by unfold FejerHat; exact max_le ( by linarith ) ( sub_le_self _ <| by positivity ) ) ( Real.exp_nonneg _ ) ;
      · exact Filter.Eventually.of_forall fun x => mul_nonneg ( le_max_left _ _ ) ( Real.exp_nonneg _ );
    rw [ ← MeasureTheory.integral_mul_const ] ; refine MeasureTheory.integral_mono_of_nonneg ?_ ?_ ?_ <;> norm_num;
    · exact Filter.eventually_inf_principal.mpr ( Filter.Eventually.of_forall fun x hx => mul_nonneg ( by unfold FejerHat; positivity ) ( Real.exp_nonneg _ ) );
    · exact Continuous.integrableOn_Icc ( by exact Continuous.mul ( by exact Continuous.max ( continuous_const ) ( by continuity ) ) ( Real.continuous_exp.comp ( by continuity ) ) );
    · norm_num [ Filter.EventuallyLE, Filter.eventually_inf_principal ];
      exact Filter.Eventually.of_forall fun x hx₁ hx₂ => mul_le_mul_of_nonneg_left ( Real.exp_le_exp.mpr <| by nlinarith [ show 0 ≤ 4 * Real.pi ^ 2 * t by positivity, show ( x - τ ) ^ 2 ≤ r ^ 2 by nlinarith ] ) ( by unfold FejerHat; positivity );
  -- Apply `core_shift_mass B r 0` to lower bound the integral.
  have h_core_shift_mass : (∫ x in Set.Icc (τ - r) (τ + r), FejerHat B (x - τ)) ≥ 2 * r^2 / B := by
    convert core_shift_mass B r 0 hB hr hrB ( by norm_num; linarith ) using 1;
    rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le ( by linarith ) ] ; unfold shifted_core_integral ; aesop;
    rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, intervalIntegral.integral_of_le ( by linarith ) ];
  exact le_trans ( mul_le_mul_of_nonneg_right h_core_shift_mass <| Real.exp_nonneg _ ) h_lower_bound