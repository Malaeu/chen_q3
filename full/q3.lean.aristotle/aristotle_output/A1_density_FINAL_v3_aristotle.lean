/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 50c17b17-d6be-429e-a15a-bd439b7e5573

Sorry, Aristotle crashed (error code: 9). Please try again.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions for HeatKernel, FejerKernel, Atom, W_K, AtomSet, diff_set, real_convolution, and AtomCone_K.
-/
open scoped BigOperators Real Nat Classical Pointwise

noncomputable def HeatKernel (t : ℝ) (x : ℝ) : ℝ :=
  (4 * Real.pi * t) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / (4 * t))

noncomputable def FejerKernel (B : ℝ) (x : ℝ) : ℝ := max 0 (1 - |x| / B)

noncomputable def Atom (B t τ : ℝ) (x : ℝ) : ℝ :=
  FejerKernel B (x - τ) * HeatKernel t (x - τ) +
  FejerKernel B (x + τ) * HeatKernel t (x + τ)

def W_K (K : ℝ) : Set (ℝ → ℝ) :=
  { f | ContinuousOn f (Set.Icc (-K) K) ∧ (∀ x, f (-x) = f x) ∧ (∀ x ∈ Set.Icc (-K) K, f x ≥ 0) }

def AtomSet (K : ℝ) : Set (ℝ → ℝ) :=
  { f | ∃ B t τ, B > 0 ∧ t > 0 ∧ τ ∈ Set.Icc (-K) K ∧ f = Atom B t τ }

def diff_set (Φ : ℝ → ℝ) (g : ℝ → ℝ) (K : ℝ) : Set ℝ :=
  (fun x ↦ |Φ x - g x|) '' Set.Icc (-K) K

noncomputable def real_convolution (f g : ℝ → ℝ) (x : ℝ) : ℝ := ∫ y, f y * g (x - y)

def AtomCone_K (K : ℝ) : Set (ℝ → ℝ) :=
  (Convex.toCone (convexHull ℝ (AtomSet K)) (convex_convexHull ℝ (AtomSet K)) : Set (ℝ → ℝ))

/-
Integral of HeatKernel is 1.
-/
lemma HeatKernel_integral (t : ℝ) (ht : t > 0) : ∫ x, HeatKernel t x = 1 := by
  -- The integral of the Gaussian function $e^{-x^2 / 4t}$ over the entire real line is $2\sqrt{\pi t}$.
  have h_gauss : ∫ x, Real.exp (-x^2 / (4 * t)) = 2 * Real.sqrt (Real.pi * t) := by
    convert integral_gaussian ( 1 / ( 4 * t ) ) using 1 <;> norm_num [ div_eq_inv_mul ] ; ring;
    norm_num [ mul_assoc, ht.le ];
  field_simp;
  unfold HeatKernel; rw [ MeasureTheory.integral_const_mul ] ; rw [ h_gauss ] ; ring ; norm_num [ ht.ne', ht.le ] ;
  rw [ Real.rpow_neg ( by positivity ) ];
  rw [ ← Real.sqrt_eq_rpow ] ; rw [ inv_mul_eq_div, div_mul_eq_mul_div, div_eq_iff ] <;> ring ; norm_num [ ht.le, Real.pi_pos.le ];
  positivity

/-
Mass concentration of HeatKernel.
-/
lemma HeatKernel_mass_concentration (δ : ℝ) (hδ : δ > 0) :
  Filter.Tendsto (fun t => ∫ x in {y | |y| > δ}, HeatKernel t x)
    (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
      -- We'll use the fact that the integral of the HeatKernel over the complement of a ball of radius δ tends to 0 as t tends to 0.
      have h_tendsto_zero : Filter.Tendsto (fun t => ∫ x in {y | |y| > δ}, (Real.exp (-x^2 / (4 * t))) / Real.sqrt (4 * Real.pi * t)) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
        -- Let's simplify the integral.
        suffices h_simp : Filter.Tendsto (fun t => ∫ x in Set.Ioi δ, (Real.exp (-x^2 / (4 * t))) / Real.sqrt (4 * Real.pi * t)) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) by
          -- Since the integral over the complement of the ball is twice the integral over the positive half-line, we can conclude.
          have h_double : ∀ t > 0, ∫ x in {y | |y| > δ}, (Real.exp (-x^2 / (4 * t))) / Real.sqrt (4 * Real.pi * t) = 2 * ∫ x in Set.Ioi δ, (Real.exp (-x^2 / (4 * t))) / Real.sqrt (4 * Real.pi * t) := by
            intros t ht
            have h_split : ∫ x in {y | |y| > δ}, (Real.exp (-x^2 / (4 * t))) / Real.sqrt (4 * Real.pi * t) = (∫ x in Set.Ioi δ, (Real.exp (-x^2 / (4 * t))) / Real.sqrt (4 * Real.pi * t)) + (∫ x in Set.Iio (-δ), (Real.exp (-x^2 / (4 * t))) / Real.sqrt (4 * Real.pi * t)) := by
              rw [ ← MeasureTheory.setIntegral_union ] <;> norm_num;
              · rcongr x ; aesop;
                · cases abs_cases x <;> [ left; right ] <;> norm_num <;> linarith;
                · cases a <;> cases abs_cases x <;> linarith [ Set.mem_Ioi.mp ‹_›, Set.mem_Iio.mp ‹_› ];
              · positivity;
              · -- The integral of the Gaussian function is finite.
                have h_gauss_integrable : MeasureTheory.IntegrableOn (fun x => Real.exp (-x^2 / (4 * t))) Set.univ := by
                  simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) );
                exact MeasureTheory.IntegrableOn.mono_set ( h_gauss_integrable.div_const _ ) ( Set.subset_univ _ );
              · -- The integral of the Gaussian function over the interval $(-\infty, -\delta)$ is finite.
                have h_gauss_integrable : MeasureTheory.IntegrableOn (fun x => Real.exp (-x^2 / (4 * t))) Set.univ := by
                  simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) );
                exact MeasureTheory.IntegrableOn.mono_set ( h_gauss_integrable.div_const _ ) ( Set.subset_univ _ );
            rw [ h_split, two_mul, ← MeasureTheory.integral_Iic_eq_integral_Iio ];
            rw [ ← neg_neg δ, ← integral_comp_neg_Iic ] ; norm_num;
          simpa using Filter.Tendsto.congr' ( Filter.eventuallyEq_of_mem self_mem_nhdsWithin fun t ht => by rw [ h_double t ht ] ) ( h_simp.const_mul 2 );
        -- We'll use the fact that the integral of $e^{-x^2 / (4t)}$ over $(\delta, \infty)$ is bounded above by $e^{-\delta^2 / (4t)}$.
        have h_bound : ∀ t > 0, ∫ x in Set.Ioi δ, Real.exp (-x^2 / (4 * t)) ≤ Real.exp (-δ^2 / (4 * t)) * ∫ x in Set.Ioi 0, Real.exp (-x^2 / (4 * t)) := by
          -- By substitution using $ y = x - \delta $, we can rewrite the integral.
          have h_subst : ∀ t > 0, ∫ x in Set.Ioi δ, Real.exp (-x^2 / (4 * t)) = ∫ y in Set.Ioi 0, Real.exp (-(y + δ)^2 / (4 * t)) := by
            intro t ht; rw [ ← MeasureTheory.integral_indicator ( measurableSet_Ioi ), ← MeasureTheory.integral_indicator ( measurableSet_Ioi ) ] ; rw [ ← MeasureTheory.integral_add_right_eq_self _ δ ] ; norm_num [ Set.indicator ] ;
          intro t ht; rw [ h_subst t ht, ← MeasureTheory.integral_const_mul ] ; refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
          · exact Filter.Eventually.of_forall fun x => Real.exp_nonneg _;
          · exact MeasureTheory.Integrable.const_mul ( by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) |> MeasureTheory.Integrable.integrableOn ) _;
          · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioi ] with x hx using by rw [ ← Real.exp_add ] ; exact Real.exp_le_exp.mpr ( by rw [ ← add_div, div_le_div_iff_of_pos_right ] <;> nlinarith [ hx.out ] ) ;
        -- We'll use the fact that the integral of $e^{-x^2 / (4t)}$ over $(0, \infty)$ is $\sqrt{4\pi t}$.
        have h_gauss : ∀ t > 0, ∫ x in Set.Ioi 0, Real.exp (-x^2 / (4 * t)) = Real.sqrt (4 * Real.pi * t) / 2 := by
          intro t ht; convert integral_gaussian_Ioi ( 1 / ( 4 * t ) ) using 1 <;> norm_num [ div_eq_inv_mul ] ; ring;
        -- Substitute the bound and the Gaussian integral result into our expression.
        have h_subst : ∀ t > 0, ∫ x in Set.Ioi δ, Real.exp (-x^2 / (4 * t)) / Real.sqrt (4 * Real.pi * t) ≤ Real.exp (-δ^2 / (4 * t)) / 2 := by
          intro t ht; rw [ MeasureTheory.integral_div ] ; rw [ div_le_iff₀ ( by positivity ) ] ; convert h_bound t ht using 1 ; rw [ h_gauss t ht ] ; ring;
        -- We'll use the fact that $\exp(-\delta^2 / (4t))$ tends to $0$ as $t$ tends to $0$.
        have h_exp_zero : Filter.Tendsto (fun t => Real.exp (-δ^2 / (4 * t))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
          norm_num [ div_eq_mul_inv ];
          exact Filter.Tendsto.const_mul_atTop ( by positivity ) ( Filter.Tendsto.atTop_mul_const ( by positivity ) ( tendsto_inv_nhdsGT_zero ) );
        refine' squeeze_zero_norm' _ ( by simpa using h_exp_zero.div_const 2 );
        filter_upwards [ self_mem_nhdsWithin ] with t ht using by rw [ Real.norm_of_nonneg ( MeasureTheory.integral_nonneg fun x => by positivity ) ] ; exact h_subst t ht;
      convert h_tendsto_zero using 1;
      unfold HeatKernel; ext; ring;
      norm_num [ Real.sqrt_eq_rpow, Real.rpow_neg_eq_inv_rpow ] ; congr ; ext ; ring;
      norm_num [ ← Real.sqrt_eq_rpow, mul_assoc, mul_comm, mul_left_comm ];
      rw [ ← Real.sqrt_inv ] ; ring

/-
HeatKernel is non-negative.
-/
lemma HeatKernel_nonneg (t : ℝ) (ht : t > 0) (x : ℝ) : 0 ≤ HeatKernel t x := by
  -- The exponential function is always positive, and the power of a positive number is also positive.
  apply mul_nonneg; apply Real.rpow_nonneg; positivity; apply Real.exp_nonneg

/-
Bounds for FejerKernel.
-/
lemma FejerKernel_bounds (B : ℝ) (hB : B > 0) (x : ℝ) :
  0 ≤ FejerKernel B x ∧ FejerKernel B x ≤ 1 := by
    -- By definition of FejerKernel, we know that it is non-negative and less than or equal to 1 because it is the maximum of 0 and (1 - |x|/B), and (1 - |x|/B) is less than or equal to 1.
    simp [FejerKernel];
    -- Since $|x| \geq 0$ and $B > 0$, their division is non-negative.
    apply div_nonneg; exact abs_nonneg x; exact hB.le

/-
Existence of a compact extension of a continuous function on a compact interval.
-/
lemma exists_compact_extension (K : ℝ) (hK : K > 0) (Φ : ℝ → ℝ)
    (hΦ_cont : ContinuousOn Φ (Set.Icc (-K) K)) :
  ∃ Ψ : ℝ → ℝ, Continuous Ψ ∧ HasCompactSupport Ψ ∧ ∀ x ∈ Set.Icc (-K) K, Ψ x = Φ x := by
    -- By the Tietze extension theorem, there exists a continuous function $\Psi$ on $\mathbb{R}$ such that $\Psi(x) = \Phi(x)$ for $x \in [-K, K]$.
    obtain ⟨Ψ, hΨ⟩ : ∃ Ψ : ℝ → ℝ, Continuous Ψ ∧ ∀ x ∈ Set.Icc (-K) K, Ψ x = Φ x := by
      have := @ContinuousMap.exists_restrict_eq;
      specialize this ( isClosed_Icc : IsClosed ( Set.Icc ( -K ) K ) ) ⟨ Φ ∘ Subtype.val, hΦ_cont.comp_continuous ( continuous_subtype_val ) fun x => x.2 ⟩;
      exact ⟨ this.choose, this.choose.continuous, fun x hx => by simpa using congr_arg ( fun f => f ⟨ x, hx ⟩ ) this.choose_spec ⟩;
    -- Let's choose a compactly supported function $\chi$ such that $\chi(x) = 1$ for $x \in [-K, K]$ and $\chi(x) = 0$ for $|x| > K + 1$.
    obtain ⟨χ, hχ⟩ : ∃ χ : ℝ → ℝ, Continuous χ ∧ (∀ x, |x| ≤ K → χ x = 1) ∧ (∀ x, |x| > K + 1 → χ x = 0) ∧ (∀ x, 0 ≤ χ x ∧ χ x ≤ 1) := by
      -- Define $\chi(x)$ as a smooth function that is 1 on $[-K, K]$ and 0 outside $[-K-1, K+1]$.
      use fun x => max 0 (min 1 (1 - (|x| - K)));
      aesop;
      · fun_prop;
      · exact Or.inr ( by linarith );
    refine' ⟨ fun x => Ψ x * χ x, _, _, _ ⟩ <;> aesop;
    · exact left.mul left_1;
    · rw [ hasCompactSupport_iff_eventuallyEq ];
      norm_num [ Filter.EventuallyEq ];
      exact ⟨ ⟨ -K - 2, fun x hx => Or.inr <| left_3 x <| by cases abs_cases x <;> linarith ⟩, ⟨ K + 2, fun x hx => Or.inr <| left_3 x <| by cases abs_cases x <;> linarith ⟩ ⟩;
    · rw [ left_3 x ( abs_le.mpr ⟨ by linarith, by linarith ⟩ ), mul_one ]

/-
HeatKernel is an approximate identity uniformly.
-/
lemma HeatKernel_approx_identity_uniform (f : ℝ → ℝ) (hf_cont : Continuous f)
    (hf_supp : HasCompactSupport f) (ε : ℝ) (hε : ε > 0) :
  ∃ t₀ > 0, ∀ t ∈ Set.Ioo 0 t₀, ∀ x, |real_convolution f (HeatKernel t) x - f x| < ε := by
    -- Since $f$ is continuous and compactly supported, it is bounded and uniformly continuous.
    obtain ⟨M, hM⟩ : ∃ M > 0, ∀ x, abs (f x) ≤ M := by
      obtain ⟨ M, hM ⟩ := hf_supp.exists_bound_of_continuous hf_cont; use Max.max M 1; aesop;
    obtain ⟨δ, hδ_pos, hδ⟩ : ∃ δ > 0, ∀ x y, abs (x - y) < δ → abs (f x - f y) < ε / 4 := by
      have h_unif_cont : UniformContinuous f := by
        exact?;
      exact Metric.uniformContinuous_iff.mp h_unif_cont ( ε / 4 ) ( by linarith );
    -- Since $f$ is bounded and uniformly continuous, we can find $t_0 > 0$ such that for all $t \in (0, t_0)$, $\int_{|y| \geq \delta} \text{HeatKernel}(t, y) \, dy < \frac{\epsilon}{4M}$.
    obtain ⟨t₀, ht₀_pos, ht₀⟩ : ∃ t₀ > 0, ∀ t ∈ Set.Ioo 0 t₀, ∫ y in {y | abs y ≥ δ}, HeatKernel t y < ε / (4 * M) := by
      have h_mass_concentration : Filter.Tendsto (fun t => ∫ y in {y | abs y ≥ δ}, HeatKernel t y) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
        have := HeatKernel_mass_concentration δ hδ_pos;
        convert this using 1;
        ext t; rw [ MeasureTheory.setIntegral_congr_set ] ; aesop;
        rw [ MeasureTheory.ae_eq_set ];
        constructor <;> rw [ MeasureTheory.measure_eq_zero_iff_ae_notMem ] <;> aesop;
        · filter_upwards [ MeasureTheory.measure_eq_zero_iff_ae_notMem.mp ( MeasureTheory.measure_singleton δ ), MeasureTheory.measure_eq_zero_iff_ae_notMem.mp ( MeasureTheory.measure_singleton ( -δ ) ) ] with x hx₁ hx₂ using fun hx₃ => lt_of_le_of_ne hx₃ <| by cases abs_cases x <;> cases lt_or_gt_of_ne hx₁ <;> cases lt_or_gt_of_ne hx₂ <;> linarith;
        · exact Filter.Eventually.of_forall fun x hx => le_of_lt hx;
      have := Metric.tendsto_nhdsWithin_nhds.mp h_mass_concentration ( ε / ( 4 * M ) ) ( by exact div_pos hε ( mul_pos zero_lt_four hM.1 ) ) ; aesop;
      exact ⟨ w, left_1, fun t ht ht' => lt_of_le_of_lt ( le_abs_self _ ) ( right_1 ht ( abs_lt.mpr ⟨ by linarith, by linarith ⟩ ) ) ⟩;
    use t₀, ht₀_pos;
    intro t ht x
    have h_conv_bound : abs (real_convolution f (HeatKernel t) x - f x) ≤ ∫ y, abs (f (x - y) - f x) * HeatKernel t y := by
      have h_conv_bound : abs (real_convolution f (HeatKernel t) x - f x) ≤ ∫ y, abs (f (x - y) - f x) * HeatKernel t y := by
        have h_conv_eq : real_convolution f (HeatKernel t) x = ∫ y, f (x - y) * HeatKernel t y := by
          rw [ ← MeasureTheory.integral_sub_left_eq_self ] ; congr ; ext ; ring
        have h_conv_bound : abs (real_convolution f (HeatKernel t) x - f x) = abs (∫ y, (f (x - y) - f x) * HeatKernel t y) := by
          simp_all +decide [ sub_mul ];
          rw [ MeasureTheory.integral_sub ];
          · simp +decide [ MeasureTheory.integral_const_mul, HeatKernel_integral t ht.1 ];
          · refine' MeasureTheory.Integrable.mono' _ _ _;
            refine' fun y => M * HeatKernel t y;
            · refine' MeasureTheory.Integrable.const_mul _ _;
              have := HeatKernel_integral t ht.1;
              exact MeasureTheory.integrable_of_integral_eq_one this;
            · exact MeasureTheory.AEStronglyMeasurable.mul ( Continuous.aestronglyMeasurable ( hf_cont.comp ( continuous_const.sub continuous_id' ) ) ) ( Continuous.aestronglyMeasurable ( show Continuous fun y => HeatKernel t y from by exact Continuous.mul ( continuous_const ) ( Real.continuous_exp.comp ( by exact Continuous.div_const ( by continuity ) _ ) ) ) );
            · filter_upwards [ ] with y using by rw [ Real.norm_eq_abs, abs_mul, abs_of_nonneg ( show 0 ≤ HeatKernel t y from by exact mul_nonneg ( Real.rpow_nonneg ( by nlinarith [ Real.pi_pos ] ) _ ) ( Real.exp_nonneg _ ) ) ] ; exact mul_le_mul_of_nonneg_right ( hM.2 _ ) ( show 0 ≤ HeatKernel t y from by exact mul_nonneg ( Real.rpow_nonneg ( by nlinarith [ Real.pi_pos ] ) _ ) ( Real.exp_nonneg _ ) ) ;
          · refine' MeasureTheory.Integrable.const_mul _ _;
            have := HeatKernel_integral t ht.1;
            exact MeasureTheory.integrable_of_integral_eq_one this;
        convert MeasureTheory.norm_integral_le_integral_norm ( fun y => ( f ( x - y ) - f x ) * HeatKernel t y ) using 1;
        norm_num [ abs_mul, abs_of_nonneg ( show 0 ≤ HeatKernel t _ from by exact le_of_lt ( by exact mul_pos ( Real.rpow_pos_of_pos ( mul_pos ( mul_pos zero_lt_four Real.pi_pos ) ht.1 ) _ ) ( Real.exp_pos _ ) ) ) ];
      exact h_conv_bound;
    -- Split the integral into two parts: one over $|y| < \delta$ and one over $|y| \geq \delta$.
    have h_split_integral : ∫ y, abs (f (x - y) - f x) * HeatKernel t y ≤ (∫ y in {y | abs y < δ}, abs (f (x - y) - f x) * HeatKernel t y) + (∫ y in {y | abs y ≥ δ}, abs (f (x - y) - f x) * HeatKernel t y) := by
      rw [ ← MeasureTheory.setIntegral_union ] <;> norm_num;
      · rw [ MeasureTheory.setIntegral_eq_integral_of_forall_compl_eq_zero ] ; aesop;
        linarith;
      · exact Set.disjoint_left.mpr fun y hy₁ hy₂ => hy₁.out.not_le hy₂.out;
      · exact measurableSet_Ici.mem.comp measurable_norm;
      · refine' MeasureTheory.Integrable.integrableOn _;
        refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun y => 2 * M * HeatKernel t y;
        · refine' MeasureTheory.Integrable.const_mul _ _;
          exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht.1 );
        · exact MeasureTheory.AEStronglyMeasurable.mul ( Continuous.aestronglyMeasurable ( by continuity ) ) ( Continuous.aestronglyMeasurable ( by exact Continuous.mul ( continuous_const ) ( Real.continuous_exp.comp ( by continuity ) ) ) );
        · filter_upwards [ ] with y using by rw [ Real.norm_of_nonneg ( mul_nonneg ( abs_nonneg _ ) ( show 0 ≤ HeatKernel t y from by exact mul_nonneg ( Real.rpow_nonneg ( mul_nonneg ( mul_nonneg zero_le_four Real.pi_pos.le ) ht.1.le ) _ ) ( Real.exp_nonneg _ ) ) ) ] ; exact mul_le_mul_of_nonneg_right ( abs_le.mpr ⟨ by linarith [ abs_le.mp ( hM.2 ( x - y ) ), abs_le.mp ( hM.2 x ) ], by linarith [ abs_le.mp ( hM.2 ( x - y ) ), abs_le.mp ( hM.2 x ) ] ⟩ ) ( show 0 ≤ HeatKernel t y from by exact mul_nonneg ( Real.rpow_nonneg ( mul_nonneg ( mul_nonneg zero_le_four Real.pi_pos.le ) ht.1.le ) _ ) ( Real.exp_nonneg _ ) ) ;
      · refine' MeasureTheory.Integrable.integrableOn _;
        refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun y => 2 * M * HeatKernel t y;
        · refine' MeasureTheory.Integrable.const_mul _ _;
          exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht.1 );
        · exact MeasureTheory.AEStronglyMeasurable.mul ( Continuous.aestronglyMeasurable ( by continuity ) ) ( Continuous.aestronglyMeasurable ( by exact Continuous.mul ( continuous_const ) ( Real.continuous_exp.comp ( by continuity ) ) ) );
        · filter_upwards [ ] with y using by rw [ Real.norm_of_nonneg ( mul_nonneg ( abs_nonneg _ ) ( show 0 ≤ HeatKernel t y from by exact mul_nonneg ( Real.rpow_nonneg ( mul_nonneg ( mul_nonneg zero_le_four Real.pi_pos.le ) ht.1.le ) _ ) ( Real.exp_nonneg _ ) ) ) ] ; exact mul_le_mul_of_nonneg_right ( abs_le.mpr ⟨ by linarith [ abs_le.mp ( hM.2 ( x - y ) ), abs_le.mp ( hM.2 x ) ], by linarith [ abs_le.mp ( hM.2 ( x - y ) ), abs_le.mp ( hM.2 x ) ] ⟩ ) ( show 0 ≤ HeatKernel t y from by exact mul_nonneg ( Real.rpow_nonneg ( mul_nonneg ( mul_nonneg zero_le_four Real.pi_pos.le ) ht.1.le ) _ ) ( Real.exp_nonneg _ ) ) ;
    -- Apply the bounds from hδ and ht₀ to each part of the split integral.
    have h_first_part : ∫ y in {y | abs y < δ}, abs (f (x - y) - f x) * HeatKernel t y ≤ (ε / 4) * ∫ y, HeatKernel t y := by
      rw [ ← MeasureTheory.integral_const_mul ];
      refine' le_trans ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _;
      use fun y => ε / 4 * HeatKernel t y;
      · filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_lt ( continuous_abs.measurable ) measurable_const ] with y hy using mul_nonneg ( abs_nonneg _ ) ( HeatKernel_nonneg t ht.1 y );
      · refine' MeasureTheory.Integrable.const_mul _ _;
        refine' MeasureTheory.Integrable.integrableOn _;
        have := HeatKernel_integral t ht.1;
        exact MeasureTheory.integrable_of_integral_eq_one this;
      · filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_lt measurable_norm measurable_const ] with y hy using mul_le_mul_of_nonneg_right ( le_of_lt <| hδ _ _ <| by simpa using hy ) <| by exact le_of_lt <| by exact ( show 0 < HeatKernel t y from by exact mul_pos ( Real.rpow_pos_of_pos ( by nlinarith [ ht.1, Real.pi_pos ] ) _ ) <| Real.exp_pos _ ) ;
      · refine' MeasureTheory.setIntegral_le_integral _ _;
        · refine' MeasureTheory.Integrable.const_mul _ _;
          exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht.1 );
        · exact Filter.Eventually.of_forall fun y => mul_nonneg ( by positivity ) ( by exact ( show 0 ≤ HeatKernel t y from by exact ( show 0 ≤ ( 4 * Real.pi * t ) ^ ( - ( 1 : ℝ ) / 2 ) * Real.exp ( -y ^ 2 / ( 4 * t ) ) from mul_nonneg ( Real.rpow_nonneg ( by nlinarith [ Real.pi_pos, ht.1 ] ) _ ) ( Real.exp_nonneg _ ) ) ) )
    have h_second_part : ∫ y in {y | abs y ≥ δ}, abs (f (x - y) - f x) * HeatKernel t y ≤ (2 * M) * ∫ y in {y | abs y ≥ δ}, HeatKernel t y := by
      rw [ ← MeasureTheory.integral_const_mul ];
      refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
      · filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_le measurable_const <| measurable_norm ] with y hy using mul_nonneg ( abs_nonneg _ ) <| le_of_lt <| show 0 < HeatKernel t y from by exact mul_pos ( Real.rpow_pos_of_pos ( mul_pos ( mul_pos zero_lt_four <| Real.pi_pos ) ht.1 ) _ ) <| Real.exp_pos _;
      · refine' MeasureTheory.Integrable.const_mul _ _;
        refine' MeasureTheory.Integrable.integrableOn _;
        exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht.1 );
      · filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_le measurable_const measurable_norm ] with y hy using mul_le_mul_of_nonneg_right ( abs_sub_le_iff.mpr ⟨ by linarith [ abs_le.mp ( hM.2 ( x - y ) ), abs_le.mp ( hM.2 x ) ], by linarith [ abs_le.mp ( hM.2 ( x - y ) ), abs_le.mp ( hM.2 x ) ] ⟩ ) <| HeatKernel_nonneg t ht.1 y;
    have h_integral_bound : ∫ y, HeatKernel t y = 1 := by
      convert HeatKernel_integral t ht.1 using 1;
    nlinarith [ ht₀ t ht, mul_div_cancel₀ ε ( by linarith : ( 4 * M ) ≠ 0 ) ]

/-
Approximation of a sum of atoms using FejerKernel.
-/
lemma fejer_sum_approx (K : ℝ) (hK : K > 0) (t : ℝ) (ht : t > 0) (s : Finset ℝ)
    (w : ℝ → ℝ) (hw_nonneg : ∀ y ∈ s, 0 ≤ w y) (hs_subset : ∀ y ∈ s, y ∈ Set.Icc (-K) K)
    (ε : ℝ) (hε : ε > 0) :
  ∃ B > 0, ∀ x ∈ Set.Icc (-K) K,
    |∑ y ∈ s, w y * Atom B t y x - (∑ y ∈ s, w y * HeatKernel t (x - y) +
      ∑ y ∈ s, w y * HeatKernel t (x + y))| < ε := by
        -- By definition of $Atom$, we can write:
        have h_atom : ∀ B > 0, ∀ x ∈ Set.Icc (-K) K, ∑ y ∈ s, w y * Atom B t y x =
                      ∑ y ∈ s, w y * FejerKernel B (x - y) * HeatKernel t (x - y) +
                      ∑ y ∈ s, w y * FejerKernel B (x + y) * HeatKernel t (x + y) := by
                        intro B hB x hx; rw [ ← Finset.sum_add_distrib ] ; congr ; ext y ; unfold Atom ; ring;
        -- Since $FejerKernel B (x - y)$ and $FejerKernel B (x + y)$ are bounded by 1, we can choose $B$ large enough such that the difference between the sums is less than $\epsilon$.
        have h_bounded : ∀ B > 0, ∀ x ∈ Set.Icc (-K) K, |∑ y ∈ s, w y * FejerKernel B (x - y) * HeatKernel t (x - y) - ∑ y ∈ s, w y * HeatKernel t (x - y)| ≤ ∑ y ∈ s, w y * |FejerKernel B (x - y) - 1| * HeatKernel t (x - y) ∧ |∑ y ∈ s, w y * FejerKernel B (x + y) * HeatKernel t (x + y) - ∑ y ∈ s, w y * HeatKernel t (x + y)| ≤ ∑ y ∈ s, w y * |FejerKernel B (x + y) - 1| * HeatKernel t (x + y) := by
          intros B hB x hx
          have h_bounded : ∀ y ∈ s, |w y * FejerKernel B (x - y) * HeatKernel t (x - y) - w y * HeatKernel t (x - y)| ≤ w y * |FejerKernel B (x - y) - 1| * HeatKernel t (x - y) ∧ |w y * FejerKernel B (x + y) * HeatKernel t (x + y) - w y * HeatKernel t (x + y)| ≤ w y * |FejerKernel B (x + y) - 1| * HeatKernel t (x + y) := by
            intro y hy; constructor <;> rw [ abs_le ] <;> constructor <;> cases abs_cases ( FejerKernel B ( x - y ) - 1 ) <;> cases abs_cases ( FejerKernel B ( x + y ) - 1 ) <;> nlinarith [ hw_nonneg y hy, show 0 ≤ w y * HeatKernel t ( x - y ) by exact mul_nonneg ( hw_nonneg y hy ) ( HeatKernel_nonneg t ht _ ), show 0 ≤ w y * HeatKernel t ( x + y ) by exact mul_nonneg ( hw_nonneg y hy ) ( HeatKernel_nonneg t ht _ ) ] ;
          exact ⟨ by simpa only [ ← Finset.sum_sub_distrib ] using Finset.abs_sum_le_sum_abs _ _ |> le_trans <| Finset.sum_le_sum fun y hy => h_bounded y hy |>.1, by simpa only [ ← Finset.sum_sub_distrib ] using Finset.abs_sum_le_sum_abs _ _ |> le_trans <| Finset.sum_le_sum fun y hy => h_bounded y hy |>.2 ⟩;
        -- Since $|FejerKernel B (x - y) - 1| \leq \frac{|x - y|}{B}$ and $|FejerKernel B (x + y) - 1| \leq \frac{|x + y|}{B}$, we can choose $B$ large enough such that the sums are less than $\epsilon$.
        have h_small : ∀ B > 0, ∀ x ∈ Set.Icc (-K) K, ∑ y ∈ s, w y * |FejerKernel B (x - y) - 1| * HeatKernel t (x - y) ≤ ∑ y ∈ s, w y * (|x - y| / B) * HeatKernel t (x - y) ∧ ∑ y ∈ s, w y * |FejerKernel B (x + y) - 1| * HeatKernel t (x + y) ≤ ∑ y ∈ s, w y * (|x + y| / B) * HeatKernel t (x + y) := by
          intros B hB x hx
          have h_abs : ∀ y ∈ s, |FejerKernel B (x - y) - 1| ≤ |x - y| / B ∧ |FejerKernel B (x + y) - 1| ≤ |x + y| / B := by
            unfold FejerKernel;
            intro y hy; constructor <;> rw [ abs_le ] <;> constructor <;> cases max_cases ( 0 : ℝ ) ( 1 - |x - y| / B ) <;> cases max_cases ( 0 : ℝ ) ( 1 - |x + y| / B ) <;> nlinarith [ abs_nonneg ( x - y ), abs_nonneg ( x + y ), div_mul_cancel₀ ( |x - y| ) hB.ne', div_mul_cancel₀ ( |x + y| ) hB.ne' ] ;
          exact ⟨ Finset.sum_le_sum fun y hy => mul_le_mul_of_nonneg_right ( mul_le_mul_of_nonneg_left ( h_abs y hy |>.1 ) ( hw_nonneg y hy ) ) ( by exact ( show 0 ≤ HeatKernel t ( x - y ) from by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ), Finset.sum_le_sum fun y hy => mul_le_mul_of_nonneg_right ( mul_le_mul_of_nonneg_left ( h_abs y hy |>.2 ) ( hw_nonneg y hy ) ) ( by exact ( show 0 ≤ HeatKernel t ( x + y ) from by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ) ⟩;
        -- Since $|x - y| \leq 2K$ and $|x + y| \leq 2K$ for all $x, y \in [-K, K]$, we can further bound the sums.
        have h_bound : ∀ B > 0, ∀ x ∈ Set.Icc (-K) K, ∑ y ∈ s, w y * (|x - y| / B) * HeatKernel t (x - y) ≤ (2 * K / B) * ∑ y ∈ s, w y * HeatKernel t (x - y) ∧ ∑ y ∈ s, w y * (|x + y| / B) * HeatKernel t (x + y) ≤ (2 * K / B) * ∑ y ∈ s, w y * HeatKernel t (x + y) := by
          intros B hB x hx
          have h_bound : ∀ y ∈ s, |x - y| ≤ 2 * K ∧ |x + y| ≤ 2 * K := by
            exact fun y hy => ⟨ abs_le.mpr ⟨ by linarith [ hx.1, hx.2, hs_subset y hy |>.1, hs_subset y hy |>.2 ], by linarith [ hx.1, hx.2, hs_subset y hy |>.1, hs_subset y hy |>.2 ] ⟩, abs_le.mpr ⟨ by linarith [ hx.1, hx.2, hs_subset y hy |>.1, hs_subset y hy |>.2 ], by linarith [ hx.1, hx.2, hs_subset y hy |>.1, hs_subset y hy |>.2 ] ⟩ ⟩;
          simp_all +decide [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _ ];
          exact ⟨ Finset.sum_le_sum fun y hy => by nlinarith [ h_bound y hy, show 0 ≤ w y * ( HeatKernel t ( x - y ) * B⁻¹ ) by exact mul_nonneg ( hw_nonneg y hy ) ( mul_nonneg ( by exact ( show 0 ≤ HeatKernel t ( x - y ) by exact ( by unfold HeatKernel; positivity ) ) ) ( inv_nonneg.2 hB.le ) ) ], Finset.sum_le_sum fun y hy => by nlinarith [ h_bound y hy, show 0 ≤ w y * ( HeatKernel t ( x + y ) * B⁻¹ ) by exact mul_nonneg ( hw_nonneg y hy ) ( mul_nonneg ( by exact ( show 0 ≤ HeatKernel t ( x + y ) by exact ( by unfold HeatKernel; positivity ) ) ) ( inv_nonneg.2 hB.le ) ) ] ⟩;
        -- Choose $B$ large enough such that $(2 * K / B) * (∑ y ∈ s, w y * HeatKernel t (x - y) + ∑ y ∈ s, w y * HeatKernel t (x + y)) < ε / 2$.
        obtain ⟨B, hB_pos, hB_small⟩ : ∃ B > 0, ∀ x ∈ Set.Icc (-K) K, (2 * K / B) * (∑ y ∈ s, w y * HeatKernel t (x - y) + ∑ y ∈ s, w y * HeatKernel t (x + y)) < ε / 2 := by
          -- Since the sums $\sum_{y \in s} w_y \HeatKernel t (x - y)$ and $\sum_{y \in s} w_y \HeatKernel t (x + y)$ are bounded, we can choose $B$ large enough such that $(2 * K / B) * (\sum_{y \in s} w_y \HeatKernel t (x - y) + \sum_{y \in s} w_y \HeatKernel t (x + y)) < \epsilon / 2$.
          have h_bounded_sums : ∃ M > 0, ∀ x ∈ Set.Icc (-K) K, (∑ y ∈ s, w y * HeatKernel t (x - y) + ∑ y ∈ s, w y * HeatKernel t (x + y)) ≤ M := by
            have h_bounded_sums : ContinuousOn (fun x => ∑ y ∈ s, w y * HeatKernel t (x - y) + ∑ y ∈ s, w y * HeatKernel t (x + y)) (Set.Icc (-K) K) := by
              refine' ContinuousOn.add _ _;
              · refine' continuousOn_finset_sum _ fun y hy => ContinuousOn.mul _ _;
                · exact continuousOn_const;
                · refine' ContinuousOn.mul _ _;
                  · exact continuousOn_const;
                  · fun_prop;
              · refine' ContinuousOn.congr _ _;
                use fun x => ∑ y ∈ s, w y * ( 4 * Real.pi * t ) ^ ( - ( 1 : ℝ ) / 2 ) * Real.exp ( - ( x + y ) ^ 2 / ( 4 * t ) );
                · fun_prop;
                · intro x hx; simp +decide [ mul_assoc, HeatKernel ] ;
            obtain ⟨ M, hM ⟩ := IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) h_bounded_sums;
            exact ⟨ Max.max M 1, by positivity, fun x hx => le_trans ( le_abs_self _ ) ( le_trans ( hM x hx ) ( le_max_left _ _ ) ) ⟩;
          obtain ⟨ M, hM_pos, hM ⟩ := h_bounded_sums;
          exact ⟨ 2 * K * M / ( ε / 2 ) + 1, by positivity, fun x hx => by rw [ div_mul_eq_mul_div, div_lt_iff₀ ] <;> nlinarith [ hM x hx, mul_div_cancel₀ ( 2 * K * M ) ( by positivity : ( ε / 2 ) ≠ 0 ), mul_pos hK hM_pos ] ⟩;
        use B, hB_pos;
        intro x hx; rw [ h_atom B hB_pos x hx ] ; rw [ abs_lt ] ; constructor <;> linarith [ abs_le.mp ( h_bounded B hB_pos x hx |>.1 ), abs_le.mp ( h_bounded B hB_pos x hx |>.2 ), h_small B hB_pos x hx, h_bound B hB_pos x hx, hB_small x hx ] ;

/-
A sum of atoms with positive weights is in the AtomCone.
-/
lemma sum_atoms_in_cone (K : ℝ) (s : Finset ℝ) (w : ℝ → ℝ) (hw : ∀ y ∈ s, 0 ≤ w y)
    (B : ℝ) (hB : B > 0) (t : ℝ) (ht : t > 0) (hs : ∀ y ∈ s, y ∈ Set.Icc (-K) K)
    (h_sum_pos : ∑ y ∈ s, w y > 0) :
  (fun x => ∑ y ∈ s, w y * Atom B t y x) ∈ AtomCone_K K := by
    norm_num +zetaDelta at *;
    unfold AtomCone_K;
    refine' ⟨ _, _ ⟩;
    exact ( ⋃ ( _ : 0 < ∑ y ∈ s, w y ), ( ∑ y ∈ s, w y ) • ( convexHull ℝ ( AtomSet K ) ) );
    aesop;
    · exact ⟨ _, by aesop ⟩;
    · -- Since each term $w y * Atom B t y x$ is in the convex hull of $AtomSet K$, their sum is also in the convex hull.
      have h_sum_in_convex_hull : ∑ y ∈ s, (w y / ∑ y ∈ s, w y) • Atom B t y ∈ convexHull ℝ (AtomSet K) := by
        rw [ convexHull_eq ];
        refine' ⟨ _, s, fun y => w y / ∑ y ∈ s, w y, fun y => Atom B t y, _, _, _, _ ⟩ <;> simp_all +decide [ Finset.centerMass ];
        · exact fun y hy => div_nonneg ( hw y hy ) h_sum_pos.le;
        · rw [ ← Finset.sum_div, div_self h_sum_pos.ne' ];
        · exact fun y hy => ⟨ B, t, y, hB, ht, hs y hy, rfl ⟩;
        · rw [ ← Finset.sum_div _ _ _, div_self h_sum_pos.ne', inv_one, one_smul ];
      refine' ⟨ _, h_sum_in_convex_hull, _ ⟩;
      ext; simp +decide [ div_eq_inv_mul, mul_assoc, mul_left_comm, Finset.mul_sum _ _ _, h_sum_pos.ne' ] ;

/-
Existence of an even compact extension of an even continuous function on a compact interval.
-/
lemma exists_even_compact_extension (K : ℝ) (hK : K > 0) (Φ : ℝ → ℝ)
    (hΦ_cont : ContinuousOn Φ (Set.Icc (-K) K)) (hΦ_even : Even Φ) :
  ∃ Ψ : ℝ → ℝ, Continuous Ψ ∧ HasCompactSupport Ψ ∧ Even Ψ ∧ ∀ x ∈ Set.Icc (-K) K, Ψ x = Φ x := by
    cases' hΦ_even with Ψ hΨ;
    simp_all +decide [ Even ];
    -- Apply the existence of a compact extension to Ψ.
    obtain ⟨Ψ_ext, hΨ_ext_cont, hΨ_ext_compact, hΨ_ext_eq⟩ : ∃ Ψ_ext : ℝ → ℝ, Continuous Ψ_ext ∧ HasCompactSupport Ψ_ext ∧ ∀ x ∈ Set.Icc (-K) K, Ψ_ext x = Ψ x := by
      apply exists_compact_extension K hK Ψ;
      convert hΦ_cont.div_const 2 using 1 ; ext ; ring;
      norm_num ; ring;
    refine' ⟨ fun x => Ψ_ext x + Ψ_ext x, _, _, _, _ ⟩ <;> aesop;
    · exact hΨ_ext_cont.add hΨ_ext_cont;
    · simp_all +decide [ hasCompactSupport_iff_eventuallyEq, Filter.EventuallyEq ]

/-
HeatKernel is an even function.
-/
lemma HeatKernel_even (t : ℝ) : Even (HeatKernel t) := by
  constructor;
  swap;
  exact fun x => ( 1 / 2 : ℝ ) * HeatKernel t x;
  ext; norm_num; ring

/-
Convolution of two even functions is even.
-/
lemma even_convolution (f g : ℝ → ℝ) (hf : Even f) (hg : Even g) : Even (real_convolution f g) := by
  obtain ⟨ f', hf' ⟩ := hf; obtain ⟨ g', hg' ⟩ := hg; unfold Even at *; aesop;
  unfold real_convolution; simp +decide [ add_mul, mul_add, mul_comm ];
  exact ⟨ fun x => ∫ y, f' y * g' ( x - y ) + f' y * g' ( x - y ), by ext; simp +decide [ ← two_mul, mul_assoc, MeasureTheory.integral_const_mul ] ⟩

/-
Uniform Riemann sum approximation for a parameterized integral.
-/
lemma uniform_riemann_sum (a b : ℝ) (hab : a < b) (X : Set ℝ) (hX : IsCompact X)
    (F : ℝ → ℝ → ℝ) (hF : ContinuousOn (Function.uncurry F) (X ×ˢ Set.Icc a b))
    (ε : ℝ) (hε : ε > 0) :
  ∃ (s : Finset ℝ) (w : ℝ → ℝ), (∀ y ∈ s, w y > 0) ∧ (∀ y ∈ s, y ∈ Set.Icc a b) ∧
  ∀ x ∈ X, |(∫ y in Set.Icc a b, F x y) - ∑ y ∈ s, w y * F x y| < ε := by
    -- Fix an arbitrary $\delta > 0$.
    obtain ⟨δ, hδ_pos, hδ⟩ : ∃ δ > 0, ∀ x ∈ X, ∀ y ∈ Set.Icc a b, ∀ y' ∈ Set.Icc a b, |y - y'| < δ → |F x y - F x y'| < ε / (2 * (b - a)) := by
      have h_unif_cont : UniformContinuousOn (Function.uncurry F) (X ×ˢ Set.Icc a b) := by
        apply_rules [ IsCompact.uniformContinuousOn_of_continuous, hX ];
        exact hX.prod CompactIccSpace.isCompact_Icc;
      rcases Metric.uniformContinuousOn_iff.mp h_unif_cont ( ε / ( 2 * ( b - a ) ) ) ( div_pos hε <| mul_pos zero_lt_two <| sub_pos.mpr hab ) with ⟨ δ, δ_pos, hδ ⟩ ; use δ ; aesop;
    -- Choose a partition of [a, b] with subintervals of length less than δ.
    obtain ⟨n, hn⟩ : ∃ n : ℕ, n > 0 ∧ (b - a) / n < δ := by
      exact ⟨ ⌊ ( b - a ) / δ⌋₊ + 1, Nat.succ_pos _, by rw [ div_lt_iff₀ ] <;> push_cast <;> nlinarith [ Nat.lt_floor_add_one ( ( b - a ) / δ ), mul_div_cancel₀ ( b - a ) hδ_pos.ne' ] ⟩;
    refine' ⟨ Finset.image ( fun i : ℕ => a + ( i : ℝ ) * ( b - a ) / n ) ( Finset.range n ), fun y => ( b - a ) / n, _, _, _ ⟩ <;> aesop;
    · exact div_nonneg ( mul_nonneg ( Nat.cast_nonneg _ ) ( sub_nonneg.mpr hab.le ) ) ( Nat.cast_nonneg _ );
    · rw [ add_div', div_le_iff₀ ] <;> nlinarith [ show ( w : ℝ ) + 1 ≤ n by norm_cast ];
    · -- By the properties of the Riemann sum and the uniform continuity of $F$, we can bound the difference.
      have h_bound : |(∫ y in Set.Icc a b, F x y) - ∑ i ∈ Finset.range n, (b - a) / n * F x (a + i * (b - a) / n)| ≤ ∑ i ∈ Finset.range n, ∫ y in (a + i * (b - a) / n).. (a + (i + 1) * (b - a) / n), |F x y - F x (a + i * (b - a) / n)| := by
        have h_bound : ∫ y in Set.Icc a b, F x y = ∑ i ∈ Finset.range n, ∫ y in (a + i * (b - a) / n).. (a + (i + 1) * (b - a) / n), F x y := by
          rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le hab.le ];
          symm;
          convert intervalIntegral.sum_integral_adjacent_intervals _ <;> norm_num [ left.ne' ];
          intro k hk; apply_rules [ ContinuousOn.intervalIntegrable ];
          refine' hF.comp ( continuousOn_const.prodMk continuousOn_id ) fun y hy => _;
          aesop;
          · cases Set.mem_uIcc.mp hy <;> nlinarith [ show ( k : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( k : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( k : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ];
          · cases Set.mem_uIcc.mp hy <;> nlinarith [ show ( k : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( k : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( k : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ];
        rw [ h_bound, ← Finset.sum_sub_distrib ];
        refine' le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( Finset.sum_le_sum _ );
        intro i hi; rw [ intervalIntegral.integral_of_le ( by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], div_mul_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), div_mul_cancel₀ ( ( ( i : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ] ; rw [ intervalIntegral.integral_of_le ( by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], div_mul_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), div_mul_cancel₀ ( ( ( i : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ] ;
        convert MeasureTheory.norm_integral_le_integral_norm ( fun y => F x y - F x ( a + i * ( b - a ) / n ) ) using 1 ; norm_num [ mul_comm, add_mul, div_eq_mul_inv ];
        rw [ MeasureTheory.integral_sub ] <;> norm_num;
        · rw [ max_eq_left ( by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], inv_mul_cancel_left₀ ( by positivity : ( n : ℝ ) ≠ 0 ) ( b - a ) ] ) ] ; ring;
        · have h_cont : ContinuousOn (fun y => F x y) (Set.Icc a b) := by
            exact hF.comp ( continuousOn_const.prodMk continuousOn_id ) fun y hy => ⟨ a_1, hy ⟩;
          exact ContinuousOn.integrableOn_Icc ( h_cont.mono <| Set.Icc_subset_Icc ( by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], inv_mul_cancel_left₀ ( by positivity : ( n : ℝ ) ≠ 0 ) ( b - a ) ] ) ( by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], inv_mul_cancel_left₀ ( by positivity : ( n : ℝ ) ≠ 0 ) ( b - a ) ] ) ) |> fun h => h.mono_set <| Set.Ioc_subset_Icc_self;
      -- By the properties of the Riemann sum and the uniform continuity of $F$, we can bound each term in the sum.
      have h_term_bound : ∀ i ∈ Finset.range n, ∫ y in (a + i * (b - a) / n).. (a + (i + 1) * (b - a) / n), |F x y - F x (a + i * (b - a) / n)| ≤ (b - a) / n * (ε / (2 * (b - a))) := by
        intros i hi
        have h_term_bound : ∀ y ∈ Set.Icc (a + i * (b - a) / n) (a + (i + 1) * (b - a) / n), |F x y - F x (a + i * (b - a) / n)| ≤ ε / (2 * (b - a)) := by
          intros y hy
          have h_dist : |y - (a + i * (b - a) / n)| ≤ (b - a) / n := by
            exact abs_le.mpr ⟨ by ring_nf at *; linarith [ hy.1, hy.2 ], by ring_nf at *; linarith [ hy.1, hy.2 ] ⟩;
          exact le_of_lt ( hδ x a_1 y ( by nlinarith [ hy.1, hy.2, show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], mul_div_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ( by nlinarith [ hy.1, hy.2, show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], mul_div_cancel₀ ( ( i + 1 : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ( a + i * ( b - a ) / n ) ( by nlinarith [ hy.1, hy.2, show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], mul_div_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ( by nlinarith [ hy.1, hy.2, show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], mul_div_cancel₀ ( ( i + 1 : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ( lt_of_le_of_lt h_dist right ) );
        convert intervalIntegral.integral_mono_on _ _ _ h_term_bound <;> norm_num;
        · ring;
        · bound;
        · apply_rules [ ContinuousOn.intervalIntegrable ];
          refine' ContinuousOn.abs ( ContinuousOn.sub _ continuousOn_const );
          refine' hF.comp ( continuousOn_const.prodMk continuousOn_id ) fun y hy => _;
          simp +zetaDelta at *;
          exact ⟨ a_1, by cases Set.mem_uIcc.mp hy <;> nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( i : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ], by cases Set.mem_uIcc.mp hy <;> nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( i : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ⟩;
      rw [ Finset.sum_image ];
      · refine' lt_of_le_of_lt h_bound ( lt_of_le_of_lt ( Finset.sum_le_sum h_term_bound ) _ );
        norm_num [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, left.ne', ne_of_gt ( sub_pos.mpr hab ) ];
        linarith;
      · field_simp;
        intros i hi j hj hij ; rw [ div_eq_div_iff ] at hij <;> norm_num [ left.ne' ] at * ; aesop;
        linarith

/-
Supremum of a continuous function on a compact set is strictly less than epsilon if the function is strictly less than epsilon everywhere.
-/
lemma sSup_lt_of_compact_image_lt (K : Set ℝ) (hK : IsCompact K) (hK_nonempty : K.Nonempty) (f : ℝ → ℝ) (hf_cont : ContinuousOn f K) (ε : ℝ) (h : ∀ x ∈ K, f x < ε) : sSup (f '' K) < ε := by
  have h_sup_lt_ε : ∃ x ∈ K, ∀ y ∈ K, f y ≤ f x := by
    exact ( IsCompact.exists_isMaxOn hK hK_nonempty hf_cont ) |> fun ⟨ x, hx₁, hx₂ ⟩ => ⟨ x, hx₁, fun y hy => hx₂ hy ⟩;
  exact lt_of_le_of_lt ( csSup_le ( Set.Nonempty.image _ hK_nonempty ) ( Set.forall_mem_image.2 h_sup_lt_ε.choose_spec.2 ) ) ( h _ h_sup_lt_ε.choose_spec.1 )

/-
Checking the definition of Even.
-/
#print Even