/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 3a7ad321-583f-4851-b63e-ba96f8092202

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

noncomputable def FejerKernel (B : ℝ) (x : ℝ) : ℝ := max 0 (1 - |x| / B)

noncomputable def HeatKernel (t : ℝ) (x : ℝ) : ℝ :=
  (4 * Real.pi * t) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / (4 * t))

def W_K (K : ℝ) : Set (ℝ → ℝ) :=
  {Φ | ContinuousOn Φ (Set.Icc (-K) K) ∧
       Function.support Φ ⊆ Set.Icc (-K) K ∧
       Even Φ ∧
       ∀ x, 0 ≤ Φ x}

noncomputable def Atom (B t τ : ℝ) (x : ℝ) : ℝ :=
  FejerKernel B (x - τ) * HeatKernel t (x - τ) +
  FejerKernel B (x + τ) * HeatKernel t (x + τ)

def AtomSet (K : ℝ) : Set (ℝ → ℝ) :=
  {g | ∃ B > 0, ∃ t > 0, ∃ τ ∈ Set.Icc (-K) K, g = Atom B t τ}

def AtomCone_K (K : ℝ) : Set (ℝ → ℝ) :=
  Convex.toCone (convexHull ℝ (AtomSet K)) (convex_convexHull ℝ (AtomSet K))

def diff_set (Φ : ℝ → ℝ) (g : ℝ → ℝ) (K : ℝ) : Set ℝ :=
  (fun x ↦ |Φ x - g x|) '' Set.Icc (-K) K

def IsDenseInWK (K : ℝ) : Prop :=
  ∀ Φ ∈ W_K K, ∀ ε > 0, ∃ g ∈ AtomCone_K K, sSup (diff_set Φ g K) < ε

noncomputable def real_convolution (f g : ℝ → ℝ) (x : ℝ) : ℝ := ∫ t, f t * g (x - t)

/-
The integral of the Heat Kernel over the real line is 1 for any t > 0.
-/
lemma HeatKernel_integral (t : ℝ) (ht : t > 0) : ∫ x, HeatKernel t x = 1 := by
  unfold HeatKernel;
  rw [ MeasureTheory.integral_const_mul ];
  have := integral_gaussian ( 1 / ( 4 * t ) ) ; norm_num [ div_eq_inv_mul ] at *;
  rw [ this, Real.rpow_neg ( by positivity ) ];
  rw [ ← Real.sqrt_eq_rpow, inv_mul_eq_div, div_eq_iff ] <;> ring ; positivity

/-
As t approaches 0 from above, the integral of the Heat Kernel outside any fixed neighborhood (-δ, δ) tends to 0.
-/
lemma HeatKernel_mass_concentration (δ : ℝ) (hδ : δ > 0) :
  Filter.Tendsto (fun t => ∫ x in {y | |y| > δ}, HeatKernel t x) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
    -- Substitute $u = \frac{x}{\sqrt{4t}}$ to rewrite the integral.
    suffices h_integral : Filter.Tendsto (fun t => 2 * ∫ u in Set.Ioi (δ / Real.sqrt (4 * t)), (Real.pi) ^ (-(1:ℝ)/2) * Real.exp (-u^2)) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) by
      -- By definition of $HeatKernel$, we know that
      have h_heat_kernel : ∀ t > 0, ∫ x in {y | |y| > δ}, HeatKernel t x = 2 * ∫ x in Set.Ioi δ, (4 * Real.pi * t) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / (4 * t)) := by
        intro t ht
        have h_integral_split : ∫ x in {y | |y| > δ}, (4 * Real.pi * t) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / (4 * t)) = (∫ x in Set.Ioi δ, (4 * Real.pi * t) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / (4 * t))) + (∫ x in Set.Iio (-δ), (4 * Real.pi * t) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / (4 * t))) := by
          rw [ ← MeasureTheory.setIntegral_union ] <;> norm_num;
          · rcongr x ; norm_num [ abs_eq_max_neg ] ; aesop;
            · exact Or.inl <| Set.mem_Ioi.mpr h;
            · exact Or.inr ( by norm_num; linarith );
            · cases a <;> aesop;
              exact Or.inr ( by linarith );
          · positivity;
          · exact MeasureTheory.Integrable.integrableOn ( by exact MeasureTheory.Integrable.const_mul ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) ) ) ) ) ) ) ) _ );
          · exact MeasureTheory.Integrable.integrableOn ( by exact MeasureTheory.Integrable.const_mul ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) ) ) ) ) ) ) ) ) ) ) ) _ );
        convert h_integral_split using 1;
        rw [ ← MeasureTheory.integral_Iic_eq_integral_Iio ] ; rw [ ← neg_neg δ, ← integral_comp_neg_Iic ] ; norm_num ; ring;
      -- Apply the substitution $u = \frac{x}{\sqrt{4t}}$ to rewrite the integral.
      have h_subst : ∀ t > 0, ∫ x in Set.Ioi δ, (4 * Real.pi * t) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / (4 * t)) = ∫ u in Set.Ioi (δ / Real.sqrt (4 * t)), (Real.pi) ^ (-(1:ℝ)/2) * Real.exp (-u^2) := by
        intro t ht
        have h_subst : ∀ {f : ℝ → ℝ}, ∫ x in Set.Ioi δ, f x = ∫ u in Set.Ioi (δ / Real.sqrt (4 * t)), f (u * Real.sqrt (4 * t)) * Real.sqrt (4 * t) := by
          intro f; rw [ MeasureTheory.integral_mul_const ] ; rw [ MeasureTheory.integral_comp_mul_right_Ioi ] ; norm_num [ ht.le, ht.ne' ] ;
          · ring ; norm_num [ ht.le, ht.ne' ];
          · positivity;
        convert h_subst using 3 ; ring;
        rw [ Real.mul_rpow ( by positivity ) ( by positivity ), Real.mul_rpow ( by positivity ) ( by positivity ) ] ; norm_num [ Real.sqrt_eq_rpow, Real.rpow_neg, ht.le, ht.ne', mul_assoc, mul_comm, mul_left_comm ] ; ring;
        norm_num [ ← Real.sqrt_eq_rpow, ht.le, ht.ne', mul_assoc, mul_left_comm, mul_comm ];
        ring ; norm_num [ ht.le, ht.ne' ];
      exact h_integral.congr' ( Filter.eventuallyEq_of_mem self_mem_nhdsWithin fun t ht => by rw [ h_heat_kernel t ht, h_subst t ht ] );
    -- The integral $\int_{\delta/\sqrt{4t}}^{\infty} e^{-u^2} du$ tends to $0$ as $t \to 0^+$.
    have h_integral : Filter.Tendsto (fun t => ∫ u in Set.Ioi (δ / Real.sqrt (4 * t)), Real.exp (-u^2)) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
      -- Using the fact that the integral of the Gaussian function over $[a, \infty)$ tends to $0$ as $a$ tends to infinity.
      have h_gauss_tendsto : Filter.Tendsto (fun a => ∫ u in Set.Ioi a, Real.exp (-u^2)) Filter.atTop (nhds 0) := by
        have h_gauss_tendsto : Filter.Tendsto (fun a => ∫ u in Set.Ioi 0, Real.exp (-u^2) * (if u > a then 1 else 0)) Filter.atTop (nhds 0) := by
          have h_gauss_tendsto : Filter.Tendsto (fun a => ∫ u in Set.Ioi 0, Real.exp (-u^2) * (if u > a then 1 else 0)) Filter.atTop (nhds (∫ u in Set.Ioi 0, Real.exp (-u^2) * 0)) := by
            refine' MeasureTheory.tendsto_integral_filter_of_dominated_convergence _ _ _ _ _;
            refine' fun u => Real.exp ( -u ^ 2 );
            · exact Filter.Eventually.of_forall fun n => Measurable.aestronglyMeasurable ( by exact Measurable.mul ( Real.continuous_exp.measurable.comp ( measurable_neg.comp ( measurable_id.pow_const 2 ) ) ) ( measurable_const.indicator ( measurableSet_Ioi ) ) );
            · filter_upwards [ Filter.eventually_gt_atTop 0 ] with n hn using Filter.Eventually.of_forall fun x => by split_ifs <;> norm_num [ Real.exp_nonneg ];
            · exact MeasureTheory.Integrable.integrableOn ( by simpa using ( integrable_exp_neg_mul_sq ( zero_lt_one' ℝ ) ) );
            · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioi ] with a ha using tendsto_const_nhds.congr' ( by filter_upwards [ Filter.eventually_gt_atTop a ] with n hn; aesop ; linarith );
          aesop;
        refine h_gauss_tendsto.congr' ?_;
        filter_upwards [ Filter.eventually_gt_atTop 0 ] with a ha;
        rw [ ← MeasureTheory.integral_indicator ( measurableSet_Ioi ), ← MeasureTheory.integral_indicator ( measurableSet_Ioi ) ];
        congr with x ; rw [ Set.indicator_apply, Set.indicator_apply ] ; aesop ; linarith;
      refine h_gauss_tendsto.comp ?_;
      refine' Filter.Tendsto.const_mul_atTop hδ _;
      refine' Filter.Tendsto.inv_tendsto_nhdsGT_zero _;
      refine' Filter.Tendsto.inf _ _ <;> norm_num;
      exact Continuous.tendsto' ( by continuity ) _ _ ( by norm_num );
    simpa [ MeasureTheory.integral_const_mul ] using h_integral.const_mul _ |> Filter.Tendsto.const_mul _

/-
The Heat Kernel is non-negative for all t > 0 and all x.
-/
lemma HeatKernel_nonneg (t : ℝ) (ht : t > 0) (x : ℝ) : 0 ≤ HeatKernel t x := by
  exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ )

/-
The Fejer Kernel is bounded between 0 and 1.
-/
lemma FejerKernel_bounds (B : ℝ) (hB : B > 0) (x : ℝ) : 0 ≤ FejerKernel B x ∧ FejerKernel B x ≤ 1 := by
  exact ⟨ le_max_left _ _, max_le_iff.2 ⟨ by norm_num, sub_le_self _ <| by positivity ⟩ ⟩

/-
For B > K, the Fejer Kernel is bounded below by 1 - K/B on [-K, K].
-/
lemma FejerKernel_approx_one (K : ℝ) (B : ℝ) (hB : B > K) (x : ℝ) (hx : x ∈ Set.Icc (-K) K) :
  1 - K / B ≤ FejerKernel B x := by
    unfold FejerKernel;
    cases max_cases ( 0 : ℝ ) ( 1 - |x| / B ) <;> cases abs_cases x <;> nlinarith [ hx.1, hx.2, mul_div_cancel₀ ( |x| : ℝ ) ( by linarith [ hx.1, hx.2 ] : B ≠ 0 ), mul_div_cancel₀ ( K : ℝ ) ( by linarith [ hx.1, hx.2 ] : B ≠ 0 ) ]

/-
Any function continuous on [-K, K] can be extended to a continuous function on ℝ with compact support.
-/
lemma exists_compact_extension (K : ℝ) (hK : K > 0) (Φ : ℝ → ℝ) (hΦ : ContinuousOn Φ (Set.Icc (-K) K)) :
  ∃ Ψ : ℝ → ℝ, Continuous Ψ ∧ HasCompactSupport Ψ ∧ ∀ x ∈ Set.Icc (-K) K, Ψ x = Φ x := by
    -- Let's choose a continuous cutoff function $\chi$ that is 1 on $[-K, K]$ and 0 outside $[-K-1, K+1]$.
    obtain ⟨χ, hχ₁, hχ₂⟩ : ∃ χ : ℝ → ℝ, Continuous χ ∧ (∀ x, |x| ≤ K → χ x = 1) ∧ (∀ x, |x| ≥ K + 1 → χ x = 0) ∧ HasCompactSupport χ := by
      -- Define the cutoff function $\chi$.
      use fun x => if |x| ≤ K then 1 else if |x| ≥ K + 1 then 0 else (1 - (|x| - K) / (K + 1 - K));
      aesop <;> try linarith [ abs_nonneg x ] ;
      · apply_rules [ Continuous.if_le, Continuous.sub, Continuous.mul, continuous_const, continuous_abs ];
        · intros; linarith;
        · aesop;
      · rw [ hasCompactSupport_iff_eventuallyEq ];
        norm_num [ Filter.EventuallyEq ];
        exact ⟨ ⟨ -K - 2, fun x hx => by split_ifs <;> cases abs_cases x <;> linarith ⟩, ⟨ K + 2, fun x hx => by split_ifs <;> cases abs_cases x <;> linarith ⟩ ⟩;
    -- Extend Φ to a continuous function g on ℝ.
    obtain ⟨g, hg₁, hg₂⟩ : ∃ g : ℝ → ℝ, Continuous g ∧ ∀ x ∈ Set.Icc (-K) K, g x = Φ x := by
      have := @ContinuousMap.exists_restrict_eq;
      specialize this ( show IsClosed ( Set.Icc ( -K ) K ) from isClosed_Icc ) ( ContinuousMap.mk ( fun x : Set.Icc ( -K ) K => Φ x ) <| by exact continuousOn_iff_continuous_restrict.mp hΦ );
      exact ⟨ this.choose, this.choose.continuous, fun x hx => congr_arg ( fun f => f ⟨ x, hx ⟩ ) this.choose_spec ⟩;
    refine' ⟨ g * χ, hg₁.mul hχ₁, _, _ ⟩ <;> aesop;
    · exact?;
    · rw [ left x ( abs_le.mpr ⟨ by linarith, by linarith ⟩ ), mul_one ]

/-
Convolution with the Heat Kernel converges uniformly to the original function for continuous functions with compact support.
-/
lemma HeatKernel_approx_identity_uniform (f : ℝ → ℝ) (hf_cont : Continuous f) (hf_supp : HasCompactSupport f) (ε : ℝ) (hε : ε > 0) :
  ∃ t₀ > 0, ∀ t ∈ Set.Ioo 0 t₀, ∀ x, |real_convolution f (HeatKernel t) x - f x| < ε := by
    -- Since f is compactly supported and continuous, it is bounded. Let M be an upper bound for |f|.
    obtain ⟨M, hM⟩ : ∃ M > 0, ∀ x, |f x| ≤ M := by
      obtain ⟨ M, hM ⟩ := hf_supp.exists_bound_of_continuous hf_cont; use Max.max M 1; aesop;
    -- Since f is uniformly continuous, there exists δ > 0 such that |x - y| < δ implies |f(x) - f(y)| < ε / 2.
    obtain ⟨δ, hδ_pos, hδ⟩ : ∃ δ > 0, ∀ x y, |x - y| < δ → |f x - f y| < ε / 2 := by
      have h_unif_cont : UniformContinuous f := by
        exact?;
      exact Metric.uniformContinuous_iff.mp h_unif_cont ( ε / 2 ) ( half_pos hε );
    -- For any $t > 0$, we can bound the difference $|(f * H_t)(x) - f(x)|$ by splitting the integral into two parts: $|y| < \delta$ and $|y| \geq \delta$.
    have h_split_integral (t : ℝ) (ht : t > 0) (x : ℝ) : |real_convolution f (HeatKernel t) x - f x| ≤ (∫ y in {y | |y| < δ}, |f (x - y) - f x| * HeatKernel t y) + (∫ y in {y | |y| ≥ δ}, |f (x - y) - f x| * HeatKernel t y) := by
      have h_split_integral (t : ℝ) (ht : t > 0) (x : ℝ) : |real_convolution f (HeatKernel t) x - f x| ≤ ∫ y, |f (x - y) - f x| * HeatKernel t y := by
        have h_split_integral (t : ℝ) (ht : t > 0) (x : ℝ) : real_convolution f (HeatKernel t) x - f x = ∫ y, (f (x - y) - f x) * HeatKernel t y := by
          simp +decide [ sub_mul, real_convolution ];
          rw [ MeasureTheory.integral_sub ];
          · simp +decide [ MeasureTheory.integral_const_mul, MeasureTheory.integral_sub, HeatKernel_integral ];
            rw [ ← MeasureTheory.integral_sub_left_eq_self ( fun y => f y * HeatKernel t ( x - y ) ) ];
            rw [ show ∫ a, HeatKernel t a = 1 from by simpa using HeatKernel_integral t ht ] ; ring;
          · refine' MeasureTheory.Integrable.mono' _ _ _;
            refine' fun y => M * HeatKernel t y;
            · refine' MeasureTheory.Integrable.const_mul _ _;
              exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht );
            · exact MeasureTheory.AEStronglyMeasurable.mul ( Continuous.aestronglyMeasurable ( hf_cont.comp ( continuous_const.sub continuous_id' ) ) ) ( Continuous.aestronglyMeasurable ( by exact Continuous.mul ( by exact Continuous.rpow ( by continuity ) ( by continuity ) <| by continuity ) <| Real.continuous_exp.comp <| by continuity ) );
            · filter_upwards [ ] with y using by rw [ Real.norm_eq_abs, abs_mul, abs_of_nonneg ( show 0 ≤ HeatKernel t y by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ] ; exact mul_le_mul_of_nonneg_right ( hM.2 _ ) ( show 0 ≤ HeatKernel t y by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ;
          · refine' MeasureTheory.Integrable.const_mul _ _;
            exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht );
        rw [ h_split_integral t ht x ];
        convert MeasureTheory.norm_integral_le_integral_norm ( _ : ℝ → ℝ ) using 1;
        norm_num [ abs_mul, abs_of_nonneg ( show 0 ≤ HeatKernel t _ from by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ];
      rw [ ← MeasureTheory.setIntegral_union ] <;> norm_num;
      · rw [ show { y : ℝ | |y| < δ } ∪ { y : ℝ | δ ≤ |y| } = Set.univ by ext y; by_cases hy : |y| < δ <;> aesop ] ; aesop;
      · exact Set.disjoint_left.mpr fun y hy₁ hy₂ => hy₁.out.not_le hy₂.out;
      · exact measurableSet_Ici.mem.comp measurable_norm;
      · refine' MeasureTheory.Integrable.integrableOn _;
        refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun y => ( M + M ) * HeatKernel t y;
        · refine' MeasureTheory.Integrable.const_mul _ _;
          exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht );
        · exact MeasureTheory.AEStronglyMeasurable.mul ( Continuous.aestronglyMeasurable ( by continuity ) ) ( Continuous.aestronglyMeasurable ( by exact Continuous.mul ( Continuous.rpow ( continuous_const.mul continuous_const ) continuous_const <| by continuity ) <| Real.continuous_exp.comp <| by continuity ) );
        · filter_upwards [ ] with y using by rw [ Real.norm_of_nonneg ( mul_nonneg ( abs_nonneg _ ) ( HeatKernel_nonneg t ht y ) ) ] ; exact mul_le_mul_of_nonneg_right ( abs_le.mpr ⟨ by linarith [ abs_le.mp ( hM.2 ( x - y ) ), abs_le.mp ( hM.2 x ) ], by linarith [ abs_le.mp ( hM.2 ( x - y ) ), abs_le.mp ( hM.2 x ) ] ⟩ ) ( HeatKernel_nonneg t ht y ) ;
      · refine' MeasureTheory.Integrable.integrableOn _;
        refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun y => ( M + M ) * HeatKernel t y;
        · refine' MeasureTheory.Integrable.const_mul _ _;
          exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht );
        · exact MeasureTheory.AEStronglyMeasurable.mul ( Continuous.aestronglyMeasurable ( by continuity ) ) ( Continuous.aestronglyMeasurable ( by exact Continuous.mul ( Continuous.rpow ( continuous_const.mul continuous_const ) continuous_const <| by continuity ) <| Real.continuous_exp.comp <| by continuity ) );
        · filter_upwards [ ] with y using by rw [ Real.norm_of_nonneg ( mul_nonneg ( abs_nonneg _ ) ( HeatKernel_nonneg t ht y ) ) ] ; exact mul_le_mul_of_nonneg_right ( abs_le.mpr ⟨ by linarith [ abs_le.mp ( hM.2 ( x - y ) ), abs_le.mp ( hM.2 x ) ], by linarith [ abs_le.mp ( hM.2 ( x - y ) ), abs_le.mp ( hM.2 x ) ] ⟩ ) ( HeatKernel_nonneg t ht y ) ;
    -- For $t > 0$, we can bound the first integral by $\frac{\epsilon}{2}$ and the second integral by $2M \int_{|y| \geq \delta} H_t(y) dy$.
    have h_bound_integral (t : ℝ) (ht : t > 0) (x : ℝ) : |real_convolution f (HeatKernel t) x - f x| ≤ (ε / 2) * (∫ y in {y | |y| < δ}, HeatKernel t y) + 2 * M * (∫ y in {y | |y| ≥ δ}, HeatKernel t y) := by
      refine le_trans ( h_split_integral t ht x ) ?_;
      refine' add_le_add _ _;
      · rw [ ← MeasureTheory.integral_const_mul ];
        refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
        · exact Filter.Eventually.of_forall fun y => mul_nonneg ( abs_nonneg _ ) ( HeatKernel_nonneg t ht y );
        · refine' MeasureTheory.Integrable.const_mul _ _;
          exact MeasureTheory.Integrable.integrableOn ( by exact MeasureTheory.integrable_of_integral_eq_one ( by rw [ HeatKernel_integral t ht ] ) );
        · filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_lt ( measurable_norm ) measurable_const ] with y hy using mul_le_mul_of_nonneg_right ( le_of_lt <| hδ _ _ <| by simpa [ abs_sub_comm ] using hy ) <| by exact ( by unfold HeatKernel; positivity ) ;
      · rw [ ← MeasureTheory.integral_const_mul ];
        refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
        · exact Filter.Eventually.of_forall fun y => mul_nonneg ( abs_nonneg _ ) ( by unfold HeatKernel; positivity );
        · refine' MeasureTheory.Integrable.const_mul _ _;
          refine' MeasureTheory.Integrable.integrableOn _;
          exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht );
        · filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_le measurable_const <| measurable_norm ] with y hy using mul_le_mul_of_nonneg_right ( abs_sub_le_iff.mpr ⟨ by linarith [ abs_le.mp ( hM.2 ( x - y ) ), abs_le.mp ( hM.2 x ) ], by linarith [ abs_le.mp ( hM.2 ( x - y ) ), abs_le.mp ( hM.2 x ) ] ⟩ ) <| by unfold HeatKernel; positivity;
    -- Since $\int_{|y| \geq \delta} H_t(y) dy$ tends to $0$ as $t$ approaches $0$, we can choose $t₀$ such that for all $t \in (0, t₀)$, $2M \int_{|y| \geq \delta} H_t(y) dy < \frac{\epsilon}{2}$.
    obtain ⟨t₀, ht₀⟩ : ∃ t₀ > 0, ∀ t ∈ Set.Ioo 0 t₀, 2 * M * (∫ y in {y | |y| ≥ δ}, HeatKernel t y) < ε / 2 := by
      have h_integral_zero : Filter.Tendsto (fun t => ∫ y in {y | |y| ≥ δ}, HeatKernel t y) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
        convert HeatKernel_mass_concentration δ hδ_pos using 1;
        ext t; rw [ MeasureTheory.setIntegral_congr_set ] ; aesop;
        rw [ MeasureTheory.ae_eq_set ];
        constructor <;> rw [ MeasureTheory.measure_eq_zero_iff_ae_notMem ] <;> aesop;
        · filter_upwards [ MeasureTheory.measure_eq_zero_iff_ae_notMem.mp ( MeasureTheory.measure_singleton ( δ ) ), MeasureTheory.measure_eq_zero_iff_ae_notMem.mp ( MeasureTheory.measure_singleton ( -δ ) ) ] with x hx₁ hx₂ using fun hx₃ => lt_of_le_of_ne hx₃ ( by cases abs_cases x <;> cases lt_or_gt_of_ne hx₁ <;> cases lt_or_gt_of_ne hx₂ <;> linarith );
        · exact Filter.Eventually.of_forall fun x hx => le_of_lt hx;
      have := Metric.tendsto_nhdsWithin_nhds.mp h_integral_zero ( ε / 4 / M ) ( div_pos ( by linarith ) hM.1 );
      exact ⟨ this.choose, this.choose_spec.1, fun t ht => by nlinarith [ abs_lt.mp ( this.choose_spec.2 ht.1 ( by simpa [ abs_of_pos ht.1 ] using ht.2 ) ), mul_div_cancel₀ ( ε / 4 ) hM.1.ne' ] ⟩;
    -- Since $\int_{|y| < \delta} H_t(y) dy \leq 1$, we can conclude that $|real_convolution f (HeatKernel t) x - f x| < \epsilon$ for all $t \in (0, t₀)$.
    use t₀, ht₀.left
    intro t ht x
    have h_integral_bound : (∫ y in {y | |y| < δ}, HeatKernel t y) ≤ 1 := by
      refine' le_trans ( MeasureTheory.setIntegral_le_integral _ _ ) _;
      · exact MeasureTheory.Integrable.const_mul ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by norm_num; linarith [ ht.1 ] : 0 < ( 4 * t ) ⁻¹ ) ) ) ) ) ) ) ) ) ) ) ) ) ) _;
      · exact Filter.Eventually.of_forall fun x => HeatKernel_nonneg t ht.1 x;
      · rw [ HeatKernel_integral t ht.1 ];
    nlinarith [ h_bound_integral t ht.1 x, ht₀.2 t ht ]

/-
The integral of a continuous function F(x, y) over y in [a, b] can be uniformly approximated in x by a Riemann sum.
-/
lemma uniform_riemann_sum (a b : ℝ) (hab : a < b) (X : Set ℝ) (hX : IsCompact X) (F : ℝ → ℝ → ℝ) (hF : ContinuousOn (Function.uncurry F) (X ×ˢ Set.Icc a b)) (ε : ℝ) (hε : ε > 0) :
  ∃ (s : Finset ℝ) (w : ℝ → ℝ), (∀ y ∈ s, w y > 0) ∧ (∀ y ∈ s, y ∈ Set.Icc a b) ∧
  ∀ x ∈ X, |(∫ y in Set.Icc a b, F x y) - ∑ y ∈ s, w y * F x y| < ε := by
    -- Since $D = X \times [a, b]$ is compact, $F$ is uniformly continuous on $D$.
    obtain ⟨δ, hδ_pos, hδ⟩ : ∃ δ > 0, ∀ x x' y y', x ∈ X → y ∈ Set.Icc a b → x' ∈ X → y' ∈ Set.Icc a b → |x - x'| < δ → |y - y'| < δ → |F x y - F x' y'| < ε / (2 * (b - a)) := by
      -- Since $F$ is uniformly continuous on the compact set $D = X \times [a, b]$, it is uniformly continuous.
      have h_unif : UniformContinuousOn (Function.uncurry F) (X ×ˢ Set.Icc a b) := by
        exact IsCompact.uniformContinuousOn_of_continuous ( hX.prod ( CompactIccSpace.isCompact_Icc ) ) hF;
      rcases Metric.uniformContinuousOn_iff.mp h_unif ( ε / ( 2 * ( b - a ) ) ) ( div_pos hε ( mul_pos zero_lt_two ( sub_pos.mpr hab ) ) ) with ⟨ δ, δ_pos, hδ ⟩ ; use δ; aesop;
      exact hδ x y a_1 a_2 a_3 x' y' a_4 a_5 a_6 ( by simpa [ Prod.dist_eq ] using max_lt a_7 a_8 );
    -- Let's choose the partition points $y_i$ such that they are spaced less than $\delta$ apart.
    obtain ⟨s, w, hs⟩ : ∃ (s : Finset ℝ) (w : ℝ → ℝ), (∀ y ∈ s, w y > 0) ∧ (∀ y ∈ s, y ∈ Set.Icc a b) ∧ (∀ x ∈ X, |(∫ y in Set.Icc a b, F x y) - ∑ y ∈ s, w y * F x y| < ε) := by
      have h_partition : ∃ (m : ℕ) (m_pos : 0 < m), δ > (b - a) / (m : ℝ) := by
        exact ⟨ ⌊ ( b - a ) / δ⌋₊ + 1, Nat.succ_pos _, by rw [ gt_iff_lt ] ; rw [ div_lt_iff₀ ] <;> push_cast <;> nlinarith [ Nat.lt_floor_add_one ( ( b - a ) / δ ), mul_div_cancel₀ ( b - a ) hδ_pos.ne' ] ⟩
      obtain ⟨ m, hm_pos, hm ⟩ := h_partition;
      refine' ⟨ Finset.image ( fun i : ℕ => a + ( i + 1 / 2 ) * ( b - a ) / m ) ( Finset.range m ), fun y => ( b - a ) / m, _, _, _ ⟩ <;> norm_num;
      · exact fun _ _ => div_pos ( sub_pos.mpr hab ) ( Nat.cast_pos.mpr hm_pos );
      · exact fun i hi => ⟨ div_nonneg ( mul_nonneg ( by positivity ) ( by linarith ) ) ( by positivity ), by rw [ add_div', div_le_iff₀ ] <;> nlinarith [ show ( i : ℝ ) + 1 ≤ m by norm_cast ] ⟩;
      · -- By the properties of the Riemann sum, we can bound the difference between the integral and the sum.
        intros x hx
        have h_riemann_sum : |(∫ y in Set.Icc a b, F x y) - ∑ i ∈ Finset.range m, (b - a) / m * F x (a + (i + 1 / 2) * (b - a) / m)| ≤ ∑ i ∈ Finset.range m, ∫ y in (a + i * (b - a) / m).. (a + (i + 1) * (b - a) / m), |F x y - F x (a + (i + 1 / 2) * (b - a) / m)| := by
          have h_riemann_sum : ∫ y in Set.Icc a b, F x y = ∑ i ∈ Finset.range m, ∫ y in (a + i * (b - a) / m).. (a + (i + 1) * (b - a) / m), F x y := by
            rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le hab.le ];
            symm;
            convert intervalIntegral.sum_integral_adjacent_intervals _ <;> norm_num;
            · rw [ mul_div_cancel_left₀ _ ( by positivity ), add_sub_cancel ];
            · intro k hk;
              apply_rules [ ContinuousOn.intervalIntegrable ];
              refine' hF.comp ( continuousOn_const.prodMk ( continuousOn_id ) ) fun y hy => _;
              simp +zetaDelta at *;
              exact ⟨ hx, by cases Set.mem_uIcc.mp hy <;> nlinarith [ show ( k : ℝ ) + 1 ≤ m by norm_cast, mul_div_cancel₀ ( ( k : ℝ ) * ( b - a ) ) ( by positivity : ( m : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( k : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( m : ℝ ) ≠ 0 ) ], by cases Set.mem_uIcc.mp hy <;> nlinarith [ show ( k : ℝ ) + 1 ≤ m by norm_cast, mul_div_cancel₀ ( ( k : ℝ ) * ( b - a ) ) ( by positivity : ( m : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( k : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( m : ℝ ) ≠ 0 ) ] ⟩;
          rw [ h_riemann_sum, ← Finset.sum_sub_distrib ];
          refine' le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( Finset.sum_le_sum fun i hi => _ );
          convert intervalIntegral.abs_integral_le_integral_abs _ using 2;
          · rw [ intervalIntegral.integral_sub ] <;> norm_num;
            · exact Or.inl <| by ring;
            · field_simp;
              apply_rules [ ContinuousOn.intervalIntegrable ];
              refine' hF.comp ( continuousOn_const.prodMk continuousOn_id ) fun y hy => _;
              simp +zetaDelta at *;
              exact ⟨ hx, by cases Set.mem_uIcc.mp hy <;> nlinarith [ show ( i : ℝ ) + 1 ≤ m by norm_cast, mul_div_cancel₀ ( a * m + ( i : ℝ ) * ( b - a ) ) ( by positivity : ( m : ℝ ) ≠ 0 ), mul_div_cancel₀ ( a * m + ( b - a ) * ( i + 1 ) ) ( by positivity : ( m : ℝ ) ≠ 0 ) ], by cases Set.mem_uIcc.mp hy <;> nlinarith [ show ( i : ℝ ) + 1 ≤ m by norm_cast, mul_div_cancel₀ ( a * m + ( i : ℝ ) * ( b - a ) ) ( by positivity : ( m : ℝ ) ≠ 0 ), mul_div_cancel₀ ( a * m + ( b - a ) * ( i + 1 ) ) ( by positivity : ( m : ℝ ) ≠ 0 ) ] ⟩;
          · bound;
        -- Since $|F x y - F x (a + (i + 1 / 2) * (b - a) / m)| < ε / (2 * (b - a))$ for all $y \in [a + i * (b - a) / m, a + (i + 1) * (b - a) / m]$, we can bound the integral.
        have h_integral_bound : ∀ i ∈ Finset.range m, ∫ y in (a + i * (b - a) / m).. (a + (i + 1) * (b - a) / m), |F x y - F x (a + (i + 1 / 2) * (b - a) / m)| ≤ (b - a) / m * (ε / (2 * (b - a))) := by
          intros i hi
          have h_integral_bound_i : ∀ y ∈ Set.Icc (a + i * (b - a) / m) (a + (i + 1) * (b - a) / m), |F x y - F x (a + (i + 1 / 2) * (b - a) / m)| < ε / (2 * (b - a)) := by
            intros y hy;
            apply hδ x x y (a + (i + 1 / 2) * (b - a) / m) hx (by
            constructor <;> nlinarith [ hy.1, hy.2, show ( i : ℝ ) + 1 ≤ m by norm_cast; linarith [ Finset.mem_range.mp hi ], mul_div_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( m : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( i : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( m : ℝ ) ≠ 0 ) ]) hx (by
            constructor <;> nlinarith [ show ( i : ℝ ) + 1 ≤ m by norm_cast; linarith [ Finset.mem_range.mp hi ], show ( i : ℝ ) ≥ 0 by positivity, mul_div_cancel₀ ( ( i + 1 / 2 ) * ( b - a ) ) ( by positivity : ( m : ℝ ) ≠ 0 ) ]) (by
            simpa using hδ_pos) (by
            exact abs_lt.mpr ⟨ by ring_nf at *; nlinarith [ hy.1, hy.2, mul_inv_cancel₀ ( by positivity : ( m : ℝ ) ≠ 0 ) ], by ring_nf at *; nlinarith [ hy.1, hy.2, mul_inv_cancel₀ ( by positivity : ( m : ℝ ) ≠ 0 ) ] ⟩);
          rw [ intervalIntegral.integral_of_le ];
          · refine' le_trans ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _;
            use fun y => ε / ( 2 * ( b - a ) );
            · exact Filter.Eventually.of_forall fun y => abs_nonneg _;
            · norm_num;
            · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with y hy using le_of_lt ( h_integral_bound_i y <| Set.Ioc_subset_Icc_self hy );
            · norm_num [ add_mul, div_eq_mul_inv ];
              rw [ max_eq_left ( by exact mul_nonneg ( sub_nonneg.2 hab.le ) ( inv_nonneg.2 ( Nat.cast_nonneg _ ) ) ) ];
          · bound;
        rw [ Finset.sum_image ];
        · refine' lt_of_le_of_lt h_riemann_sum ( lt_of_le_of_lt ( Finset.sum_le_sum h_integral_bound ) _ );
          norm_num [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, hm_pos.ne', ne_of_gt ( sub_pos.mpr hab ) ];
          linarith;
        · simp +decide [ div_eq_mul_inv, ne_of_gt ( show 0 < m by positivity ), ne_of_gt ( show 0 < b - a by linarith ) ];
    use s, w

/-
The convolution of a non-negative continuous function supported on [-K, K] with the Heat Kernel can be uniformly approximated by a non-negative Riemann sum on [-K, K].
-/
lemma convolution_approx_by_sum (K : ℝ) (hK : K > 0) (f : ℝ → ℝ) (hf_cont : ContinuousOn f (Set.Icc (-K) K)) (hf_supp : Function.support f ⊆ Set.Icc (-K) K) (hf_nonneg : ∀ x, 0 ≤ f x) (t : ℝ) (ht : t > 0) (ε : ℝ) (hε : ε > 0) :
  ∃ (s : Finset ℝ) (w : ℝ → ℝ), (∀ y ∈ s, w y ≥ 0) ∧ (∀ y ∈ s, y ∈ Set.Icc (-K) K) ∧
  ∀ x ∈ Set.Icc (-K) K, |real_convolution f (HeatKernel t) x - ∑ y ∈ s, w y * HeatKernel t (x - y)| < ε := by
    -- Apply uniform_riemann_sum to F(x, y) = f(y) * HeatKernel t (x - y) on [-K, K] x [-K, K].
    obtain ⟨s, w, hw_pos, hw_bounds, hw_approx⟩ : ∃ (s : Finset ℝ) (w : ℝ → ℝ), (∀ y ∈ s, w y > 0) ∧ (∀ y ∈ s, y ∈ Set.Icc (-K) K) ∧ ∀ x ∈ Set.Icc (-K) K, |(∫ y in Set.Icc (-K) K, f y * HeatKernel t (x - y)) - ∑ y ∈ s, w y * f y * HeatKernel t (x - y)| < ε := by
      have := @uniform_riemann_sum ( -K ) K ( by linarith ) ( Set.Icc ( -K ) K ) ?_ ( fun x y => f y * HeatKernel t ( x - y ) ) ?_ ε ?_ <;> norm_num at *;
      · simpa only [ mul_assoc ] using this;
      · exact CompactIccSpace.isCompact_Icc;
      · refine' ContinuousOn.mul _ _;
        · exact hf_cont.comp continuousOn_snd fun x hx => ⟨ by aesop, by aesop ⟩;
        · refine' ContinuousOn.mul _ _;
          · exact continuousOn_const;
          · exact Continuous.continuousOn ( by continuity );
      · bound;
    refine' ⟨ s, fun y => w y * f y, _, _, _ ⟩ <;> aesop;
    convert hw_approx x left right using 1;
    rw [ MeasureTheory.setIntegral_eq_integral_of_forall_compl_eq_zero ];
    · rfl;
    · exact fun y hy => mul_eq_zero_of_left ( Classical.not_not.1 fun h => hy <| hf_supp y h ) _

/-
For large B, the sum of Atoms approximates the sum of Heat Kernels.
-/
lemma fejer_sum_approx (K : ℝ) (hK : K > 0) (t : ℝ) (ht : t > 0) (s : Finset ℝ) (w : ℝ → ℝ) (hw_nonneg : ∀ y ∈ s, w y ≥ 0) (hs_subset : ∀ y ∈ s, y ∈ Set.Icc (-K) K) (ε : ℝ) (hε : ε > 0) :
  ∃ B > 0, ∀ x ∈ Set.Icc (-K) K,
  |∑ y ∈ s, w y * Atom B t y x - (∑ y ∈ s, w y * HeatKernel t (x - y) + ∑ y ∈ s, w y * HeatKernel t (x + y))| < ε := by
    -- The error term is bounded by sum of w y * (2K/B) * (H_t(x - y) + H_t(x + y)).
    have h_error_bound : ∀ B > 0, ∀ x ∈ Set.Icc (-K) K, |∑ y ∈ s, w y * (Atom B t y x) - (∑ y ∈ s, w y * (HeatKernel t (x - y)) + ∑ y ∈ s, w y * (HeatKernel t (x + y)))| ≤ ∑ y ∈ s, w y * (2 * K / B) * (HeatKernel t (x - y) + HeatKernel t (x + y)) := by
      -- For x, y in [-K, K], x - y and x + y are in [-2K, 2K]. Therefore, |Fejer B (x - y) - 1| ≤ 2K/B and |Fejer B (x + y) - 1| ≤ 2K/B.
      have h_fejer_bound : ∀ B > 0, ∀ x ∈ Set.Icc (-K) K, ∀ y ∈ s, |FejerKernel B (x - y) - 1| ≤ 2 * K / B ∧ |FejerKernel B (x + y) - 1| ≤ 2 * K / B := by
        intros B hB x hx y hy
        have h_fejer_bound : ∀ z ∈ Set.Icc (-2 * K) (2 * K), |FejerKernel B z - 1| ≤ 2 * K / B := by
          unfold FejerKernel; aesop;
          cases max_cases ( 0 : ℝ ) ( 1 - |z| / B ) <;> cases abs_cases ( Max.max 0 ( 1 - |z| / B ) - 1 ) <;> cases abs_cases z <;> nlinarith [ div_mul_cancel₀ ( |z| ) hB.ne', div_mul_cancel₀ ( 2 * K ) hB.ne' ];
        exact ⟨ h_fejer_bound _ ⟨ by linarith [ hx.1, hx.2, hs_subset y hy |>.1, hs_subset y hy |>.2 ], by linarith [ hx.1, hx.2, hs_subset y hy |>.1, hs_subset y hy |>.2 ] ⟩, h_fejer_bound _ ⟨ by linarith [ hx.1, hx.2, hs_subset y hy |>.1, hs_subset y hy |>.2 ], by linarith [ hx.1, hx.2, hs_subset y hy |>.1, hs_subset y hy |>.2 ] ⟩ ⟩;
      -- Applying the bound from h_fejer_bound to each term in the sum.
      intros B hB x hx
      have h_term_bound : ∀ y ∈ s, |w y * (Atom B t y x) - (w y * (HeatKernel t (x - y)) + w y * (HeatKernel t (x + y)))| ≤ w y * (2 * K / B) * (HeatKernel t (x - y) + HeatKernel t (x + y)) := by
        intro y hy; specialize h_fejer_bound B hB x hx y hy; unfold Atom; aesop;
        rw [ abs_le ];
        constructor <;> nlinarith [ abs_le.mp left_1, abs_le.mp right_1, show 0 ≤ w y * HeatKernel t ( x - y ) by exact mul_nonneg ( hw_nonneg y hy ) ( show 0 ≤ HeatKernel t ( x - y ) by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ), show 0 ≤ w y * HeatKernel t ( x + y ) by exact mul_nonneg ( hw_nonneg y hy ) ( show 0 ≤ HeatKernel t ( x + y ) by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ];
      simpa only [ ← Finset.sum_add_distrib, Finset.sum_sub_distrib ] using Finset.abs_sum_le_sum_abs _ _ |> le_trans <| Finset.sum_le_sum h_term_bound;
    -- Choose B large enough to make this < ε.
    obtain ⟨B₀, hB₀⟩ : ∃ B₀ > 0, ∀ x ∈ Set.Icc (-K) K, ∑ y ∈ s, w y * (2 * K) * (HeatKernel t (x - y) + HeatKernel t (x + y)) < ε * B₀ := by
      -- The sum of continuous functions over a compact interval is continuous, hence bounded.
      have h_sum_cont : ContinuousOn (fun x => ∑ y ∈ s, w y * (2 * K) * (HeatKernel t (x - y) + HeatKernel t (x + y))) (Set.Icc (-K) K) := by
        exact Continuous.continuousOn ( by unfold HeatKernel; continuity );
      obtain ⟨ M, hM ⟩ := IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) h_sum_cont;
      exact ⟨ ( M + 1 ) / ε, div_pos ( by linarith [ show 0 ≤ M by exact le_trans ( abs_nonneg _ ) ( hM ( -K ) ⟨ by linarith, by linarith ⟩ ) ] ) hε, fun x hx => by rw [ mul_div_cancel₀ _ hε.ne' ] ; linarith [ abs_le.mp ( hM x hx ) ] ⟩;
    refine' ⟨ B₀, hB₀.1, fun x hx => lt_of_le_of_lt ( h_error_bound B₀ hB₀.1 x hx ) _ ⟩;
    convert div_lt_iff₀ hB₀.1 |>.2 ( hB₀.2 x hx ) using 1 ; ring;
    rw [ Finset.mul_sum _ _ _ ] ; exact Finset.sum_congr rfl fun _ _ => by ring;

/-
The convolution of two even functions is an even function.
-/
lemma even_convolution (f g : ℝ → ℝ) (hf : Even f) (hg : Even g) : Even (real_convolution f g) := by
  unfold real_convolution Even at *; aesop;
  exact ⟨ fun x => ∫ t, ( w t + w t ) * ( w_1 ( x - t ) + w_1 ( x - t ) ) / 2, by ext; norm_num; rw [ MeasureTheory.integral_div ] ; ring ⟩

/-
A non-negative linear combination with positive total weight of elements of S is in the cone generated by the convex hull of S.
-/
lemma sum_mem_cone {E : Type*} [AddCommGroup E] [Module ℝ E] (S : Set E) (s : Finset E) (w : E → ℝ) (hw : ∀ x ∈ s, 0 ≤ w x) (hs : ∀ x ∈ s, x ∈ S) (h_sum_pos : ∑ x ∈ s, w x > 0) :
  (∑ x ∈ s, w x • x) ∈ Convex.toCone (convexHull ℝ S) (convex_convexHull ℝ S) := by
    have h_comb : ∑ x ∈ s, (w x / ∑ x ∈ s, w x) • x ∈ convexHull ℝ S := by
      refine' mem_convexHull_iff.mpr _;
      aesop;
      convert a_1.sum_mem _ _ _;
      · exact fun x hx => div_nonneg ( hw x hx ) h_sum_pos.le;
      · rw [ ← Finset.sum_div, div_self h_sum_pos.ne' ];
      · exact?;
    simp_all +decide [ div_eq_inv_mul, Finset.mul_sum _ _ _, MulAction.mul_smul ];
    refine' ⟨ ( ∑ x ∈ s, w x ) • _, _, _ ⟩;
    exact ( convexHull ℝ S );
    · exact ⟨ _, by aesop ⟩;
    · refine' ⟨ _, h_comb, _ ⟩;
      simp +decide [ Finset.smul_sum, smul_smul, h_sum_pos.ne' ]

/-
A non-negative linear combination of Atoms with positive total weight is in the AtomCone.
-/
lemma sum_atoms_in_cone (K : ℝ) (s : Finset ℝ) (w : ℝ → ℝ) (hw : ∀ y ∈ s, 0 ≤ w y) (B : ℝ) (hB : B > 0) (t : ℝ) (ht : t > 0) (hs : ∀ y ∈ s, y ∈ Set.Icc (-K) K) (h_sum_pos : ∑ y ∈ s, w y > 0) :
  (fun x => ∑ y ∈ s, w y * Atom B t y x) ∈ AtomCone_K K := by
    convert sum_mem_cone _ _ _ _ _ _;
    rotate_left;
    exact ℝ → ℝ;
    all_goals try infer_instance;
    exact AtomSet K;
    exact Finset.image ( fun y => Atom B t y ) s;
    use fun x => ∑ y ∈ s, if Atom B t y = x then w y else 0;
    · exact fun x hx => Finset.sum_nonneg fun y hy => by split_ifs <;> linarith [ hw y hy ] ;
    · simp +zetaDelta at *;
      exact fun y hy => ⟨ B, hB, t, ht, y, hs y hy, rfl ⟩;
    · rw [ Finset.sum_image' ] ; aesop;
      exact fun x hx => by rw [ Finset.sum_filter ] ;
    · rw [ Finset.sum_image' ];
      rotate_left;
      use fun y => w y • Atom B t y;
      · simp +contextual [ Finset.sum_filter, Finset.sum_smul ];
      · simp +zetaDelta at *;
        congr! 1;
        ext x; simp +decide [ Finset.sum_apply, Pi.smul_apply ] ;

/-
The integral of f over [-K, K] is the integral of f(x) + f(-x) over [0, K].
-/
lemma integral_Icc_eq_integral_Icc_add_neg (K : ℝ) (hK : K > 0) (f : ℝ → ℝ) (hf : MeasureTheory.IntegrableOn f (Set.Icc (-K) K)) :
  ∫ x in Set.Icc (-K) K, f x = ∫ x in Set.Icc 0 K, (f x + f (-x)) := by
    bound;
    rw [ MeasureTheory.integral_add ] <;> norm_num [ *, MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le ];
    · rw [ add_comm, intervalIntegral.integral_add_adjacent_intervals ] <;> apply_rules [ MeasureTheory.IntegrableOn.intervalIntegrable ];
      · exact hf.mono_set ( by rw [ Set.uIcc_of_le ( by linarith ) ] ; exact Set.Icc_subset_Icc ( by linarith ) ( by linarith ) );
      · simpa only [ Set.uIcc_of_le hK.le ] using hf.mono_set ( Set.Icc_subset_Icc ( by linarith ) ( by linarith ) );
    · exact hf.mono_set <| Set.Icc_subset_Icc ( by linarith ) le_rfl;
    · exact MeasureTheory.IntegrableOn.mono_set ( by simpa using hf.comp_neg ) ( Set.Icc_subset_Icc ( by linarith ) le_rfl )