/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b8582d19-dc7a-450a-b056-9b886f3f3648
-/

/-
We define the RKHS weight function `w_RKHS`, the maximum weight `w_max`, the set of nodes `nodes`, the minimal spacing `δ_K`, the sum `S_K`, the matrix `T_P_matrix`, and its operator norm `T_P_norm`. We prove that `w_RKHS` is bounded by `w_max`, that `δ_K` is positive, and establish bounds for `S_K` and `T_P_norm`. Finally, we prove the RKHS Contraction Theorem: for $K \ge 1$, there exists $t > 0$ and $\rho < 1$ such that $\|T_P\| \le \rho$.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The weight w_RKHS(n) is bounded by w_max = 2/e.
-/
open Real

noncomputable def w_RKHS (n : ℕ) : ℝ := (ArithmeticFunction.vonMangoldt n) / Real.sqrt n

noncomputable def w_max : ℝ := 2 / Real.exp 1

theorem w_RKHS_le_w_max (n : ℕ) : w_RKHS n ≤ w_max := by
  -- We'll use that $|\log(n) / \sqrt{n}| \leq 2 / e$ for all $n \geq 1$.
  have h_ineq : ∀ n ≥ 1, abs (Real.log n / Real.sqrt n) ≤ 2 / Real.exp 1 := by
    -- We'll use that $|\log(n) / \sqrt{n}| \leq 2 / e$ for all $n \geq 1$ which follows by checking the function $f(x) = \log(x) / \sqrt{x}$ at $x = e^2$.
    have h_ineq : ∀ x ≥ 1, abs (Real.log x / Real.sqrt x) ≤ 2 / Real.exp 1 := by
      intros x hx_ge_1
      have h_abs : Real.log x ≤ 2 * Real.sqrt x / Real.exp 1 := by
        have := Real.log_le_sub_one_of_pos ( by positivity : 0 < Real.sqrt x / Real.exp 1 );
        rw [ Real.log_div ( by positivity ) ( by positivity ), Real.log_sqrt ( by positivity ), Real.log_exp ] at this ; ring_nf at * ; linarith;
      rw [ abs_of_nonneg ( div_nonneg ( Real.log_nonneg hx_ge_1 ) ( Real.sqrt_nonneg x ) ), div_le_iff₀ ( Real.sqrt_pos.mpr ( by positivity ) ) ];
      exact h_abs.trans_eq ( by ring );
    exact fun n hn => h_ineq n <| mod_cast hn;
  unfold w_RKHS w_max; specialize h_ineq n; rcases n with ( _ | n ) <;> norm_num at *;
  · positivity;
  · rw [ ArithmeticFunction.vonMangoldt ];
    aesop;
    · refine' le_trans _ h_ineq;
      exact le_trans ( div_le_div_of_nonneg_right ( Real.log_le_log ( Nat.cast_pos.mpr <| Nat.minFac_pos _ ) <| mod_cast Nat.minFac_le <| Nat.succ_pos _ ) <| Real.sqrt_nonneg _ ) ( le_abs_self _ );
    · positivity

/-
Definitions of nodes and Node type for RKHS.
-/
open Real BigOperators

noncomputable def ξ (n : ℕ) : ℝ := Real.log n

def nodes (K : ℝ) : Finset ℕ := (Finset.range (Nat.floor (Real.exp K) + 1)).filter (fun n => 1 ≤ n ∧ Real.log n ≤ K)

abbrev Node (K : ℝ) := {x // x ∈ nodes K}

instance (K : ℝ) : Fintype (Node K) := inferInstance

/-
Definition of minimal spacing δ_K.
-/
noncomputable def δ_K (K : ℝ) : ℝ :=
  let s := (nodes K).image ξ
  let diffs := (s.product s).filter (fun (x : ℝ × ℝ) => x.1 ≠ x.2) |>.image (fun (x : ℝ × ℝ) => |x.1 - x.2|)
  if h : diffs.Nonempty then diffs.min' h else 1

/-
Definitions of S_K, T_P_matrix, and T_P_norm.
-/
open Real BigOperators

noncomputable def S_K (K : ℝ) (t : ℝ) : ℝ :=
  let vals := (Finset.univ : Finset (Node K)).image (fun (n : Node K) => ∑ m : Node K, if m ≠ n then Real.exp (-((ξ m.1 - ξ n.1)^2) / (4 * t)) else 0)
  if h : vals.Nonempty then vals.max' h else 0

noncomputable def T_P_matrix (K : ℝ) (t : ℝ) : Matrix (Node K) (Node K) ℝ :=
  fun i j => Real.sqrt (w_RKHS i.1) * Real.sqrt (w_RKHS j.1) * Real.exp (-((ξ i.1 - ξ j.1)^2) / (4 * t))

noncomputable def T_P_norm (K : ℝ) (t : ℝ) : ℝ :=
  ‖(Matrix.toEuclideanLin (T_P_matrix K t)).toContinuousLinearMap‖

/-
The minimal spacing δ_K is positive for K ≥ 1.
-/
lemma delta_K_pos (K : ℝ) (hK : K ≥ 1) : 0 < δ_K K := by
  unfold δ_K;
  aesop;
  exact a_4 ( sub_eq_zero.mp a_1 )

/-
Bound for S_K(t) using a geometric series.
-/
lemma S_K_bound (K : ℝ) (t : ℝ) (hK : K ≥ 1) (ht : t > 0) :
  S_K K t ≤ 2 * Real.exp (- (δ_K K)^2 / (4 * t)) / (1 - Real.exp (- (δ_K K)^2 / (4 * t))) := by
    -- Let the nodes be sorted $n_1 < n_2 < \dots < n_N$.
    -- Then $|\xi(n_i) - \xi(n_j)| \ge |i-j| \delta_K$.
    have h_dist : ∀ (i j : Node K), i ≠ j → |ξ i.1 - ξ j.1| ≥ δ_K K * |(i.1 : ℝ) - (j.1 : ℝ)| := by
      intro i j hij
      have h_dist : |ξ i.1 - ξ j.1| ≥ δ_K K * |(i.1 : ℝ) - (j.1 : ℝ)| := by
        have h_min : ∀ x y : ℝ, x ∈ (nodes K).image ξ → y ∈ (nodes K).image ξ → x ≠ y → |x - y| ≥ δ_K K := by
          unfold δ_K;
          simp +zetaDelta at *;
          intro x y x_1 hx_1 hx x_2 hx_2 hy hxy; split_ifs <;> simp_all +decide [ Finset.min' ] ;
          · exact ⟨ x, y, ⟨ ⟨ ⟨ x_1, hx_1, hx ⟩, ⟨ x_2, hx_2, hy ⟩ ⟩, hxy ⟩, le_rfl ⟩;
          · exact False.elim <| hxy <| by linarith [ ‹∀ a b : ℝ, ∀ x ∈ nodes K, ξ x = a → ∀ x ∈ nodes K, ξ x = b → a = b› _ _ _ hx_1 hx _ hx_2 hy ] ;
        have h_dist : ∀ i j : ℕ, i ∈ nodes K → j ∈ nodes K → i < j → |ξ i - ξ j| ≥ δ_K K * (j - i) := by
          intros i j hi hj hij
          induction' j with j ih generalizing i;
          · contradiction;
          · by_cases hij' : i < j;
            · have h_dist : |ξ i - ξ (j + 1)| ≥ |ξ i - ξ j| + |ξ j - ξ (j + 1)| := by
                unfold ξ; aesop;
                rw [ abs_of_nonpos, abs_of_nonpos, abs_of_nonpos ] <;> linarith [ Real.log_le_log ( by norm_cast; linarith [ Finset.mem_filter.mp hi ] ) ( by norm_cast; linarith : ( i : ℝ ) ≤ j ), Real.log_le_log ( by norm_cast; linarith [ Finset.mem_filter.mp hi ] ) ( by norm_cast; linarith : ( j : ℝ ) ≤ j + 1 ) ];
              have h_dist : |ξ j - ξ (j + 1)| ≥ δ_K K := by
                apply h_min;
                · aesop;
                  use j;
                  unfold nodes at *; aesop;
                  · linarith;
                  · linarith;
                  · exact le_trans ( Real.log_le_log ( by norm_cast; linarith ) ( by norm_cast; linarith ) ) right_1;
                · exact Finset.mem_image_of_mem _ hj;
                · exact ne_of_lt ( Real.log_lt_log ( Nat.cast_pos.mpr ( Nat.pos_of_ne_zero ( by aesop_cat ) ) ) ( by norm_num ) );
              norm_num at *; linarith [ ih i hi ( by
                unfold nodes at *; aesop;
                · exact?;
                · linarith;
                · exact le_trans ( Real.log_le_log ( by norm_cast; linarith ) ( by norm_cast; linarith ) ) right_1 ) hij' ] ;
            · norm_num [ show i = j by linarith ] at *;
              contrapose! h_min;
              use ξ j, ξ (j + 1), j, hi, rfl, j + 1, hj, rfl;
              aesop;
              exact ne_of_lt ( Real.log_lt_log ( Nat.cast_pos.mpr ( Nat.pos_of_ne_zero ( by rintro rfl; exact absurd hi ( by unfold nodes; norm_num ) ) ) ) ( by norm_num ) ) a;
        cases lt_or_gt_of_ne ( show ( i : ℕ ) ≠ j from fun h => hij <| Subtype.ext h ) <;> simp_all +decide [ abs_sub_comm ];
        · rw [ abs_of_neg ] <;> aesop;
        · rw [ abs_of_nonneg ( sub_nonneg.mpr <| Nat.cast_le.mpr <| le_of_lt ‹_› ) ];
          simpa only [ abs_sub_comm ] using h_dist _ _ j.2 i.2 ‹_›;
      exact h_dist;
    -- For any $i$, $\sum_{j \neq i} \exp(- (i-j)^2 \delta_K^2 / (4t)) \leq 2 \sum_{p=1}^\infty \exp(- p^2 \delta_K^2 / (4t))$.
    have h_sum_bound : ∀ (i : Node K), ∑ j : Node K, (if j ≠ i then Real.exp (-((ξ j.1 - ξ i.1) ^ 2) / (4 * t)) else 0) ≤ 2 * ∑' p : ℕ, Real.exp (-(p + 1) ^ 2 * (δ_K K) ^ 2 / (4 * t)) := by
      -- For any $i$, $\sum_{j \neq i} \exp(- (i-j)^2 \delta_K^2 / (4t)) \leq \sum_{p=1}^\infty \exp(- p^2 \delta_K^2 / (4t)) + \sum_{p=1}^\infty \exp(- p^2 \delta_K^2 / (4t))$.
      intro i
      have h_split_sum : ∑ j : Node K, (if j ≠ i then Real.exp (-((ξ j.1 - ξ i.1) ^ 2) / (4 * t)) else 0) ≤ ∑ j : Node K, (if j.1 < i.1 then Real.exp (-((i.1 - j.1) ^ 2) * (δ_K K) ^ 2 / (4 * t)) else 0) + ∑ j : Node K, (if j.1 > i.1 then Real.exp (-((j.1 - i.1) ^ 2) * (δ_K K) ^ 2 / (4 * t)) else 0) := by
        rw [ ← Finset.sum_add_distrib ] ; refine' Finset.sum_le_sum fun j hj => _ ; aesop;
        · linarith;
        · gcongr;
          convert pow_le_pow_left₀ ( mul_nonneg ( show 0 ≤ δ_K K from _ ) ( abs_nonneg _ ) ) ( h_dist val_1 property_1 val property ( by aesop ) ) 2 using 1 <;> norm_num [ abs_of_nonneg, h_2 ] ; ring;
          · rw [ sq_abs ] ; ring;
          · exact le_of_lt ( delta_K_pos K hK );
        · have := h_dist val_1 property_1 val property ( by aesop ) ; simp_all +decide [ abs_of_nonneg, sub_nonneg ];
          rw [ div_le_div_iff_of_pos_right ] <;> nlinarith [ show 0 ≤ δ_K K * ( val_1 - val : ℝ ) by exact mul_nonneg ( le_of_lt ( delta_K_pos K hK ) ) ( sub_nonneg.mpr ( Nat.cast_le.mpr h_1 ) ), abs_mul_abs_self ( ξ val_1 - ξ val ) ];
        · exact False.elim <| h <| le_antisymm h_2 h_1;
      -- Let's bound the sums $\sum_{j < i} \exp(- (i-j)^2 \delta_K^2 / (4t))$ and $\sum_{j > i} \exp(- (j-i)^2 \delta_K^2 / (4t))$ separately.
      have h_sum_bound_left : ∑ j : Node K, (if j.1 < i.1 then Real.exp (-((i.1 - j.1) ^ 2) * (δ_K K) ^ 2 / (4 * t)) else 0) ≤ ∑' p : ℕ, Real.exp (-(p + 1) ^ 2 * (δ_K K) ^ 2 / (4 * t)) := by
        -- Let's bound the sum $\sum_{j < i} \exp(- (i-j)^2 \delta_K^2 / (4t))$ by considering the terms where $j < i$.
        have h_sum_bound_left : ∑ j : Node K, (if j.1 < i.1 then Real.exp (-((i.1 - j.1) ^ 2) * (δ_K K) ^ 2 / (4 * t)) else 0) ≤ ∑ j ∈ Finset.range (i.1), Real.exp (-((i.1 - j) ^ 2) * (δ_K K) ^ 2 / (4 * t)) := by
          rw [ ← Finset.sum_filter ];
          refine' le_trans _ ( Finset.sum_le_sum_of_subset_of_nonneg _ _ );
          rotate_left;
          exact Finset.image ( fun j : Node K => j.1 ) ( Finset.filter ( fun j : Node K => j.1 < i.1 ) Finset.univ );
          · exact Finset.image_subset_iff.mpr fun x hx => Finset.mem_range.mpr <| Finset.mem_filter.mp hx |>.2;
          · exact fun _ _ _ => Real.exp_nonneg _;
          · rw [ Finset.sum_image ] ; aesop;
        -- Let's bound the sum $\sum_{j < i} \exp(- (i-j)^2 \delta_K^2 / (4t))$ by considering the terms where $j < i$ and using the fact that $\exp(- (i-j)^2 \delta_K^2 / (4t))$ is decreasing.
        have h_sum_bound_left' : ∑ j ∈ Finset.range (i.1), Real.exp (-((i.1 - j) ^ 2) * (δ_K K) ^ 2 / (4 * t)) ≤ ∑ j ∈ Finset.range (i.1), Real.exp (-((j + 1) ^ 2) * (δ_K K) ^ 2 / (4 * t)) := by
          rw [ ← Finset.sum_range_reflect ];
          exact Finset.sum_le_sum fun x hx => by rw [ Nat.cast_sub <| Nat.le_sub_one_of_lt <| Finset.mem_range.mp hx ] ; rw [ Nat.cast_sub <| by linarith [ Finset.mem_range.mp hx ] ] ; push_cast ; ring_nf; norm_num;
        refine le_trans h_sum_bound_left <| le_trans h_sum_bound_left' <| Summable.sum_le_tsum ( Finset.range ( i.1 ) ) ( fun _ _ => Real.exp_nonneg _ ) ?_;
        have h_summable : Summable (fun j : ℕ => Real.exp (-j * (δ_K K) ^ 2 / (4 * t))) := by
          have h_summable : Summable (fun j : ℕ => (Real.exp (-δ_K K ^ 2 / (4 * t))) ^ j) := by
            exact summable_geometric_of_lt_one ( by positivity ) ( by rw [ Real.exp_lt_one_iff ] ; exact div_neg_of_neg_of_pos ( neg_lt_zero.mpr ( sq_pos_of_pos ( delta_K_pos K hK ) ) ) ( by positivity ) );
          exact h_summable.congr fun j => by rw [ ← Real.exp_nat_mul ] ; ring;
        exact Summable.of_nonneg_of_le ( fun _ => Real.exp_nonneg _ ) ( fun n => Real.exp_le_exp.mpr <| by rw [ div_le_div_iff_of_pos_right <| by positivity ] ; nlinarith [ sq ( n : ℝ ) ] ) h_summable
      have h_sum_bound_right : ∑ j : Node K, (if j.1 > i.1 then Real.exp (-((j.1 - i.1) ^ 2) * (δ_K K) ^ 2 / (4 * t)) else 0) ≤ ∑' p : ℕ, Real.exp (-(p + 1) ^ 2 * (δ_K K) ^ 2 / (4 * t)) := by
        -- Let's bound the sum $\sum_{j > i} \exp(- (j-i)^2 \delta_K^2 / (4t))$.
        have h_sum_bound_right : ∑ j : Node K, (if j.1 > i.1 then Real.exp (-((j.1 - i.1) ^ 2) * (δ_K K) ^ 2 / (4 * t)) else 0) ≤ ∑ p ∈ Finset.range (Nat.floor (Real.exp K) + 1 - i.1), Real.exp (-(p + 1) ^ 2 * (δ_K K) ^ 2 / (4 * t)) := by
          have h_sum_bound_right : ∑ j : Node K, (if j.1 > i.1 then Real.exp (-((j.1 - i.1) ^ 2) * (δ_K K) ^ 2 / (4 * t)) else 0) ≤ ∑ p ∈ Finset.Ico (i.1 + 1) (Nat.floor (Real.exp K) + 1), Real.exp (-(p - i.1) ^ 2 * (δ_K K) ^ 2 / (4 * t)) := by
            have h_sum_bound_right : ∑ j : Node K, (if j.1 > i.1 then Real.exp (-((j.1 - i.1) ^ 2) * (δ_K K) ^ 2 / (4 * t)) else 0) ≤ ∑ p ∈ Finset.filter (fun p => p > i.1) (Finset.range (Nat.floor (Real.exp K) + 1)), Real.exp (-(p - i.1) ^ 2 * (δ_K K) ^ 2 / (4 * t)) := by
              have h_sum_bound_right : Finset.image (fun j : Node K => j.1) (Finset.filter (fun j : Node K => j.1 > i.1) Finset.univ) ⊆ Finset.filter (fun p => p > i.1) (Finset.range (Nat.floor (Real.exp K) + 1)) := by
                simp +decide [ Finset.subset_iff ];
                exact fun x hx hx' => ⟨ Finset.mem_range.mp ( Finset.mem_filter.mp hx |>.1 ), hx' ⟩;
              rw [ ← Finset.sum_filter ];
              refine' le_trans _ ( Finset.sum_le_sum_of_subset_of_nonneg h_sum_bound_right fun _ _ _ => Real.exp_nonneg _ );
              rw [ Finset.sum_image ] ; aesop;
            convert h_sum_bound_right using 1;
            simp +zetaDelta at *;
            rcongr x ; aesop;
          refine le_trans h_sum_bound_right ?_;
          rw [ Finset.sum_Ico_eq_sum_range ] ; norm_num [ add_comm, add_left_comm, add_assoc ];
          rw [ show ( 1 + ⌊Real.exp K⌋₊ - ( i + 1 ) : ℕ ) = ( 1 + ⌊Real.exp K⌋₊ - i ) - 1 from by omega ] ; ring_nf ; norm_num;
          exact le_trans ( Finset.sum_le_sum_of_subset_of_nonneg ( Finset.range_mono ( Nat.sub_le _ _ ) ) fun _ _ _ => Real.exp_nonneg _ ) ( Finset.sum_le_sum fun _ _ => Real.exp_le_exp.mpr <| by nlinarith );
        refine le_trans h_sum_bound_right <| Summable.sum_le_tsum _ ?_ ?_;
        · exact fun _ _ => Real.exp_nonneg _;
        · have h_geo_series : Summable (fun p : ℕ => Real.exp (-p * (δ_K K) ^ 2 / (4 * t))) := by
            have h_geo_series : Summable (fun p : ℕ => (Real.exp (-δ_K K ^ 2 / (4 * t))) ^ p) := by
              exact summable_geometric_of_lt_one ( by positivity ) ( by rw [ Real.exp_lt_one_iff ] ; exact div_neg_of_neg_of_pos ( neg_lt_zero.mpr ( sq_pos_of_pos ( delta_K_pos K hK ) ) ) ( by positivity ) );
            exact h_geo_series.congr fun p => by rw [ ← Real.exp_nat_mul ] ; ring;
          refine Summable.of_nonneg_of_le ( fun p => Real.exp_nonneg _ ) ( fun p => ?_ ) h_geo_series;
          bound;
          · nlinarith;
          · norm_num;
      linarith;
    -- Now consider the sum $\sum_{p=1}^\infty \exp(- p^2 \delta_K^2 / (4t))$.
    have h_geo_series : ∑' p : ℕ, Real.exp (-(p + 1) ^ 2 * (δ_K K) ^ 2 / (4 * t)) ≤ Real.exp (-(δ_K K) ^ 2 / (4 * t)) / (1 - Real.exp (-(δ_K K) ^ 2 / (4 * t))) := by
      have h_geo_series : ∑' p : ℕ, Real.exp (-(p + 1) ^ 2 * (δ_K K) ^ 2 / (4 * t)) ≤ ∑' p : ℕ, Real.exp (-(δ_K K) ^ 2 / (4 * t)) * (Real.exp (-(δ_K K) ^ 2 / (4 * t))) ^ p := by
        refine' Summable.tsum_le_tsum _ _ _;
        · intro i; rw [ ← Real.exp_nat_mul, ← Real.exp_add ] ; ring_nf; norm_num;
          nlinarith [ show 0 ≤ ( i : ℝ ) * δ_K K ^ 2 * t⁻¹ by positivity ];
        · have h_geo_series : Summable (fun p : ℕ => Real.exp (-(p + 1) * (δ_K K) ^ 2 / (4 * t))) := by
            have h_geo_series : Summable (fun p : ℕ => (Real.exp (-(δ_K K) ^ 2 / (4 * t))) ^ p) := by
              norm_num +zetaDelta at *;
              exact div_neg_of_neg_of_pos ( neg_neg_of_pos ( sq_pos_of_pos ( delta_K_pos K hK ) ) ) ( by positivity );
            norm_num +zetaDelta at *;
            convert Summable.comp_injective ( summable_geometric_of_lt_one ( by positivity ) ( Real.exp_lt_one_iff.mpr h_geo_series ) ) ( show Function.Injective ( fun p : ℕ => p + 1 ) from fun p q h => by simpa using h ) using 2 ; norm_num [ ← Real.exp_nat_mul ] ; ring;
          exact h_geo_series.of_nonneg_of_le ( fun p => by positivity ) fun p => by gcongr ; nlinarith;
        · exact Summable.mul_left _ ( summable_geometric_of_lt_one ( by positivity ) ( by rw [ Real.exp_lt_one_iff ] ; exact div_neg_of_neg_of_pos ( neg_lt_zero.mpr ( sq_pos_of_pos ( delta_K_pos K hK ) ) ) ( by positivity ) ) );
      rw [ tsum_mul_left, tsum_geometric_of_lt_one ( by positivity ) ( by rw [ Real.exp_lt_one_iff ] ; exact div_neg_of_neg_of_pos ( neg_lt_zero.mpr ( sq_pos_of_pos ( show 0 < δ_K K from delta_K_pos K hK ) ) ) ( by positivity ) ) ] at * ; ring_nf at * ; aesop;
      exact Eq.trans_le ( by congr; ext; ring ) h_geo_series;
    unfold S_K; aesop;
    · simpa only [ mul_div_assoc ] using le_trans ( h_sum_bound x x_1 ) ( mul_le_mul_of_nonneg_left h_geo_series zero_le_two );
    · exact div_nonneg ( mul_nonneg zero_le_two ( Real.exp_nonneg _ ) ) ( sub_nonneg.2 ( Real.exp_le_one_iff.2 <| by exact div_nonpos_of_nonpos_of_nonneg ( neg_nonpos.2 <| sq_nonneg _ ) <| by positivity ) )

/-
The row sum of the absolute values of the entries of T_P is bounded.
-/
lemma T_P_row_sum_bound (K : ℝ) (t : ℝ) (hK : K ≥ 1) (ht : t > 0) (i : Node K) :
  ∑ j : Node K, |T_P_matrix K t i j| ≤ w_max + w_max * S_K K t := by
    -- Applying the bounds for T_P(i,j), we get:
    have row_sum_T_P : ∀ i : Node K, ∑ j : Node K, |T_P_matrix K t i j| ≤ w_max + w_max * ∑ j ∈ Finset.univ, if j = i then 0 else Real.exp (-((ξ j.1 - ξ i.1)^2) / (4 * t)) := by
      -- Applying the bounds for $w_RKHS$ and $exp(-(ξ_i - ξ_j)^2 / (4t))$.
      have h_bound : ∀ i j : Node K, |T_P_matrix K t i j| ≤ w_max * Real.exp (-((ξ j.1 - ξ i.1)^2) / (4 * t)) := by
        -- Since $w_RKHS(n) \leq w_{max}$, we have $\sqrt{w_RKHS(i)} \sqrt{w_RKHS(j)} \leq w_{max}$.
        have h_sqrt_bound : ∀ i j : Node K, Real.sqrt (w_RKHS i.1) * Real.sqrt (w_RKHS j.1) ≤ w_max := by
          have h_sqrt_bound : ∀ n : ℕ, Real.sqrt (w_RKHS n) ≤ Real.sqrt w_max := by
            exact fun n => Real.sqrt_le_sqrt <| w_RKHS_le_w_max n;
          exact fun i j => le_trans ( mul_le_mul ( h_sqrt_bound _ ) ( h_sqrt_bound _ ) ( by positivity ) ( by positivity ) ) ( by rw [ Real.mul_self_sqrt ( by exact div_nonneg zero_le_two ( Real.exp_nonneg _ ) ) ] );
        unfold T_P_matrix; aesop; ring_nf at *; aesop;
        rw [ abs_of_nonneg ( Real.sqrt_nonneg _ ), abs_of_nonneg ( Real.sqrt_nonneg _ ) ] ; nlinarith [ h_sqrt_bound val_1 property_1 val_2 property_2, Real.exp_pos ( ξ val_1 * ξ val_2 * t⁻¹ * 2⁻¹ + ξ val_1 ^ 2 * t⁻¹ * ( -1 / 4 ) + ξ val_2 ^ 2 * t⁻¹ * ( -1 / 4 ) ) ] ;
      intro i; refine le_trans ( Finset.sum_le_sum fun j _ => h_bound i j ) ?_; simp +decide [ Finset.sum_ite, Finset.filter_ne' ];
      norm_num [ mul_sub, Finset.mul_sum _ _ _ ];
    -- By definition of $S_K$, we know that $\sum_{j \ne i} \exp(-(ξ j - ξ i)^2 / (4t)) \leq S_K(t)$.
    have S_K_le : ∀ i : Node K, ∑ j ∈ Finset.univ, (if j = i then 0 else Real.exp (-((ξ j.1 - ξ i.1)^2) / (4 * t))) ≤ S_K K t := by
      intro i; unfold S_K; aesop;
      refine' Finset.le_max' _ _ _ ; aesop;
    exact le_trans ( row_sum_T_P i ) ( add_le_add_left ( mul_le_mul_of_nonneg_left ( S_K_le i ) ( by exact div_nonneg zero_le_two ( Real.exp_nonneg _ ) ) ) _ )

/-
Schur test for matrix operator norm.
-/
lemma l2_opNorm_le_of_row_col_sum_bound {n : Type*} [Fintype n] (A : Matrix n n ℝ) (C_row C_col : ℝ) (h_row : 0 ≤ C_row) (h_col : 0 ≤ C_col)
    (h_row_sum : ∀ i, ∑ j, |A i j| ≤ C_row) (h_col_sum : ∀ j, ∑ i, |A i j| ≤ C_col) :
    ‖(Matrix.toEuclideanLin A).toContinuousLinearMap‖ ≤ Real.sqrt (C_row * C_col) := by
      refine' ContinuousLinearMap.opNorm_le_bound _ _ _ <;> aesop
      generalize_proofs at *;
      · positivity;
      · -- By the properties of the Euclidean norm and the Cauchy-Schwarz inequality, we have:
        have h_norm : ∀ i, |(∑ j, A i j * x j)| ≤ Real.sqrt C_row * Real.sqrt (∑ j, |A i j| * |x j|^2) := by
          intro i;
          -- Applying the Cauchy-Schwarz inequality, we get:
          have h_cauchy_schwarz : (∑ j, A i j * x j)^2 ≤ (∑ j, |A i j|) * (∑ j, |A i j| * |x j|^2) := by
            -- Applying the Cauchy-Schwarz inequality to the sums.
            have h_cauchy_schwarz : (∑ j, A i j * x j)^2 ≤ (∑ j, |A i j| * |x j|)^2 := by
              exact le_of_abs_le ( by simpa [ abs_mul ] using pow_le_pow_left₀ ( abs_nonneg _ ) ( Finset.abs_sum_le_sum_abs ( fun j => A i j * x j ) ( Finset.univ : Finset n ) ) 2 );
            -- Applying the Cauchy-Schwarz inequality to the sums, we get:
            have h_cauchy_schwarz : (∑ j, |A i j| * |x j|)^2 ≤ (∑ j, |A i j|) * (∑ j, |A i j| * |x j|^2) := by
              have h_cauchy_schwarz : ∀ (u v : n → ℝ), (∑ j, u j * v j)^2 ≤ (∑ j, u j^2) * (∑ j, v j^2) := by
                exact?
              convert h_cauchy_schwarz ( fun j => Real.sqrt ( |A i j| ) ) ( fun j => Real.sqrt ( |A i j| ) * |x j| ) using 3 <;> ring <;> norm_num [ Real.sq_sqrt ( abs_nonneg _ ) ] ; ring;
              ring;
            linarith;
          simpa only [ ← Real.sqrt_mul h_row ] using Real.abs_le_sqrt ( h_cauchy_schwarz.trans ( mul_le_mul_of_nonneg_right ( h_row_sum i ) ( Finset.sum_nonneg fun _ _ => mul_nonneg ( abs_nonneg _ ) ( sq_nonneg _ ) ) ) );
        -- By the properties of the Euclidean norm and the Cauchy-Schwarz inequality, we have $\sum_{i} |A_{ij}| |x_j|^2 \leq C_{col} \|x\|^2$.
        have h_sum_norm : ∑ i, ∑ j, |A i j| * |x j|^2 ≤ C_col * ‖x‖^2 := by
          rw [ Finset.sum_comm ];
          -- By the properties of the Euclidean norm and the Cauchy-Schwarz inequality, we have $\sum_{i} |A_{ij}| |x_j|^2 \leq C_{col} \|x\|^2$ for each $j$.
          have h_sum_norm : ∀ j, ∑ i, |A i j| * |x j|^2 ≤ C_col * |x j|^2 := by
            exact fun j => by rw [ ← Finset.sum_mul ] ; exact mul_le_mul_of_nonneg_right ( h_col_sum j ) ( sq_nonneg _ ) ;
          convert Finset.sum_le_sum fun j _ => h_sum_norm j using 1 ; simp +decide [ EuclideanSpace.norm_eq, Real.sq_sqrt <| Finset.sum_nonneg fun _ _ => sq_nonneg _ ] ; ring!;
          rw [ Finset.mul_sum _ _ _ ];
        -- By combining the results from h_norm and h_sum_norm, we get:
        have h_combined : ∑ i, |(∑ j, A i j * x j)|^2 ≤ C_row * C_col * ‖x‖^2 := by
          refine' le_trans ( Finset.sum_le_sum fun i _ => pow_le_pow_left₀ ( abs_nonneg _ ) ( h_norm i ) 2 ) _;
          simp +decide only [mul_pow, Real.sq_sqrt (h_row)];
          rw [ ← Finset.mul_sum _ _ _ ] ; rw [ mul_assoc ] ; rw [ Finset.sum_congr rfl fun i _ => Real.sq_sqrt <| Finset.sum_nonneg fun j _ => mul_nonneg ( abs_nonneg _ ) <| sq_nonneg _ ] ; exact mul_le_mul_of_nonneg_left h_sum_norm h_row;
        rw [ ← Real.sqrt_mul h_row ];
        convert Real.sqrt_le_sqrt h_combined using 1 <;> norm_num [ EuclideanSpace.norm_eq ] ; ring!;

/-
Bound for the operator norm of T_P.
-/
lemma T_P_norm_bound (K : ℝ) (t : ℝ) (hK : K ≥ 1) (ht : t > 0) :
  T_P_norm K t ≤ w_max + w_max * S_K K t := by
    -- Let C = `w_max + w_max * S_K K t`.
    set C := w_max + w_max * S_K K t;
    -- By the Schur test, we have that the operator norm of T_P is bounded by the square root of the product of the row and column sums.
    have h_schur : ‖(Matrix.toEuclideanLin (T_P_matrix K t)).toContinuousLinearMap‖ ≤ Real.sqrt (C * C) := by
      apply l2_opNorm_le_of_row_col_sum_bound;
      · refine' add_nonneg ( div_nonneg zero_le_two ( Real.exp_nonneg _ ) ) ( mul_nonneg ( div_nonneg zero_le_two ( Real.exp_nonneg _ ) ) _ );
        unfold S_K; aesop;
        norm_num [ Finset.max' ];
        exact ⟨ _, h.choose_spec, Finset.sum_nonneg fun _ _ => by positivity ⟩;
      · refine' add_nonneg ( by exact div_nonneg zero_le_two <| Real.exp_nonneg _ ) ( mul_nonneg ( by exact div_nonneg zero_le_two <| Real.exp_nonneg _ ) _ );
        unfold S_K;
        norm_num +zetaDelta at *;
        split_ifs <;> first | positivity | exact Finset.max'_mem _ _ |> fun x => Finset.mem_image.mp x |> fun ⟨ y, _, hy ⟩ => hy ▸ Finset.sum_nonneg fun _ _ => by positivity;
      · exact?;
      · -- By definition of $T_P$, we know that its entries are symmetric.
        have h_symm : ∀ i j : Node K, T_P_matrix K t i j = T_P_matrix K t j i := by
          unfold T_P_matrix; intros; ring;
        intro j; convert T_P_row_sum_bound K t hK ht j using 1; simp +decide [ h_symm ] ;
    rw [ Real.sqrt_mul_self ] at h_schur;
    · exact h_schur;
    · refine' add_nonneg _ _ <;> norm_num [ w_max ];
      · positivity;
      · refine' mul_nonneg ( by positivity ) ( _ );
        unfold S_K;
        field_simp;
        split_ifs <;> [ exact Finset.max'_mem _ _ |> fun x => Finset.mem_image.mp x |> fun ⟨ n, hn, hn' ⟩ => hn'.symm ▸ Finset.sum_nonneg fun _ _ => by positivity; ; norm_num ]

/-
For K ≥ 1, there exists t > 0 and ρ < 1 such that ‖T_P‖ ≤ ρ.
-/
theorem RKHS_contraction (K : ℝ) (hK : K ≥ 1) :
  ∃ t > 0, ∃ ρ < 1, T_P_norm K t ≤ ρ := by
    -- Choose $\rho = \frac{1 + w_{max}}{2} < 1$.
    set ρ := (1 + w_max) / 2 with hρ_def
    have hρ_lt_one : ρ < 1 := by
      -- Since $w_{max} = \frac{2}{e}$, we have $ρ = \frac{1 + \frac{2}{e}}{2} = \frac{e + 2}{2e}$.
      have hρ_val : ρ = (Real.exp 1 + 2) / (2 * Real.exp 1) := by
        unfold w_max at *; ring_nf at *; aesop;
      rw [ hρ_val, div_lt_iff₀ ] <;> have := Real.exp_one_gt_d9.le <;> norm_num at * <;> linarith;
    -- Choose $t$ such that $e^{-\delta_K^2/(4t)} = \frac{\rho/w_{max} - 1}{2 + (\rho/w_{max} - 1)}$.
    obtain ⟨t, ht⟩ : ∃ t > 0, Real.exp (- (δ_K K)^2 / (4 * t)) = (ρ / w_max - 1) / (2 + (ρ / w_max - 1)) := by
      -- Let $q = \frac{\rho}{w_{max}} - 1$.
      set q := (ρ / w_max - 1) with hq_def
      have hq_pos : 0 < q := by
        simp +zetaDelta at *;
        rw [ lt_div_iff₀ ] <;> linarith [ show 0 < w_max from by exact div_pos zero_lt_two <| Real.exp_pos 1 ];
      use (δ_K K)^2 / (-4 * Real.log (q / (2 + q)));
      aesop;
      · exact div_pos ( sq_pos_of_pos ( delta_K_pos K hK ) ) ( neg_pos_of_neg ( mul_neg_of_pos_of_neg ( by norm_num ) ( Real.log_neg ( by rw [ lt_div_iff₀ ] <;> linarith ) ( by rw [ div_lt_iff₀ ] <;> linarith ) ) ) );
      · rw [ ← Real.exp_log ( show 0 < ( ( 1 + w_max ) / 2 / w_max - 1 ) / ( 2 + ( ( 1 + w_max ) / 2 / w_max - 1 ) ) from div_pos ( sub_pos.mpr hq_pos ) ( by linarith ) ) ];
        ring_nf; norm_num [ ne_of_gt ( show 0 < δ_K K from delta_K_pos K hK ) ] ;
    -- With this choice of $t$, we have $S_K(t) \leq \frac{2(\rho / w_{max} - 1)}{1 - (\rho / w_{max} - 1)} = \rho / w_{max} - 1$.
    have hS_K_bound : S_K K t ≤ ρ / w_max - 1 := by
      -- Apply the bound from Lemma 2.
      have hS_K_bound : S_K K t ≤ 2 * Real.exp (- (δ_K K)^2 / (4 * t)) / (1 - Real.exp (- (δ_K K)^2 / (4 * t))) := by
        convert S_K_bound K t hK ht.1 using 1;
      convert hS_K_bound using 1;
      rw [ eq_div_iff ] <;> nlinarith [ show 0 < w_max from by exact div_pos zero_lt_two <| Real.exp_pos 1, div_mul_cancel₀ ( ( 1 + w_max ) / 2 ) <| show w_max ≠ 0 from by exact ne_of_gt <| div_pos zero_lt_two <| Real.exp_pos 1, div_mul_cancel₀ ( ( ( 1 + w_max ) / 2 / w_max - 1 ) ) <| show ( 2 + ( ( 1 + w_max ) / 2 / w_max - 1 ) ) ≠ 0 from by nlinarith [ show 0 < w_max from by exact div_pos zero_lt_two <| Real.exp_pos 1, div_mul_cancel₀ ( ( 1 + w_max ) / 2 ) <| show w_max ≠ 0 from by exact ne_of_gt <| div_pos zero_lt_two <| Real.exp_pos 1 ] ];
    refine' ⟨ t, ht.1, ρ, hρ_lt_one, _ ⟩;
    refine le_trans ( T_P_norm_bound K t hK ht.1 ) ?_;
    nlinarith [ show 0 < w_max from by exact div_pos zero_lt_two <| Real.exp_pos 1, mul_div_cancel₀ ρ <| show w_max ≠ 0 from by exact ne_of_gt <| div_pos zero_lt_two <| Real.exp_pos 1 ]