/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: dd21a597-b222-4033-a958-903ad48c690e

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Checking Complex.Gamma
-/
#check Complex.Gamma

/-
Definition of digamma function as the logarithmic derivative of Gamma
-/
noncomputable def digamma (z : ℂ) : ℂ := (deriv Complex.Gamma z) / (Complex.Gamma z)

/-
Definition of base density a(ξ) = log(π) - Re(ψ(1/4 + iπξ))
-/
noncomputable def a (ξ : ℝ) : ℝ := Real.log Real.pi - (digamma (1/4 + Complex.I * Real.pi * ξ)).re

/-
Definition of cutoff function (1 - |ξ|/B)_+
-/
noncomputable def cutoff (B : ℝ) (ξ : ℝ) : ℝ := max 0 (1 - |ξ| / B)

/-
Definition of weighted integral A_0(B, t_sym)
-/
noncomputable def A_0 (B t_sym : ℝ) : ℝ :=
  ∫ ξ in Set.Ioo (-B) B, a ξ * cutoff B ξ * Real.exp (-4 * Real.pi^2 * t_sym * ξ^2)

/-
Definition of weighted integral L_int(B, t_sym)
-/
noncomputable def L_int (B t_sym : ℝ) : ℝ :=
  ∫ ξ in Set.Ioo (-B) B, |a ξ| * |ξ| * cutoff B ξ * Real.exp (-4 * Real.pi^2 * t_sym * ξ^2)

/-
Definition of uniform constant A_*(t_sym) := inf_{B ≥ B_min} A_0(B, t_sym)
-/
noncomputable def A_star (B_min t_sym : ℝ) : ℝ := sInf { A_0 B t_sym | B ≥ B_min }

/-
Definition of uniform constant L_*(t_sym) := sup_{B ≥ B_min} L_int(B, t_sym)
-/
noncomputable def L_star (B_min t_sym : ℝ) : ℝ := sSup { L_int B t_sym | B ≥ B_min }

/-
Definition of uniform constant c_* := A_*(t_sym) - π · L_*(t_sym)
-/
noncomputable def c_star (B_min t_sym : ℝ) : ℝ := A_star B_min t_sym - Real.pi * L_star B_min t_sym

/-
Definitions of constants t_sym, C_SB, M_0^unif, t_rkhs^unif
-/
noncomputable def t_sym_val : ℝ := 3 / 50

noncomputable def C_SB : ℝ := 4

noncomputable def M_0_unif (B_min : ℝ) : ℕ := ⌈(2 * Real.pi * C_SB * L_star B_min t_sym_val) / c_star B_min t_sym_val⌉.toNat

noncomputable def t_rkhs_unif (B_min : ℝ) : ℝ := (1 / (8 * Real.pi^2)) * (1 / 2 + 4 * Real.exp (1 / 4) / c_star B_min t_sym_val)

/-
Value of B_min, assumed to be 1 based on context
-/
noncomputable def B_min_val : ℝ := 1

/-
Value of the real part of digamma at 1/4
-/
theorem digamma_one_quarter_re : (digamma (1 / 4)).re = -Real.eulerMascheroniConstant - Real.pi / 2 - 3 * Real.log 2 := by
  -- Use the definitions of digamma and digamma_add_one to simplify the expression.
  unfold digamma at *; simp_all +decide [ Complex.ext_iff, Complex.exp_re, Complex.exp_im ] ; ring_nf at * ; norm_num at *;
  -- Use the reflection formula for the digamma function: $\psi(1-z) - \psi(z) = \pi \cot(\pi z)$.
  have h_reflection : ∀ z : ℂ, z.re > 0 ∧ z.re < 1 → (deriv Complex.Gamma z / Complex.Gamma z) - (deriv Complex.Gamma (1 - z) / Complex.Gamma (1 - z)) = -Real.pi * Complex.cos (Real.pi * z) / Complex.sin (Real.pi * z) := by
    -- Use the fact that the digamma function satisfies the reflection formula: $\psi(1-z) - \psi(z) = \pi \cot(\pi z)$.
    have h_reflection : ∀ z : ℂ, z.re > 0 ∧ z.re < 1 → deriv (fun z => Complex.Gamma z * Complex.Gamma (1 - z)) z = Complex.Gamma z * deriv Complex.Gamma (1 - z) * (-1) + deriv Complex.Gamma z * Complex.Gamma (1 - z) := by
      intro z hz
      have h_diff : DifferentiableAt ℂ Complex.Gamma z ∧ DifferentiableAt ℂ Complex.Gamma (1 - z) := by
        constructor;
        · apply_rules [ Complex.differentiableAt_Gamma ];
          exact fun m => ne_of_apply_ne Complex.re <| by norm_num; linarith;
        · refine' Complex.differentiableAt_Gamma _ _;
          intro m hm; norm_num [ Complex.ext_iff ] at hm; linarith;
      convert HasDerivAt.deriv ( HasDerivAt.mul ( h_diff.1.hasDerivAt ) ( HasDerivAt.comp z ( h_diff.2.hasDerivAt ) ( hasDerivAt_id' z |> HasDerivAt.const_sub 1 ) ) ) using 1 ; ring!;
    -- Use the fact that $\Gamma(z) \Gamma(1-z) = \frac{\pi}{\sin(\pi z)}$.
    have h_gamma_reflection : ∀ z : ℂ, z.re > 0 ∧ z.re < 1 → Complex.Gamma z * Complex.Gamma (1 - z) = Real.pi / Complex.sin (Real.pi * z) := by
      exact fun z hz => Complex.Gamma_mul_Gamma_one_sub z ▸ by ring;
    -- Use the fact that the derivative of $\frac{\pi}{\sin(\pi z)}$ is $-\frac{\pi^2 \cos(\pi z)}{\sin^2(\pi z)}$.
    have h_deriv_gamma_reflection : ∀ z : ℂ, z.re > 0 ∧ z.re < 1 → deriv (fun z => Real.pi / Complex.sin (Real.pi * z)) z = -Real.pi^2 * Complex.cos (Real.pi * z) / Complex.sin (Real.pi * z)^2 := by
      intro z hz;
      convert HasDerivAt.deriv ( HasDerivAt.div ( hasDerivAt_const _ _ ) ( HasDerivAt.comp z ( Complex.hasDerivAt_sin _ ) ( HasDerivAt.const_mul _ ( hasDerivAt_id z ) ) ) _ ) using 1 <;> norm_num [ mul_comm ] ; ring;
      rw [ Complex.sin_eq_zero_iff ];
      exact fun ⟨ k, hk ⟩ => by rcases k with ⟨ _ | k ⟩ <;> norm_num [ Complex.ext_iff ] at hk <;> nlinarith [ Real.pi_pos ] ;
    -- By combining the results from h_reflection, h_gamma_reflection, and h_deriv_gamma_reflection, we can conclude the proof.
    intros z hz
    have h_eq : Complex.Gamma z * deriv Complex.Gamma (1 - z) * (-1) + deriv Complex.Gamma z * Complex.Gamma (1 - z) = -Real.pi^2 * Complex.cos (Real.pi * z) / Complex.sin (Real.pi * z)^2 := by
      rw [ ← h_deriv_gamma_reflection z hz, ← h_reflection z hz, show deriv ( fun z => Complex.Gamma z * Complex.Gamma ( 1 - z ) ) z = deriv ( fun z => ( Real.pi : ℂ ) / Complex.sin ( Real.pi * z ) ) z from Filter.EventuallyEq.deriv_eq <| Filter.eventuallyEq_of_mem ( IsOpen.mem_nhds ( isOpen_Ioo.preimage Complex.continuous_re ) hz ) fun x hx => h_gamma_reflection x hx ];
    have h_eq : deriv Complex.Gamma z / Complex.Gamma z - deriv Complex.Gamma (1 - z) / Complex.Gamma (1 - z) = (-Real.pi^2 * Complex.cos (Real.pi * z) / Complex.sin (Real.pi * z)^2) / (Complex.Gamma z * Complex.Gamma (1 - z)) := by
      rw [ ← h_eq, div_sub_div ] <;> ring <;> norm_num [ Complex.Gamma_ne_zero ];
      · exact Complex.Gamma_ne_zero_of_re_pos hz.1;
      · exact Complex.Gamma_ne_zero_of_re_pos ( by norm_num; linarith );
    rw [ h_eq, h_gamma_reflection z hz ] ; ring;
    by_cases h : Complex.sin ( Real.pi * z ) = 0 <;> simp_all +decide [ sq, mul_assoc, mul_comm, mul_left_comm, Real.pi_ne_zero ];
  -- Use the duplication formula for the digamma function: $\psi(2z) = \frac{1}{2} (\psi(z) + \psi(z + 1/2)) + \log 2$.
  have h_duplication : ∀ z : ℂ, z.re > 0 → (deriv Complex.Gamma (2 * z) / Complex.Gamma (2 * z)) = (deriv Complex.Gamma z / Complex.Gamma z) / 2 + (deriv Complex.Gamma (z + 1 / 2) / Complex.Gamma (z + 1 / 2)) / 2 + Real.log 2 := by
    -- Use the duplication formula for the Gamma function: $\Gamma(2z) = 2^{2z-1} \Gamma(z) \Gamma(z + 1/2) / \sqrt{\pi}$.
    have h_duplication_gamma : ∀ z : ℂ, z.re > 0 → Complex.Gamma (2 * z) = 2 ^ (2 * z - 1) * Complex.Gamma z * Complex.Gamma (z + 1 / 2) / Real.sqrt Real.pi := by
      intro z hz
      have := Complex.Gamma_mul_Gamma_add_half z
      simp_all +decide [ Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im, Complex.cpow_def ];
      rw [ eq_div_iff ( by norm_num [ Real.sqrt_ne_zero'.mpr Real.pi_pos ] ) ] ; rw [ mul_assoc ] ; rw [ this ] ; ring;
      norm_num [ mul_assoc, ← Complex.exp_add ];
    -- Use the chain rule to differentiate the duplication formula.
    intros z hz
    have h_chain : deriv (fun z => Complex.Gamma (2 * z)) z = 2 * deriv Complex.Gamma (2 * z) := by
      convert HasDerivAt.deriv ( HasDerivAt.comp z ( Complex.differentiableAt_Gamma _ _ |> DifferentiableAt.hasDerivAt ) ( hasDerivAt_id' z |> HasDerivAt.const_mul _ ) ) using 1 ; norm_num [ mul_comm ];
      exact fun m => ne_of_apply_ne Complex.re <| by norm_num; linarith;
    -- Apply the chain rule to differentiate the right-hand side of the duplication formula.
    have h_chain_rhs : deriv (fun z => 2 ^ (2 * z - 1) * Complex.Gamma z * Complex.Gamma (z + 1 / 2) / Real.sqrt Real.pi) z = (2 ^ (2 * z - 1) * Complex.Gamma z * Complex.Gamma (z + 1 / 2) / Real.sqrt Real.pi) * (2 * Real.log 2 + deriv Complex.Gamma z / Complex.Gamma z + deriv Complex.Gamma (z + 1 / 2) / Complex.Gamma (z + 1 / 2)) := by
      apply_rules [ HasDerivAt.deriv ];
      convert HasDerivAt.div_const ( HasDerivAt.mul ( HasDerivAt.mul ( HasDerivAt.cpow ( hasDerivAt_const _ _ ) ( HasDerivAt.sub ( HasDerivAt.const_mul _ ( hasDerivAt_id z ) ) ( hasDerivAt_const _ _ ) ) _ ) ( Complex.differentiableAt_Gamma _ _ |> DifferentiableAt.hasDerivAt ) ) ( Complex.differentiableAt_Gamma _ _ |> DifferentiableAt.hasDerivAt |> HasDerivAt.comp _ <| HasDerivAt.add ( hasDerivAt_id z ) <| hasDerivAt_const _ _ ) ) _ using 1 <;> norm_num [ Complex.Gamma_ne_zero, hz.ne' ] ; ring;
      · field_simp;
        rw [ div_eq_iff ( mul_ne_zero ( Complex.Gamma_ne_zero_of_re_pos hz ) ( Complex.Gamma_ne_zero_of_re_pos ( by norm_num; linarith ) ) ) ] ; ring;
      · exact fun m => ne_of_apply_ne Complex.re <| by norm_num; linarith;
      · intro m; intro H; norm_num [ Complex.ext_iff ] at H; linarith [ show ( m : ℝ ) ≥ 0 by positivity ] ;
    -- Equate the derivatives from the chain rule and the duplication formula.
    have h_eq : 2 * deriv Complex.Gamma (2 * z) = (2 ^ (2 * z - 1) * Complex.Gamma z * Complex.Gamma (z + 1 / 2) / Real.sqrt Real.pi) * (2 * Real.log 2 + deriv Complex.Gamma z / Complex.Gamma z + deriv Complex.Gamma (z + 1 / 2) / Complex.Gamma (z + 1 / 2)) := by
      rw [ ← h_chain_rhs, ← h_chain ];
      exact Filter.EventuallyEq.deriv_eq ( by filter_upwards [ IsOpen.mem_nhds ( isOpen_lt continuous_const Complex.continuous_re ) hz ] with x hx using h_duplication_gamma x hx );
    rw [ h_duplication_gamma z hz ];
    rw [ div_eq_iff ] <;> norm_num [ Complex.Gamma_ne_zero, Real.sqrt_ne_zero'.mpr Real.pi_pos ] at * ; linear_combination h_eq / 2;
    exact ⟨ Complex.Gamma_ne_zero_of_re_pos hz, Complex.Gamma_ne_zero_of_re_pos ( by norm_num; linarith ) ⟩;
  -- Use the fact that $\psi(1/2) = -\gamma - 2 \log 2$.
  have h_psi_half : (deriv Complex.Gamma (1 / 2) / Complex.Gamma (1 / 2)).re = -Real.eulerMascheroniConstant - 2 * Real.log 2 := by
    -- Use the fact that $\psi(1/2) = -\gamma - 2 \log 2$ from the provided solution.
    have h_psi_half : (deriv Complex.Gamma (1 / 2) / Complex.Gamma (1 / 2)) = -Real.eulerMascheroniConstant - 2 * Real.log 2 := by
      have := @Complex.hasDerivAt_Gamma_one_half
      rw [ this.deriv, div_eq_iff ] <;> norm_num [ Complex.Gamma_one_half_eq ] ; ring;
      norm_num [ ← Complex.ofReal_cpow, Real.sqrt_eq_rpow ] ; ring;
      norm_num [ Complex.ofReal_cpow, Real.pi_pos.le ] ; ring;
    norm_num [ h_psi_half ];
    norm_num [ Complex.log_re ];
  -- Apply the reflection formula with $z = 1/4$.
  have h_reflection_1_4 : (deriv Complex.Gamma (1 / 4) / Complex.Gamma (1 / 4)) - (deriv Complex.Gamma (3 / 4) / Complex.Gamma (3 / 4)) = -Real.pi := by
    convert h_reflection ( 1 / 4 ) ⟨ by norm_num, by norm_num ⟩ using 1 ; norm_num [ mul_div ];
    norm_num [ mul_div ];
    norm_cast ; norm_num [ mul_div ];
    ring_nf; norm_num [ Real.pi_ne_zero ];
  -- Apply the duplication formula with $z = 1/4$.
  have h_duplication_1_4 : (deriv Complex.Gamma (1 / 2) / Complex.Gamma (1 / 2)) = (deriv Complex.Gamma (1 / 4) / Complex.Gamma (1 / 4)) / 2 + (deriv Complex.Gamma (3 / 4) / Complex.Gamma (3 / 4)) / 2 + Real.log 2 := by
    convert h_duplication ( 1 / 4 ) ( by norm_num ) using 1 <;> ring;
  norm_num [ Complex.ext_iff ] at *;
  norm_num [ Complex.log_re, Complex.log_im ] at *;
  norm_num [ div_eq_mul_inv ] at * ; linarith!

/-
Value of a(0)
-/
theorem a_zero_val : a 0 = Real.log Real.pi + Real.eulerMascheroniConstant + Real.pi / 2 + 3 * Real.log 2 := by
  unfold a; norm_num [ digamma_one_quarter_re ] ; ring;

/-
Summability of the digamma series
-/
noncomputable def digamma_series_term (z : ℂ) (n : ℕ) : ℂ := 1 / (n + 1 : ℂ) - 1 / (n + z)

theorem digamma_series_summable (z : ℂ) (hz : ∀ n : ℕ, z ≠ -n) : Summable (digamma_series_term z) := by
  -- Since $|z - 1|$ is a constant, the series $\sum_{n=0}^{\infty} \frac{|z - 1|}{(n + 1) |n + z|}$ converges if and only if $\sum_{n=0}^{\infty} \frac{1}{(n + 1) |n + z|}$ converges.
  have h_summable : Summable (fun n : ℕ => 1 / ((n + 1) * ‖n + z‖)) := by
    -- We'll use the comparison test. Since $|n + z| \geq |n| - |z|$, we can find a lower bound for $|n + z|$.
    have h_lower_bound : ∃ N : ℕ, ∀ n ≥ N, ‖n + z‖ ≥ (n : ℝ) / 2 := by
      use Nat.ceil ( 2 * ‖z‖ + 1 ), fun n hn => ?_ ; norm_num [ Complex.normSq, Complex.norm_def ] at *;
      exact Real.le_sqrt_of_sq_le ( by nlinarith [ sq_nonneg ( z.re + n / 2 ), Real.sqrt_nonneg ( z.re * z.re + z.im * z.im ), Real.mul_self_sqrt ( add_nonneg ( mul_self_nonneg z.re ) ( mul_self_nonneg z.im ) ) ] );
    -- Using the lower bound, we can find an upper bound for the terms of the series.
    obtain ⟨N, hN⟩ : ∃ N : ℕ, ∀ n ≥ N, 1 / ((n + 1) * ‖n + z‖) ≤ 2 / ((n + 1) * n) := by
      obtain ⟨ N, hN ⟩ := h_lower_bound; use N + 1; intro n hn; rw [ div_le_div_iff₀ ] <;> nlinarith [ show ( n : ℝ ) ≥ N + 1 by exact_mod_cast hn, hN n ( by linarith ), show ( ‖ ( n : ℂ ) + z‖ : ℝ ) ≥ 0 by positivity ] ;
    -- The series $\sum_{n=N}^{\infty} \frac{2}{(n+1)n}$ is a convergent p-series with $p=2$.
    have h_pseries : Summable (fun n : ℕ => 2 / ((n + 1) * n : ℝ)) := by
      ring_nf;
      exact Summable.mul_right _ <| Summable.of_nonneg_of_le ( fun n => by positivity ) ( fun n => by cases n <;> norm_num ; gcongr ; nlinarith ) <| Real.summable_one_div_nat_pow.2 one_lt_two;
    rw [ ← summable_nat_add_iff N ] at *;
    exact Summable.of_nonneg_of_le ( fun n => by positivity ) ( fun n => hN _ ( by linarith ) ) h_pseries;
  refine' .of_norm _;
  convert h_summable.mul_left ‖z - 1‖ using 2 ; norm_num [ digamma_series_term ];
  rw [ inv_sub_inv ] <;> norm_num <;> ring;
  · norm_cast ; ring;
  · exact mod_cast by positivity;
  · exact fun h => hz _ <| by linear_combination' h