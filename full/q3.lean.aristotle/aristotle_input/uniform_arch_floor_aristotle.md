/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 091e7a36-e0aa-46b3-acb0-c34e24adfde1

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of the digamma function as the logarithmic derivative of the Gamma function.
-/
noncomputable def digamma (z : ℂ) : ℂ := (deriv Complex.Gamma z) / (Complex.Gamma z)

/-
Definition of the base density a(ξ) = log(π) - Re(ψ(1/4 + iπξ)).
-/
noncomputable def base_density (ξ : ℝ) : ℝ := Real.log Real.pi - (digamma (1/4 + Complex.I * Real.pi * ξ)).re

/-
Definition of the weighted integral A_0(B, t_sym).
-/
noncomputable def A_0 (B t_sym : ℝ) : ℝ := ∫ ξ in -B..B, base_density ξ * (max 0 (1 - |ξ|/B)) * Real.exp (-4 * Real.pi^2 * t_sym * ξ^2)

/-
Definition of the weighted integral L_int(B, t_sym).
-/
noncomputable def L_int (B t_sym : ℝ) : ℝ := ∫ ξ in -B..B, |base_density ξ| * |ξ| * (max 0 (1 - |ξ|/B)) * Real.exp (-4 * Real.pi^2 * t_sym * ξ^2)

/-
Definition of A_*(t_sym) := inf_{B ≥ B_min} A_0(B, t_sym).
-/
noncomputable def A_star (B_min t_sym : ℝ) : ℝ := sInf (Set.image (fun B => A_0 B t_sym) (Set.Ici B_min))

/-
Definition of L_*(t_sym) := sup_{B ≥ B_min} L_int(B, t_sym).
-/
noncomputable def L_star (B_min t_sym : ℝ) : ℝ := sSup (Set.image (fun B => L_int B t_sym) (Set.Ici B_min))

/-
Definition of c_* := A_*(t_sym) - π · L_*(t_sym).
-/
noncomputable def c_star (B_min t_sym : ℝ) : ℝ := A_star B_min t_sym - Real.pi * L_star B_min t_sym

/-
Definitions of t_sym = 0.06 and C_SB = 4.
-/
noncomputable def t_sym_val : ℝ := 3 / 50
noncomputable def C_SB : ℝ := 4

/-
Definition of M_0^unif := ⌈(2π · C_SB · L_*(t_sym)) / c_*⌉.
-/
noncomputable def M_0_unif (B_min t_sym : ℝ) : ℕ := Nat.ceil ((2 * Real.pi * C_SB * L_star B_min t_sym) / c_star B_min t_sym)

/-
Definition of t_rkhs^unif := (1/(8π²)) · (1/2 + 4·e^{1/4}/c_*).
-/
noncomputable def t_rkhs_unif (B_min t_sym : ℝ) : ℝ := (1 / (8 * Real.pi ^ 2)) * (1 / 2 + 4 * Real.exp (1 / 4) / c_star B_min t_sym)

/-
Lemma: Gap Positivity. c_* ≥ 811/1000 > 0.
-/
theorem gap_positivity (B_min : ℝ) (hA : A_star B_min t_sym_val ≥ 1867 / 1000) (hL : L_star B_min t_sym_val ≤ 42 / 125) : c_star B_min t_sym_val ≥ 811 / 1000 := by
  -- Using the provided bounds, we can derive that $c_* \geq 1867/1000 - \pi \cdot (42/125)$.
  have h_c_star_bound : c_star B_min (t_sym_val) ≥ 1867 / 1000 - Real.pi * (42 / 125) := by
    exact sub_le_sub hA ( mul_le_mul_of_nonneg_left hL <| Real.pi_pos.le );
  refine le_trans ?_ h_c_star_bound;
  have h_pi_bound : Real.pi < 3.1416 := by
    exact?;
  norm_num at h_pi_bound ; linarith

/-
Proposition 8.5 (Mean minus modulus): min f ≥ mean f - π * L.
-/
theorem mean_minus_modulus (f : ℝ → ℝ) (L : ℝ) (h_per : Function.Periodic f (2 * Real.pi)) (h_lip : LipschitzWith (Real.nnabs L) f) (hL : L ≥ 0) :
    ∀ x, f x ≥ (1 / (2 * Real.pi)) * ∫ t in 0..2*Real.pi, f t - Real.pi * L := by
      -- Let's choose any $x \in \mathbb{R}$.
      intro x
      -- By definition of $f$, we know that $f(x) \geq \frac{1}{2\pi} \int_0^{2\pi} f(t) dt - \pi L$.
      suffices h' : f x ≥ (1 / (2 * Real.pi)) * (∫ t in (0 : ℝ)..2 * Real.pi, f t) - Real.pi * L by
        rw [ intervalIntegral.integral_sub ] <;> norm_num;
        · convert h'.le using 1 ; ring_nf ; norm_num [ Real.pi_ne_zero ];
          norm_num [ sq, Real.pi_ne_zero ];
        · exact h_lip.continuous.intervalIntegrable _ _;
      -- By Lemma 25, for any $x \in \mathbb{R}$, we have $f(x) \geq \frac{1}{2\pi} \int_{-\pi}^{\pi} f(x+t) dt - \pi L$.
      have h_lemma25 : ∀ x, f x ≥ (1 / (2 * Real.pi)) * (∫ t in (-Real.pi)..Real.pi, f (x + t)) - Real.pi * L := by
        -- By Lemma 25, for any $x \in \mathbb{R}$, we have $f(x) \geq \frac{1}{2\pi} \int_{-\pi}^{\pi} f(x+t) dt - \pi L$. Use this fact.
        intros x
        have h_integral_bound : ∫ t in (-Real.pi)..Real.pi, f (x + t) ≤ ∫ t in (-Real.pi)..Real.pi, f x + L * |t| := by
          refine' intervalIntegral.integral_mono_on _ _ _ _ <;> norm_num;
          · positivity;
          · exact Continuous.intervalIntegrable ( by exact h_lip.continuous.comp ( continuous_const.add continuous_id' ) ) _ _;
          · exact Continuous.intervalIntegrable ( by continuity ) _ _;
          · exact fun t ht₁ ht₂ => by have := h_lip.dist_le_mul ( x + t ) x; simp_all +decide [ abs_of_nonneg, Real.pi_pos.le ] ; nlinarith [ abs_le.mp this ] ;
        -- Evaluate the integral $\int_{-\pi}^{\pi} (f(x) + L|t|) dt$.
        have h_integral_eval : ∫ t in (-Real.pi)..Real.pi, (f x + L * |t|) = 2 * Real.pi * f x + L * (Real.pi ^ 2) := by
          rw [ intervalIntegral.integral_add ] <;> norm_num;
          · -- Evaluate the integral $\int_{-\pi}^{\pi} |t| dt$.
            have h_integral_abs : ∫ t in (-Real.pi)..Real.pi, |t| = (∫ t in (-Real.pi)..0, |t|) + (∫ t in (0)..Real.pi, |t|) := by
              rw [ intervalIntegral.integral_add_adjacent_intervals ] <;> exact Continuous.intervalIntegrable ( by continuity ) _ _;
            rw [ h_integral_abs, intervalIntegral.integral_congr fun t ht => abs_of_nonpos ( by linarith [ Set.mem_Icc.mp ( by simpa [ Real.pi_pos.le ] using ht ) ] ), intervalIntegral.integral_congr fun t ht => abs_of_nonneg ( by linarith [ Set.mem_Icc.mp ( by simpa [ Real.pi_pos.le ] using ht ) ] ) ] ; norm_num ; ring;
            rw [ intervalIntegral.integral_neg ] ; norm_num ; ring;
          · exact Continuous.intervalIntegrable ( by continuity ) _ _;
        rw [ div_mul_eq_mul_div, ge_iff_le, sub_le_iff_le_add ];
        rw [ div_le_iff₀ ] <;> nlinarith [ Real.pi_pos ];
      -- By periodicity, we have $\int_{-\pi}^{\pi} f(x+t) dt = \int_{0}^{2\pi} f(t) dt$.
      have h_periodic_integral : ∀ x, ∫ t in (-Real.pi)..Real.pi, f (x + t) = ∫ t in (0)..2 * Real.pi, f t := by
        intro x; rw [ intervalIntegral.integral_comp_add_left ] ; ring;
        -- By periodicity, we can split the integral into two parts:
        have h_split : ∫ x in (x - Real.pi)..x + Real.pi, f x = (∫ x in (x - Real.pi)..0, f x) + (∫ x in (0)..x + Real.pi, f x) := by
          rw [ intervalIntegral.integral_add_adjacent_intervals ] <;> apply_rules [ Continuous.intervalIntegrable, h_lip.continuous ];
        -- By periodicity, we can shift the interval of integration:
        have h_shift : ∫ x in (x - Real.pi)..0, f x = ∫ x in (x + Real.pi)..2 * Real.pi, f x := by
          convert intervalIntegral.integral_comp_add_right _ ( 2 * Real.pi ) using 2 <;> ring;
          exact funext fun x => by rw [ mul_comm, h_per ] ;
        rw [ h_split, h_shift, mul_comm ];
        rw [ add_comm, intervalIntegral.integral_add_adjacent_intervals ] <;> apply_rules [ Continuous.intervalIntegrable, h_lip.continuous ];
      simpa only [ h_periodic_integral ] using h_lemma25 x

/-
Lemma: Uniform Archimedean Floor (8.17'). For every B ≥ B_min and the corresponding Archimedean symbol P_A: min_{θ ∈ T} P_A(θ) ≥ c_*.
-/
theorem uniform_archimedean_floor (B_min t_sym : ℝ) (h_pi : 0 < Real.pi)
  (h_B_min : B_min > 0)
  (B : ℝ) (hB : B ≥ B_min)
  (P_A : ℝ → ℝ)
  (h_per : Function.Periodic P_A (2 * Real.pi))
  (h_mean : (1 / (2 * Real.pi)) * ∫ t in 0..2*Real.pi, P_A t = A_0 B t_sym)
  (h_lip : LipschitzWith (Real.nnabs (L_int B t_sym)) P_A)
  (h_L_int_nonneg : 0 ≤ L_int B t_sym)
  (h_A_bdd : BddBelow (Set.image (fun B => A_0 B t_sym) (Set.Ici B_min)))
  (h_L_bdd : BddAbove (Set.image (fun B => L_int B t_sym) (Set.Ici B_min))) :
  ∀ θ, P_A θ ≥ c_star B_min t_sym := by
    -- Apply `mean_minus_modulus` to get `P_A θ ≥ A_0(B, t_sym) - π * L_int(B, t_sym)`.
    have hP_A_ge_A_minus_pi_L : ∀ θ, P_A θ ≥ A_0 B t_sym - Real.pi * L_int B t_sym := by
      intro θ;
      have := mean_minus_modulus P_A ( L_int B t_sym ) h_per h_lip h_L_int_nonneg;
      convert this θ using 1;
      rw [ intervalIntegral.integral_sub ] <;> norm_num [ h_mean.symm ];
      · grind;
      · exact h_lip.continuous.intervalIntegrable _ _;
    refine fun θ => le_trans ?_ ( hP_A_ge_A_minus_pi_L θ );
    exact sub_le_sub ( csInf_le h_A_bdd <| Set.mem_image_of_mem _ <| show B ∈ Set.Ici B_min from hB ) ( mul_le_mul_of_nonneg_left ( le_csSup h_L_bdd <| Set.mem_image_of_mem _ <| show B ∈ Set.Ici B_min from hB ) <| Real.pi_pos.le )

/-
Definition of the k-th Fourier coefficient of a 2π-periodic function f.
-/
noncomputable def fourier_coeff (f : ℝ → ℝ) (k : ℤ) : ℂ := (1 / (2 * Real.pi)) * ∫ x in 0..2*Real.pi, (f x : ℂ) * Complex.exp (-Complex.I * k * x)

/-
Definition of the Toeplitz matrix of size n generated by the symbol f.
-/
noncomputable def ToeplitzMatrix (n : ℕ) (f : ℝ → ℝ) : Matrix (Fin n) (Fin n) ℂ := fun i j => fourier_coeff f ((i : ℤ) - (j : ℤ))

/-
Lemma: Uniform Archimedean Floor (8.17'). For every B ≥ B_min and the corresponding Archimedean symbol P_A: min_{θ ∈ T} P_A(θ) ≥ c_*.
-/
theorem uniform_archimedean_floor_v2 (B_min t_sym : ℝ) (h_pi : 0 < Real.pi)
  (h_B_min : B_min > 0)
  (B : ℝ) (hB : B ≥ B_min)
  (P_A : ℝ → ℝ)
  (h_per : Function.Periodic P_A (2 * Real.pi))
  (h_mean : (1 / (2 * Real.pi)) * ∫ t in 0..2*Real.pi, P_A t = A_0 B t_sym)
  (h_lip : LipschitzWith (Real.nnabs (L_int B t_sym)) P_A)
  (h_L_int_nonneg : 0 ≤ L_int B t_sym)
  (h_A_bdd : BddBelow (Set.image (fun B => A_0 B t_sym) (Set.Ici B_min)))
  (h_L_bdd : BddAbove (Set.image (fun B => L_int B t_sym) (Set.Ici B_min))) :
  ∀ θ, P_A θ ≥ c_star B_min t_sym := by
    exact?

/-
Definition of the minimum eigenvalue of a Hermitian matrix.
-/
noncomputable def min_eigenvalue {n : ℕ} (A : Matrix (Fin n) (Fin n) ℂ) (hA : A.IsHermitian) : ℝ :=
  if h : 0 < n then
    (Finset.univ.image (Matrix.IsHermitian.eigenvalues hA)).min' (by
    exact ⟨ _, Finset.mem_image_of_mem _ ( Finset.mem_univ ⟨ 0, h ⟩ ) ⟩)
  else 0

/-
Definition of the minimum eigenvalue of a Hermitian matrix. Returns 0 if n=0.
-/
noncomputable def min_eigenvalue_def {n : ℕ} (A : Matrix (Fin n) (Fin n) ℂ) (hA : A.IsHermitian) : ℝ :=
  if h : 0 < n then
    (Finset.univ.image (Matrix.IsHermitian.eigenvalues hA)).min' (by
    exact ⟨ _, Finset.mem_image_of_mem _ ( Finset.mem_univ ⟨ 0, h ⟩ ) ⟩)
  else 0

/-
Lemma: The Toeplitz matrix of a real-valued symbol is Hermitian.
-/
theorem toeplitz_is_hermitian {n : ℕ} (f : ℝ → ℝ) : (ToeplitzMatrix n f).IsHermitian := by
  unfold ToeplitzMatrix;
  ext i j; simp +decide [ fourier_coeff, Complex.exp_neg ] ; ring;
  norm_num [ intervalIntegral.integral_of_le, Real.pi_pos.le ];
  rw [ ← integral_conj ] ; congr ; ext ; norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im ] ; ring;
  exact Or.inl ⟨ by rw [ ← Real.cos_neg ] ; ring, by rw [ ← Real.sin_neg ] ; ring ⟩