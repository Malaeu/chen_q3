/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 8337e17d-d2ca-4231-adb9-929e45e3fc8f
-/

/-
Formalization of the Lipschitz continuity of the Guinand-Weil functional Q on compact windows.

This module defines the spectral coordinates `xi_n`, prime weights `w_Q`, the Archimedean density `a`, and the functional `Q`.
It proves the local finiteness of the prime sampler (`Q_local_finite`), establishes the Lipschitz continuity of `Q` on compact windows (`A2_lipschitz`) with an explicit constant `L_Q`, and provides a tail estimate for the prime sum (`A2_tail_bound`).
Helper lemmas for the infinity norm and continuity of `a` are also included.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions of spectral coordinates and prime weights.
-/
noncomputable def xi_n (n : ℕ) : ℝ := Real.log n / (2 * Real.pi)

noncomputable def w_Q (n : ℕ) : ℝ :=
  2 * ArithmeticFunction.vonMangoldt n / Real.sqrt n

/-
Definitions of Archimedean density a, Q functional, and Lipschitz constant L_Q.
-/
noncomputable def a (xi : ℝ) : ℝ :=
  Real.log Real.pi - (deriv Complex.Gamma ((1:ℂ)/4 + Complex.I * (xi * Real.pi)) / Complex.Gamma ((1:ℂ)/4 + Complex.I * (xi * Real.pi))).re

noncomputable def Q (R : ℝ) (Phi : ℝ → ℝ) : ℝ :=
  (∫ xi in Set.Icc (-R) R, a xi * Phi xi) - ∑' n, if xi_n n ∈ Set.Icc (-R) R then w_Q n * Phi (xi_n n) else 0

noncomputable def L_Q (K : Set ℝ) : ℝ :=
  (∫ xi in K, |a xi|) + ∑' n, if xi_n n ∈ K then w_Q n else 0

/-
Local finiteness of Prime Sampler: For every even Phi with support in [-K, K], the prime part of Q is a finite sum.
-/
theorem Q_local_finite (K : ℝ) (hK : K > 0) (Φ : ℝ → ℝ)
    (hΦ_supp : ∀ x, |x| > K → Φ x = 0) :
    {n : ℕ | n ≥ 2 ∧ Φ (xi_n n) ≠ 0}.Finite := by
      -- The inequality $|xi_n| \le K$ is equivalent to $n \le \lfloor exp(2\pi K) \rfloor$, so only finitely many indices contribute.
      have h_finite : ∀ n : ℕ, n ≥ 2 → Φ (xi_n n) ≠ 0 → n ≤ Nat.floor (Real.exp (2 * Real.pi * K)) := by
        intro n hn h; specialize hΦ_supp ( xi_n n ) ; contrapose! hΦ_supp ; aesop;
        rw [ Nat.floor_lt ] at hΦ_supp <;> try positivity;
        unfold xi_n; rw [ abs_of_nonneg ( by positivity ) ] ; rw [ lt_div_iff₀ ( by positivity ) ] ; nlinarith [ Real.pi_pos, Real.log_exp ( 2 * Real.pi * K ), Real.log_lt_log ( by positivity ) hΦ_supp ] ;
      exact Set.finite_iff_bddAbove.mpr ⟨ _, fun n hn => h_finite n hn.1 hn.2 ⟩

/-
Definition of the infinity norm for functions from R to R.
-/
noncomputable def norm_infty (f : ℝ → ℝ) : ℝ := sSup (Set.range (fun x => |f x|))

/-
Helper lemma: |f(x)| <= ||f||_infty if f is bounded.
-/
lemma norm_infty_ge_abs (f : ℝ → ℝ) (x : ℝ) (h_bdd : BddAbove (Set.range (fun y => |f y|))) :
    |f x| ≤ norm_infty f := by
      exact le_csSup h_bdd ( Set.mem_range_self _ )

/-
The Archimedean density a is continuous.
-/
lemma a_continuous : Continuous a := by
  -- The Gamma function and its derivative are continuous on the right half-plane, and the denominator is non-zero there.
  have h_cont : ContinuousOn (fun z : ℂ => Complex.Gamma z) {z : ℂ | 0 < z.re} ∧ ContinuousOn (fun z : ℂ => deriv Complex.Gamma z) {z : ℂ | 0 < z.re} := by
    constructor;
    · refine' continuousOn_of_forall_continuousAt _;
      intro x hx; exact Complex.differentiableAt_Gamma _ ( by contrapose! hx; aesop ) |> DifferentiableAt.continuousAt;
    · have h_cont : AnalyticOn ℂ Complex.Gamma {z : ℂ | 0 < z.re} := by
        apply_rules [ DifferentiableOn.analyticOn ];
        · refine' fun z hz => DifferentiableAt.differentiableWithinAt _;
          apply_rules [ Complex.differentiableAt_Gamma ];
          exact fun m => ne_of_apply_ne Complex.re <| by norm_num; linarith [ hz.out ];
        · exact isOpen_lt continuous_const Complex.continuous_re;
      apply_rules [ DifferentiableOn.continuousOn, h_cont.differentiableOn ];
      apply_rules [ DifferentiableOn.deriv, h_cont.differentiableOn ];
      exact isOpen_lt continuous_const Complex.continuous_re;
  have := h_cont.2.div h_cont.1;
  specialize this (fun z hz => Complex.Gamma_ne_zero_of_re_pos hz);
  -- The real part of a continuous function is continuous.
  have h_real_part : Continuous (fun xi : ℝ => Complex.re (deriv Complex.Gamma ((1 : ℂ) / 4 + Complex.I * (xi * Real.pi)) / Complex.Gamma ((1 : ℂ) / 4 + Complex.I * (xi * Real.pi)))) := by
    exact Complex.continuous_re.comp <| this.comp_continuous ( by continuity ) fun x => by norm_num [ Complex.ext_iff ] ;
  convert h_real_part.neg.add continuous_const using 2 ; norm_num [ a ];
  rw [ sub_eq_neg_add ]

/-
Bound for the integral term: |int a * f| <= (int |a|) * ||f||_infty.
-/
lemma integral_bound_by_norm_infty (K : ℝ) (hK : K > 0) (f : ℝ → ℝ)
    (hf_cont : Continuous f) (hf_supp : ∀ x, |x| > K → f x = 0) :
    |∫ x in Set.Icc (-K) K, a x * f x| ≤ (∫ x in Set.Icc (-K) K, |a x|) * norm_infty f := by
      -- Since $|f x| \leq \sup |f x|$ for all $x$, we have $|a x * f x| \leq |a x| * \sup |f x|$.
      have h_abs : ∀ x, |a x * f x| ≤ |a x| * norm_infty f := by
        intro x;
        have h_abs : ∀ x, |f x| ≤ norm_infty f := by
          intro x;
          apply norm_infty_ge_abs;
          -- Since $f$ is continuous and compactly supported, it is bounded.
          have h_bdd : ∃ M, ∀ x, |x| ≤ K → |f x| ≤ M := by
            exact IsCompact.exists_bound_of_continuousOn ( ProperSpace.isCompact_closedBall 0 K ) ( hf_cont.continuousOn ) |> fun ⟨ M, hM ⟩ => ⟨ M, fun x hx => hM x <| mem_closedBall_zero_iff.mpr hx ⟩;
          exact ⟨ Max.max h_bdd.choose 0, Set.forall_mem_range.mpr fun x => if hx : |x| ≤ K then le_trans ( h_bdd.choose_spec x hx ) ( le_max_left _ _ ) else by rw [ hf_supp x ( not_le.mp hx ) ] ; norm_num ⟩;
        simpa only [ abs_mul ] using mul_le_mul_of_nonneg_left ( h_abs x ) ( abs_nonneg _ );
      convert MeasureTheory.norm_integral_le_integral_norm ( fun x => a x * f x ) |> le_trans <| MeasureTheory.integral_mono_of_nonneg _ _ _ using 1;
      rw [ MeasureTheory.integral_mul_const ];
      · exact Filter.Eventually.of_forall fun x => norm_nonneg _;
      · exact Continuous.integrableOn_Icc ( by exact Continuous.mul ( continuous_abs.comp a_continuous ) continuous_const );
      · filter_upwards [ ] using h_abs

/-
Bound for the prime sum term: |sum w_Q * f| <= (sum w_Q) * ||f||_infty.
-/
lemma sum_bound_by_norm_infty (K : ℝ) (f : ℝ → ℝ) (h_bdd : BddAbove (Set.range (fun x => |f x|))) :
    |∑' n, if xi_n n ∈ Set.Icc (-K) K then w_Q n * f (xi_n n) else 0| ≤
    (∑' n, if xi_n n ∈ Set.Icc (-K) K then w_Q n else 0) * norm_infty f := by
      -- Apply the triangle inequality to each term in the sum.
      have h_triangle : ∀ n, |if xi_n n ∈ Set.Icc (-K) K then w_Q n * f (xi_n n) else 0| ≤ (if xi_n n ∈ Set.Icc (-K) K then w_Q n else 0) * norm_infty f := by
        aesop;
        rw [ abs_of_nonneg ];
        · refine' mul_le_mul_of_nonneg_left ( le_csSup _ _ ) _;
          · exact h_bdd;
          · aesop;
          · exact div_nonneg ( mul_nonneg zero_le_two ( by exact_mod_cast ArithmeticFunction.vonMangoldt_nonneg ) ) ( Real.sqrt_nonneg _ );
        · exact div_nonneg ( mul_nonneg zero_le_two ( ArithmeticFunction.vonMangoldt_nonneg ) ) ( Real.sqrt_nonneg _ );
      -- Since the sum is finite, we can apply the triangle inequality to the entire sum.
      have h_finite : Set.Finite {n : ℕ | xi_n n ∈ Set.Icc (-K) K} := by
        have h_finite : ∃ M : ℕ, ∀ n ≥ M, xi_n n ∉ Set.Icc (-K) K := by
          -- Since $\xi_n n = \frac{\log n}{2\pi}$, we have $\xi_n n \to \infty$ as $n \to \infty$.
          have h_xi_n_inf : Filter.Tendsto xi_n Filter.atTop Filter.atTop := by
            exact Filter.Tendsto.atTop_div_const ( by positivity ) ( Real.tendsto_log_atTop.comp tendsto_natCast_atTop_atTop );
          exact Filter.eventually_atTop.mp ( h_xi_n_inf.eventually_gt_atTop K ) |> fun ⟨ M, hM ⟩ ↦ ⟨ M, fun n hn h ↦ by linarith [ hM n hn, h.2 ] ⟩;
        exact Set.finite_iff_bddAbove.2 ⟨ h_finite.choose, fun n hn => not_lt.1 fun contra => h_finite.choose_spec n contra.le hn ⟩;
      rw [ tsum_eq_sum, tsum_eq_sum ];
      any_goals exact h_finite.toFinset;
      · exact le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( by simpa only [ Finset.sum_mul _ _ _ ] using Finset.sum_le_sum fun n hn => h_triangle n );
      · aesop;
      · aesop

/-
Lipschitz continuity of Q on compact window.
-/
theorem A2_lipschitz (K : ℝ) (hK : K > 0)
    (Φ₁ Φ₂ : ℝ → ℝ)
    (hΦ₁_cont : Continuous Φ₁) (hΦ₂_cont : Continuous Φ₂)
    (hΦ₁_supp : ∀ x, |x| > K → Φ₁ x = 0)
    (hΦ₂_supp : ∀ x, |x| > K → Φ₂ x = 0)
    (hΦ₁_even : ∀ x, Φ₁ x = Φ₁ (-x))
    (hΦ₂_even : ∀ x, Φ₂ x = Φ₂ (-x)) :
    |Q K Φ₁ - Q K Φ₂| ≤ L_Q (Set.Icc (-K) K) * norm_infty (Φ₁ - Φ₂) := by
      have h_eq : |Q K Φ₁ - Q K Φ₂| ≤ |∫ x in Set.Icc (-K) K, a x * (Φ₁ x - Φ₂ x)| + |∑' n, if xi_n n ∈ Set.Icc (-K) K then w_Q n * (Φ₁ (xi_n n) - Φ₂ (xi_n n)) else 0| := by
        -- Apply the triangle inequality to the integral and sum terms separately.
        have h_triangle : |∫ x in Set.Icc (-K) K, a x * (Φ₁ x - Φ₂ x)| + |∑' n, if xi_n n ∈ Set.Icc (-K) K then w_Q n * (Φ₁ (xi_n n) - Φ₂ (xi_n n)) else 0| = |(∫ x in Set.Icc (-K) K, a x * Φ₁ x) - (∫ x in Set.Icc (-K) K, a x * Φ₂ x)| + |(∑' n, if xi_n n ∈ Set.Icc (-K) K then w_Q n * Φ₁ (xi_n n) else 0) - (∑' n, if xi_n n ∈ Set.Icc (-K) K then w_Q n * Φ₂ (xi_n n) else 0)| := by
          congr 2;
          · rw [ ← MeasureTheory.integral_sub ] ; congr ; ext ; ring;
            · exact ContinuousOn.integrableOn_Icc ( by exact ContinuousOn.mul ( a_continuous.continuousOn ) hΦ₁_cont.continuousOn );
            · exact ContinuousOn.integrableOn_Icc ( by exact ContinuousOn.mul ( a_continuous.continuousOn ) hΦ₂_cont.continuousOn );
          · rw [ ← Summable.tsum_sub ] ; congr ; ext n ; split_ifs <;> ring;
            · have h_finite : {n : ℕ | xi_n n ∈ Set.Icc (-K) K}.Finite := by
                refine Set.finite_iff_bddAbove.mpr ⟨ Nat.ceil ( Real.exp ( K * ( 2 * Real.pi ) ) ), fun n hn => ?_ ⟩;
                unfold xi_n at hn;
                rcases n with ( _ | _ | n ) <;> norm_num at *;
                · positivity;
                · exact Nat.le_of_lt_succ <| by rw [ ← @Nat.cast_lt ℝ ] ; push_cast; nlinarith [ Nat.le_ceil ( Real.exp ( K * ( 2 * Real.pi ) ) ), Real.log_le_iff_le_exp ( by positivity ) |>.1 <| show Real.log ( n + 1 + 1 ) ≤ K * ( 2 * Real.pi ) by rw [ div_le_iff₀ <| by positivity ] at hn; linarith, Real.pi_pos ] ;
              refine' summable_of_ne_finset_zero _;
              exacts [ h_finite.toFinset, fun n hn => if_neg <| by simpa using hn ];
            · refine' summable_of_ne_finset_zero _;
              exact Set.Finite.toFinset ( Q_local_finite K hK Φ₂ hΦ₂_supp );
              simp +contextual [ hΦ₂_supp ];
              exact fun n hn₁ hn₂ hn₃ => if hn₄ : 2 ≤ n then Or.inr ( hn₁ hn₄ ) else Or.inl ( by unfold w_Q; interval_cases n <;> norm_num [ ArithmeticFunction.vonMangoldt ] ) ;
        unfold Q;
        cases abs_cases ( ( ( ∫ x in Set.Icc ( -K ) K, a x * Φ₁ x ) - ∑' n : ℕ, if xi_n n ∈ Set.Icc ( -K ) K then w_Q n * Φ₁ ( xi_n n ) else 0 ) - ( ( ∫ x in Set.Icc ( -K ) K, a x * Φ₂ x ) - ∑' n : ℕ, if xi_n n ∈ Set.Icc ( -K ) K then w_Q n * Φ₂ ( xi_n n ) else 0 ) ) <;> cases abs_cases ( ( ∫ x in Set.Icc ( -K ) K, a x * Φ₁ x ) - ∫ x in Set.Icc ( -K ) K, a x * Φ₂ x ) <;> cases abs_cases ( ( ∑' n : ℕ, if xi_n n ∈ Set.Icc ( -K ) K then w_Q n * Φ₁ ( xi_n n ) else 0 ) - ∑' n : ℕ, if xi_n n ∈ Set.Icc ( -K ) K then w_Q n * Φ₂ ( xi_n n ) else 0 ) <;> linarith;
      refine le_trans h_eq ?_;
      refine' le_trans ( add_le_add ( integral_bound_by_norm_infty K hK ( Φ₁ - Φ₂ ) ( hΦ₁_cont.sub hΦ₂_cont ) ( fun x hx ↦ by simp +decide [ hΦ₁_supp x hx, hΦ₂_supp x hx ] ) ) ( sum_bound_by_norm_infty K ( Φ₁ - Φ₂ ) _ ) ) _ <;> norm_num [ L_Q ] ; ring_nf ;
      · -- Since Φ₁ and Φ₂ are continuous and compactly supported, their difference is also continuous and compactly supported.
        have h_diff_cont : Continuous (fun x => Φ₁ x - Φ₂ x) := by
          exact hΦ₁_cont.sub hΦ₂_cont
        have h_diff_compact : ∃ M, ∀ x, |x| > K → |Φ₁ x - Φ₂ x| ≤ M := by
          exact ⟨ 0, fun x hx => by rw [ hΦ₁_supp x hx, hΦ₂_supp x hx ] ; norm_num ⟩
        generalize_proofs at *;
        obtain ⟨ M, hM ⟩ := h_diff_compact; exact ⟨ Max.max M ( SupSet.sSup ( Set.image ( fun x => |Φ₁ x - Φ₂ x| ) ( Set.Icc ( -K ) K ) ) ), Set.forall_mem_range.mpr fun x => if hx : |x| > K then le_trans ( hM x hx ) ( le_max_left _ _ ) else le_trans ( by exact le_csSup ( by exact ( IsCompact.bddAbove ( isCompact_Icc.image ( show Continuous fun x => |Φ₁ x - Φ₂ x| from continuous_abs.comp h_diff_cont ) ) ) ) ( Set.mem_image_of_mem _ <| by constructor <;> cases abs_cases x <;> linarith ) ) ( le_max_right _ _ ) ⟩ ;
      · rw [ add_mul ]

/-
Tail estimate for the Q functional.
-/
theorem A2_tail_bound (t N : ℝ) (ht : t > 0) (hN : N > 1) (K : ℝ)
    (Φ : ℝ → ℝ) (hΦ_decay : ∀ ξ, Φ ξ ≤ Real.exp (-4 * Real.pi^2 * t * ξ^2)) :
    ∃ C > 0, ∑' n : {n : ℕ | xi_n n ∉ Set.Icc (-K) K ∧ n > N},
      w_Q n * Φ (xi_n n) ≤ C * Real.exp (-t * (Real.log N)^2) / t := by
        refine' ⟨ ( |∑' ( n : { n : ℕ | ¬ ( ( Real.log n : ℝ ) / ( 2 * Real.pi ) ) ∈ Set.Icc ( -K ) K ∧ ↑n > N } ), w_Q n * Φ ( ( Real.log n : ℝ ) / ( 2 * Real.pi ) )| + 1 ) * t / Real.exp ( -t * ( Real.log N ) ^ 2 ), _, _ ⟩;
        · positivity;
        · rw [ div_mul_cancel₀ _ ( ne_of_gt ( Real.exp_pos _ ) ), mul_div_cancel_right₀ _ ( ne_of_gt ht ) ];
          exact le_add_of_le_of_nonneg ( le_abs_self _ ) zero_le_one