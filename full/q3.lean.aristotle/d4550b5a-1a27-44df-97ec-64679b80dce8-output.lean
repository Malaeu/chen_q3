/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d4550b5a-1a27-44df-97ec-64679b80dce8

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators Real Nat Classical Pointwise

noncomputable def HeatKernel (t : ℝ) (x : ℝ) : ℝ :=
  (4 * Real.pi * t) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / (4 * t))

noncomputable def FejerKernel (B : ℝ) (x : ℝ) : ℝ := max 0 (1 - |x| / B)

noncomputable def Atom (B t τ : ℝ) (x : ℝ) : ℝ :=
  FejerKernel B (x - τ) * HeatKernel t (x - τ) +
  FejerKernel B (x + τ) * HeatKernel t (x + τ)

def W_K (K : ℝ) : Set (ℝ → ℝ) :=
  { f | ContinuousOn f (Set.Icc (-K) K) ∧ (∀ x, f (-x) = f x) ∧ (∀ x ∈ Set.Icc (-K) K, f x ≥ 0) }

def AtomSet (K : ℝ) : Set (ℝ → ℝ) :=
  { f | ∃ B t τ, B > 0 ∧ t > 0 ∧ τ ∈ Set.Icc (-K) K ∧ f = Atom B t τ }

def diff_set (Φ : ℝ → ℝ) (g : ℝ → ℝ) (K : ℝ) : Set ℝ :=
  (fun x ↦ |Φ x - g x|) '' Set.Icc (-K) K

noncomputable def real_convolution (f g : ℝ → ℝ) (x : ℝ) : ℝ := ∫ y, f y * g (x - y)

def AtomCone_K (K : ℝ) : Set (ℝ → ℝ) :=
  (Convex.toCone (convexHull ℝ (AtomSet K)) (convex_convexHull ℝ (AtomSet K)) : Set (ℝ → ℝ))

lemma HeatKernel_integral (t : ℝ) (ht : t > 0) : ∫ x, HeatKernel t x = 1 := by
  -- The integral of the Gaussian function is given by $\sqrt{4\pi t}$.
  have h_gauss_integral : ∫ x, Real.exp (-x^2 / (4 * t)) = Real.sqrt (4 * Real.pi * t) := by
    -- The integral of the Gaussian function over the entire real line is given by the well-known result $\int_{-\infty}^{\infty} e^{-ax^2} \, dx = \sqrt{\frac{\pi}{a}}$ for $a > 0$.
    have h_gaussian : ∀ a > 0, ∫ x, Real.exp (-a * x^2) = Real.sqrt (Real.pi / a) := by
      exact fun a ha => by simpa using integral_gaussian a;
    convert h_gaussian ( 1 / ( 4 * t ) ) ( by positivity ) using 1 <;> norm_num [ div_eq_inv_mul ] ; ring;
  unfold HeatKernel;
  rw [ MeasureTheory.integral_const_mul, h_gauss_integral ];
  rw [ Real.sqrt_eq_rpow, ← Real.rpow_add ] <;> norm_num ; positivity

lemma HeatKernel_mass_concentration (δ : ℝ) (hδ : δ > 0) :
  Filter.Tendsto (fun t => ∫ x in {y | |y| > δ}, HeatKernel t x)
    (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
      -- By substitution using $ y = \frac{x}{\sqrt{t}} $, we can transform the integral.
      have h_subst : ∀ t > 0, ∫ x in {y | |y| > δ}, HeatKernel t x = ∫ y in {y | |y| > δ / Real.sqrt t}, (1 / Real.sqrt (4 * Real.pi)) * Real.exp (-y^2 / 4) := by
        intro t ht
        have h_subst : ∀ {f : ℝ → ℝ}, ∫ x in {y | |y| > δ}, f x = ∫ y in {y | |y| > δ / Real.sqrt t}, f (y * Real.sqrt t) * Real.sqrt t := by
          intro f
          have h_subst : ∀ {f : ℝ → ℝ}, ∫ x in {y | |y| > δ}, f x = ∫ y in (fun y => y * Real.sqrt t) '' {y | |y| > δ / Real.sqrt t}, f y := by
            intro f; congr; ext y; simp +decide [ abs_mul, abs_div, abs_of_pos, ht, hδ ] ; ring_nf ; aesop;
            · -- Let $a = \frac{y}{\sqrt{t}}$. Then $|a| = \left|\frac{y}{\sqrt{t}}\right| = \frac{|y|}{\sqrt{t}}$.
              use y / Real.sqrt t;
              exact ⟨ by rw [ abs_div, abs_of_nonneg ( Real.sqrt_nonneg _ ) ] ; rw [ ← div_eq_mul_inv ] ; gcongr, mul_div_cancel₀ _ ( ne_of_gt ( Real.sqrt_pos.mpr ht ) ) ⟩;
            · rw [ abs_of_pos ( Real.sqrt_pos.mpr ht ) ] ; nlinarith [ Real.sqrt_nonneg t, Real.sq_sqrt ht.le, inv_mul_cancel_left₀ ( ne_of_gt ( Real.sqrt_pos.mpr ht ) ) δ ];
          rw [ h_subst, MeasureTheory.integral_image_eq_integral_abs_deriv_smul ];
          any_goals intro x hx; exact HasDerivAt.hasDerivWithinAt ( by simpa using HasDerivAt.mul ( hasDerivAt_id x ) ( hasDerivAt_const _ _ ) );
          · norm_num [ mul_comm, abs_of_pos ( Real.sqrt_pos.mpr ht ) ];
          · exact measurableSet_lt measurable_const ( measurable_norm );
          · exact fun x hx y hy hxy => mul_right_cancel₀ ( ne_of_gt ( Real.sqrt_pos.mpr ht ) ) hxy;
        rw [ h_subst ] ; congr; ext y; unfold HeatKernel; ring ; norm_num [ ht.le, ht.ne' ] ; ring;
        rw [ Real.mul_rpow ( by positivity ) ( by positivity ), Real.mul_rpow ( by positivity ) ( by positivity ) ] ; norm_num [ Real.sqrt_eq_rpow, Real.rpow_neg, Real.pi_pos.le, ht.le ] ; ring; norm_num [ Real.pi_pos.le, ht.le ] ; ring;
        norm_num [ ← Real.sqrt_eq_rpow, ht.ne' ];
        rw [ mul_assoc, mul_inv_cancel₀ ( ne_of_gt ( Real.sqrt_pos.mpr ht ) ), mul_one ];
      -- As $t \to 0$, $\frac{\delta}{\sqrt{t}} \to \infty$, so the integral of the Gaussian over $|y| > \frac{\delta}{\sqrt{t}}$ tends to zero.
      have h_gauss_tail : Filter.Tendsto (fun a => ∫ y in {y | |y| > a}, (1 / Real.sqrt (4 * Real.pi)) * Real.exp (-y^2 / 4)) Filter.atTop (nhds 0) := by
        -- The integral of a Gaussian function over the entire real line is 1, so the integral over |y| > a tends to zero as a tends to infinity.
        have h_gauss_tail : Filter.Tendsto (fun a => ∫ y in Set.univ, (1 / Real.sqrt (4 * Real.pi)) * Real.exp (-y^2 / 4) * (if |y| > a then 1 else 0)) Filter.atTop (nhds 0) := by
          have h_gauss_tail : Filter.Tendsto (fun a => ∫ y in Set.univ, (1 / Real.sqrt (4 * Real.pi)) * Real.exp (-y^2 / 4) * (if |y| > a then 1 else 0)) Filter.atTop (nhds (∫ y in Set.univ, (1 / Real.sqrt (4 * Real.pi)) * Real.exp (-y^2 / 4) * 0)) := by
            refine' MeasureTheory.tendsto_integral_filter_of_dominated_convergence _ _ _ _ _;
            refine' fun x => 1 / Real.sqrt ( 4 * Real.pi ) * Real.exp ( -x ^ 2 / 4 );
            · exact Filter.Eventually.of_forall fun n => Measurable.aestronglyMeasurable ( by exact Measurable.mul ( by exact Continuous.measurable ( by continuity ) ) ( by exact Measurable.ite ( measurableSet_lt measurable_const ( measurable_norm ) ) measurable_const measurable_const ) );
            · filter_upwards [ Filter.eventually_gt_atTop 0 ] with n hn using Filter.Eventually.of_forall fun x => by split_ifs <;> norm_num [ abs_of_nonneg, Real.exp_nonneg, mul_nonneg, div_nonneg, Real.sqrt_nonneg ] ;
            · exact MeasureTheory.Integrable.const_mul ( by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) ) _;
            · filter_upwards [ ] with x using tendsto_const_nhds.congr' ( by filter_upwards [ Filter.eventually_gt_atTop |x| ] with n hn; aesop ; linarith );
          aesop;
        convert h_gauss_tail using 2 ; rw [ ← MeasureTheory.integral_indicator ] <;> norm_num [ Set.indicator ];
        exact measurableSet_Ioi.mem.comp measurable_norm;
      have h_lim : Filter.Tendsto (fun t => δ / Real.sqrt t) (nhdsWithin 0 (Set.Ioi 0)) Filter.atTop := by
        refine' Filter.Tendsto.const_mul_atTop hδ _;
        refine' Filter.Tendsto.inv_tendsto_nhdsGT_zero _;
        refine' Filter.Tendsto.inf _ _ <;> simpa using Real.continuous_sqrt.tendsto 0;
      exact Filter.Tendsto.congr' ( Filter.eventuallyEq_of_mem self_mem_nhdsWithin fun x hx => by aesop ) ( h_gauss_tail.comp h_lim )

lemma HeatKernel_nonneg (t : ℝ) (ht : t > 0) (x : ℝ) : 0 ≤ HeatKernel t x := by
  -- The exponential function is always positive, and the power of a positive number is also positive.
  apply mul_nonneg; apply Real.rpow_nonneg; positivity; apply Real.exp_nonneg

lemma FejerKernel_bounds (B : ℝ) (hB : B > 0) (x : ℝ) :
  0 ≤ FejerKernel B x ∧ FejerKernel B x ≤ 1 := by
    -- By definition of FejerKernel, we know that it is non-negative and less than or equal to 1 because it is the maximum of 0 and (1 - |x|/B), and (1 - |x|/B) is less than or equal to 1.
    simp [FejerKernel];
    -- Since $|x| \geq 0$ and $B > 0$, their division is non-negative.
    apply div_nonneg; exact abs_nonneg x; exact hB.le

lemma exists_compact_extension (K : ℝ) (hK : K > 0) (Φ : ℝ → ℝ)
    (hΦ_cont : ContinuousOn Φ (Set.Icc (-K) K)) :
  ∃ Ψ : ℝ → ℝ, Continuous Ψ ∧ HasCompactSupport Ψ ∧ ∀ x ∈ Set.Icc (-K) K, Ψ x = Φ x := by
    -- Extend Φ to a continuous function on ℝ with compact support using the Tietze extension theorem.
    have h_tietze : ∃ Ψ : ℝ → ℝ, Continuous Ψ ∧ ∀ x ∈ Set.Icc (-K) K, Ψ x = Φ x := by
      have := @ContinuousMap.exists_restrict_eq;
      specialize this ( isClosed_Icc ) ( ContinuousMap.mk ( fun x : Set.Icc ( -K ) K => Φ x ) ( by exact continuousOn_iff_continuous_restrict.mp hΦ_cont ) );
      exact ⟨ _, this.choose.continuous, fun x hx => by simpa using congr_arg ( fun f => f ⟨ x, hx ⟩ ) this.choose_spec ⟩;
    -- Let $\psi$ be a smooth function that is 1 on $[-K, K]$ and 0 outside $[-K-1, K+1]$.
    obtain ⟨ψ, hψ_cont, hψ_support⟩ : ∃ ψ : ℝ → ℝ, Continuous ψ ∧ (∀ x, ψ x ∈ Set.Icc 0 1) ∧ (∀ x ∈ Set.Icc (-K) K, ψ x = 1) ∧ (∀ x, |x| > K + 1 → ψ x = 0) := by
      -- Define the function ψ that is 1 on [-K, K] and 0 outside [-K-1, K+1] by using a smooth bump function.
      obtain ⟨ψ, hψ⟩ : ∃ ψ : ℝ → ℝ, Continuous ψ ∧ (∀ x, ψ x ∈ Set.Icc 0 1) ∧ (∀ x, ψ x = 1 ↔ |x| ≤ K) ∧ (∀ x, ψ x = 0 ↔ |x| ≥ K + 1) := by
        refine' ⟨ fun x => Max.max 0 ( Min.min 1 ( ( K + 1 - |x| ) / ( K + 1 - K ) ) ), _, _, _, _ ⟩ <;> norm_num;
        · fun_prop;
        · intro x; rw [ max_eq_iff ] ; aesop <;> cases min_cases ( 1 : ℝ ) ( K + 1 - |x| ) <;> cases abs_cases x <;> linarith;
      exact ⟨ ψ, hψ.1, hψ.2.1, fun x hx => hψ.2.2.1 x |>.2 <| abs_le.2 hx, fun x hx => hψ.2.2.2 x |>.2 <| le_of_lt hx ⟩;
    obtain ⟨ Ψ, hΨ_cont, hΨ_eq ⟩ := h_tietze; use fun x => Ψ x * ψ x; aesop;
    · exact hΨ_cont.mul hψ_cont;
    · rw [ hasCompactSupport_iff_eventuallyEq ];
      norm_num [ Filter.EventuallyEq ];
      exact ⟨ ⟨ -K - 2, fun x hx => Or.inr <| right x <| by cases abs_cases x <;> linarith ⟩, ⟨ K + 2, fun x hx => Or.inr <| right x <| by cases abs_cases x <;> linarith ⟩ ⟩

lemma HeatKernel_approx_identity_uniform (f : ℝ → ℝ) (hf_cont : Continuous f)
    (hf_supp : HasCompactSupport f) (ε : ℝ) (hε : ε > 0) :
  ∃ t₀ > 0, ∀ t ∈ Set.Ioo 0 t₀, ∀ x, |real_convolution f (HeatKernel t) x - f x| < ε := by
    -- By the properties of the heat kernel and the uniform continuity of $f$, we can find such a $t₀$.
    have h_uniform_cont : ∃ δ > 0, ∀ x y : ℝ, |x - y| < δ → |f x - f y| < ε / 2 := by
      have h_unif_cont : UniformContinuous f := by
        exact hf_supp.uniformContinuous_of_continuous hf_cont;
      exact Metric.uniformContinuous_iff.mp h_unif_cont ( ε / 2 ) ( half_pos hε );
    obtain ⟨ δ, hδ_pos, hδ ⟩ := h_uniform_cont;
    -- Using the fact that the heat kernel is an approximation to the identity, we can bound the integral of the convolution.
    have h_conv_bound : ∀ t > 0, ∀ x : ℝ, |real_convolution f (HeatKernel t) x - f x| ≤ ∫ y, |f (x - y) - f x| * HeatKernel t y := by
      intros t ht x;
      -- By the properties of the heat kernel and the uniform continuity of $f$, we can bound the integral of the convolution. We'll use the fact that $|a - b| \leq |a| + |b|$.
      have h_conv_bound : ∫ y, (f (x - y) - f x) * HeatKernel t y = real_convolution f (HeatKernel t) x - f x * ∫ y, HeatKernel t y := by
        simp +decide [ sub_mul, mul_sub, ← MeasureTheory.integral_const_mul ];
        rw [ MeasureTheory.integral_sub ];
        · rw [ ← MeasureTheory.integral_sub_left_eq_self ] ; congr ; ext ; ring;
        · -- Since $f$ is continuous and has compact support, it is bounded. Let $M$ be an upper bound for $|f|$.
          obtain ⟨M, hM⟩ : ∃ M, ∀ x, |f x| ≤ M := by
            have := hf_supp.exists_bound_of_continuous hf_cont;
            tauto;
          refine' MeasureTheory.Integrable.mono' _ _ _;
          refine' fun y => M * HeatKernel t y;
          · refine' MeasureTheory.Integrable.const_mul _ _;
            have := HeatKernel_integral t ht;
            exact MeasureTheory.integrable_of_integral_eq_one this;
          · refine' MeasureTheory.AEStronglyMeasurable.mul _ _;
            · exact Continuous.aestronglyMeasurable ( hf_cont.comp ( continuous_const.sub continuous_id' ) );
            · exact Continuous.aestronglyMeasurable ( by exact Continuous.mul ( continuous_const ) ( Real.continuous_exp.comp ( by continuity ) ) );
          · filter_upwards [ ] with y using by rw [ Real.norm_eq_abs, abs_mul, abs_of_nonneg ( show 0 ≤ HeatKernel t y by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ] ; exact mul_le_mul_of_nonneg_right ( hM _ ) ( show 0 ≤ HeatKernel t y by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ;
        · refine' MeasureTheory.Integrable.const_mul _ _;
          have h_integrable : ∫ x, HeatKernel t x = 1 := by
            exact HeatKernel_integral t ht;
          exact MeasureTheory.integrable_of_integral_eq_one h_integrable;
      -- By the properties of the heat kernel and the uniform continuity of $f$, we can bound the integral of the convolution. We'll use the fact that $|a - b| \leq |a| + |b|$ and the triangle inequality.
      have h_conv_bound : |∫ y, (f (x - y) - f x) * HeatKernel t y| ≤ ∫ y, |f (x - y) - f x| * HeatKernel t y := by
        convert MeasureTheory.norm_integral_le_integral_norm ( _ : ℝ → ℝ ) using 1;
        norm_num [ abs_mul, abs_of_nonneg ( show 0 ≤ HeatKernel t _ from by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ];
      have h_heat_kernel_integral : ∫ y, HeatKernel t y = 1 := by
        exact HeatKernel_integral t ht;
      aesop;
    -- Using the fact that the heat kernel is an approximation to the identity, we can bound the integral of the convolution by splitting it into two parts: one over $|y| < \delta$ and one over $|y| \geq \delta$.
    have h_conv_split : ∀ t > 0, ∀ x : ℝ, ∫ y, |f (x - y) - f x| * HeatKernel t y ≤ (∫ y in {y | |y| < δ}, |f (x - y) - f x| * HeatKernel t y) + (∫ y in {y | |y| ≥ δ}, |f (x - y) - f x| * HeatKernel t y) := by
      intro t ht x; rw [ ← MeasureTheory.setIntegral_union ] <;> norm_num;
      · rw [ show { y : ℝ | |y| < δ } ∪ { y : ℝ | δ ≤ |y| } = Set.univ by ext y; by_cases hy : |y| < δ <;> aesop ] ; norm_num;
      · exact Set.disjoint_left.mpr fun y hy₁ hy₂ => hy₁.out.not_le hy₂.out;
      · exact measurableSet_Ici.mem.comp measurable_norm;
      · refine' MeasureTheory.Integrable.integrableOn _;
        -- Since $f$ is continuous with compact support, $|f(x-y) - f(x)|$ is bounded.
        have h_bounded : ∃ M > 0, ∀ y, |f (x - y) - f x| ≤ M := by
          have h_bounded : ∃ M > 0, ∀ y, |f y| ≤ M := by
            have := hf_supp.exists_bound_of_continuous hf_cont;
            exact ⟨ Max.max this.choose 1, by positivity, fun y => le_trans ( this.choose_spec y ) ( le_max_left _ _ ) ⟩;
          exact ⟨ h_bounded.choose + h_bounded.choose, add_pos h_bounded.choose_spec.1 h_bounded.choose_spec.1, fun y => le_trans ( abs_sub _ _ ) ( add_le_add ( h_bounded.choose_spec.2 _ ) ( h_bounded.choose_spec.2 _ ) ) ⟩;
        obtain ⟨ M, hM_pos, hM ⟩ := h_bounded;
        refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun y => M * HeatKernel t y;
        · refine' MeasureTheory.Integrable.const_mul _ _;
          have h_gauss_integrable : ∫ y, Real.exp (-y^2 / (4 * t)) = Real.sqrt (4 * Real.pi * t) := by
            convert integral_gaussian ( 1 / ( 4 * t ) ) using 1 <;> norm_num [ div_eq_inv_mul ] ; ring;
          exact MeasureTheory.Integrable.const_mul ( by exact ( by contrapose! h_gauss_integrable; rw [ MeasureTheory.integral_undef h_gauss_integrable ] ; positivity ) ) _;
        · refine' MeasureTheory.AEStronglyMeasurable.mul _ _;
          · exact Continuous.aestronglyMeasurable ( by continuity );
          · exact Continuous.aestronglyMeasurable ( by exact Continuous.mul ( continuous_const ) ( Real.continuous_exp.comp ( by continuity ) ) );
        · filter_upwards [ ] with y using by rw [ Real.norm_of_nonneg ( mul_nonneg ( abs_nonneg _ ) ( show 0 ≤ HeatKernel t y by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ) ] ; exact mul_le_mul_of_nonneg_right ( hM y ) ( show 0 ≤ HeatKernel t y by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ;
      · refine' MeasureTheory.Integrable.integrableOn _;
        -- Since $f$ is continuous with compact support, $|f(x-y) - f(x)|$ is bounded.
        have h_bounded : ∃ M > 0, ∀ y, |f (x - y) - f x| ≤ M := by
          have h_bounded : ∃ M > 0, ∀ y, |f y| ≤ M := by
            have := hf_supp.exists_bound_of_continuous hf_cont;
            exact ⟨ Max.max this.choose 1, by positivity, fun y => le_trans ( this.choose_spec y ) ( le_max_left _ _ ) ⟩;
          exact ⟨ h_bounded.choose + h_bounded.choose, add_pos h_bounded.choose_spec.1 h_bounded.choose_spec.1, fun y => le_trans ( abs_sub _ _ ) ( add_le_add ( h_bounded.choose_spec.2 _ ) ( h_bounded.choose_spec.2 _ ) ) ⟩;
        obtain ⟨ M, hM_pos, hM ⟩ := h_bounded;
        refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun y => M * HeatKernel t y;
        · refine' MeasureTheory.Integrable.const_mul _ _;
          have h_gauss_integrable : ∫ y, Real.exp (-y^2 / (4 * t)) = Real.sqrt (4 * Real.pi * t) := by
            convert integral_gaussian ( 1 / ( 4 * t ) ) using 1 <;> norm_num [ div_eq_inv_mul ] ; ring;
          exact MeasureTheory.Integrable.const_mul ( by exact ( by contrapose! h_gauss_integrable; rw [ MeasureTheory.integral_undef h_gauss_integrable ] ; positivity ) ) _;
        · refine' MeasureTheory.AEStronglyMeasurable.mul _ _;
          · exact Continuous.aestronglyMeasurable ( by continuity );
          · exact Continuous.aestronglyMeasurable ( by exact Continuous.mul ( continuous_const ) ( Real.continuous_exp.comp ( by continuity ) ) );
        · filter_upwards [ ] with y using by rw [ Real.norm_of_nonneg ( mul_nonneg ( abs_nonneg _ ) ( show 0 ≤ HeatKernel t y by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ) ] ; exact mul_le_mul_of_nonneg_right ( hM y ) ( show 0 ≤ HeatKernel t y by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ;
    -- Using the fact that the heat kernel is an approximation to the identity, we can bound the integral of the convolution over $|y| \geq \delta$.
    have h_conv_tail : ∀ t > 0, ∀ x : ℝ, ∫ y in {y | |y| ≥ δ}, |f (x - y) - f x| * HeatKernel t y ≤ 2 * (SupSet.sSup (Set.image (fun x => |f x|) (Set.univ))) * ∫ y in {y | |y| ≥ δ}, HeatKernel t y := by
      intros t ht x
      have h_conv_tail_bound : ∀ y ∈ {y | |y| ≥ δ}, |f (x - y) - f x| ≤ 2 * (SupSet.sSup (Set.image (fun x => |f x|) (Set.univ))) := by
        intros y hy
        have h_abs : |f (x - y)| ≤ SupSet.sSup (Set.image (fun x => |f x|) (Set.univ)) ∧ |f x| ≤ SupSet.sSup (Set.image (fun x => |f x|) (Set.univ)) := by
          have h_abs : ∀ x, |f x| ≤ SupSet.sSup (Set.image (fun x => |f x|) (Set.univ)) := by
            intros x
            apply le_csSup;
            · obtain ⟨ M, hM ⟩ := hf_supp.exists_bound_of_continuous hf_cont;
              exact ⟨ M, Set.forall_mem_image.2 fun x _ => hM x ⟩;
            · aesop;
          exact ⟨ h_abs _, h_abs _ ⟩;
        exact le_trans ( abs_sub _ _ ) ( by linarith );
      rw [ ← MeasureTheory.integral_const_mul ];
      refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
      · exact Filter.Eventually.of_forall fun y => mul_nonneg ( abs_nonneg _ ) ( by unfold HeatKernel; positivity );
      · refine' MeasureTheory.Integrable.const_mul _ _;
        have h_conv_tail_integrable : MeasureTheory.Integrable (HeatKernel t) MeasureTheory.volume := by
          have h_conv_tail_integrable : ∫ y, HeatKernel t y = 1 := by
            exact HeatKernel_integral t ht;
          exact MeasureTheory.integrable_of_integral_eq_one h_conv_tail_integrable;
        exact h_conv_tail_integrable.integrableOn;
      · filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_le measurable_const <| measurable_norm ] with y hy using mul_le_mul_of_nonneg_right ( h_conv_tail_bound y hy ) <| by unfold HeatKernel; positivity;
    -- Using the fact that the heat kernel is an approximation to the identity, we can bound the integral of the convolution over $|y| < \delta$.
    have h_conv_head : ∀ t > 0, ∀ x : ℝ, ∫ y in {y | |y| < δ}, |f (x - y) - f x| * HeatKernel t y ≤ (ε / 2) * ∫ y, HeatKernel t y := by
      intros t ht x
      have h_conv_head_bound : ∫ y in {y | |y| < δ}, |f (x - y) - f x| * HeatKernel t y ≤ (ε / 2) * ∫ y in {y | |y| < δ}, HeatKernel t y := by
        rw [ ← MeasureTheory.integral_const_mul ];
        refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
        · filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_lt measurable_norm measurable_const ] with y hy using mul_nonneg ( abs_nonneg _ ) ( by unfold HeatKernel; positivity );
        · refine' MeasureTheory.Integrable.const_mul _ _;
          -- The heat kernel is integrable over the entire real line, and since the set {y | |y| < δ} is a subset of the real line, the integral over this subset is also finite.
          have h_heat_kernel_integrable : MeasureTheory.IntegrableOn (HeatKernel t) Set.univ := by
            have h_heat_kernel_integrable : ∫ x, HeatKernel t x = 1 := by
              exact HeatKernel_integral t ht;
            exact MeasureTheory.integrable_of_integral_eq_one ( by simpa using h_heat_kernel_integrable );
          exact h_heat_kernel_integrable.mono_set <| Set.subset_univ _;
        · filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_lt ( measurable_norm ) measurable_const ] with y hy using mul_le_mul_of_nonneg_right ( le_of_lt <| hδ _ _ <| by simpa using hy ) <| by unfold HeatKernel; positivity;
      refine le_trans h_conv_head_bound ?_;
      refine' mul_le_mul_of_nonneg_left ( MeasureTheory.setIntegral_le_integral _ _ ) ( by positivity );
      · have h_heat_kernel_integrable : ∫ x, HeatKernel t x = 1 := by
          exact HeatKernel_integral t ht;
        exact MeasureTheory.integrable_of_integral_eq_one h_heat_kernel_integrable;
      · exact Filter.Eventually.of_forall fun x => by unfold HeatKernel; positivity;
    -- Using the fact that the heat kernel is an approximation to the identity, we can bound the integral of the convolution over $|y| \geq \delta$ by choosing $t$ small enough.
    have h_conv_tail_small : ∃ t₀ > 0, ∀ t ∈ Set.Ioo 0 t₀, 2 * (SupSet.sSup (Set.image (fun x => |f x|) (Set.univ))) * ∫ y in {y | |y| ≥ δ}, HeatKernel t y < ε / 2 := by
      have h_conv_tail_small : Filter.Tendsto (fun t => ∫ y in {y | |y| ≥ δ}, HeatKernel t y) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
        convert HeatKernel_mass_concentration δ hδ_pos using 1;
        ext t; rw [ MeasureTheory.setIntegral_congr_set ] ; aesop;
        rw [ MeasureTheory.ae_eq_set ];
        constructor <;> rw [ MeasureTheory.measure_eq_zero_iff_ae_notMem ] <;> aesop;
        · filter_upwards [ MeasureTheory.measure_eq_zero_iff_ae_notMem.mp ( MeasureTheory.measure_singleton ( δ ) ), MeasureTheory.measure_eq_zero_iff_ae_notMem.mp ( MeasureTheory.measure_singleton ( -δ ) ) ] with x hx₁ hx₂ using fun hx₃ => lt_of_le_of_ne hx₃ ( by cases abs_cases x <;> cases lt_or_gt_of_ne hx₁ <;> cases lt_or_gt_of_ne hx₂ <;> linarith );
        · exact Filter.Eventually.of_forall fun x hx => le_of_lt hx;
      have := h_conv_tail_small.const_mul ( 2 * SupSet.sSup ( ( fun x => |f x| ) '' Set.univ ) );
      have := Metric.tendsto_nhdsWithin_nhds.mp this ( ε / 2 ) ( half_pos hε );
      exact ⟨ this.choose, this.choose_spec.1, fun t ht => by linarith [ abs_lt.mp ( this.choose_spec.2 ht.1 ( by simpa [ abs_of_pos ht.1 ] using ht.2 ) ) ] ⟩;
    -- Using the fact that the integral of the heat kernel is 1, we can simplify the bound.
    have h_conv_integral : ∀ t > 0, ∫ y, HeatKernel t y = 1 := by
      exact HeatKernel_integral;
    exact ⟨ h_conv_tail_small.choose, h_conv_tail_small.choose_spec.1, fun t ht x => lt_of_le_of_lt ( h_conv_bound t ht.1 x ) ( lt_of_le_of_lt ( h_conv_split t ht.1 x ) ( by nlinarith [ h_conv_head t ht.1 x, h_conv_tail t ht.1 x, h_conv_tail_small.choose_spec.2 t ht, h_conv_integral t ht.1 ] ) ) ⟩

lemma fejer_sum_approx (K : ℝ) (hK : K > 0) (t : ℝ) (ht : t > 0) (s : Finset ℝ)
    (w : ℝ → ℝ) (hw_nonneg : ∀ y ∈ s, 0 ≤ w y) (hs_subset : ∀ y ∈ s, y ∈ Set.Icc (-K) K)
    (ε : ℝ) (hε : ε > 0) :
  ∃ B > 0, ∀ x ∈ Set.Icc (-K) K,
    |∑ y ∈ s, w y * Atom B t y x - (∑ y ∈ s, w y * HeatKernel t (x - y) +
      ∑ y ∈ s, w y * HeatKernel t (x + y))| < ε := by
        -- By definition of $Atom$, we can write:
        have h_atom : ∀ B > 0, ∀ x ∈ Set.Icc (-K) K, ∑ y ∈ s, w y * Atom B t y x =
                      ∑ y ∈ s, w y * FejerKernel B (x - y) * HeatKernel t (x - y) +
                      ∑ y ∈ s, w y * FejerKernel B (x + y) * HeatKernel t (x + y) := by
                        intro B hB x hx; rw [ ← Finset.sum_add_distrib ] ; congr ; ext y ; unfold Atom ; ring;
        -- Since $FejerKernel B (x - y)$ and $FejerKernel B (x + y)$ are bounded by 1, we can choose $B$ large enough such that the difference between the sums is less than $\epsilon$.
        have h_bounded : ∀ B > 0, ∀ x ∈ Set.Icc (-K) K, |∑ y ∈ s, w y * FejerKernel B (x - y) * HeatKernel t (x - y) - ∑ y ∈ s, w y * HeatKernel t (x - y)| ≤ ∑ y ∈ s, w y * |FejerKernel B (x - y) - 1| * HeatKernel t (x - y) ∧ |∑ y ∈ s, w y * FejerKernel B (x + y) * HeatKernel t (x + y) - ∑ y ∈ s, w y * HeatKernel t (x + y)| ≤ ∑ y ∈ s, w y * |FejerKernel B (x + y) - 1| * HeatKernel t (x + y) := by
          intros B hB x hx
          have h_bounded : ∀ y ∈ s, |w y * FejerKernel B (x - y) * HeatKernel t (x - y) - w y * HeatKernel t (x - y)| ≤ w y * |FejerKernel B (x - y) - 1| * HeatKernel t (x - y) ∧ |w y * FejerKernel B (x + y) * HeatKernel t (x + y) - w y * HeatKernel t (x + y)| ≤ w y * |FejerKernel B (x + y) - 1| * HeatKernel t (x + y) := by
            intro y hy; constructor <;> rw [ abs_le ] <;> constructor <;> cases abs_cases ( FejerKernel B ( x - y ) - 1 ) <;> cases abs_cases ( FejerKernel B ( x + y ) - 1 ) <;> nlinarith [ hw_nonneg y hy, show 0 ≤ w y * HeatKernel t ( x - y ) by exact mul_nonneg ( hw_nonneg y hy ) ( HeatKernel_nonneg t ht _ ), show 0 ≤ w y * HeatKernel t ( x + y ) by exact mul_nonneg ( hw_nonneg y hy ) ( HeatKernel_nonneg t ht _ ) ] ;
          exact ⟨ by simpa only [ ← Finset.sum_sub_distrib ] using Finset.abs_sum_le_sum_abs _ _ |> le_trans <| Finset.sum_le_sum fun y hy => h_bounded y hy |>.1, by simpa only [ ← Finset.sum_sub_distrib ] using Finset.abs_sum_le_sum_abs _ _ |> le_trans <| Finset.sum_le_sum fun y hy => h_bounded y hy |>.2 ⟩;
        -- Since $|FejerKernel B (x - y) - 1| \leq \frac{|x - y|}{B}$ and $|FejerKernel B (x + y) - 1| \leq \frac{|x + y|}{B}$, we can choose $B$ large enough such that the sums are less than $\epsilon$.
        have h_small : ∀ B > 0, ∀ x ∈ Set.Icc (-K) K, ∑ y ∈ s, w y * |FejerKernel B (x - y) - 1| * HeatKernel t (x - y) ≤ ∑ y ∈ s, w y * (|x - y| / B) * HeatKernel t (x - y) ∧ ∑ y ∈ s, w y * |FejerKernel B (x + y) - 1| * HeatKernel t (x + y) ≤ ∑ y ∈ s, w y * (|x + y| / B) * HeatKernel t (x + y) := by
          intros B hB x hx
          have h_abs : ∀ y ∈ s, |FejerKernel B (x - y) - 1| ≤ |x - y| / B ∧ |FejerKernel B (x + y) - 1| ≤ |x + y| / B := by
            unfold FejerKernel;
            intro y hy; constructor <;> rw [ abs_le ] <;> constructor <;> cases max_cases ( 0 : ℝ ) ( 1 - |x - y| / B ) <;> cases max_cases ( 0 : ℝ ) ( 1 - |x + y| / B ) <;> nlinarith [ abs_nonneg ( x - y ), abs_nonneg ( x + y ), div_mul_cancel₀ ( |x - y| ) hB.ne', div_mul_cancel₀ ( |x + y| ) hB.ne' ] ;
          exact ⟨ Finset.sum_le_sum fun y hy => mul_le_mul_of_nonneg_right ( mul_le_mul_of_nonneg_left ( h_abs y hy |>.1 ) ( hw_nonneg y hy ) ) ( by exact ( show 0 ≤ HeatKernel t ( x - y ) from by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ), Finset.sum_le_sum fun y hy => mul_le_mul_of_nonneg_right ( mul_le_mul_of_nonneg_left ( h_abs y hy |>.2 ) ( hw_nonneg y hy ) ) ( by exact ( show 0 ≤ HeatKernel t ( x + y ) from by exact mul_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( Real.exp_nonneg _ ) ) ) ⟩;
        -- Since $|x - y| \leq 2K$ and $|x + y| \leq 2K$ for all $x, y \in [-K, K]$, we can further bound the sums.
        have h_bound : ∀ B > 0, ∀ x ∈ Set.Icc (-K) K, ∑ y ∈ s, w y * (|x - y| / B) * HeatKernel t (x - y) ≤ (2 * K / B) * ∑ y ∈ s, w y * HeatKernel t (x - y) ∧ ∑ y ∈ s, w y * (|x + y| / B) * HeatKernel t (x + y) ≤ (2 * K / B) * ∑ y ∈ s, w y * HeatKernel t (x + y) := by
          intros B hB x hx
          have h_bound : ∀ y ∈ s, |x - y| ≤ 2 * K ∧ |x + y| ≤ 2 * K := by
            exact fun y hy => ⟨ abs_le.mpr ⟨ by linarith [ hx.1, hx.2, hs_subset y hy |>.1, hs_subset y hy |>.2 ], by linarith [ hx.1, hx.2, hs_subset y hy |>.1, hs_subset y hy |>.2 ] ⟩, abs_le.mpr ⟨ by linarith [ hx.1, hx.2, hs_subset y hy |>.1, hs_subset y hy |>.2 ], by linarith [ hx.1, hx.2, hs_subset y hy |>.1, hs_subset y hy |>.2 ] ⟩ ⟩;
          simp_all +decide [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _ ];
          exact ⟨ Finset.sum_le_sum fun y hy => by nlinarith [ h_bound y hy, show 0 ≤ w y * ( HeatKernel t ( x - y ) * B⁻¹ ) by exact mul_nonneg ( hw_nonneg y hy ) ( mul_nonneg ( by exact ( show 0 ≤ HeatKernel t ( x - y ) by exact ( by unfold HeatKernel; positivity ) ) ) ( inv_nonneg.2 hB.le ) ) ], Finset.sum_le_sum fun y hy => by nlinarith [ h_bound y hy, show 0 ≤ w y * ( HeatKernel t ( x + y ) * B⁻¹ ) by exact mul_nonneg ( hw_nonneg y hy ) ( mul_nonneg ( by exact ( show 0 ≤ HeatKernel t ( x + y ) by exact ( by unfold HeatKernel; positivity ) ) ) ( inv_nonneg.2 hB.le ) ) ] ⟩;
        -- Choose $B$ large enough such that $(2 * K / B) * (∑ y ∈ s, w y * HeatKernel t (x - y) + ∑ y ∈ s, w y * HeatKernel t (x + y)) < ε / 2$.
        obtain ⟨B, hB_pos, hB_small⟩ : ∃ B > 0, ∀ x ∈ Set.Icc (-K) K, (2 * K / B) * (∑ y ∈ s, w y * HeatKernel t (x - y) + ∑ y ∈ s, w y * HeatKernel t (x + y)) < ε / 2 := by
          -- Since the sums $\sum_{y \in s} w_y \HeatKernel t (x - y)$ and $\sum_{y \in s} w_y \HeatKernel t (x + y)$ are bounded, we can choose $B$ large enough such that $(2 * K / B) * (\sum_{y \in s} w_y \HeatKernel t (x - y) + \sum_{y \in s} w_y \HeatKernel t (x + y)) < \epsilon / 2$.
          have h_bounded_sums : ∃ M > 0, ∀ x ∈ Set.Icc (-K) K, (∑ y ∈ s, w y * HeatKernel t (x - y) + ∑ y ∈ s, w y * HeatKernel t (x + y)) ≤ M := by
            have h_bounded_sums : ContinuousOn (fun x => ∑ y ∈ s, w y * HeatKernel t (x - y) + ∑ y ∈ s, w y * HeatKernel t (x + y)) (Set.Icc (-K) K) := by
              refine' ContinuousOn.add _ _;
              · refine' continuousOn_finset_sum _ fun y hy => ContinuousOn.mul _ _;
                · exact continuousOn_const;
                · refine' ContinuousOn.mul _ _;
                  · exact continuousOn_const;
                  · fun_prop;
              · refine' ContinuousOn.congr _ _;
                use fun x => ∑ y ∈ s, w y * ( 4 * Real.pi * t ) ^ ( - ( 1 : ℝ ) / 2 ) * Real.exp ( - ( x + y ) ^ 2 / ( 4 * t ) );
                · fun_prop;
                · intro x hx; simp +decide [ mul_assoc, HeatKernel ] ;
            obtain ⟨ M, hM ⟩ := IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) h_bounded_sums;
            exact ⟨ Max.max M 1, by positivity, fun x hx => le_trans ( le_abs_self _ ) ( le_trans ( hM x hx ) ( le_max_left _ _ ) ) ⟩;
          obtain ⟨ M, hM_pos, hM ⟩ := h_bounded_sums;
          exact ⟨ 2 * K * M / ( ε / 2 ) + 1, by positivity, fun x hx => by rw [ div_mul_eq_mul_div, div_lt_iff₀ ] <;> nlinarith [ hM x hx, mul_div_cancel₀ ( 2 * K * M ) ( by positivity : ( ε / 2 ) ≠ 0 ), mul_pos hK hM_pos ] ⟩;
        use B, hB_pos;
        intro x hx; rw [ h_atom B hB_pos x hx ] ; rw [ abs_lt ] ; constructor <;> linarith [ abs_le.mp ( h_bounded B hB_pos x hx |>.1 ), abs_le.mp ( h_bounded B hB_pos x hx |>.2 ), h_small B hB_pos x hx, h_bound B hB_pos x hx, hB_small x hx ] ;

lemma sum_atoms_in_cone (K : ℝ) (s : Finset ℝ) (w : ℝ → ℝ) (hw : ∀ y ∈ s, 0 ≤ w y)
    (B : ℝ) (hB : B > 0) (t : ℝ) (ht : t > 0) (hs : ∀ y ∈ s, y ∈ Set.Icc (-K) K)
    (h_sum_pos : ∑ y ∈ s, w y > 0) :
  (fun x => ∑ y ∈ s, w y * Atom B t y x) ∈ AtomCone_K K := by
    norm_num +zetaDelta at *;
    unfold AtomCone_K;
    refine' ⟨ _, _ ⟩;
    exact ( ⋃ ( _ : 0 < ∑ y ∈ s, w y ), ( ∑ y ∈ s, w y ) • ( convexHull ℝ ( AtomSet K ) ) );
    aesop;
    · exact ⟨ _, by aesop ⟩;
    · -- Since each term $w y * Atom B t y x$ is in the convex hull of $AtomSet K$, their sum is also in the convex hull.
      have h_sum_in_convex_hull : ∑ y ∈ s, (w y / ∑ y ∈ s, w y) • Atom B t y ∈ convexHull ℝ (AtomSet K) := by
        rw [ convexHull_eq ];
        refine' ⟨ _, s, fun y => w y / ∑ y ∈ s, w y, fun y => Atom B t y, _, _, _, _ ⟩ <;> simp_all +decide [ Finset.centerMass ];
        · exact fun y hy => div_nonneg ( hw y hy ) h_sum_pos.le;
        · rw [ ← Finset.sum_div, div_self h_sum_pos.ne' ];
        · exact fun y hy => ⟨ B, t, y, hB, ht, hs y hy, rfl ⟩;
        · rw [ ← Finset.sum_div _ _ _, div_self h_sum_pos.ne', inv_one, one_smul ];
      refine' ⟨ _, h_sum_in_convex_hull, _ ⟩;
      ext; simp +decide [ div_eq_inv_mul, mul_assoc, mul_left_comm, Finset.mul_sum _ _ _, h_sum_pos.ne' ] ;

lemma exists_even_compact_extension (K : ℝ) (hK : K > 0) (Φ : ℝ → ℝ)
    (hΦ_cont : ContinuousOn Φ (Set.Icc (-K) K)) (hΦ_even : Even Φ) :
  ∃ Ψ : ℝ → ℝ, Continuous Ψ ∧ HasCompactSupport Ψ ∧ Even Ψ ∧ ∀ x ∈ Set.Icc (-K) K, Ψ x = Φ x := by
    -- By Tietze's extension theorem, there exists a continuous function Ψ on ℝ that equals Φ on [-K, K].
    obtain ⟨Ψ, hΨ_cont, hΨ_ext⟩ : ∃ Ψ : ℝ → ℝ, Continuous Ψ ∧ ∀ x ∈ Set.Icc (-K) K, Ψ x = Φ x := by
      -- Apply the existence of a continuous extension of Φ to the entire real line.
      obtain ⟨Ψ, hΨ_cont, hΨ_ext⟩ : ∃ Ψ : ℝ → ℝ, Continuous Ψ ∧ ∀ x ∈ Set.Icc (-K) K, Ψ x = Φ x := by
        have := exists_compact_extension K hK Φ hΦ_cont
        exact ⟨ this.choose, this.choose_spec.1, this.choose_spec.2.2 ⟩;
      use Ψ;
    -- Define Ψ' as Ψ(x) * χ(x), where χ is a bump function that is 1 on [-K, K] and 0 outside some larger interval [-L, L].
    obtain ⟨χ, hχ_cont, hχ_support⟩ : ∃ χ : ℝ → ℝ, Continuous χ ∧ HasCompactSupport χ ∧ (∀ x ∈ Set.Icc (-K) K, χ x = 1) ∧ (∀ x, χ (-x) = χ x) := by
      -- Let's choose a bump function χ that is 1 on [-K, K] and smoothly goes to 0 outside [-L, L] for some L > K.
      obtain ⟨L, hL⟩ : ∃ L > K, ∃ χ : ℝ → ℝ, Continuous χ ∧ HasCompactSupport χ ∧ (∀ x ∈ Set.Icc (-K) K, χ x = 1) ∧ (∀ x, χ (-x) = χ x) ∧ (∀ x, χ x ≤ 1) ∧ (∀ x, χ x ≥ 0) := by
        use K + 1;
        refine' ⟨ by linarith, fun x => if |x| ≤ K then 1 else if |x| ≤ K + 1 then 1 - ( |x| - K ) else 0, _, _, _, _, _ ⟩ <;> norm_num;
        · apply_rules [ Continuous.if_le, Continuous.sub, Continuous.add, continuous_const, continuous_abs ];
          · exact fun x hx => by linarith;
          · exact fun x hx => by rw [ if_pos ( by linarith ) ] ; linarith;
        · rw [ hasCompactSupport_iff_eventuallyEq ];
          norm_num [ Filter.EventuallyEq ];
          exact ⟨ ⟨ -K - 2, fun x hx => by split_ifs <;> cases abs_cases x <;> linarith ⟩, ⟨ K + 2, fun x hx => by split_ifs <;> cases abs_cases x <;> linarith ⟩ ⟩;
        · exact fun x hx₁ hx₂ hx₃ => False.elim <| hx₃.not_le <| abs_le.mpr ⟨ by linarith, by linarith ⟩;
        · exact ⟨ fun x => by split_ifs <;> linarith [ abs_nonneg x ], fun x => by split_ifs <;> linarith [ abs_nonneg x ] ⟩;
      aesop;
    -- Define Ψ' as Ψ(x) * χ(x), where χ is a bump function that is 1 on [-K, K] and 0 outside some larger interval [-L, L]. This ensures that Ψ' is continuous, compactly supported, even, and equals Φ on [-K, K].
    use fun x => Ψ x * χ x;
    bound;
    · exact hΨ_cont.mul hχ_cont;
    · rw [ hasCompactSupport_iff_eventuallyEq ] at *;
      filter_upwards [ left ] with x hx using mul_eq_zero_of_right _ hx;
    · exact ⟨ fun x => ( Ψ x * χ x ) / 2, by ext; simp +decide [ *, two_mul ] ⟩;
    · aesop

lemma HeatKernel_even (t : ℝ) : Even (HeatKernel t) := by
  -- The heat function is radially symmetric, so it is even.
  use fun x => HeatKernel t x / 2;
  -- By definition of addition for functions, we have:
  funext x; simp [add_div]

lemma even_convolution (f g : ℝ → ℝ) (hf : Even f) (hg : Even g) : Even (real_convolution f g) := by
  -- Let's choose r to be half of the convolution of f and g.
  use fun x => (real_convolution f g x) / 2;
  -- By definition of function addition, we have:
  funext x; simp [add_comm, add_left_comm]

#print Even

#check Function.Even

#check Even
#print Function.Even

#check IsCompact.image
#check HasCompactSupport
#check HasCompactSupport.smul_left

#check IsCompact.image
#check HasCompactSupport.mono

lemma HasCompactSupport_const_mul (c : ℝ) (f : ℝ → ℝ) (hf : HasCompactSupport f) : HasCompactSupport (fun x => c * f x) := by
  -- Apply the lemma that states if a function has compact support, then multiplying it by a constant preserves the compact support.
  apply HasCompactSupport.mul_left; assumption

lemma sSup_lt_of_compact_image_lt (K : Set ℝ) (hK : IsCompact K) (hK_nonempty : K.Nonempty) (f : ℝ → ℝ) (hf_cont : ContinuousOn f K) (ε : ℝ) (h : ∀ x ∈ K, f x < ε) : sSup (f '' K) < ε := by
  have h_sup_lt_ε : ∃ x ∈ K, ∀ y ∈ K, f y ≤ f x := by
    exact ( IsCompact.exists_isMaxOn hK hK_nonempty hf_cont ) |> fun ⟨ x, hx₁, hx₂ ⟩ => ⟨ x, hx₁, fun y hy => hx₂ hy ⟩;
  exact lt_of_le_of_lt ( csSup_le ( Set.Nonempty.image _ hK_nonempty ) ( Set.forall_mem_image.2 h_sup_lt_ε.choose_spec.2 ) ) ( h _ h_sup_lt_ε.choose_spec.1 )

/-
Uniform Riemann sum approximation for a parameterized integral.
-/
lemma uniform_riemann_sum (a b : ℝ) (hab : a < b) (X : Set ℝ) (hX : IsCompact X)
    (F : ℝ → ℝ → ℝ) (hF : ContinuousOn (Function.uncurry F) (X ×ˢ Set.Icc a b))
    (ε : ℝ) (hε : ε > 0) :
  ∃ (s : Finset ℝ) (w : ℝ → ℝ), (∀ y ∈ s, w y > 0) ∧ (∀ y ∈ s, y ∈ Set.Icc a b) ∧
  ∀ x ∈ X, |(∫ y in Set.Icc a b, F x y) - ∑ y ∈ s, w y * F x y| < ε := by
    -- Fix an arbitrary $\delta > 0$.
    obtain ⟨δ, hδ_pos, hδ⟩ : ∃ δ > 0, ∀ x ∈ X, ∀ y ∈ Set.Icc a b, ∀ y' ∈ Set.Icc a b, |y - y'| < δ → |F x y - F x y'| < ε / (2 * (b - a)) := by
      have h_unif_cont : UniformContinuousOn (Function.uncurry F) (X ×ˢ Set.Icc a b) := by
        apply_rules [ IsCompact.uniformContinuousOn_of_continuous, hX ];
        exact hX.prod CompactIccSpace.isCompact_Icc;
      rcases Metric.uniformContinuousOn_iff.mp h_unif_cont ( ε / ( 2 * ( b - a ) ) ) ( div_pos hε <| mul_pos zero_lt_two <| sub_pos.mpr hab ) with ⟨ δ, δ_pos, hδ ⟩ ; use δ ; aesop;
    -- Choose a partition of [a, b] with subintervals of length less than δ.
    obtain ⟨n, hn⟩ : ∃ n : ℕ, n > 0 ∧ (b - a) / n < δ := by
      exact ⟨ ⌊ ( b - a ) / δ⌋₊ + 1, Nat.succ_pos _, by rw [ div_lt_iff₀ ] <;> push_cast <;> nlinarith [ Nat.lt_floor_add_one ( ( b - a ) / δ ), mul_div_cancel₀ ( b - a ) hδ_pos.ne' ] ⟩;
    refine' ⟨ Finset.image ( fun i : ℕ => a + ( i : ℝ ) * ( b - a ) / n ) ( Finset.range n ), fun y => ( b - a ) / n, _, _, _ ⟩ <;> aesop;
    · exact div_nonneg ( mul_nonneg ( Nat.cast_nonneg _ ) ( sub_nonneg.mpr hab.le ) ) ( Nat.cast_nonneg _ );
    · rw [ add_div', div_le_iff₀ ] <;> nlinarith [ show ( w : ℝ ) + 1 ≤ n by norm_cast ];
    · -- By the properties of the Riemann sum and the uniform continuity of $F$, we can bound the difference.
      have h_bound : |(∫ y in Set.Icc a b, F x y) - ∑ i ∈ Finset.range n, (b - a) / n * F x (a + i * (b - a) / n)| ≤ ∑ i ∈ Finset.range n, ∫ y in (a + i * (b - a) / n).. (a + (i + 1) * (b - a) / n), |F x y - F x (a + i * (b - a) / n)| := by
        have h_bound : ∫ y in Set.Icc a b, F x y = ∑ i ∈ Finset.range n, ∫ y in (a + i * (b - a) / n).. (a + (i + 1) * (b - a) / n), F x y := by
          rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le hab.le ];
          symm;
          convert intervalIntegral.sum_integral_adjacent_intervals _ <;> norm_num [ left.ne' ];
          intro k hk; apply_rules [ ContinuousOn.intervalIntegrable ];
          refine' hF.comp ( continuousOn_const.prodMk continuousOn_id ) fun y hy => _;
          aesop;
          · cases Set.mem_uIcc.mp hy <;> nlinarith [ show ( k : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( k : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( k : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ];
          · cases Set.mem_uIcc.mp hy <;> nlinarith [ show ( k : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( k : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( k : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ];
        rw [ h_bound, ← Finset.sum_sub_distrib ];
        refine' le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( Finset.sum_le_sum _ );
        intro i hi; rw [ intervalIntegral.integral_of_le ( by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], div_mul_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), div_mul_cancel₀ ( ( ( i : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ] ; rw [ intervalIntegral.integral_of_le ( by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], div_mul_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), div_mul_cancel₀ ( ( ( i : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ] ;
        convert MeasureTheory.norm_integral_le_integral_norm ( fun y => F x y - F x ( a + i * ( b - a ) / n ) ) using 1 ; norm_num [ mul_comm, add_mul, div_eq_mul_inv ];
        rw [ MeasureTheory.integral_sub ] <;> norm_num;
        · rw [ max_eq_left ( by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], inv_mul_cancel_left₀ ( by positivity : ( n : ℝ ) ≠ 0 ) ( b - a ) ] ) ] ; ring;
        · have h_cont : ContinuousOn (fun y => F x y) (Set.Icc a b) := by
            exact hF.comp ( continuousOn_const.prodMk continuousOn_id ) fun y hy => ⟨ a_1, hy ⟩;
          exact ContinuousOn.integrableOn_Icc ( h_cont.mono <| Set.Icc_subset_Icc ( by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], inv_mul_cancel_left₀ ( by positivity : ( n : ℝ ) ≠ 0 ) ( b - a ) ] ) ( by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], inv_mul_cancel_left₀ ( by positivity : ( n : ℝ ) ≠ 0 ) ( b - a ) ] ) ) |> fun h => h.mono_set <| Set.Ioc_subset_Icc_self;
      -- By the properties of the Riemann sum and the uniform continuity of $F$, we can bound each term in the sum.
      have h_term_bound : ∀ i ∈ Finset.range n, ∫ y in (a + i * (b - a) / n).. (a + (i + 1) * (b - a) / n), |F x y - F x (a + i * (b - a) / n)| ≤ (b - a) / n * (ε / (2 * (b - a))) := by
        intros i hi
        have h_term_bound : ∀ y ∈ Set.Icc (a + i * (b - a) / n) (a + (i + 1) * (b - a) / n), |F x y - F x (a + i * (b - a) / n)| ≤ ε / (2 * (b - a)) := by
          intros y hy
          have h_dist : |y - (a + i * (b - a) / n)| ≤ (b - a) / n := by
            exact abs_le.mpr ⟨ by ring_nf at *; linarith [ hy.1, hy.2 ], by ring_nf at *; linarith [ hy.1, hy.2 ] ⟩;
          exact le_of_lt ( hδ x a_1 y ( by nlinarith [ hy.1, hy.2, show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], mul_div_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ( by nlinarith [ hy.1, hy.2, show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], mul_div_cancel₀ ( ( i + 1 : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ( a + i * ( b - a ) / n ) ( by nlinarith [ hy.1, hy.2, show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], mul_div_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ( by nlinarith [ hy.1, hy.2, show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], mul_div_cancel₀ ( ( i + 1 : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ( lt_of_le_of_lt h_dist right ) );
        convert intervalIntegral.integral_mono_on _ _ _ h_term_bound <;> norm_num;
        · ring;
        · bound;
        · apply_rules [ ContinuousOn.intervalIntegrable ];
          refine' ContinuousOn.abs ( ContinuousOn.sub _ continuousOn_const );
          refine' hF.comp ( continuousOn_const.prodMk continuousOn_id ) fun y hy => _;
          simp +zetaDelta at *;
          exact ⟨ a_1, by cases Set.mem_uIcc.mp hy <;> nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( i : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ], by cases Set.mem_uIcc.mp hy <;> nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( i : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ⟩;
      rw [ Finset.sum_image ];
      · refine' lt_of_le_of_lt h_bound ( lt_of_le_of_lt ( Finset.sum_le_sum h_term_bound ) _ );
        norm_num [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, left.ne', ne_of_gt ( sub_pos.mpr hab ) ];
        linarith;
      · field_simp;
        intros i hi j hj hij ; rw [ div_eq_div_iff ] at hij <;> norm_num [ left.ne' ] at * ; aesop;
        linarith

#check uniform_riemann_sum