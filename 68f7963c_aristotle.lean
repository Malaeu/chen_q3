/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 68f7963c-a7d9-4971-8777-2bd0b7425e9a

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators Real


-- Digamma function
def digamma (z : ℂ) : ℂ := (deriv Complex.Gamma z) / (Complex.Gamma z)

-- Base Archimedean density
def a (ξ : ℝ) : ℝ := Real.log Real.pi - (digamma (1/4 + Complex.I * Real.pi * ξ)).re

-- Gaussian-windowed kernel
def g (B t ξ : ℝ) : ℝ :=
  a ξ * (max 0 (1 - |ξ| / B)) * Real.exp (-4 * Real.pi^2 * t * ξ^2)

-- Derivative of g with respect to ξ
def g' (B t ξ : ℝ) : ℝ := deriv (g B t) ξ

-- Periodized symbol
def P_A (B t θ : ℝ) : ℝ := ∑' m : ℤ, g B t (θ + 2 * Real.pi * m)

-- Lipschitz modulus for periodized symbol
def L_A (B t : ℝ) : ℝ :=
  2 * Real.pi * sSup { y | ∃ θ ∈ Set.Icc (-Real.pi) Real.pi,
    y = ∑' m : ℤ, |g' B t (θ + 2 * Real.pi * m)| }

-- Mean integral A_0
def A_0 (B t : ℝ) : ℝ :=
  ∫ ξ in (-B)..B, a ξ * (max 0 (1 - |ξ| / B)) * Real.exp (-4 * Real.pi^2 * t * ξ^2)

-- Fixed parameters
def t_sym : ℝ := 3 / 50
def B_min : ℝ := 3

-- Uniform constants
def A_star (t : ℝ) : ℝ := sInf { y | ∃ B ≥ B_min, y = A_0 B t }
def L_star (t : ℝ) : ℝ := sSup { y | ∃ B ≥ B_min, y = L_A B t }
def c_star : ℝ := A_star t_sym - Real.pi * L_star t_sym

/-
g is zero outside [-B, B].
-/
lemma g_support (B t ξ : ℝ) (hB : B > 0) : |ξ| ≥ B → g B t ξ = 0 := by
  intro h
  unfold g
  have : 1 - |ξ| / B ≤ 0 := by
    rw [sub_nonpos]
    exact (one_le_div hB).mpr h
  rw [max_eq_left this]
  simp

/-
g is continuous.
-/
lemma g_continuous (B t : ℝ) (hB : B > 0) : Continuous (g B t) := by
  apply_rules [ Continuous.mul, Continuous.max, Continuous.add, continuous_id', continuous_const ];
  · apply_rules [ Continuous.neg, Complex.continuous_re.comp, Continuous.add, Continuous.mul, continuous_id, continuous_const ];
    · -- The derivative of the Gamma function is continuous.
      have h_gamma_deriv_cont : ContinuousOn (deriv Complex.Gamma) {z : ℂ | z.re > 0} := by
        have h_gamma_deriv_cont : DifferentiableOn ℂ (deriv Complex.Gamma) {z : ℂ | z.re > 0} := by
          have h_gamma_deriv_cont : DifferentiableOn ℂ Complex.Gamma {z : ℂ | z.re > 0} := by
            refine' fun z hz => DifferentiableAt.differentiableWithinAt ( Complex.differentiableAt_Gamma _ _ );
            exact fun m => ne_of_apply_ne Complex.re <| by norm_num; linarith [ hz.out ];
          apply_rules [ DifferentiableOn.deriv, h_gamma_deriv_cont ];
          exact isOpen_lt continuous_const Complex.continuous_re;
        exact h_gamma_deriv_cont.continuousOn;
      refine' continuous_iff_continuousAt.mpr _;
      intro x;
      exact h_gamma_deriv_cont.continuousAt ( IsOpen.mem_nhds ( isOpen_lt continuous_const Complex.continuous_re ) <| by norm_num [ Complex.ext_iff ] ) |> ContinuousAt.comp <| Continuous.continuousAt <| by continuity;
    · refine' Complex.continuous_conj.comp _;
      refine' continuous_iff_continuousAt.mpr _;
      intro x;
      refine' Complex.differentiableAt_Gamma _ _ |> DifferentiableAt.continuousAt |> ContinuousAt.comp <| Continuous.continuousAt <| by continuity;
      norm_num [ Complex.ext_iff ];
      exact fun m hm => by linarith;
    · refine' Complex.continuous_ofReal.comp _;
      refine' Continuous.inv₀ _ _;
      · -- The Gamma function is continuous, and the norm squared of a continuous function is continuous.
        have h_gamma_cont : Continuous (fun x : ℝ => Complex.Gamma (1 / 4 + Complex.I * Real.pi * x)) := by
          refine' continuous_iff_continuousAt.mpr _;
          intro x;
          refine' Complex.differentiableAt_Gamma _ _ |> DifferentiableAt.continuousAt |> ContinuousAt.comp <| Continuous.continuousAt <| by continuity;
          norm_num [ Complex.ext_iff ];
          exact fun m hm => by linarith;
        exact Complex.continuous_normSq.comp h_gamma_cont;
      · norm_num [ Complex.Gamma_eq_zero_iff ];
        norm_num [ Complex.ext_iff ];
        intros; linarith;
  · continuity;
  · fun_prop

/-
The periodization sum is finite.
-/
lemma periodization_summable (B t θ : ℝ) (hB : B > 0) : Summable (fun m : ℤ => g B t (θ + 2 * Real.pi * m)) := by
  -- The function g(B, t, ·) is supported on [-B, B] (by lemma g_support).
  have h_support : ∀ m : ℤ, abs (θ + 2 * Real.pi * m) ≥ B → g B t (θ + 2 * Real.pi * m) = 0 := by
    exact?;
  -- Therefore, the sum has finite support, which implies it is summable.
  have h_finite_support : Set.Finite {m : ℤ | abs (θ + 2 * Real.pi * m) < B} := by
    exact Set.Finite.subset ( Set.finite_Icc ( ⌈ ( -B - θ ) / ( 2 * Real.pi ) ⌉ ) ( ⌊ ( B - θ ) / ( 2 * Real.pi ) ⌋ ) ) fun m hm => ⟨ Int.ceil_le.mpr <| by rw [ div_le_iff₀ <| by positivity ] ; linarith [ abs_lt.mp hm.out ], Int.le_floor.mpr <| by rw [ le_div_iff₀ <| by positivity ] ; linarith [ abs_lt.mp hm.out ] ⟩;
  refine' summable_of_ne_finset_zero _;
  exacts [ h_finite_support.toFinset, fun m hm => h_support m <| le_of_not_gt fun h => hm <| h_finite_support.mem_toFinset.mpr h ]

/-
g' is zero outside [-B, B].
-/
lemma g_prime_support (B t ξ : ℝ) (hB : B > 0) : |ξ| > B → g' B t ξ = 0 := by
  intro hξ;
  have h_g_zero : ∀ᶠ x in nhds ξ, g B t x = 0 := by
    filter_upwards [ IsOpen.mem_nhds ( isOpen_lt continuous_const continuous_abs ) hξ ] with x hx using g_support B t x hB ( le_of_lt hx );
  exact HasDerivAt.deriv ( HasDerivAt.congr_of_eventuallyEq ( hasDerivAt_const _ _ ) h_g_zero )

def g_lipschitz_bound (B t θ : ℝ) : ℝ := ∑' m : ℤ, |g' B t (θ + 2 * Real.pi * m)|

/-
g is differentiable away from singularities.
-/
lemma g_diff_at (B t x : ℝ) (hB : B > 0) (hx : x ≠ 0 ∧ x ≠ B ∧ x ≠ -B) :
    DifferentiableAt ℝ (g B t) x := by
      refine' DifferentiableAt.mul ( DifferentiableAt.mul _ _ ) _;
      · -- Since $x \neq 0$, the function $a(x)$ is differentiable at $x$.
        have ha_diff : DifferentiableAt ℂ (fun z => (deriv Complex.Gamma z) / (Complex.Gamma z)) (1 / 4 + Complex.I * Real.pi * x) := by
          refine' DifferentiableAt.div _ _ _;
          · -- The derivative of the Gamma function is differentiable at $z = 1/4 + i \pi x$ because $\Gamma(z)$ is analytic there.
            have h_gamma_analytic : AnalyticAt ℂ Complex.Gamma (1 / 4 + Complex.I * Real.pi * x) := by
              refine' DifferentiableOn.analyticAt _ _;
              exact { z : ℂ | Complex.re z > 0 };
              · intro z hz;
                refine' DifferentiableAt.differentiableWithinAt _;
                apply_rules [ Complex.differentiableAt_Gamma ];
                exact fun m => ne_of_apply_ne Complex.re <| by norm_num; linarith [ hz.out ];
              · exact IsOpen.mem_nhds ( isOpen_lt continuous_const Complex.continuous_re ) ( by norm_num );
            exact h_gamma_analytic.deriv.differentiableAt;
          · refine' Complex.differentiableAt_Gamma _ _ ; norm_num [ Complex.ext_iff ];
            exact fun m hm => hx.1;
          · exact Complex.Gamma_ne_zero_of_re_pos ( by norm_num [ Complex.add_re, Complex.mul_re ] );
        have ha_diff : DifferentiableAt ℝ (fun x : ℝ => ((deriv Complex.Gamma (1 / 4 + Complex.I * Real.pi * x)) / (Complex.Gamma (1 / 4 + Complex.I * Real.pi * x))).re) x := by
          exact Complex.reCLM.differentiableAt.comp x ( ha_diff.restrictScalars ℝ |> DifferentiableAt.comp x <| DifferentiableAt.add ( differentiableAt_const _ ) <| DifferentiableAt.mul ( differentiableAt_const _ ) <| differentiableAt_id.comp x <| Complex.ofRealCLM.differentiableAt );
        convert ha_diff.const_sub ( Real.log Real.pi ) using 1;
      · -- Since $x \neq 0$ and $x \neq \pm B$, the function $1 - |x| / B$ is differentiable at $x$.
        have h_diff : DifferentiableAt ℝ (fun ξ => 1 - |ξ| / B) x := by
          exact DifferentiableAt.sub ( differentiableAt_const _ ) ( DifferentiableAt.div_const ( differentiableAt_id.norm ℝ hx.1 ) _ );
        by_cases h : 1 - |x| / B ≤ 0;
        · exact DifferentiableAt.congr_of_eventuallyEq ( differentiableAt_const _ ) ( Filter.eventuallyEq_of_mem ( h_diff.continuousAt.eventually ( gt_mem_nhds <| lt_of_le_of_ne h <| by cases abs_cases x <;> cases lt_or_gt_of_ne hx.1 <;> cases lt_or_gt_of_ne hx.2.1 <;> cases lt_or_gt_of_ne hx.2.2 <;> nlinarith [ mul_div_cancel₀ ( |x| ) hB.ne' ] ) ) fun y hy => max_eq_left hy.le );
        · exact DifferentiableAt.congr_of_eventuallyEq ( h_diff ) ( Filter.eventuallyEq_of_mem ( h_diff.continuousAt.eventually ( lt_mem_nhds ( not_le.mp h ) ) ) fun y hy => max_eq_right hy.out.le );
      · norm_num