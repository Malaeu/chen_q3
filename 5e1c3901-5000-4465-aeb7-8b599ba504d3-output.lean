/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 5e1c3901-5000-4465-aeb7-8b599ba504d3
-/

/-
Formalization of the A3 Core Lower Bound Lemma for the Archimedean coefficient A_0.
Definitions include `a_density`, `FejerHeatWindow`, `A_zero`, `m_r`, and `M_B`.
The main result `core_lower_bound` establishes a lower bound for `A_zero` in terms of core region parameters.
Note: The main lemma `core_lower_bound` requires the assumption `m_r r ≥ 0` to hold as stated, as the lower bound logic relies on the non-negativity of the lower bound of the density function for the product inequality to integrate correctly.
Helper lemmas `tail_bound_two_sided_tight` and `core_integral_bound_aux_nonneg` were proven to support the main result.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Complex.Gamma

/-
Definition of the digamma function as the logarithmic derivative of the Gamma function.
-/
noncomputable def Complex.digamma (z : ℂ) : ℂ := (deriv Gamma z) / (Gamma z)

noncomputable def a_density (ξ : ℝ) : ℝ := Real.log Real.pi - (Complex.re (Complex.digamma (1/4 + Complex.I * Real.pi * ξ)))

noncomputable def FejerHeatWindow (B t : ℝ) (ξ : ℝ) : ℝ :=
  max 0 (1 - |ξ| / B) * Real.exp (-4 * Real.pi^2 * t * ξ^2)

noncomputable def A_zero (B t : ℝ) : ℝ :=
  ∫ ξ in Set.Icc (-B) B, a_density ξ * FejerHeatWindow B t ξ

noncomputable def m_r (r : ℝ) : ℝ := ⨅ ξ ∈ Set.Icc (-r) r, a_density ξ

noncomputable def M_B (B : ℝ) : ℝ := ⨆ ξ ∈ Set.Icc (-B) B, |a_density ξ|

lemma tail_integral_bound_aux (B r t : ℝ) (hr : 0 < r) (hrB : r < B) (ht : t > 0) :
    ∫ ξ in Set.Icc r B, (1 - ξ / B) * Real.exp (-4 * Real.pi^2 * t * ξ^2) ≤
    1 / (4 * Real.pi^2 * t * r) * Real.exp (-4 * Real.pi^2 * t * r^2) := by
  -- Apply the comparison test to bound the integral.
  have h_bound : ∫ ξ in Set.Icc r B, Real.exp (-4 * Real.pi ^ 2 * t * ξ ^ 2) ≤ Real.exp (-4 * Real.pi ^ 2 * t * r ^ 2) * ∫ ξ in Set.Icc r B, Real.exp (-4 * Real.pi ^ 2 * t * r * (ξ - r)) := by
    rw [ ← MeasureTheory.integral_mul_left ];
    exact MeasureTheory.setIntegral_mono_on ( by exact Continuous.integrableOn_Icc <| by continuity ) ( by exact Continuous.integrableOn_Icc <| by continuity ) measurableSet_Icc fun x hx => by rw [ ← Real.exp_add ] ; exact Real.exp_le_exp.mpr <| by nlinarith [ hx.1, hx.2, show 0 ≤ 4 * Real.pi ^ 2 * t * r by positivity, show 0 ≤ 4 * Real.pi ^ 2 * t * ( x - r ) by exact mul_nonneg ( by positivity ) ( sub_nonneg.mpr hx.1 ) ] ;
  -- Evaluate the remaining integral.
  have h_remaining : ∫ ξ in Set.Icc r B, Real.exp (-4 * Real.pi ^ 2 * t * r * (ξ - r)) ≤ 1 / (4 * Real.pi ^ 2 * t * r) := by
    rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le ( by linarith ), intervalIntegral.integral_comp_sub_right fun ξ => Real.exp ( -4 * Real.pi ^ 2 * t * r * ξ ) ] ; norm_num;
    rw [ intervalIntegral.integral_comp_mul_left ( fun x => Real.exp ( -x ) ) ] <;> norm_num <;> ring <;> norm_num [ ne_of_gt, hr, hrB, ht ];
    positivity;
  refine' le_trans ( MeasureTheory.setIntegral_mono_on _ _ measurableSet_Icc fun x hx => mul_le_of_le_one_left ( Real.exp_nonneg _ ) <| sub_le_self _ <| div_nonneg ( by linarith [ hx.1 ] ) <| by linarith [ hx.1 ] ) _;
  · exact Continuous.integrableOn_Icc ( by continuity );
  · exact Continuous.integrableOn_Icc ( by continuity );
  · exact h_bound.trans ( by rw [ mul_comm ] ; gcongr )

lemma digamma_continuous_on_line : Continuous (fun ξ : ℝ => Complex.digamma (1/4 + Complex.I * Real.pi * ξ)) := by
  refine' continuous_iff_continuousAt.mpr _;
  intro x;
  refine' ContinuousAt.div _ _ _;
  · -- The derivative of the Gamma function is also analytic on the right half-plane.
    have h_deriv_analytic : AnalyticOn ℂ (deriv Complex.Gamma) {z : ℂ | 0 < z.re} := by
      apply_rules [ DifferentiableOn.analyticOn, DifferentiableOn.deriv ];
      · refine' fun z hz => DifferentiableAt.differentiableWithinAt _;
        apply_rules [ Complex.differentiableAt_Gamma ];
        exact fun m => ne_of_apply_ne Complex.re <| by norm_num; linarith [ hz.out ];
      · exact isOpen_lt continuous_const Complex.continuous_re;
      · exact isOpen_lt continuous_const Complex.continuous_re;
    refine' h_deriv_analytic.continuousOn.continuousAt _ |> ContinuousAt.comp <| Continuous.continuousAt <| by continuity;
    exact IsOpen.mem_nhds ( isOpen_lt continuous_const Complex.continuous_re ) ( by norm_num );
  · refine' ( Complex.differentiableAt_Gamma _ _ |> fun h => h.continuousAt.comp _ );
    · norm_num [ Complex.ext_iff ];
      exact fun m hm => by linarith;
    · exact Continuous.continuousAt ( by continuity );
  · exact Complex.Gamma_ne_zero_of_re_pos ( by norm_num [ Complex.add_re, Complex.mul_re ] )

lemma a_density_continuous : Continuous a_density := by
  refine' continuous_const.sub ( Complex.continuous_re.comp _ );
  exact?

lemma FejerHeatWindow_ge (B r t : ℝ) (hB : B > 0) (hr : 0 < r) (hrB : r < B) (ht : t > 0) :
    ∀ ξ ∈ Set.Icc (-r) r, FejerHeatWindow B t ξ ≥ (1 - r / B) * Real.exp (-4 * Real.pi^2 * t * r^2) := by
  norm_num +zetaDelta at *;
  intro ξ hξ₁ hξ₂; unfold FejerHeatWindow ; aesop;
  refine' le_trans _ ( mul_le_mul_of_nonneg_right ( le_max_of_le_right _ ) ( Real.exp_nonneg _ ) );
  refine' mul_le_mul _ _ _ _;
  exact 1 - r / B;
  · norm_num;
  · exact Real.exp_le_exp.mpr ( by nlinarith [ show 0 ≤ 4 * Real.pi ^ 2 * t by positivity, show ξ ^ 2 ≤ r ^ 2 by nlinarith ] );
  · positivity;
  · rw [ sub_nonneg, div_le_iff₀ ] <;> linarith;
  · gcongr ; cases abs_cases ξ <;> linarith

lemma core_integral_bound_aux_nonneg (B r t : ℝ) (hB : B > 0) (hr : 0 < r) (hrB : r < B) (ht : t > 0) (hm : m_r r ≥ 0) :
    ∫ ξ in Set.Icc (-r) r, a_density ξ * FejerHeatWindow B t ξ ≥
    2 * m_r r * r * (1 - r / B) * Real.exp (-4 * Real.pi^2 * t * r^2) := by
  -- Since $m_r r \geq 0$, we have $a_density ξ \geq m_r r$ for all $\xi \in [-r, r]$.
  have h_lower_bound : ∀ ξ ∈ Set.Icc (-r) r, a_density ξ ≥ m_r r := by
    aesop;
    refine' ( csInf_le _ _ );
    · -- Since $a_density$ is continuous on a compact interval, it is bounded below.
      have h_bdd_below : ∃ m, ∀ ξ ∈ Set.Icc (-r) r, a_density ξ ≥ m := by
        exact ⟨ ( InfSet.sInf <| a_density '' Set.Icc ( -r ) r ), fun x hx => ( csInf_le ( IsCompact.bddBelow <| isCompact_Icc.image <| show Continuous a_density from by exact? ) <| Set.mem_image_of_mem _ hx ) ⟩;
      obtain ⟨ m, hm ⟩ := h_bdd_below; use Min.min m 0; rintro x ⟨ ξ, rfl ⟩ ; by_cases hξ : -r ≤ ξ ∧ ξ ≤ r <;> aesop;
    · exact ⟨ ξ, by aesop ⟩;
  refine' le_trans _ ( MeasureTheory.setIntegral_mono_on _ _ measurableSet_Icc fun x hx => mul_le_mul_of_nonneg_right ( h_lower_bound x hx ) <| show 0 ≤ FejerHeatWindow B t x from _ );
  · rw [ MeasureTheory.integral_const_mul ];
    have h_integral_bound : ∫ ξ in Set.Icc (-r) r, FejerHeatWindow B t ξ ≥ ∫ ξ in Set.Icc (-r) r, (1 - r / B) * Real.exp (-4 * Real.pi^2 * t * r^2) := by
      refine' MeasureTheory.setIntegral_mono_on _ _ _ _;
      · exact Continuous.integrableOn_Icc ( by continuity );
      · refine' Continuous.integrableOn_Icc _;
        exact Continuous.mul ( Continuous.max continuous_const <| Continuous.sub continuous_const <| continuous_abs.div_const _ ) <| Real.continuous_exp.comp <| by continuity;
      · norm_num;
      · exact?;
    simp_all +decide [ le_of_lt hr ];
    nlinarith;
  · refine' Continuous.integrableOn_Icc _;
    refine' Continuous.mul continuous_const _;
    exact Continuous.mul ( Continuous.max continuous_const <| Continuous.sub continuous_const <| continuous_abs.div_const _ ) <| Real.continuous_exp.comp <| by continuity;
  · refine' Continuous.integrableOn_Icc _;
    refine' Continuous.mul _ _;
    · exact?;
    · exact Continuous.max ( continuous_const ) ( Continuous.sub continuous_const ( Continuous.div_const ( continuous_abs ) _ ) ) |> Continuous.mul <| Real.continuous_exp.comp <| Continuous.mul continuous_const <| continuous_pow 2;
  · exact mul_nonneg ( le_max_left _ _ ) ( Real.exp_nonneg _ )

lemma tail_bound_two_sided (B r t : ℝ) (hr : 0 < r) (hrB : r < B) (ht : t > 0) :
    ∫ ξ in Set.Icc (-B) B \ Set.Icc (-r) r, (1 - |ξ| / B) * Real.exp (-4 * Real.pi^2 * t * ξ^2) ≤
    1 / (2 * Real.pi^2 * t * r) * Real.exp (-4 * Real.pi^2 * t * r^2) := by
  by_contra h_contra;
  -- By definition of integrals, we can write
  have h_integral : ∫ ξ in Set.Icc (-B) B \ Set.Icc (-r) r, (1 - |ξ| / B) * Real.exp (-4 * Real.pi ^ 2 * t * ξ ^ 2) = 2 * ∫ ξ in Set.Ioc r B, (1 - ξ / B) * Real.exp (-4 * Real.pi ^ 2 * t * ξ ^ 2) := by
    have h_integral : ∫ ξ in Set.Icc (-B) B \ Set.Icc (-r) r, (1 - |ξ| / B) * Real.exp (-4 * Real.pi ^ 2 * t * ξ ^ 2) = (∫ ξ in Set.Ioc r B, (1 - |ξ| / B) * Real.exp (-4 * Real.pi ^ 2 * t * ξ ^ 2)) + (∫ ξ in Set.Ico (-B) (-r), (1 - |ξ| / B) * Real.exp (-4 * Real.pi ^ 2 * t * ξ ^ 2)) := by
      rw [ ← MeasureTheory.setIntegral_union ];
      · rcongr x ; aesop <;> try linarith;
        exact Classical.or_iff_not_imp_left.2 fun h => not_le.1 fun h' => h <| right <| by linarith;
      · exact Set.disjoint_left.mpr fun x hx₁ hx₂ => by linarith [ hx₁.1, hx₁.2, hx₂.1, hx₂.2 ];
      · norm_num;
      · exact Continuous.integrableOn_Ioc ( by continuity );
      · exact Continuous.integrableOn_Icc ( by continuity ) |> fun h => h.mono_set ( Set.Ico_subset_Icc_self );
    -- By symmetry of the integrand, we have
    have h_symm : ∫ ξ in Set.Ico (-B) (-r), (1 - |ξ| / B) * Real.exp (-4 * Real.pi ^ 2 * t * ξ ^ 2) = ∫ ξ in Set.Ioc r B, (1 - |ξ| / B) * Real.exp (-4 * Real.pi ^ 2 * t * ξ ^ 2) := by
      rw [ ← MeasureTheory.integral_Icc_eq_integral_Ico, ← MeasureTheory.integral_Icc_eq_integral_Ioc ];
      rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, MeasureTheory.integral_Icc_eq_integral_Ioc ] ; rw [ ← intervalIntegral.integral_of_le ( by linarith ), ← intervalIntegral.integral_of_le ( by linarith ) ] ; convert intervalIntegral.integral_comp_neg _ using 2 <;> norm_num;
    rw [ h_integral, h_symm, two_mul ];
    exact congrArg₂ ( · + · ) ( MeasureTheory.setIntegral_congr_fun measurableSet_Ioc fun x hx => by rw [ abs_of_nonneg ( by linarith [ hx.1 ] ) ] ) ( MeasureTheory.setIntegral_congr_fun measurableSet_Ioc fun x hx => by rw [ abs_of_nonneg ( by linarith [ hx.1 ] ) ] );
  -- Using the result from `tail_integral_bound_aux`, we have
  have h_tail_bound : ∫ ξ in Set.Ioc r B, (1 - ξ / B) * Real.exp (-4 * Real.pi ^ 2 * t * ξ ^ 2) ≤ (1 / (4 * Real.pi ^ 2 * t * r)) * Real.exp (-4 * Real.pi ^ 2 * t * r ^ 2) := by
    convert tail_integral_bound_aux B r t hr hrB ht using 1;
    rw [ MeasureTheory.integral_Icc_eq_integral_Ioc ];
  exact h_contra <| h_integral.symm ▸ by convert mul_le_mul_of_nonneg_left h_tail_bound zero_le_two using 1 ; ring;

lemma tail_bound_two_sided_tight (B r t : ℝ) (hr : 0 < r) (hrB : r < B) (ht : t > 0) :
    ∫ ξ in Set.Icc (-B) B \ Set.Icc (-r) r, (1 - |ξ| / B) * Real.exp (-4 * Real.pi^2 * t * ξ^2) ≤
    1 / (4 * Real.pi^2 * t * r) * Real.exp (-4 * Real.pi^2 * t * r^2) := by
  field_simp;
  -- The integral bounds can be simplified using the provided solution's approach and symmetry.
  have h_symm : (∫ ξ in ((Set.Icc (-B) B) \ (Set.Icc (-r) r)), (1 - |ξ| / B) * (Real.exp (-(4 * Real.pi ^ 2 * t * ξ ^ 2)))) = 2 * (∫ ξ in (r)..B, (1 - ξ / B) * (Real.exp (-(4 * Real.pi ^ 2 * t * ξ ^ 2)))) := by
    -- By symmetry of the integrand, we can split the integral into two parts:
    have h_split : (∫ ξ in ((Set.Icc (-B) B) \ (Set.Icc (-r) r)), (1 - |ξ| / B) * (Real.exp (-(4 * Real.pi ^ 2 * t * ξ ^ 2)))) =
               (∫ ξ in (-B)..(-r), (1 - |ξ| / B) * (Real.exp (-(4 * Real.pi ^ 2 * t * ξ ^ 2)))) +
               (∫ ξ in r..B, (1 - |ξ| / B) * (Real.exp (-(4 * Real.pi ^ 2 * t * ξ ^ 2)))) := by
                 rw [ show ( Set.Icc ( -B ) B \ Set.Icc ( -r ) r : Set ℝ ) = Set.Ico ( -B ) ( -r ) ∪ Set.Ioc r B from ?_, MeasureTheory.setIntegral_union ] <;> norm_num [ hr.le, hrB.le ];
                 · rw [ intervalIntegral.integral_of_le ( by linarith ), intervalIntegral.integral_of_le ( by linarith ), MeasureTheory.Measure.restrict_congr_set MeasureTheory.Ico_ae_eq_Ioc ];
                 · exact Set.disjoint_left.mpr fun x hx₁ hx₂ => by linarith [ hx₁.2, hx₂.1 ];
                 · exact Continuous.integrableOn_Icc ( by continuity ) |> fun h => h.mono_set ( Set.Ico_subset_Icc_self );
                 · exact Continuous.integrableOn_Ioc ( by continuity );
                 · ext ; aesop <;> try linarith;
                   exact Classical.or_iff_not_imp_left.2 fun h => right <| by linarith;
    rw [ h_split, two_mul ];
    rw [ ← intervalIntegral.integral_comp_neg, ] ; norm_num;
    rw [ intervalIntegral.integral_congr fun x hx => by rw [ abs_of_nonneg ( by linarith [ Set.mem_Icc.mp ( by simpa [ hr.le, hrB.le ] using hx ) ] ) ] ];
  -- Using the Gaussian tail bound, we can bound the integral over $(r, B)$.
  have h_gauss_tail : ∫ ξ in (r)..B, (Real.exp (-(4 * Real.pi ^ 2 * t * ξ ^ 2))) ≤ Real.exp (-(4 * Real.pi ^ 2 * t * r ^ 2)) / (2 * 4 * Real.pi ^ 2 * t * r) := by
    have h_gauss_tail : ∫ ξ in (r)..B, (Real.exp (-(4 * Real.pi ^ 2 * t * ξ ^ 2))) ≤ ∫ ξ in (r)..B, (Real.exp (-(4 * Real.pi ^ 2 * t * r ^ 2))) * (Real.exp (-(4 * Real.pi ^ 2 * t * (ξ - r) * (2 * r)))) := by
      refine' intervalIntegral.integral_mono_on _ _ _ _ <;> norm_num;
      · linarith;
      · exact Continuous.intervalIntegrable ( by continuity ) _ _;
      · exact Continuous.intervalIntegrable ( by continuity ) _ _;
      · intro x hx₁ hx₂; rw [ ← Real.exp_add ] ; exact Real.exp_le_exp.mpr ( by nlinarith [ show 0 ≤ 4 * Real.pi ^ 2 * t * ( x - r ) by exact mul_nonneg ( by positivity ) ( by linarith ) ] ) ;
    -- Evaluating the integral of the Gaussian tail bound.
    have h_gauss_tail_eval : ∫ ξ in (r)..B, (Real.exp (-(4 * Real.pi ^ 2 * t * r ^ 2))) * (Real.exp (-(4 * Real.pi ^ 2 * t * (ξ - r) * (2 * r)))) = (Real.exp (-(4 * Real.pi ^ 2 * t * r ^ 2))) / (8 * Real.pi ^ 2 * t * r) * (1 - Real.exp (-(8 * Real.pi ^ 2 * t * r * (B - r)))) := by
      rw [ intervalIntegral.integral_const_mul ];
      rw [ intervalIntegral.integral_comp_sub_right fun x => Real.exp ( - ( 4 * Real.pi ^ 2 * t * x * ( 2 * r ) ) ) ] ; norm_num ; ring;
      rw [ intervalIntegral.integral_comp_mul_left ( fun x => Real.exp ( - ( x * 8 ) ) ) ] <;> norm_num ; ring;
      · rw [ intervalIntegral.integral_comp_mul_right ( fun x => Real.exp ( -x ) ) ] <;> norm_num ; ring;
      · exact ⟨ ht.ne', hr.ne' ⟩;
    exact h_gauss_tail.trans ( h_gauss_tail_eval ▸ mul_le_of_le_one_right ( by positivity ) ( sub_le_self _ ( by positivity ) ) |> le_trans <| by ring_nf; norm_num );
  -- Applying the Gaussian tail bound to our integral.
  have h_int_bound : ∫ ξ in (r)..B, (1 - ξ / B) * (Real.exp (-(4 * Real.pi ^ 2 * t * ξ ^ 2))) ≤ ∫ ξ in (r)..B, (Real.exp (-(4 * Real.pi ^ 2 * t * ξ ^ 2))) := by
    refine' intervalIntegral.integral_mono_on _ _ _ _ <;> norm_num;
    · linarith;
    · exact Continuous.intervalIntegrable ( by continuity ) _ _;
    · exact Continuous.intervalIntegrable ( by continuity ) _ _;
    · exact fun x hx₁ hx₂ => mul_le_of_le_one_left ( Real.exp_nonneg _ ) ( sub_le_self _ ( div_nonneg ( by linarith ) ( by linarith ) ) );
  norm_num [ mul_assoc, mul_comm, mul_left_comm ] at *;
  rw [ le_div_iff₀ ] at * <;> nlinarith [ show 0 < r * ( t * ( Real.pi ^ 2 * 4 ) ) by positivity ]

/-- Core contribution lemma: A_0 has explicit lower bound from core region.
    Note: We assume m_r r ≥ 0, as the bound fails if m_r r < 0. -/
lemma core_lower_bound (B r t : ℝ) (hB : B > 0) (hr : 0 < r) (hrB : r < B) (ht : t > 0) (hm : m_r r ≥ 0) :
    A_zero B t ≥ 2 * m_r r * r * (1 - r / B) * Real.exp (-4 * Real.pi^2 * t * r^2)
                 - M_B B / (4 * Real.pi^2 * t * r) * Real.exp (-4 * Real.pi^2 * t * r^2) := by
  -- For the first part, we use the fact that $a_density (\xi) \geq m_r r$ for $\xi \in [-r, r]$.
  have h_core : ∫ ξ in Set.Icc (-r) r, a_density ξ * (FejerHeatWindow B t ξ) ≥ 2 * m_r r * r * (1 - r / B) * Real.exp (-4 * Real.pi ^ 2 * t * r ^ 2) := by
    apply_rules [ core_integral_bound_aux_nonneg ];
  -- For the second part, we use the fact that $|a_density (\xi)| \leq M_B$ for $\xi \in [-B, B]$.
  have h_tail : ∫ ξ in Set.Icc (-B) B \ Set.Icc (-r) r, abs (a_density ξ) * (FejerHeatWindow B t ξ) ≤ M_B B / (4 * Real.pi ^ 2 * t * r) * Real.exp (-4 * Real.pi ^ 2 * t * r ^ 2) := by
    -- Using the bound on $|a_density (\xi)|$, we get:
    have h_tail_bound : ∫ ξ in Set.Icc (-B) B \ Set.Icc (-r) r, abs (a_density ξ) * (FejerHeatWindow B t ξ) ≤ M_B B * ∫ ξ in Set.Icc (-B) B \ Set.Icc (-r) r, (1 - |ξ| / B) * Real.exp (-4 * Real.pi ^ 2 * t * ξ ^ 2) := by
      have h_abs : ∀ ξ ∈ Set.Icc (-B) B \ Set.Icc (-r) r, abs (a_density ξ) ≤ M_B B := by
        intro ξ hξ; unfold M_B; aesop;
        refine' le_trans _ ( le_ciSup _ ξ );
        · aesop;
        · -- The range of $|a_density|$ is bounded above since $a_density$ is continuous on a compact interval.
          have h_bdd_above : ∃ C, ∀ ξ ∈ Set.Icc (-B) B, abs (a_density ξ) ≤ C := by
            exact IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) ( a_density_continuous.continuousOn );
          obtain ⟨ C, hC ⟩ := h_bdd_above; use Max.max C 1; rintro x ⟨ ξ, rfl ⟩ ; by_cases hξ : -B ≤ ξ ∧ ξ ≤ B <;> aesop;
      rw [ ← MeasureTheory.integral_const_mul ];
      refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
      · filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_Icc.diff measurableSet_Icc ] with ξ hξ using mul_nonneg ( abs_nonneg _ ) ( by unfold FejerHeatWindow; exact mul_nonneg ( by exact le_max_left _ _ ) <| Real.exp_nonneg _ );
      · exact Continuous.integrableOn_Icc ( by continuity ) |> fun h => h.mono_set <| Set.diff_subset;
      · filter_upwards [ MeasureTheory.ae_restrict_mem <| measurableSet_Icc.diff <| measurableSet_Icc ] with ξ hξ ; aesop;
        refine' mul_le_mul ( h_abs ξ left right_1 right ) _ _ _;
        · unfold FejerHeatWindow;
          rw [ max_eq_right ( sub_nonneg.2 <| div_le_one_of_le₀ ( by cases abs_cases ξ <;> linarith ) hB.le ) ] ; ring_nf ; norm_num;
        · exact mul_nonneg ( le_max_left _ _ ) ( Real.exp_nonneg _ );
        · exact le_trans ( abs_nonneg _ ) ( h_abs ( -B ) ( by linarith ) ( by linarith ) ( by intros; linarith ) );
    refine le_trans h_tail_bound ?_;
    convert mul_le_mul_of_nonneg_left ( tail_bound_two_sided_tight B r t hr hrB ht ) ( show 0 ≤ M_B B by
                                                                                        apply_rules [ Real.iSup_nonneg ] ; norm_num [ abs_nonneg ];
                                                                                        exact fun x => Real.iSup_nonneg fun _ => abs_nonneg _ ) using 1 ; ring;
  -- Using the triangle inequality, we can combine the two parts.
  have h_combined : abs (∫ ξ in Set.Icc (-B) B \ Set.Icc (-r) r, a_density ξ * (FejerHeatWindow B t ξ)) ≤ M_B B / (4 * Real.pi ^ 2 * t * r) * Real.exp (-4 * Real.pi ^ 2 * t * r ^ 2) := by
    refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm ( _ : ℝ → ℝ ) ) _;
    refine' le_trans _ h_tail;
    refine' le_of_eq ( MeasureTheory.setIntegral_congr_fun _ _ );
    · exact measurableSet_Icc.diff measurableSet_Icc;
    · intro ξ hξ; simp +decide [ abs_mul, abs_of_nonneg ( show 0 ≤ FejerHeatWindow B t ξ from mul_nonneg ( le_max_left _ _ ) ( Real.exp_nonneg _ ) ) ] ;
  have h_combined : ∫ ξ in Set.Icc (-B) B, a_density ξ * (FejerHeatWindow B t ξ) = (∫ ξ in Set.Icc (-r) r, a_density ξ * (FejerHeatWindow B t ξ)) + (∫ ξ in Set.Icc (-B) B \ Set.Icc (-r) r, a_density ξ * (FejerHeatWindow B t ξ)) := by
    rw [ MeasureTheory.integral_diff ] <;> norm_num;
    · refine' Continuous.integrableOn_Icc _;
      refine' Continuous.mul _ _;
      · exact?;
      · refine' Continuous.mul _ _;
        · fun_prop;
        · fun_prop;
    · exact Set.Icc_subset_Icc ( by linarith ) ( by linarith );
  linarith! [ abs_le.mp ‹_› ]