/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b1c82f72-6bf0-48d5-9674-dcf18ecc67a0

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The twin prime sum S₂(N) is the sum of Λ(n)Λ(n+2) for n ≤ N.
-/
noncomputable def S₂ (N : ℕ) : ℝ := ∑ n ∈ Finset.range (N + 1), ArithmeticFunction.vonMangoldt n * ArithmeticFunction.vonMangoldt (n + 2)

/-
Auxiliary functions for the Commutator Kernel: ξ_p = log(p)/(2π), w_r = 2Λ(r)/√r, G(δ) = √(2πt) · exp(-δ²/(8t)).
-/
noncomputable def ξ (p : ℕ) : ℝ := Real.log p / (2 * Real.pi)

noncomputable def w (r : ℕ) : ℝ := 2 * ArithmeticFunction.vonMangoldt r / Real.sqrt r

noncomputable def G (t δ : ℝ) : ℝ := Real.sqrt (2 * Real.pi * t) * Real.exp (-δ^2 / (8 * t))

/-
is_twin_prime(p) is true if p and p+2 are both prime. T(X) is the set of twin primes ≤ X.
-/
def is_twin_prime (p : ℕ) : Prop := Nat.Prime p ∧ Nat.Prime (p + 2)

noncomputable def T (X : ℕ) : Finset ℕ := (Finset.range (X + 1)).filter is_twin_prime

/-
K_comm(ξ_p, ξ_q) = Σ_{r,s≤X} w_r w_s G(ξ_p-ξ_r) G(ξ_q-ξ_s) G(ξ_s-ξ_r) · [(ξ_p-ξ_s)(ξ_q-ξ_r)/4 + t]
-/
noncomputable def K_comm (X : ℕ) (t : ℝ) (u v : ℝ) : ℝ :=
  ∑ r ∈ Finset.range (X + 1), ∑ s ∈ Finset.range (X + 1),
    w r * w s * G t (u - ξ r) * G t (v - ξ s) * G t (ξ s - ξ r) * ((u - ξ s) * (v - ξ r) / 4 + t)

/-
ℰ_X(λ) := Σ_{p,q ∈ T(X)} λ_p λ_q K_comm(ξ_p, ξ_q) where λ_p = Λ(p)Λ(p+2).
-/
noncomputable def lambda (p : ℕ) : ℝ := ArithmeticFunction.vonMangoldt p * ArithmeticFunction.vonMangoldt (p + 2)

noncomputable def ℰ_X (X : ℕ) (t : ℝ) : ℝ :=
  ∑ p ∈ T X, ∑ q ∈ T X, lambda p * lambda q * K_comm X t (ξ p) (ξ q)

/-
Defining Fact 7 (K_comm is PSD) and Fact 5 (Diagonal Energy Bound) as predicates to be used as assumptions.
-/
def Fact7_K_comm_PSD (X : ℕ) (t : ℝ) : Prop :=
  ∀ c : ℕ → ℝ, ∑ p ∈ T X, ∑ q ∈ T X, c p * c q * K_comm X t (ξ p) (ξ q) ≥ 0

def Fact5_Diagonal_Energy_Bound (t : ℝ) : Prop :=
  ∃ C > 0, ∃ X₀ : ℕ, ∀ X ≥ X₀,
    ∑ p ∈ T X, (lambda p)^2 * K_comm X t (ξ p) (ξ p) ≥ C * S₂ X

/-
Lemma 1: ℰ_X(λ) ≥ c₁(t) · S₂(X). Proof: Assume ℰ_X ≥ ℰ_X_diag (from PSD of off-diagonal) and ℰ_X_diag ≥ C·S₂ (Fact 5).
-/
noncomputable def ℰ_X_diag (X : ℕ) (t : ℝ) : ℝ :=
  ∑ p ∈ T X, (lambda p)^2 * K_comm X t (ξ p) (ξ p)

theorem lemma1 (t : ℝ) (ht : t > 0)
  (h_diag_dom : ∀ X, ℰ_X X t ≥ ℰ_X_diag X t)
  (h_diag_bound : ∃ C > 0, ∃ X₀ : ℕ, ∀ X ≥ X₀, ℰ_X_diag X t ≥ C * S₂ X) :
  ∃ C₁ > 0, ∃ X₀ : ℕ, ∀ X ≥ X₀, ℰ_X X t ≥ C₁ * S₂ X := by
    exact ⟨ h_diag_bound.choose, h_diag_bound.choose_spec.1, h_diag_bound.choose_spec.2.choose, fun X hX => le_trans ( h_diag_bound.choose_spec.2.choose_spec X hX ) ( h_diag_dom X ) ⟩

/-
Checking availability of Complex.exp, Complex.I, and Complex.normSq.
-/
#check Complex.exp
#check Complex.I
#check Complex.normSq

/-
Defining DFT_Λ and Fact 1 (Parseval Identity) using Complex.normSq.
-/
noncomputable def DFT_Λ (N : ℕ) (ξ : ℝ) : ℂ :=
  ∑ n ∈ Finset.range (N + 1), (ArithmeticFunction.vonMangoldt n : ℂ) * Complex.exp (-2 * Real.pi * Complex.I * n * ξ)

def Fact1_Parseval (N : ℕ) : Prop :=
  (S₂ N : ℂ) = (1 / (N : ℂ)) * ∑ k ∈ Finset.range N, (Complex.normSq (DFT_Λ N (k / N)) : ℂ) * Complex.exp (4 * Real.pi * Complex.I * k / N)

/-
Defining Lemma 2 (Upper Bound) as a predicate.
-/
def Lemma2_Upper_Bound (t : ℝ) : Prop :=
  ∃ C₂ > 0, ∃ X₀ : ℕ, ∀ X ≥ X₀, ℰ_X X t ≤ C₂ * S₂ X * (Real.log X)^2

/-
Defining the spectral gap hypothesis (Q3).
-/
def spectral_gap (δ : ℝ) : Prop :=
  ∃ c₀ > 0, ∀ X : ℕ, X > 0 → ∃ Φ_X : ℕ → ℝ,
    (∑ p ∈ T X, ∑ q ∈ T X, Φ_X p * Φ_X q * K_comm X 1 (ξ p) (ξ q)) ≥ c₀ * (X : ℝ)^δ * (∑ p ∈ T X, (Φ_X p)^2)

/-
S₂_twin(X) is the sum of Λ(n)Λ(n+2) restricted to twin primes n ≤ X.
-/
noncomputable def S₂_twin (X : ℕ) : ℝ :=
  ∑ n ∈ Finset.range (X + 1), if is_twin_prime n then ArithmeticFunction.vonMangoldt n * ArithmeticFunction.vonMangoldt (n + 2) else 0

/-
S₂_rest(X) is the sum of Λ(n)Λ(n+2) for n ≤ X where n is not a twin prime.
-/
noncomputable def S₂_rest (X : ℕ) : ℝ :=
  ∑ n ∈ Finset.range (X + 1), if is_twin_prime n then 0 else ArithmeticFunction.vonMangoldt n * ArithmeticFunction.vonMangoldt (n + 2)

/-
S₂(X) = S₂_twin(X) + S₂_rest(X). This follows directly from the definitions by splitting the sum based on whether n is a twin prime or not.
-/
theorem S₂_split (X : ℕ) : S₂ X = S₂_twin X + S₂_rest X := by
  unfold S₂ S₂_twin S₂_rest;
  simpa only [ ← Finset.sum_add_distrib ] using Finset.sum_congr rfl fun _ _ => by split_ifs <;> ring;