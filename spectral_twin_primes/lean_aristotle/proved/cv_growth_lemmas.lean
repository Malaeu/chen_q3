/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 3645cb77-e7d8-4b2c-ba4d-8ac990c18a9d
-/

/-
This module formalizes the argument that the growth of the coefficient of variation (cv) of twin prime gaps implies the Twin Prime Conjecture.
It defines twin prime gaps, the coefficient of variation, and proves (conditional on helper lemmas) that:
1. The mean gap scales with span/N.
2. The variance decomposes into within-group and between-group variance.
3. The local mean gap scales as ξ².
4. The between-group variance grows unboundedly.
5. The cv grows unboundedly.
6. The growth of cv implies the growth of the commutator energy ratio R.
Finally, it proves that if the cv grows unboundedly, then there must be infinitely many twin primes.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def twin_gaps (twins : List ℕ) : List ℝ :=
  List.zipWith (fun p q => (Real.log q - Real.log p) / (2 * Real.pi))
               twins twins.tail

def cv (gaps : List ℝ) : ℝ :=
  let N := (gaps.length : ℝ)
  let μ := gaps.sum / N
  let var := (gaps.map (fun g => (g - μ) * (g - μ))).sum / N
  Real.sqrt var / μ

/-
Lemma 1: Mean Gap Scales with Span/N
mean_gap = span / (N-1)
        = (ξ_{p_N} - ξ_{p_1}) / (N-1)
-/
lemma lemma1_mean_gap (twins : List ℕ) (h_len : twins.length ≥ 2) :
  let gaps := twin_gaps twins
  let N := twins.length
  let span := (Real.log (twins.getLast (List.ne_nil_of_length_pos (lt_of_lt_of_le (by norm_num) h_len))) - Real.log (twins.head (List.ne_nil_of_length_pos (lt_of_lt_of_le (by norm_num) h_len)))) / (2 * Real.pi)
  gaps.sum / gaps.length = span / (N - 1) := by
  unfold twin_gaps
  generalize_proofs at *;
  induction twins <;> aesop;
  rcases tail <;> aesop;
  by_cases h : 1 ≤ List.length tail <;> aesop;
  rw [ div_eq_iff ( by positivity ) ] at *;
  rw [ tail_ih, div_mul_cancel₀ _ ( by positivity ) ] ; ring;
  -- Combine like terms and simplify the expression.
  field_simp
  ring

def mean (l : List ℝ) : ℝ := l.sum / l.length

def variance (l : List ℝ) : ℝ :=
  let μ := mean l
  (l.map (fun x => (x - μ)^2)).sum / l.length

/-
Lemma 2: Gap Variance Decomposition
var_gap = mean(local_variances) + variance(local_means)
        = within-group variance + between-group variance
-/
lemma lemma2_variance_decomposition (groups : List (List ℝ))
  (h_groups : groups ≠ [])
  (m : ℕ) (hm : m > 0)
  (h_lengths : ∀ g ∈ groups, g.length = m) :
  let gaps := groups.flatten
  variance gaps = mean (groups.map variance) + variance (groups.map mean) := by
  -- Let's calculate the total variance.
  have h_total_variance : ∀ (groups : List (List ℝ)), groups ≠ [] → (∀ g ∈ groups, g.length = m) → let gaps := groups.flatten;
      variance gaps = (List.sum (List.map (fun g => (variance g) * g.length) groups) +
                      List.sum (List.map (fun g => g.length * (mean g - mean groups.flatten) ^ 2) groups)) / groups.flatten.length := by
                        intro groups h_groups h_lengths; unfold mean variance; aesop;
                        -- Apply the Law of Total Variance to each group.
                        have h_group_variance : ∀ (g : List ℝ), g.length = m → (List.map (fun x => (x - mean groups.flatten) ^ 2) g).sum = (List.map (fun x => (x - mean g) ^ 2) g).sum + g.length * (mean g - mean groups.flatten) ^ 2 := by
                          intro g hg; simp +decide [ sub_sq, Finset.sum_add_distrib, Finset.mul_sum _ _ _, Finset.sum_mul _ _ _, hg ] ; ring;
                          have := List.sum_map_mul_right g ( fun x => x ) ( -2 * mean groups.flatten ) ; ( have := List.sum_map_mul_right g ( fun x => x ) ( -2 * mean g ) ; ( simp_all +decide [ mul_assoc, mul_comm, mul_left_comm, List.sum_map_mul_right ] ; ring; ) );
                          rw [ show mean g = g.sum / g.length from ?_ ] ; rw [ hg ] ; ring;
                          · simpa [ sq, mul_assoc, mul_comm, mul_left_comm, hm.ne' ] using by ring;
                          · exact?;
                        congr 2;
                        rw [ ← List.sum_map_add ] ; refine' congr_arg _ ( List.ext_get _ _ ) <;> aesop;
                        rw [ div_mul_cancel₀ _ ( by positivity ) ] ; aesop;
                        unfold mean; aesop;
  -- Since each group has the same length $m$, we can simplify the sums.
  have h_group_length : ∀ (groups : List (List ℝ)), groups ≠ [] → (∀ g ∈ groups, g.length = m) → let gaps := groups.flatten;
      (List.sum (List.map (fun g => g.length * (mean g - mean groups.flatten) ^ 2) groups)) = m * (List.length groups) * (variance (List.map mean groups)) := by
        -- Let's simplify the expression inside the sum.
        intros groups h_groups h_lengths
        simp [variance, List.sum_map_mul_right, List.sum_map_mul_left, h_lengths];
        -- By definition of mean, we know that
        have h_mean : mean groups.flatten = mean (List.map mean groups) := by
          unfold mean; aesop;
          rw [ show List.map ( Nat.cast ∘ List.length ) groups = List.map ( fun _ => ( m : ℝ ) ) groups by exact List.ext_get ( by aesop ) ( by aesop ) ] ; norm_num [ List.sum_replicate, hm.ne' ] ; ring;
          rw [ show List.map ( fun l => l.sum * ( l.length : ℝ ) ⁻¹ ) groups = List.map ( fun l => l.sum * ( m : ℝ ) ⁻¹ ) groups by exact List.map_congr_left fun l hl => by rw [ h_lengths l hl ] ] ; ring;
          rw [ List.sum_map_mul_left ] ; ring;
        rw [ h_mean, mul_assoc, mul_div_cancel₀ _ ( by aesop ) ];
        rw [ ← List.sum_map_mul_left ] ; exact congr_arg _ ( List.ext_get ( by aesop ) ( by aesop ) ) ;
  -- Substitute h_group_length into h_total_variance.
  have h_substitute : ∀ (groups : List (List ℝ)), groups ≠ [] → (∀ g ∈ groups, g.length = m) → let gaps := groups.flatten;
      variance gaps = ((List.sum (List.map (fun g => (variance g) * m) groups)) +
                      m * (List.length groups) * (variance (List.map mean groups))) / (m * (List.length groups)) := by
                        intro groups h_groups h_lengths; specialize h_total_variance groups h_groups h_lengths; specialize h_group_length groups h_groups h_lengths; aesop;
                        congr! 2;
                        · exact congr_arg _ ( List.ext_get ( by aesop ) ( by aesop ) );
                        · rw [ mul_comm, List.sum_eq_card_nsmul ] <;> aesop;
  convert h_substitute groups h_groups h_lengths using 1 ; norm_num [ mean, hm.ne', mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _, div_eq_mul_inv ] ; ring!;
  norm_num [ mul_assoc, mul_comm, mul_left_comm, hm.ne', List.sum_map_mul_right ] ; ring!; aesop;

/-
Lemma 3: Local Mean Gap Scales as ξ²
Defined local density ρ(ξ) ~ 1/ξ² following user's hypothesis.
Then mean gap μ(ξ) = 1/ρ(ξ) ~ ξ².
-/
noncomputable def C_twin : ℝ := 1 -- Placeholder value

noncomputable def local_density (ξ : ℝ) : ℝ := C_twin / (2 * Real.pi * ξ)^2

noncomputable def local_mean_gap (ξ : ℝ) : ℝ := 1 / local_density ξ

open Filter Asymptotics

lemma lemma3_local_mean_gap_scaling :
  local_mean_gap =ᶠ[atTop] fun ξ => (4 * Real.pi^2 / C_twin) * ξ^2 := by
  unfold local_mean_gap local_density
  filter_upwards with ξ
  field_simp
  ring

/-
Lemma 4: Between-Group Variance Grows
The variance of the local mean gap function (which scales as ξ²) over the interval [a, b] grows unboundedly as b → ∞.
-/
noncomputable def continuous_mean (f : ℝ → ℝ) (a b : ℝ) : ℝ :=
  (∫ x in a..b, f x) / (b - a)

noncomputable def continuous_variance (f : ℝ → ℝ) (a b : ℝ) : ℝ :=
  (∫ x in a..b, (f x - continuous_mean f a b)^2) / (b - a)

lemma lemma4_between_group_variance_grows (a : ℝ) :
  Tendsto (fun b => continuous_variance (fun x => x^2) a b) atTop atTop := by
  -- Calculate the variance of $x^2$ over the interval $[a, b]$.
  have h_var : ∀ b > a, continuous_variance (fun x : ℝ => x ^ 2) a b = (b ^ 5 / 5 - a ^ 5 / 5 - (b ^ 3 / 3 - a ^ 3 / 3) ^ 2 / (b - a)) / (b - a) := by
    intros b hb
    simp [continuous_variance, hb];
    norm_num [ continuous_mean, sub_sq ];
    norm_num [ ← pow_mul ] ; ring;
    grind;
  rw [ Filter.tendsto_atTop_atTop ];
  -- We'll use the fact that $b^5 / 5 - a^5 / 5 - (b^3 / 3 - a^3 / 3)^2 / (b - a)$ grows without bound as $b$ tends to infinity.
  have h_bound : Filter.Tendsto (fun b : ℝ => (b ^ 5 / 5 - a ^ 5 / 5 - (b ^ 3 / 3 - a ^ 3 / 3) ^ 2 / (b - a)) / (b - a)) Filter.atTop Filter.atTop := by
    -- We can factor out $b^4$ from the numerator and simplify the expression.
    suffices h_factor : Filter.Tendsto (fun b : ℝ => (b ^ 4 * (1 / 5 - a ^ 5 / (5 * b ^ 5) - (1 / 9 - 2 * a ^ 3 / (9 * b ^ 3) + a ^ 6 / (9 * b ^ 6)) / (1 - a / b)) / (1 - a / b))) Filter.atTop Filter.atTop by
      refine h_factor.congr' ?_;
      filter_upwards [ Filter.eventually_gt_atTop 0, Filter.eventually_gt_atTop a ] with b hb₁ hb₂;
      field_simp;
      ring;
    -- As $b$ tends to infinity, the terms involving $a$ become negligible, and the expression simplifies to $b^4 * (1 / 5 - 1 / 9) / 1 = b^4 * (4 / 45)$.
    have h_simplify : Filter.Tendsto (fun b : ℝ => (1 / 5 - a ^ 5 / (5 * b ^ 5) - (1 / 9 - 2 * a ^ 3 / (9 * b ^ 3) + a ^ 6 / (9 * b ^ 6)) / (1 - a / b)) / (1 - a / b)) Filter.atTop (nhds (4 / 45)) := by
      exact le_trans ( Filter.Tendsto.div ( Filter.Tendsto.sub ( tendsto_const_nhds.sub <| tendsto_const_nhds.div_atTop <| Filter.Tendsto.const_mul_atTop ( by norm_num ) <| by norm_num ) <| Filter.Tendsto.div ( Filter.Tendsto.add ( tendsto_const_nhds.sub <| tendsto_const_nhds.div_atTop <| Filter.Tendsto.const_mul_atTop ( by norm_num ) <| by norm_num ) <| tendsto_const_nhds.div_atTop <| Filter.Tendsto.const_mul_atTop ( by norm_num ) <| by norm_num ) ( tendsto_const_nhds.sub <| tendsto_const_nhds.div_atTop <| Filter.tendsto_id ) <| by norm_num ) ( tendsto_const_nhds.sub <| tendsto_const_nhds.div_atTop <| Filter.tendsto_id ) <| by norm_num ) <| by norm_num;
    have h_final : Filter.Tendsto (fun b : ℝ => b ^ 4 * ((1 / 5 - a ^ 5 / (5 * b ^ 5) - (1 / 9 - 2 * a ^ 3 / (9 * b ^ 3) + a ^ 6 / (9 * b ^ 6)) / (1 - a / b)) / (1 - a / b))) Filter.atTop Filter.atTop := by
      apply Filter.Tendsto.atTop_mul_pos;
      exacts [ show 0 < 4 / 45 by norm_num, by norm_num, h_simplify ];
    simpa only [ mul_div_assoc ] using h_final;
  exact fun b => Filter.eventually_atTop.mp ( h_bound.eventually_ge_atTop b ) |> fun ⟨ i, hi ⟩ => ⟨ Max.max i ( a + 1 ), fun x hx => h_var x ( by linarith [ le_max_left i ( a + 1 ), le_max_right i ( a + 1 ) ] ) ▸ hi x ( by linarith [ le_max_left i ( a + 1 ), le_max_right i ( a + 1 ) ] ) ⟩

/-
Lemma 5: cv → ∞ as X → ∞
Assuming between-group variance scales as span⁴ (from Lemma 4) and mean_gap = span/N,
then cv² scales as span² * N², which grows unboundedly.
-/
lemma lemma5_cv_growth (span : ℕ → ℝ) (N : ℕ → ℝ) (between_var : ℕ → ℝ)
  (h_span : Tendsto span atTop atTop)
  (h_N : Tendsto N atTop atTop)
  (h_between : between_var =ᶠ[atTop] fun n => (span n)^4) :
  let mean_gap n := span n / N n
  let cv_sq n := between_var n / (mean_gap n)^2
  Tendsto cv_sq atTop atTop := by
    have h_mean_gap : Filter.Tendsto (fun n => span n ^ 2 * N n ^ 2) Filter.atTop Filter.atTop := by
      exact Filter.Tendsto.atTop_mul_atTop₀ ( Filter.tendsto_pow_atTop ( by norm_num ) |> Filter.Tendsto.comp <| h_span ) ( Filter.tendsto_pow_atTop ( by norm_num ) |> Filter.Tendsto.comp <| h_N );
    refine' Filter.Tendsto.congr' _ h_mean_gap;
    filter_upwards [ h_between, h_span.eventually_gt_atTop 0, h_N.eventually_gt_atTop 0 ] with n hn hn' hn'' ; aesop;
    field_simp

/-
Lemma 6: cv Growth Implies R Growth
If R scales as N^1.7 * cv^0.4, and both N and cv grow unboundedly, then R grows unboundedly.
-/
lemma lemma6_cv_implies_R_growth (N : ℕ → ℝ) (cv : ℕ → ℝ) (R : ℕ → ℝ)
  (h_N : Tendsto N atTop atTop)
  (h_cv : Tendsto cv atTop atTop)
  (h_R_scaling : R =ᶠ[atTop] fun n => (N n)^(17/10 : ℝ) * (cv n)^(2/5 : ℝ)) :
  Tendsto R atTop atTop := by
  rw [ Filter.tendsto_congr' h_R_scaling ];
  -- Apply the fact that if the limits of $N$ and $cv$ are both infinity, then the limit of their product is also infinity.
  have h_prod_tendsto : Filter.Tendsto (fun n => N n^(17 / 10 : ℝ)) Filter.atTop Filter.atTop ∧ Filter.Tendsto (fun n => cv n^(2 / 5 : ℝ)) Filter.atTop Filter.atTop := by
    exact ⟨ tendsto_rpow_atTop ( by norm_num ) |> Filter.Tendsto.comp <| h_N, tendsto_rpow_atTop ( by norm_num ) |> Filter.Tendsto.comp <| h_cv ⟩;
  bound;
  exact Filter.Tendsto.atTop_mul_atTop₀ left right

def is_twin_prime (p : ℕ) := Nat.Prime p ∧ Nat.Prime (p + 2)

def twins_up_to (n : ℕ) : List ℕ := (List.range (n + 1)).filter is_twin_prime

/-
Main Theorem: cv Growth Path to TPC
If the coefficient of variation of twin prime gaps grows unboundedly, then there are infinitely many twin primes.
Proof: If twins were finite, the list of twins up to X would stabilize, so cv would be bounded.
-/
theorem cv_path_to_TPC :
  (∀ M > 0, ∃ X, cv (twin_gaps (twins_up_to X)) > M) →
  (∀ N, ∃ p > N, is_twin_prime p) := by
  intro h_cv_unbounded N
  -- We argue by contradiction. Suppose there are finitely many twin primes.
  by_contra h_finite
  push_neg at h_finite
  -- Then there exists a largest twin prime P.
  -- For all X >= P, twins_up_to X is the same list L.
  -- Then cv(twin_gaps(twins_up_to X)) is constant = cv(twin_gaps(L)).
  -- This contradicts the unboundedness of cv.
  contrapose h_cv_unbounded;
  -- If there are only finitely many twin primes, then the set of cv values is finite.
  have h_finite_set : Set.Finite {cv (twin_gaps (twins_up_to X)) | X : ℕ} := by
    -- Since there are only finitely many twin primes, the set of possible lists of twin primes up to X is finite.
    have h_finite_lists : Set.Finite {twins_up_to X | X : ℕ} := by
      have h_finite_lists : ∀ X : ℕ, X > N → twins_up_to X = twins_up_to N := by
        unfold twins_up_to; aesop;
        induction a <;> simp_all +decide [ List.range_succ ];
        · grind;
        · grind;
      exact Set.Finite.subset ( Set.toFinite ( Finset.image ( fun X => twins_up_to X ) ( Finset.range ( N + 1 ) ) ) ) fun x hx => by rcases hx with ⟨ X, rfl ⟩ ; exact if hX : X ≤ N then Finset.mem_image_of_mem _ ( Finset.mem_range_succ_iff.mpr hX ) else h_finite_lists X ( not_le.mp hX ) ▸ Finset.mem_image_of_mem _ ( Finset.mem_range_succ_iff.mpr le_rfl ) ;
    exact Set.Finite.subset ( h_finite_lists.image fun x => cv ( twin_gaps x ) ) fun x hx => by aesop;
  exact fun h => by obtain ⟨ M, hM ⟩ := h_finite_set.bddAbove; obtain ⟨ X, hX ⟩ := h ( Max.max M 1 + 1 ) ( by positivity ) ; linarith [ hM ⟨ X, rfl ⟩, le_max_left M 1, le_max_right M 1 ] ;