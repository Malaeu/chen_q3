/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 3c744600-86d0-48da-8a29-eeb4b5a42f81
-/

/-
We formalized the operator-theoretic bounds for the Spectral/Q3 attack.
The main theorem `rankOne_comm_bound` establishes that ‖[rankOne(v), U]‖ ≤ 2 · ‖Uv - v‖ · ‖v‖.
Corollary 1 extends this to sums of rank-one operators, and Corollary 2 applies it to heat kernel vectors.
Corollary 3 was found to be false as stated (see `corollary_3_false`), suggesting that additional assumptions or a different formulation are needed for the minor arcs suppression claim.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check comm

#check @inner
#check @inner_add_left
#check @inner_smul_left
#check @ContinuousLinearMap.smulRight

open scoped ComplexConjugate
open Complex

variable {H : Type} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]

/-- Commutator of bounded operators -/
def commOp (A U : H →L[ℂ] H) : H →L[ℂ] H :=
  A * U - U * A

/-- Rank-one operator: x ↦ ⟪v, x⟫ · v -/
noncomputable def rankOne (v : H) : H →L[ℂ] H :=
  (innerSL ℂ v).smulRight v

/-
The norm of the commutator of a rank-one operator |v><v| and an isometry U is bounded by 2 * ||Uv - v|| * ||v||.
-/
theorem rankOne_comm_bound
    (U : H →L[ℂ] H) (hU : Isometry U) (v : H) :
    ‖commOp (rankOne v) U‖ ≤ 2 * ‖U v - v‖ * ‖v‖ := by
      -- Apply the inequality from h_norm to each term in the supremum.
      have h_sup : ∀ w : H, ‖w‖ ≤ 1 → ‖rankOne v (U w) - U (rankOne v w)‖ ≤ 2 * ‖U v - v‖ * ‖v‖ := by
        -- Let's choose any $w$ with $\|w\| \leq 1$.
        intro w hw
        unfold rankOne;
        -- By the properties of the inner product and the isometry $U$, we have:
        have h_inner : ‖inner ℂ v (U w) • v - U (inner ℂ v w • v)‖ ≤ ‖inner ℂ v (U w) - inner ℂ v w‖ * ‖v‖ + ‖inner ℂ v w‖ * ‖U v - v‖ := by
          have h_inner : ‖inner ℂ v (U w) • v - U (inner ℂ v w • v)‖ = ‖(inner ℂ v (U w) - inner ℂ v w) • v + inner ℂ v w • (v - U v)‖ := by
            simp +decide [ sub_smul, smul_sub ];
          rw [ h_inner, ← norm_neg ( U v - v ) ];
          convert norm_add_le _ _ using 2 <;> norm_num [ norm_smul ];
        -- By the properties of the inner product and the isometry $U$, we have $\| \langle v, Uw \rangle - \langle v, w \rangle \| \leq \| Uv - v \| \| w \| \leq \| Uv - v \|$.
        have h_inner_bound : ‖inner ℂ v (U w) - inner ℂ v w‖ ≤ ‖U v - v‖ := by
          -- Using the fact that $U$ is an isometry, we have $\langle Uv, Uw \rangle = \langle v, w \rangle$.
          have h_inner_isometry : inner ℂ (U v) (U w) = inner ℂ v w := by
            have h_inner_isometry : ∀ x y : H, inner ℂ (U x) (U y) = inner ℂ x y := by
              intro x y
              have h_norm : ‖U x + U y‖ ^ 2 = ‖x + y‖ ^ 2 := by
                have := hU.dist_eq ( x + y ) 0; aesop;
              have h_norm' : ‖U x - U y‖ ^ 2 = ‖x - y‖ ^ 2 := by
                have := hU.dist_eq x y; simp_all +decide [ dist_eq_norm ] ;
              have h_norm'' : ‖U x + Complex.I • U y‖ ^ 2 = ‖x + Complex.I • y‖ ^ 2 := by
                have := hU.dist_eq ( x + Complex.I • y ) 0; simp_all +decide [ dist_eq_norm ] ;
              norm_num [ @norm_add_sq ℂ, @norm_sub_sq ℂ ] at *;
              simp_all +decide [ norm_smul, inner_smul_right ];
              exact Complex.ext ( by linarith ) ( by linarith );
            exact h_inner_isometry v w;
          have h_inner_diff_norm : ‖inner ℂ (U v - v) (U w)‖ ≤ ‖U v - v‖ * ‖U w‖ := by
            exact norm_inner_le_norm _ _;
          simp_all +decide [ norm_sub_rev ];
          exact h_inner_diff_norm.trans ( mul_le_of_le_one_right ( norm_nonneg _ ) ( by simpa using hU.dist_eq w 0 |> fun h => by simpa using h.le.trans ( by simpa using hw ) ) );
        -- By the properties of the inner product and the isometry $U$, we have $\| \langle v, w \rangle \| \leq \| v \| \| w \| \leq \| v \|$.
        have h_inner_bound' : ‖inner ℂ v w‖ ≤ ‖v‖ := by
          exact le_trans ( norm_inner_le_norm _ _ ) ( mul_le_of_le_one_right ( norm_nonneg _ ) hw );
        exact h_inner.trans ( by nlinarith [ norm_nonneg v, norm_nonneg ( U v - v ) ] );
      refine' ContinuousLinearMap.opNorm_le_bound _ _ _;
      · positivity;
      · intro x; specialize h_sup ( ‖x‖⁻¹ • x ) ; by_cases hx : x = 0 <;> simp_all +decide [ norm_smul, mul_assoc ] ;
        simp_all +decide [ ← mul_assoc, ← smul_sub, norm_smul ];
        rw [ inv_mul_eq_div, div_le_iff₀ ( norm_pos_iff.mpr hx ) ] at h_sup ; aesop

/-
The norm of the commutator of a sum of weighted rank-one operators with an isometry is bounded by 2 * (sum of weights) * (max displacement).
-/
theorem corollary_1 {ι : Type} (s : Finset ι) (w : ι → ℝ) (v : ι → H)
    (U : H →L[ℂ] H) (hU : Isometry U)
    (hw : ∀ i ∈ s, 0 ≤ w i) (hv : ∀ i ∈ s, ‖v i‖ = 1)
    (M : ℝ) (hM : ∀ i ∈ s, ‖U (v i) - v i‖ ≤ M) :
    ‖commOp (∑ i ∈ s, (w i : ℂ) • rankOne (v i)) U‖ ≤ 2 * (∑ i ∈ s, w i) * M := by
      -- Apply the triangle inequality to the sum of the commutators.
      have h_triangle : ‖commOp (∑ i ∈ s, w i • rankOne (v i)) U‖ ≤ ∑ i ∈ s, ‖commOp (rankOne (v i)) U‖ * w i := by
        -- By linearity of the commutator, we can write
        have h_comm_linear : commOp (∑ i ∈ s, w i • rankOne (v i)) U = ∑ i ∈ s, w i • commOp (rankOne (v i)) U := by
          -- By the properties of the commutator and the linearity of the inner product, we can expand the left-hand side.
          simp [commOp, Finset.sum_mul];
          simp +decide [ mul_sub, Finset.mul_sum _ _ _, Finset.sum_mul, smul_sub ];
        rw [ h_comm_linear ];
        exact le_trans ( norm_sum_le _ _ ) ( Finset.sum_le_sum fun i hi => by rw [ norm_smul, Real.norm_of_nonneg ( hw i hi ) ] ; ring_nf; norm_num );
      -- Use the bound from `rankOne_comm_bound` to further simplify the expression.
      have h_bound : ∀ i ∈ s, ‖commOp (rankOne (v i)) U‖ ≤ 2 * M := by
        intros i hi;
        exact le_trans ( rankOne_comm_bound U hU ( v i ) ) ( by nlinarith [ norm_nonneg ( U ( v i ) - v i ), hv i hi, hM i hi ] );
      exact_mod_cast h_triangle.trans ( le_trans ( Finset.sum_le_sum fun i hi => mul_le_mul_of_nonneg_right ( h_bound i hi ) ( hw i hi ) ) ( by simp +decide [ mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _, Finset.sum_mul ] ) )

/-
The commutator of the rank-one operator of a heat kernel vector with the shift is exponentially small.
-/
theorem corollary_2 {Ξ : Type} (k : Ξ → H) (U : H →L[ℂ] H) (hU : Isometry U)
    (C t : ℝ) (h_disp : ∀ ξ, ‖U (k ξ) - k ξ‖ ≤ C * Real.exp (-t)) :
    ∀ ξ, ‖commOp (rankOne (k ξ)) U‖ ≤ 2 * (C * Real.exp (-t)) * ‖k ξ‖ := by
      -- Apply the bound on the norm of the commutator.
      intros ξ
      have := @rankOne_comm_bound H;
      exact le_trans ( this U hU _ ) ( by gcongr; exact h_disp ξ )