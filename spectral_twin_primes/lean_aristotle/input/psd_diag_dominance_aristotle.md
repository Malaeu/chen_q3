/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 0c06c57f-ad18-498e-8bb7-1ffa3a3d53dc
-/

/-
We define the Gaussian kernel `K`, twin prime weights `lambda`, and the energy functionals `E_full` and `E_diag`. We then prove that the kernel is strictly positive (`kernel_positive`), the cross terms are non-negative (`cross_term_nonneg`), the sum of off-diagonal terms is non-negative (`sum_cross_terms_nonneg`), and finally that the full energy dominates the diagonal energy (`diag_dominance`).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def is_twin_prime (p : ℕ) : Prop := Nat.Prime p ∧ Nat.Prime (p + 2)

def twins_up_to (X : ℕ) : Finset ℕ := (Finset.range (X + 1)).filter is_twin_prime

def K (t : ℝ) (ξ_p ξ_q : ℝ) : ℝ := 2 * Real.pi * t * Real.exp (-(ξ_p - ξ_q)^2 / (4 * t))

def lambda (p : ℕ) : ℝ := if is_twin_prime p then Real.log p * Real.log (p + 2) else 0

def E_full (X : ℕ) (t : ℝ) (ξ : ℕ → ℝ) : ℝ :=
  Finset.sum (twins_up_to X) (fun p => Finset.sum (twins_up_to X) (fun q => lambda p * lambda q * K t (ξ p) (ξ q)))

def E_diag (X : ℕ) (t : ℝ) (ξ : ℕ → ℝ) : ℝ :=
  Finset.sum (twins_up_to X) (fun p => (lambda p)^2 * K t (ξ p) (ξ p))

/-
For all t > 0 and all ξ_p, ξ_q ∈ ℝ, K(t, ξ_p, ξ_q) > 0
-/
theorem kernel_positive (t : ℝ) (ht : t > 0) (x y : ℝ) : K t x y > 0 := by
  exact mul_pos ( by positivity ) ( Real.exp_pos _ )

/-
For non-negative weights and positive kernel, each cross term is non-negative
-/
theorem cross_term_nonneg (t : ℝ) (ht : t > 0) (lambda_p lambda_q : ℝ) (h_lambda_p : lambda_p ≥ 0) (h_lambda_q : lambda_q ≥ 0)
    (ξp ξq : ℝ) : lambda_p * lambda_q * K t ξp ξq ≥ 0 := by
      exact mul_nonneg ( mul_nonneg h_lambda_p h_lambda_q ) ( kernel_positive t ht ξp ξq |> le_of_lt )

/-
The sum of all off-diagonal terms is non-negative
-/
theorem sum_cross_terms_nonneg (X : ℕ) (t : ℝ) (ht : t > 0) (ξ : ℕ → ℝ) :
    Finset.sum (twins_up_to X) (fun p => Finset.sum (twins_up_to X) (fun q =>
      if p ≠ q then lambda p * lambda q * K t (ξ p) (ξ q) else 0)) ≥ 0 := by
        refine' Finset.sum_nonneg fun p hp => Finset.sum_nonneg fun q hq => _;
        unfold lambda at *; aesop;
        exact mul_nonneg ( mul_nonneg ( mul_nonneg ( Real.log_nonneg ( mod_cast h_2.1.one_lt.le ) ) ( Real.log_nonneg ( mod_cast by linarith [ h_2.1.one_lt ] ) ) ) ( mul_nonneg ( Real.log_nonneg ( mod_cast h_1.1.one_lt.le ) ) ( Real.log_nonneg ( mod_cast by linarith [ h_1.1.one_lt ] ) ) ) ) ( kernel_positive t ht ( ξ p ) ( ξ q ) |> le_of_lt )

/-
The full energy dominates the diagonal energy
-/
theorem diag_dominance (X : ℕ) (t : ℝ) (ht : t > 0) (ξ : ℕ → ℝ) :
    E_full X t ξ ≥ E_diag X t ξ := by
      -- The cross terms are non-negative because K is positive and lambda is non-negative.
      have h_cross_nonneg : ∀ (p q : ℕ), p ∈ twins_up_to X → q ∈ twins_up_to X → lambda p * lambda q * K t (ξ p) (ξ q) ≥ 0 := by
        unfold lambda; aesop;
        exact mul_nonneg ( mul_nonneg ( mul_nonneg ( Real.log_nonneg ( mod_cast h_1.1.pos ) ) ( Real.log_nonneg ( mod_cast by linarith ) ) ) ( mul_nonneg ( Real.log_nonneg ( mod_cast h.1.pos ) ) ( Real.log_nonneg ( mod_cast by linarith ) ) ) ) ( by exact mul_nonneg ( mul_nonneg ( by positivity ) ( by positivity ) ) ( Real.exp_nonneg _ ) );
      exact Finset.sum_le_sum fun p hp => by simpa only [ sq, mul_assoc ] using Finset.single_le_sum ( fun q hq => h_cross_nonneg p q hp hq ) hp;