/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 3b4063f3-d610-41a9-b02a-e6bfaecb2162
-/

/-
Formalization of Step 6B of the Vector 3 attack: RKHS Translation Isometry and Shift Stability.

We have defined the Gaussian heat kernel `k`, the kernel span `KSpan`, and the shift operator on sections `UΔ_on_sec`.
We have proven:
1. `k_diag`: The kernel value at the diagonal is 1.
2. `k_translation_invariant`: The kernel is translation invariant.
3. `shift_preserves_inner_on_sections`: The shift operator preserves the inner product on sections (isometry property).
4. `UΔ_isometry`: The shift operator preserves the norm of sections.
5. `rkhs_shift_stability_on_sections`: The quantitative stability bound `‖UΔ(sec y) - sec y‖ ≤ |Δ|/√(2t)`.
6. `shift_stability_improves_with_t`: Stability improves as `t` increases.

These results establish the necessary RKHS properties for the commutator estimates in Vector 3.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Gaussian heat kernel k(t, x, y) = exp(-(x-y)²/(4t))
-/
noncomputable def Step6B_GaussianShift.k (t : ℝ) (x y : ℝ) : ℝ :=
  Real.exp (-(x - y)^2 / (4*t))

/-
Kernel value at diagonal is 1
-/
lemma Step6B_GaussianShift.k_diag (t : ℝ) (ht : 0 < t) (x : ℝ) : Step6B_GaussianShift.k t x x = 1 := by
  simp only [Step6B_GaussianShift.k, sub_self, sq, mul_zero, neg_zero, zero_div, Real.exp_zero]

/-
Translation invariance of Gaussian kernel
-/
lemma Step6B_GaussianShift.k_translation_invariant (t Δ x y : ℝ) :
    Step6B_GaussianShift.k t (x + Δ) (y + Δ) = Step6B_GaussianShift.k t x y := by
  simp only [Step6B_GaussianShift.k]
  ring_nf

/-
The kernel span
-/
def Step6B_GaussianShift.KSpan (H0 : Type) [NormedAddCommGroup H0] [InnerProductSpace ℝ H0] [CompleteSpace H0] (sec : ℝ → H0) : Submodule ℝ H0 := Submodule.span ℝ (Set.range sec)

/-
Shift operator on sections: UΔ(sec y) = sec(y + Δ)
-/
noncomputable def Step6B_GaussianShift.UΔ_on_sec (H0 : Type) [NormedAddCommGroup H0] [InnerProductSpace ℝ H0] [CompleteSpace H0] (sec : ℝ → H0) (Δ : ℝ) (y : ℝ) : H0 := sec (y + Δ)

/-
Shift preserves inner product on sections
-/
theorem Step6B_GaussianShift.shift_preserves_inner_on_sections
    (H0 : Type) [NormedAddCommGroup H0] [InnerProductSpace ℝ H0] [CompleteSpace H0]
    (t : ℝ) (sec : ℝ → H0)
    (h_sec : ∀ y z, inner ℝ (sec y) (sec z) = Step6B_GaussianShift.k t y z)
    (Δ y z : ℝ) (ht : 0 < t) :
    inner ℝ (Step6B_GaussianShift.UΔ_on_sec H0 sec Δ y) (Step6B_GaussianShift.UΔ_on_sec H0 sec Δ z) = inner ℝ (sec y) (sec z) := by
  simp only [Step6B_GaussianShift.UΔ_on_sec]
  rw [h_sec (y + Δ) (z + Δ)]
  rw [h_sec y z]
  exact Step6B_GaussianShift.k_translation_invariant t Δ y z

/-
UΔ is an isometry on KSpan
-/
theorem Step6B_GaussianShift.UΔ_isometry
    (H0 : Type) [NormedAddCommGroup H0] [InnerProductSpace ℝ H0] [CompleteSpace H0]
    (t : ℝ) (sec : ℝ → H0)
    (h_sec : ∀ y z, inner ℝ (sec y) (sec z) = Step6B_GaussianShift.k t y z)
    (Δ : ℝ) (ht : 0 < t) :
    ∀ y : ℝ, ‖Step6B_GaussianShift.UΔ_on_sec H0 sec Δ y‖ = ‖sec y‖ := by
      simp_all +decide [ Step6B_GaussianShift.UΔ_on_sec ];
      intro y; have := h_sec ( y + Δ ) ( y + Δ ) ; have := h_sec y y; aesop;
      have := h_sec y y; have := h_sec ( y + Δ ) ( y + Δ ) ; have := h_sec y ( y + Δ ) ; have := h_sec ( y + Δ ) y; simp_all +decide [ norm_eq_sqrt_real_inner ] ;
      unfold Step6B_GaussianShift.k; ring;

/-
Quantitative shift stability on sections: ‖UΔ(sec y) - sec y‖ ≤ |Δ|/√(2t)
-/
theorem Step6B_GaussianShift.rkhs_shift_stability_on_sections
    (H0 : Type) [NormedAddCommGroup H0] [InnerProductSpace ℝ H0] [CompleteSpace H0]
    (t : ℝ) (sec : ℝ → H0)
    (h_sec : ∀ y z, inner ℝ (sec y) (sec z) = Step6B_GaussianShift.k t y z)
    (Δ y : ℝ) (ht : 0 < t) :
    ‖Step6B_GaussianShift.UΔ_on_sec H0 sec Δ y - sec y‖ ≤ |Δ| / Real.sqrt (2*t) := by
      -- By the properties of the Gaussian kernel and the shift operator, we have:
      have h_norm_sq : ‖sec (y + Δ) - sec y‖^2 = 2 * (1 - Real.exp (-(Δ)^2 / (4 * t))) := by
        rw [ @norm_sub_sq ℝ ];
        have := h_sec ( y + Δ ) ( y + Δ ) ; have := h_sec y y ; have := h_sec ( y + Δ ) y ; simp_all ( config := { decide := Bool.true } ) [ Step6B_GaussianShift.k, neg_div ];
        rw [ ← real_inner_self_eq_norm_sq, ← real_inner_self_eq_norm_sq ] ; have := h_sec ( y + Δ ) ( y + Δ ) ; have := h_sec y y ; have := h_sec ( y + Δ ) y ; norm_num at * ; ring_nf at * ; linarith;
      -- Using the inequality $1 - e^{-x} \leq x$ for $x \geq 0$, we get:
      have h_ineq : 2 * (1 - Real.exp (-Δ ^ 2 / (4 * t))) ≤ Δ ^ 2 / (2 * t) := by
        ring_nf;
        nlinarith [ Real.add_one_le_exp ( Δ ^ 2 * t⁻¹ * ( -1 / 4 ) ), mul_inv_cancel₀ ht.ne' ];
      convert Real.le_sqrt_of_sq_le <| h_norm_sq.trans_le h_ineq using 1;
      rw [ Real.sqrt_div ( sq_nonneg _ ), Real.sqrt_sq_eq_abs ]

/-
COROLLARY: Shift stability in terms of heat parameter t
-/
theorem Step6B_GaussianShift.shift_stability_improves_with_t
    (Δ y : ℝ) (hΔ : Δ ≠ 0) (t₁ t₂ : ℝ) (ht₁ : 0 < t₁) (ht₂ : 0 < t₂) (h : t₁ < t₂) :
    |Δ| / Real.sqrt (2*t₂) < |Δ| / Real.sqrt (2*t₁) := by
      bound;
      · positivity;
      · positivity