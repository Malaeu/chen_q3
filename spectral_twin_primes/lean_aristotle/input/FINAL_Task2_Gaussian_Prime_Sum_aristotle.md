/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 54a537a3-5b0f-4213-8a0c-007025452c47
-/

/-
This module formalizes bounds on sums over primes with Gaussian weights.
It defines the spectral coordinate `xi` and proves:
1. `gaussian_integral_bound`: A bound on the tail of the Gaussian integral.
2. `pi_bound_exists`: A Chebyshev-type bound for the prime counting function.
3. `sum_primes_bound`: A general bound for sums over primes using Abel summation.
4. `gaussian_prime_sum_bound_lemma`: A specific bound for the Gaussian sum over primes.
5. `gaussian_prime_series_summable`: Convergence of the Gaussian prime series.
6. `gaussian_prime_sum_asymptotic`: An asymptotic bound for the Gaussian prime sum.
7. `gaussian_prime_sum_corrected`: A corrected version of the main theorem with explicit constants and conditions.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Real MeasureTheory Finset Nat ArithmeticFunction

noncomputable def xi (n : ℕ) : ℝ := Real.log n / (2 * Real.pi)

lemma gaussian_integral_bound (t D : ℝ) (ht : 0 < t) (hD : 0 < D) :
  ∫ x in Set.Ioi D, Real.exp (-x^2 / (4 * t)) ≤ (2 * t / D) * Real.exp (-D^2 / (4 * t)) := by
  have h_integral_bound : ∫ x in Set.Ioi D, Real.exp (-x^2 / (4 * t)) ≤ ∫ x in Set.Ioi D, (x / D) * Real.exp (-x^2 / (4 * t)) := by
    refine' MeasureTheory.setIntegral_mono_on _ _ measurableSet_Ioi fun x hx => le_mul_of_one_le_left ( Real.exp_nonneg _ ) ( by rw [ le_div_iff₀ hD ] ; linarith [ hx.out ] );
    · exact MeasureTheory.Integrable.integrableOn ( by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) );
    · have h_integrable : MeasureTheory.IntegrableOn (fun x => x * Real.exp (-x^2 / (4 * t))) (Set.Ioi 0) := by
        have := @integral_rpow_mul_exp_neg_mul_rpow 2 ( 1 : ℝ ) ( 1 / ( 4 * t ) ) ?_ ?_ <;> norm_num at *;
        contrapose! this;
        exact ⟨ ht, by rw [ MeasureTheory.integral_undef ( by simpa [ div_eq_inv_mul ] using this ) ] ; positivity ⟩;
      simpa only [ div_mul_eq_mul_div ] using MeasureTheory.IntegrableOn.mono_set ( h_integrable.div_const D ) ( Set.Ioi_subset_Ioi hD.le );
  -- Evaluate the integral $\int_D^\infty x e^{-x^2 / (4t)} \, dx$.
  have h_integral_x : ∫ x in Set.Ioi D, x * Real.exp (-x^2 / (4 * t)) = 2 * t * Real.exp (-D^2 / (4 * t)) := by
    have h_integral_x : ∀ a b : ℝ, a < b → ∫ x in a..b, x * Real.exp (-x^2 / (4 * t)) = -2 * t * Real.exp (-b^2 / (4 * t)) + 2 * t * Real.exp (-a^2 / (4 * t)) := by
      simp +zetaDelta at *;
      intros a b hab; rw [ intervalIntegral.integral_deriv_eq_sub' ];
      -- Let's choose the antiderivative $f(x) = -2t e^{-x^2 / (4t)}$.
      case f => exact fun x => -2 * t * Real.exp (-x ^ 2 / (4 * t));
      · ring;
      · norm_num +zetaDelta at *;
        grind;
      · norm_num;
      · exact Continuous.continuousOn ( by continuity );
    -- Apply the fundamental theorem of calculus to evaluate the integral.
    have h_ftc : Filter.Tendsto (fun b => ∫ x in D..b, x * Real.exp (-x^2 / (4 * t))) Filter.atTop (nhds (∫ x in Set.Ioi D, x * Real.exp (-x^2 / (4 * t)))) := by
      apply_rules [ MeasureTheory.intervalIntegral_tendsto_integral_Ioi ];
      · have := @integrable_rpow_mul_exp_neg_mul_sq;
        specialize @this ( 1 / ( 4 * t ) ) ( by positivity ) 1 ; aesop;
        exact MeasureTheory.Integrable.integrableOn ( by convert this using 3; ring );
      · exact Filter.tendsto_id;
    exact tendsto_nhds_unique h_ftc ( Filter.Tendsto.congr' ( by filter_upwards [ Filter.eventually_gt_atTop D ] with b hb; rw [ h_integral_x _ _ hb ] ) <| by simpa using Filter.Tendsto.add ( Filter.Tendsto.neg <| tendsto_const_nhds.mul <| Real.tendsto_exp_atBot.comp <| by exact Filter.Tendsto.atBot_div_const ( by positivity ) <| by simpa ) tendsto_const_nhds ) ▸ by ring;
  simp_all +decide [ div_eq_inv_mul, mul_assoc, MeasureTheory.integral_const_mul ]

noncomputable def weight (t : ℝ) (x : ℝ) : ℝ := Real.exp (-(Real.log x / (2 * Real.pi))^2 / (4 * t))

lemma weight_decreasing (t : ℝ) (ht : 0 < t) :
  AntitoneOn (weight t) (Set.Ici 1) := by
  -- By combining the results, we conclude that the weight function is antitone on the interval [1, ∞).
  intros m hm n hn hmn
  have h_log : Real.log m / (2 * Real.pi) ≤ Real.log n / (2 * Real.pi) := by
    gcongr ; aesop;
    linarith;
  unfold weight; aesop;
  gcongr;
  exact div_nonneg ( Real.log_nonneg hm ) ( by positivity )

lemma pi_bound_exists : ∃ C > 0, ∀ x ≥ 2, (Nat.primeCounting ⌊x⌋₊ : ℝ) ≤ C * x / Real.log x := by
  -- We can use the fact that $\pi(x) \leq \frac{6x}{\log x}$ for all $x \geq 2$.
  use 6, by norm_num
  intro x hx
  have h_pi_bound : (Nat.primeCounting (Nat.floor x) : ℝ) ≤ 6 * x / Real.log x := by
    rw [ le_div_iff₀ ( Real.log_pos <| by linarith ) ];
    -- We'll use that π(x) is the number of primes less than or equal to x, and that the sum of the logarithms of these primes is less than or equal to x log 4.
    have h_sum_log_primes_le_x_log_4 : ∀ x : ℝ, 2 ≤ x → (∑ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 (Nat.floor x)), Real.log p) ≤ x * Real.log 4 := by
      -- We'll use that the product of primes up to $x$ is less than or equal to $4^x$.
      have h_prod_primes_le_4x : ∀ x : ℕ, 2 ≤ x → (∏ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 x), p) ≤ 4 ^ x := by
        -- We'll use induction on $x$ to prove that the product of primes up to $x$ is less than or equal to $4^x$.
        intro x hx
        induction' x using Nat.strong_induction_on with x ih;
        -- Consider two cases: $x$ is even and $x$ is odd.
        by_cases hx_even : Even x;
        · rcases hx_even with ⟨ k, rfl ⟩ ; simp_all +decide [ Nat.primeFactors_mul ] ; ring_nf at * ; aesop;
          -- By the properties of primes, we know that $\prod_{p \leq 2k} p \leq \prod_{p \leq k} p \cdot \binom{2k}{k}$.
          have h_prod_le_binom : (∏ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 (2 * k)), p) ≤ (∏ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 k), p) * Nat.choose (2 * k) k := by
            have h_prod_le_binom : (∏ p ∈ Finset.filter Nat.Prime (Finset.Icc (k + 1) (2 * k)), p) ≤ Nat.choose (2 * k) k := by
              have h_prod_le_binom : ∀ p ∈ Finset.filter Nat.Prime (Finset.Icc (k + 1) (2 * k)), p ∣ Nat.choose (2 * k) k := by
                aesop;
                apply_mod_cast right.dvd_choose;
                · exact?;
                · omega;
                · linarith;
              refine' Nat.le_of_dvd ( Nat.choose_pos ( by linarith ) ) ( Nat.dvd_trans _ ( Nat.prod_primeFactors_dvd _ ) );
              apply_rules [ Finset.prod_dvd_prod_of_subset ] ; intro p ; aesop;
              exact absurd a <| Nat.ne_of_gt <| Nat.choose_pos <| by linarith;
            have h_prod_le_binom : (∏ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 (2 * k)), p) = (∏ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 k), p) * (∏ p ∈ Finset.filter Nat.Prime (Finset.Icc (k + 1) (2 * k)), p) := by
              erw [ ← Finset.prod_union ( Finset.disjoint_right.mpr fun x hx => by aesop ) ] ; congr ; ext ; aesop <;> omega;
            exact h_prod_le_binom.symm ▸ Nat.mul_le_mul_left _ ‹_›;
          -- By the properties of binomial coefficients, we know that $\binom{2k}{k} \leq 4^k$.
          have h_binom_le_4k : Nat.choose (2 * k) k ≤ 4 ^ k := by
            rw [ show 4 ^ k = ( 2 : ℕ ) ^ ( 2 * k ) by norm_num [ pow_mul ] ] ; rw [ ← Nat.sum_range_choose ] ; exact Finset.single_le_sum ( fun a _ => Nat.zero_le _ ) ( Finset.mem_range.mpr ( by linarith ) ) ;
          rw [ mul_comm k 2 ] ; exact h_prod_le_binom.trans ( by rw [ pow_mul' ] ; exact Nat.mul_le_mul ( if h : 2 ≤ k then ih k ( by linarith ) h else by interval_cases k ; trivial ) h_binom_le_4k |> le_trans <| by ring_nf; norm_num ) ;
        · -- Since $x$ is odd, we can write $x = 2k + 1$ for some integer $k$.
          obtain ⟨k, rfl⟩ : ∃ k, x = 2 * k + 1 := by
            exact x.even_or_odd.resolve_left hx_even;
          -- By the properties of primes, we know that $\prod_{p \leq 2k+1} p \leq \binom{2k+1}{k} \prod_{p \leq k+1} p$.
          have h_prod_le_binom : (∏ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 (2 * k + 1)), p) ≤ Nat.choose (2 * k + 1) k * (∏ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 (k + 1)), p) := by
            have h_prod_le_binom : (∏ p ∈ Finset.filter Nat.Prime (Finset.Icc (k + 2) (2 * k + 1)), p) ≤ Nat.choose (2 * k + 1) k := by
              have h_prod_le_binom : ∀ p ∈ Finset.filter Nat.Prime (Finset.Icc (k + 2) (2 * k + 1)), p ∣ Nat.choose (2 * k + 1) k := by
                aesop;
                apply_mod_cast right.dvd_choose;
                · linarith;
                · omega;
                · linarith;
              refine' Nat.le_of_dvd ( Nat.choose_pos ( by linarith ) ) ( Nat.dvd_trans _ ( Nat.prod_primeFactors_dvd _ ) );
              apply_rules [ Finset.prod_dvd_prod_of_subset ];
              intro p hp; specialize h_prod_le_binom p hp; aesop;
              exact absurd a <| Nat.ne_of_gt <| Nat.choose_pos <| by linarith;
            have h_prod_le_binom : (∏ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 (2 * k + 1)), p) = (∏ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 (k + 1)), p) * (∏ p ∈ Finset.filter Nat.Prime (Finset.Icc (k + 2) (2 * k + 1)), p) := by
              erw [ ← Finset.prod_union ( Finset.disjoint_right.mpr fun x hx => by aesop ) ] ; congr ; ext ; aesop <;> omega;
            nlinarith [ show 0 < ∏ p ∈ Finset.Icc 1 ( k + 1 ) with Nat.Prime p, p from Finset.prod_pos fun p hp => Nat.Prime.pos <| by aesop ];
          -- By the induction hypothesis, we know that $\prod_{p \leq k+1} p \leq 4^{k+1}$.
          have h_ind_hyp : (∏ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 (k + 1)), p) ≤ 4 ^ (k + 1) := by
            exact if hk : 2 ≤ k + 1 then ih _ ( by linarith ) hk else by interval_cases k + 1 <;> trivial;
          -- By the properties of binomial coefficients, we know that $\binom{2k+1}{k} \leq 2^{2k}$.
          have h_binom_le_pow : Nat.choose (2 * k + 1) k ≤ 2 ^ (2 * k) := by
            exact?;
          refine le_trans h_prod_le_binom <| le_trans ( Nat.mul_le_mul h_binom_le_pow h_ind_hyp ) ?_ ; ring_nf ; norm_num [ pow_mul' ] at * ; aesop;
          norm_num [ ← mul_pow ];
      -- Taking the logarithm of both sides of the inequality $\prod_{p \leq x} p \leq 4^x$, we get $\sum_{p \leq x} \log p \leq x \log 4$.
      have h_log_prod_primes_le_x_log_4 : ∀ x : ℕ, 2 ≤ x → (∑ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 x), Real.log p) ≤ x * Real.log 4 := by
        intros x hx
        have h_log_prod_primes_le_x_log_4 : Real.log (∏ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 x), p) ≤ Real.log (4 ^ x) := by
          exact Real.log_le_log ( Finset.prod_pos fun p hp => Nat.cast_pos.mpr <| Nat.Prime.pos <| Finset.mem_filter.mp hp |>.2 ) <| by rw [ ← Nat.cast_prod ] ; exact_mod_cast h_prod_primes_le_4x x hx;
        rw [ Real.log_prod _ _ fun p hp => Nat.cast_ne_zero.mpr <| Nat.Prime.ne_zero <| Finset.mem_filter.mp hp |>.2 ] at h_log_prod_primes_le_x_log_4 ; aesop;
      exact fun x hx => le_trans ( h_log_prod_primes_le_x_log_4 _ <| Nat.le_floor <| mod_cast hx ) <| mul_le_mul_of_nonneg_right ( Nat.floor_le <| by positivity ) <| Real.log_nonneg <| by norm_num;
    -- Applying the inequality $\sum_{p \leq x} \log p \geq (\pi(x) - \pi(\sqrt{x})) \log \sqrt{x}$, we get $\pi(x) \leq \frac{2x \log 4}{\log x} + \pi(\sqrt{x})$.
    have h_pi_le : ∀ x : ℝ, 2 ≤ x → (Nat.primeCounting (Nat.floor x)) ≤ (2 * x * Real.log 4) / Real.log x + (Nat.primeCounting (Nat.floor (Real.sqrt x))) := by
      intros x hx
      have h_sum_log_primes_ge : (∑ p ∈ Finset.filter Nat.Prime (Finset.Icc 1 (Nat.floor x)), Real.log p) ≥ ((Nat.primeCounting (Nat.floor x)) - (Nat.primeCounting (Nat.floor (Real.sqrt x)))) * Real.log (Real.sqrt x) := by
        have h_sum_log_primes_ge : (∑ p ∈ Finset.filter Nat.Prime (Finset.Icc (Nat.floor (Real.sqrt x) + 1) (Nat.floor x)), Real.log p) ≥ ((Nat.primeCounting (Nat.floor x)) - (Nat.primeCounting (Nat.floor (Real.sqrt x)))) * Real.log (Real.sqrt x) := by
          -- Since each prime $p$ in the interval $(\sqrt{x}, x]$ satisfies $\log p \geq \log \sqrt{x}$, we can bound the sum from below.
          have h_log_bound : ∀ p ∈ Finset.filter Nat.Prime (Finset.Icc (Nat.floor (Real.sqrt x) + 1) (Nat.floor x)), Real.log p ≥ Real.log (Real.sqrt x) := by
            exact fun p hp => Real.log_le_log ( Real.sqrt_pos.mpr <| by positivity ) <| le_trans ( Nat.lt_floor_add_one _ |> le_of_lt ) <| mod_cast Finset.mem_Icc.mp ( Finset.mem_filter.mp hp |>.1 ) |>.1.trans' <| by norm_num;
          refine' le_trans _ ( Finset.sum_le_sum h_log_bound ) ; aesop;
          rw [ Nat.primeCounting, Nat.primeCounting ];
          norm_num [ Nat.primeCounting', Nat.count_eq_card_filter_range ];
          rw [ show ( Finset.filter Nat.Prime ( Finset.Icc ( ⌊Real.sqrt x⌋₊ + 1 ) ⌊x⌋₊ ) ) = Finset.filter Nat.Prime ( Finset.range ( ⌊x⌋₊ + 1 ) ) \ Finset.filter Nat.Prime ( Finset.range ( ⌊Real.sqrt x⌋₊ + 1 ) ) from ?_, Finset.card_sdiff ];
          · rw [ Nat.cast_sub ] <;> norm_num [ Finset.inter_comm ];
            · rw [ Finset.inter_eq_right.mpr ( Finset.filter_subset_filter _ <| Finset.range_mono <| Nat.succ_le_succ <| Nat.floor_mono <| Real.sqrt_le_iff.mpr ⟨ by positivity, by nlinarith ⟩ ) ];
            · exact Finset.card_mono <| Finset.inter_subset_left;
          · ext; simp [Finset.mem_Icc, Finset.mem_range, Finset.mem_sdiff];
            grind +ring;
        exact h_sum_log_primes_ge.trans ( Finset.sum_le_sum_of_subset_of_nonneg ( Finset.filter_subset_filter _ <| Finset.Icc_subset_Icc ( by norm_num ) le_rfl ) fun _ _ _ => Real.log_nonneg <| Nat.one_le_cast.2 <| Nat.Prime.pos <| by aesop );
      rw [ Real.log_sqrt ( by positivity ) ] at h_sum_log_primes_ge ; rw [ div_add', le_div_iff₀ ] <;> nlinarith [ h_sum_log_primes_le_x_log_4 x hx, Real.log_pos <| show 1 < x by linarith, Real.log_pos <| show 1 < Real.sqrt x by exact Real.lt_sqrt_of_sq_lt <| by linarith ] ;
    -- Since $\pi(\sqrt{x}) \leq \sqrt{x}$, we have $\pi(x) \leq \frac{2x \log 4}{\log x} + \sqrt{x}$.
    have h_pi_le_sqrt : ∀ x : ℝ, 2 ≤ x → (Nat.primeCounting (Nat.floor x)) ≤ (2 * x * Real.log 4) / Real.log x + Real.sqrt x := by
      intros x hx
      have h_pi_sqrt : (Nat.primeCounting (Nat.floor (Real.sqrt x))) ≤ Real.sqrt x := by
        rw [ Nat.primeCounting ];
        rw [ Nat.primeCounting', Nat.count_eq_card_filter_range ] ; linarith [ Nat.floor_le ( Real.sqrt_nonneg x ), show ( Finset.card ( Finset.filter Nat.Prime ( Finset.range ( ⌊Real.sqrt x⌋₊ + 1 ) ) ) : ℝ ) ≤ ⌊Real.sqrt x⌋₊ by exact_mod_cast le_trans ( Finset.card_le_card ( show Finset.filter Nat.Prime ( Finset.range ( ⌊Real.sqrt x⌋₊ + 1 ) ) ⊆ Finset.Ico 2 ( ⌊Real.sqrt x⌋₊ + 1 ) from fun p hp => Finset.mem_Ico.mpr ⟨ Nat.Prime.two_le ( Finset.mem_filter.mp hp |>.2 ), Finset.mem_range.mp ( Finset.mem_filter.mp hp |>.1 ) ⟩ ) ) ( by simp +arith +decide ) ] ;
      specialize h_pi_le x hx
      linarith [h_pi_sqrt];
    -- We'll use that $\sqrt{x} \log x \leq x$ for all $x \geq 2$.
    have h_sqrt_x_log_x_le_x : ∀ x : ℝ, 2 ≤ x → Real.sqrt x * Real.log x ≤ x := by
      intros x hx
      have h_sqrt_x_log_x_le_x : Real.log x ≤ Real.sqrt x := by
        have := Real.log_le_sub_one_of_pos ( by positivity : 0 < Real.sqrt x / 2 );
        rw [ Real.log_div ( by positivity ) ( by positivity ), Real.log_sqrt ( by positivity ) ] at this ; linarith [ Real.log_le_sub_one_of_pos zero_lt_two ];
      nlinarith [ Real.sqrt_nonneg x, Real.sq_sqrt ( show 0 ≤ x by linarith ) ];
    have := h_pi_le_sqrt x hx; rw [ div_add', le_div_iff₀ ] at this <;> nlinarith [ Real.log_pos <| show 1 < x by linarith, Real.log_le_sub_one_of_pos <| show 0 < x by linarith, h_sqrt_x_log_x_le_x x hx, Real.sqrt_nonneg x, Real.sq_sqrt <| show 0 ≤ x by linarith, show ( Real.log 4 : ℝ ) ≤ 2 by rw [ show ( 4 : ℝ ) = 2 ^ 2 by norm_num, Real.log_pow ] ; norm_num ; linarith [ Real.log_le_sub_one_of_pos zero_lt_two ] ] ;
  exact h_pi_bound

lemma sum_primes_bound {f : ℝ → ℝ} {A B : ℝ} (hA : 1 ≤ A) (hB : 1 ≤ B) (hBA : B ≤ A)
  (hf_diff : DifferentiableOn ℝ f (Set.Icc B A))
  (hf_dec : AntitoneOn f (Set.Icc B A))
  (hf_nonneg : ∀ x ∈ Set.Icc B A, 0 ≤ f x) :
  ∑ p ∈ (range ⌊A⌋₊).filter (fun (p : ℕ) => p.Prime ∧ B ≤ (p : ℝ)), f p ≤
    (Nat.primeCounting ⌊A⌋₊) * f B + ∫ x in Set.Ioc B A, (Nat.primeCounting ⌊x⌋₊) * (-deriv f x) := by
  -- Since $f$ is decreasing, we have $f(p) \leq f(B)$ for any prime $p$ in $[B, A]$.
  have h_decreasing : ∀ p ∈ Finset.filter (fun p => Nat.Prime p ∧ B ≤ p) (Finset.range (Nat.floor A)), f p ≤ f B := by
    norm_num +zetaDelta at *;
    exact fun p hp₁ hp₂ hp₃ => hf_dec ⟨ by linarith, by linarith [ Nat.floor_le ( show 0 ≤ A by linarith ), show ( p : ℝ ) ≤ ⌊A⌋₊ by exact_mod_cast Nat.le_of_lt hp₁ ] ⟩ ⟨ by linarith, by linarith [ Nat.floor_le ( show 0 ≤ A by linarith ), show ( p : ℝ ) ≤ ⌊A⌋₊ by exact_mod_cast Nat.le_of_lt hp₁ ] ⟩ hp₃;
  refine' le_add_of_le_of_nonneg ( le_trans ( Finset.sum_le_sum h_decreasing ) _ ) _;
  · norm_num [ Nat.primeCounting ];
    rw [ Nat.primeCounting', Nat.count_eq_card_filter_range ];
    exact mul_le_mul_of_nonneg_right ( mod_cast Finset.card_mono <| fun x hx => by aesop ; linarith ) <| hf_nonneg B ⟨ by linarith, by linarith ⟩;
  · -- Since $f$ is decreasing, we have $-deriv f x \geq 0$ for all $x \in [B, A]$.
    have h_deriv_nonpos : ∀ x ∈ Set.Ioo B A, -deriv f x ≥ 0 := by
      aesop;
      have h_deriv_nonpos : ∀ x ∈ Set.Ioo B A, deriv f x ≤ 0 := by
        intro x hx
        have h_lim : Filter.Tendsto (fun h => (f (x + h) - f x) / h) (nhdsWithin 0 (Set.Ioi 0)) (nhds (deriv f x)) := by
          simpa [ div_eq_inv_mul ] using hf_diff.hasDerivAt ( Icc_mem_nhds hx.1 hx.2 ) |> HasDerivAt.tendsto_slope_zero_right
        refine' le_of_tendsto h_lim _;
        filter_upwards [ Ioo_mem_nhdsGT_of_mem ⟨ le_rfl, show 0 < A - x from sub_pos.mpr hx.2 ⟩ ] with y hy using div_nonpos_of_nonpos_of_nonneg ( sub_nonpos.mpr <| hf_dec ⟨ by linarith [ hx.1, hy.1 ], by linarith [ hx.2, hy.2 ] ⟩ ⟨ by linarith [ hx.1, hy.1 ], by linarith [ hx.2, hy.2 ] ⟩ <| by linarith [ hx.1, hx.2, hy.1, hy.2 ] ) hy.1.le;
      exact h_deriv_nonpos x ⟨ left, right ⟩;
    rw [ MeasureTheory.integral_Ioc_eq_integral_Ioo ] ; exact MeasureTheory.setIntegral_nonneg measurableSet_Ioo fun x hx => mul_nonneg ( Nat.cast_nonneg _ ) ( h_deriv_nonpos x hx ) ;

lemma weight_deriv (t : ℝ) (x : ℝ) (ht : 0 < t) (hx : 0 < x) :
  deriv (weight t) x = - (weight t x) * (Real.log x) / (8 * Real.pi ^ 2 * t * x) := by
  -- Apply the chain rule to compute the derivative.
  have h_deriv : deriv (fun x => Real.exp (-(Real.log x / (2 * Real.pi))^2 / (4 * t))) x = Real.exp (-(Real.log x / (2 * Real.pi))^2 / (4 * t)) * (-(2 * (Real.log x / (2 * Real.pi)) * (1 / (2 * Real.pi)) * (1 / x)) / (4 * t)) := by
    norm_num [ Real.differentiableAt_exp, hx.ne', Real.differentiableAt_log ] ; ring;
  unfold weight; convert h_deriv using 1; ring;

lemma gaussian_prime_sum_bound_lemma (A D t B : ℝ) (hA : 1 < A) (hD : 0 < D) (ht : 0 < t)
  (hB_eq : B = Real.exp (2 * Real.pi * D)) (hBA : B ≤ A) :
  ∑ p ∈ (range ⌊A⌋₊).filter (fun p => p.Prime ∧ xi p ≥ D), Real.exp (-xi p ^ 2 / (4 * t)) ≤
  (Nat.primeCounting ⌊A⌋₊) * Real.exp (-D^2 / (4 * t)) +
  ∫ x in Set.Ioc B A, (Nat.primeCounting ⌊x⌋₊) * (weight t x * Real.log x / (8 * Real.pi^2 * t * x)) := by
  convert sum_primes_bound _ _ _ _ _ _ using 1;
  case convert_1 => exact fun x => Real.exp ( - ( Real.log x / ( 2 * Real.pi ) ) ^ 2 / ( 4 * t ) );
  case convert_2 => exact A;
  case convert_3 => exact Real.exp ( 2 * Real.pi * D );
  any_goals nlinarith [ Real.pi_pos, Real.add_one_le_exp ( 2 * Real.pi * D ), mul_pos Real.pi_pos hD ];
  · unfold xi; aesop;
    congr! 2;
    ext; aesop;
    · rw [ le_div_iff₀ ( by positivity ) ] at a_1 ; rw [ ← Real.log_le_log_iff ( by positivity ) ( by exact Nat.cast_pos.mpr a.pos ), Real.log_exp ] ; linarith;
    · rw [ le_div_iff₀' ] <;> nlinarith [ Real.pi_pos, Real.log_exp ( 2 * Real.pi * D ), Real.log_le_log ( by positivity ) a_1 ];
  · unfold weight; aesop;
    refine' MeasureTheory.setIntegral_congr_fun measurableSet_Ioc fun x hx => _ ; norm_num [ Real.differentiableAt_exp, Real.differentiableAt_log, show x ≠ 0 from ne_of_gt <| lt_trans ( Real.exp_pos _ ) hx.1 ] ; ring;
  · exact DifferentiableOn.exp ( DifferentiableOn.div_const ( DifferentiableOn.neg ( DifferentiableOn.pow ( DifferentiableOn.div_const ( Real.differentiableOn_log.mono ( by intro x hx; exact ne_of_gt ( lt_of_lt_of_le ( by positivity ) hx.1 ) ) ) _ ) _ ) ) _ );
  · refine' fun x hx y hy hxy => Real.exp_le_exp.mpr _;
    gcongr ; aesop;
    · exact div_nonneg ( Real.log_nonneg ( by linarith [ Real.add_one_le_exp ( 2 * Real.pi * D ), Real.pi_pos, mul_pos Real.pi_pos hD ] ) ) ( by positivity );
    · linarith [ hx.1, Real.exp_pos ( 2 * Real.pi * D ) ];
  · exact fun x hx => Real.exp_nonneg _

lemma gaussian_prime_series_summable (t : ℝ) (ht : 0 < t) :
  Summable (fun p : ℕ => if p.Prime then Real.exp (-xi p ^ 2 / (4 * t)) else 0) := by
  have h_summable : Summable (fun p : ℕ => if Nat.Prime p then Real.exp (-xi p ^ 2 / (4 * t)) else 0) := by
    have h_bound : ∀ p : ℕ, Nat.Prime p → Real.exp (-xi p ^ 2 / (4 * t)) ≤ Real.exp (-Real.log p ^ 2 / (16 * Real.pi ^ 2 * t)) := by
      intro p hp; unfold xi; ring_nf; norm_num [ Real.pi_pos.ne' ] ;
    have h_summable : Summable (fun p : ℕ => Real.exp (-Real.log p ^ 2 / (16 * Real.pi ^ 2 * t))) := by
      -- For sufficiently large $p$, we have $\exp(-(\log p)^2 / (16 \pi^2 t)) \leq \exp(-\log p) = 1/p$.
      have h_exp_bound : ∃ N : ℕ, ∀ p ≥ N, Real.exp (-Real.log p ^ 2 / (16 * Real.pi ^ 2 * t)) ≤ 1 / p ^ 2 := by
        -- Taking the natural logarithm of both sides, we get $-(\log p)^2 / (16 \pi^2 t) \leq -2 \log p$.
        have h_ln_bound : ∃ N : ℕ, ∀ p ≥ N, -(Real.log p)^2 / (16 * Real.pi^2 * t) ≤ -2 * Real.log p := by
          have h_ln_bound : ∃ N : ℕ, ∀ p ≥ N, Real.log p ≥ 32 * Real.pi^2 * t := by
            have h_log_growth : Filter.Tendsto (fun p : ℕ => Real.log p) Filter.atTop Filter.atTop := by
              exact Real.tendsto_log_atTop.comp tendsto_natCast_atTop_atTop;
            simpa using h_log_growth.eventually_ge_atTop ( 32 * Real.pi ^ 2 * t );
          exact h_ln_bound.imp fun N hN p hp => by rw [ div_le_iff₀ ] <;> nlinarith [ hN p hp, show 0 < Real.pi ^ 2 * t by positivity ] ;
        obtain ⟨ N, hN ⟩ := h_ln_bound; use N + 1; intro p hp; specialize hN p ( by linarith ) ; rw [ ← Real.log_le_log_iff ( by positivity ) ( by exact one_div_pos.mpr <| sq_pos_of_pos <| Nat.cast_pos.mpr <| by linarith ), Real.log_div ( by positivity ) ( by exact ne_of_gt <| sq_pos_of_pos <| Nat.cast_pos.mpr <| by linarith ) ] ; aesop;
      rw [ ← summable_nat_add_iff h_exp_bound.choose ];
      exact Summable.of_nonneg_of_le ( fun n => Real.exp_nonneg _ ) ( fun n => h_exp_bound.choose_spec _ ( Nat.le_add_left _ _ ) ) ( by simpa using summable_nat_add_iff h_exp_bound.choose |>.2 <| Real.summable_one_div_nat_pow.2 one_lt_two );
    exact Summable.of_nonneg_of_le ( fun p => by positivity ) ( fun p => by split_ifs <;> first | positivity | exact h_bound p ‹_› ) h_summable;
  convert h_summable using 1

theorem gaussian_prime_sum_asymptotic (D t : ℝ) (hD : 0 < D) (ht : 0 < t) :
  ∃ C > 0, ∀ᶠ A in Filter.atTop,
    ∑ p ∈ (range ⌊A⌋₊).filter (fun p => p.Prime ∧ xi p ≥ D),
      Real.exp (-xi p ^ 2 / (4 * t)) ≤
        C * (A / Real.log A) * Real.exp (-D^2 / (4 * t)) := by
  -- By Lemma~\ref{lem:gaussian_prime_series_summable}, we can choose $C$ such that the sum of the weights over primes is bounded by $C$.
  obtain ⟨C, hC_pos, hC_bound⟩ : ∃ C > 0, ∀ A ≥ 2, (∑ p ∈ ((range ⌊A⌋₊).filter (fun p => p.Prime ∧ (xi p) ≥ D)), (Real.exp (-(xi p) ^ 2 / (4 * t)))) ≤ C := by
    -- By Lemma~\ref{lem:gaussian_prime_series_summable}, we can choose $C$ such that the sum of the weights over primes is bounded by $C$ for all $A \geq 2$.
    obtain ⟨C, hC⟩ : ∃ C > 0, ∀ A ≥ 2, (∑ p ∈ ((range ⌊A⌋₊).filter (Nat.Prime)), (Real.exp (-(xi p) ^ 2 / (4 * t)))) ≤ C := by
      have := gaussian_prime_series_summable t ht;
      obtain ⟨ C, hC ⟩ := this;
      exact ⟨ Max.max C 1, by positivity, fun A hA => le_trans ( by simpa [ Finset.sum_filter ] using sum_le_hasSum ( Finset.range ⌊A⌋₊ ) ( fun p _ => by positivity ) hC ) ( le_max_left _ _ ) ⟩;
    exact ⟨ C, hC.1, fun A hA => le_trans ( Finset.sum_le_sum_of_subset_of_nonneg ( fun p hp => by aesop ) fun _ _ _ => Real.exp_nonneg _ ) ( hC.2 A hA ) ⟩;
  -- Since $A / \log A$ tends to infinity as $A$ tends to infinity, we can choose $C$ such that $C \exp(-D^2 / (4t))$ is large enough to cover the bound.
  obtain ⟨A₀, hA₀⟩ : ∃ A₀ : ℝ, ∀ A ≥ A₀, A / Real.log A ≥ 1 / Real.exp (-D ^ 2 / (4 * t)) := by
    have h_lim_inf : Filter.Tendsto (fun A : ℝ => A / Real.log A) Filter.atTop Filter.atTop := by
      -- We can use the change of variables $u = \log A$ to transform the limit expression.
      suffices h_log : Filter.Tendsto (fun u : ℝ => Real.exp u / u) Filter.atTop Filter.atTop by
        have := h_log.comp Real.tendsto_log_atTop;
        exact this.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with x hx using by rw [ Function.comp_apply, Real.exp_log hx ] );
      simpa using Real.tendsto_exp_div_pow_atTop 1;
    exact Filter.eventually_atTop.mp ( h_lim_inf.eventually_ge_atTop _ );
  refine' ⟨ C, hC_pos, Filter.eventually_atTop.mpr ⟨ Max.max A₀ 2, fun A hA => _ ⟩ ⟩ ; aesop;
  refine le_trans ( hC_bound ⌊A⌋₊ ( Nat.le_floor right ) ) ?_;
  rw [ mul_assoc ] ; exact le_mul_of_one_le_right hC_pos.le ( by have := hA₀ A left; rw [ inv_eq_one_div, div_le_iff₀ ( Real.exp_pos _ ) ] at this; nlinarith [ Real.exp_pos ( -D ^ 2 / ( 4 * t ) ) ] ) ;

theorem gaussian_prime_sum_corrected : ∃ C > 0, ∀ (A D t : ℝ) (hA : 1 < A) (hD : 0 < D) (ht : 0 < t) (hD_large : D ≥ 4 * Real.pi * t),
  ∑ p ∈ (range ⌊A⌋₊).filter (fun p => p.Prime ∧ xi p ≥ D),
    Real.exp (-xi p ^ 2 / (4 * t)) ≤
      C * (A / Real.log A) * Real.exp (-D^2 / (4 * t)) * (1 + t / D) := by
  obtain ⟨C, hC_pos, hC⟩ : ∃ C > 0, ∀ A D t : ℝ, 1 < A → 0 < D → 0 < t → D ≥ 4 * Real.pi * t → ∑ p ∈ Finset.range ⌊A⌋₊, (if p.Prime ∧ xi p ≥ D then Real.exp (-(xi p) ^ 2 / (4 * t)) else 0) ≤ C * (A / Real.log A) * Real.exp (-D^2 / (4 * t)) := by
    -- Apply the asymptotic bound from Gaussian Prime Sum Asymptotics to obtain such a constant $C$.
    have h_asymptotic : ∀ A D t : ℝ, 1 < A → 0 < D → 0 < t → D ≥ 4 * Real.pi * t →
      ∑ p ∈ Finset.range ⌊A⌋₊, (if p.Prime ∧ xi p ≥ D then Real.exp (-xi p ^ 2 / (4 * t)) else 0) ≤
      (Nat.primeCounting ⌊A⌋₊) * Real.exp (-D^2 / (4 * t)) := by
        intros A D t hA hD ht hD_ge
        have h_sum_le : (∑ p ∈ Finset.range ⌊A⌋₊, if Nat.Prime p ∧ xi p ≥ D then Real.exp (-xi p ^ 2 / (4 * t)) else 0) ≤ (∑ p ∈ Finset.filter (fun p => Nat.Prime p ∧ xi p ≥ D) (Finset.range ⌊A⌋₊), 1) * Real.exp (-D^2 / (4 * t)) := by
          have h_sum_le : ∀ p ∈ Finset.filter (fun p => Nat.Prime p ∧ xi p ≥ D) (Finset.range ⌊A⌋₊), Real.exp (-xi p ^ 2 / (4 * t)) ≤ Real.exp (-D^2 / (4 * t)) := by
            intro p hp; gcongr ; aesop;
          simpa [ Finset.sum_ite ] using Finset.sum_le_sum h_sum_le;
        refine le_trans h_sum_le ?_;
        norm_num [ Nat.primeCounting ];
        rw [ Nat.primeCounting', Nat.count_eq_card_filter_range ];
        exact mul_le_mul_of_nonneg_right ( mod_cast Finset.card_mono <| fun x hx => by aesop ; linarith ) <| Real.exp_nonneg _;
    -- Use the fact that $\pi(x) \leq C \frac{x}{\log x}$ for some constant $C$.
    obtain ⟨C, hC_pos, hC_bound⟩ : ∃ C > 0, ∀ x ≥ 2, (Nat.primeCounting ⌊x⌋₊ : ℝ) ≤ C * x / Real.log x := by
      exact?;
    refine' ⟨ C, hC_pos, fun A D t hA hD ht hDt => le_trans ( h_asymptotic A D t hA hD ht hDt ) _ ⟩;
    by_cases hA_ge_2 : 2 ≤ A;
    · exact mul_le_mul_of_nonneg_right ( by simpa only [ mul_div_assoc ] using hC_bound A hA_ge_2 ) ( Real.exp_nonneg _ );
    · norm_num [ show ⌊A⌋₊ = 1 by exact Nat.floor_eq_iff ( by positivity ) |>.2 ⟨ by norm_num; linarith, by norm_num; linarith ⟩ ];
      exact mul_nonneg ( mul_nonneg hC_pos.le ( div_nonneg ( by linarith ) ( Real.log_nonneg ( by linarith ) ) ) ) ( Real.exp_nonneg _ );
  simp_all +decide [ Finset.sum_ite ];
  exact ⟨ C, hC_pos, fun A D t hA hD ht hD' => le_trans ( hC A D t hA hD ht hD' ) ( le_mul_of_one_le_right ( mul_nonneg ( mul_nonneg hC_pos.le ( div_nonneg ( by linarith ) ( Real.log_nonneg ( by linarith ) ) ) ) ( Real.exp_nonneg _ ) ) ( le_add_of_nonneg_right ( div_nonneg ht.le hD.le ) ) ) ⟩