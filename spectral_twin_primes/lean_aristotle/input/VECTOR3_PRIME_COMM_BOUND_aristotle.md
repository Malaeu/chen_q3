/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 626d9078-974a-42b0-bc11-e1b0733b56b1
-/

/-
This module formalizes the "Prime Operator Commutator Bound" for Vector 3 Task #3.
It defines the commutator `comm` and rank-one operator `rankOne`.
It establishes the bound `‖[rankOne(v), U]‖ ≤ 2 * ‖U v - v‖ * ‖v‖` and the additivity of the commutator norm.
Finally, it proves the main theorem `prime_comm_bound`: `‖[T_P, U]‖ ≤ 2ε · Σ |wᵢ| · ‖vᵢ‖²` under the shift-stability assumption.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped ComplexConjugate
open Complex

/-- Commutator of bounded operators -/
def Vector3Task3.comm {H : Type} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    (A U : H →L[ℂ] H) : H →L[ℂ] H :=
  A.comp U - U.comp A

#check innerSL
#check ContinuousLinearMap.smulRight

noncomputable def Vector3Task3.rankOne {H : Type} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    (v : H) : H →L[ℂ] H :=
  ContinuousLinearMap.smulRight (innerSL ℂ v) v

/-- AXIOM: Step 1 result (rankOne commutator bound) -/
theorem Vector3Task3.rankOne_comm_bound {H : Type} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    (U : H →L[ℂ] H) (hU : Isometry U) (v : H) :
    ‖Vector3Task3.comm (Vector3Task3.rankOne v) U‖ ≤ 2 * ‖U v - v‖ * ‖v‖ := by
      have h_ineq : ‖Vector3Task3.comm (Vector3Task3.rankOne v) U‖ ≤ ‖Vector3Task3.rankOne v - Vector3Task3.rankOne (U v)‖ := by
        refine' ContinuousLinearMap.opNorm_le_bound _ _ _;
        · positivity;
        · intro x;
          -- By definition of commutator, we have
          have h_comm : (Vector3Task3.rankOne v).comp U x - U.comp (Vector3Task3.rankOne v) x = (Vector3Task3.rankOne v - Vector3Task3.rankOne (U v)) (U x) := by
            -- By definition of rankOne, we have:
            simp [Vector3Task3.rankOne];
            -- Since $U$ is an isometry, we have $\langle Uv, Ux \rangle = \langle v, x \rangle$.
            have h_inner : inner ℂ (U v) (U x) = inner ℂ v x := by
              -- Since $U$ is an isometry, we have $\langle Uv, Ux \rangle = \langle v, x \rangle$ by the definition of an isometry.
              have h_isometry : ∀ v x : H, inner ℂ (U v) (U x) = inner ℂ v x := by
                intro v x;
                have h_isometry : ∀ v x : H, ‖U v - U x‖^2 = ‖v - x‖^2 := by
                  exact fun v x => by rw [ ← dist_eq_norm, ← dist_eq_norm, hU.dist_eq ] ;
                simp_all +decide [ @norm_sub_sq ℂ ];
                have := h_isometry v 0; have := h_isometry x 0; simp_all +decide [ norm_eq_sqrt_real_inner ] ;
                have := h_isometry v x; simp_all +decide [ Complex.ext_iff, sq ] ;
                have := h_isometry v ( Complex.I • x ) ; simp_all +decide [ Complex.ext_iff, inner_smul_right ] ;
                simp_all +decide [ norm_smul ];
              exact h_isometry v x;
            rw [ h_inner ];
          convert ContinuousLinearMap.le_opNorm ( Vector3Task3.rankOne v - Vector3Task3.rankOne ( U v ) ) ( U x ) using 1 ; aesop;
          · unfold Vector3Task3.comm; aesop;
          · -- Since $U$ is an isometry, we have $\|U x\| = \|x\|$.
            have h_norm_Ux : ‖U x‖ = ‖x‖ := by
              simpa using hU.dist_eq x 0;
            rw [ h_norm_Ux ];
      -- Using the fact that $A_v - A_{Uv} = (v - Uv)(v + Uv)^\dagger$, we can apply the triangle inequality.
      have h_triangle : ‖Vector3Task3.rankOne v - Vector3Task3.rankOne (U v)‖ ≤ ‖(innerSL ℂ (v - U v))‖ * ‖v‖ + ‖(innerSL ℂ (U v))‖ * ‖v - U v‖ := by
        have h_triangle : Vector3Task3.rankOne v - Vector3Task3.rankOne (U v) = ContinuousLinearMap.smulRight (innerSL ℂ (v - U v)) v + ContinuousLinearMap.smulRight (innerSL ℂ (U v)) (v - U v) := by
          ext; simp +decide [ Vector3Task3.rankOne ] ; ring;
          rw [ sub_smul, smul_sub ] ; abel1;
        refine' h_triangle ▸ le_trans ( norm_add_le _ _ ) _;
        norm_num +zetaDelta at *;
      -- Using the fact that $‖innerSL ℂ (v - U v)‖ = ‖v - U v‖$ and $‖innerSL ℂ (U v)‖ = ‖U v‖$, we can simplify the expression.
      have h_simplify : ‖(innerSL ℂ (v - U v))‖ = ‖v - U v‖ ∧ ‖(innerSL ℂ (U v))‖ = ‖U v‖ := by
        exact ⟨ by exact?;, by exact? ⟩;
      simp_all +decide [ norm_sub_rev ];
      exact h_ineq.trans <| h_triangle.trans_eq <| by rw [ show ‖U v‖ = ‖v‖ from by simpa using hU.dist_eq v 0 ] ; ring;

/-- AXIOM: Step 2 result (commutator sum bound) -/
theorem Vector3Task3.comm_sum_bound {H : Type} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    {ι : Type} [DecidableEq ι]
    (U : H →L[ℂ] H) (s : Finset ι) (Ai : ι → (H →L[ℂ] H)) :
    ‖Vector3Task3.comm (∑ i ∈ s, Ai i) U‖ ≤ ∑ i ∈ s, ‖Vector3Task3.comm (Ai i) U‖ := by
      -- By the properties of the norm and the triangle inequality, we can split the commutator into a sum of commutators.
      have h_split : Vector3Task3.comm (∑ i ∈ s, Ai i) U = ∑ i ∈ s, Vector3Task3.comm (Ai i) U := by
        unfold Vector3Task3.comm;
        bound;
      -- Apply the triangle inequality to the sum of the commutators.
      rw [h_split]
      apply norm_sum_le

/-- Scalar factors out of commutator -/
lemma Vector3Task3.comm_smul {H : Type} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    (c : ℂ) (A U : H →L[ℂ] H) :
    Vector3Task3.comm (c • A) U = c • Vector3Task3.comm A U := by
      -- By definition of commutator, we have:
      simp [Vector3Task3.comm, mul_assoc, sub_eq_add_neg]

/-- Norm of scalar-commutator -/
lemma Vector3Task3.norm_comm_smul {H : Type} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    (c : ℂ) (A U : H →L[ℂ] H) :
    ‖Vector3Task3.comm (c • A) U‖ = ‖c‖ * ‖Vector3Task3.comm A U‖ := by
      -- By the properties of the norm, we can factor out the scalar 'c' from the norm.
      have h_norm : ‖c • Vector3Task3.comm A U‖ = ‖c‖ * ‖Vector3Task3.comm A U‖ := by
        -- Apply the norm_smul theorem to conclude the proof.
        apply norm_smul;
      -- Apply the scalar multiplication property of the commutator to conclude the proof.
      have h_comm_smul : Vector3Task3.comm (c • A) U = c • Vector3Task3.comm A U := by
        -- By the properties of the commutator, we have [cA, U] = c[A, U] because the commutator is linear in the first argument.
        apply Vector3Task3.comm_smul
      rw [h_comm_smul, h_norm]

theorem Vector3Task3.prime_comm_bound {H : Type} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    {ι : Type} [DecidableEq ι]
    (U : H →L[ℂ] H) (hU : Isometry U)
    (s : Finset ι) (w : ι → ℝ) (v : ι → H)
    (ε : ℝ) (hε : 0 ≤ ε)
    (hst : ∀ i, ‖U (v i) - v i‖ ≤ ε * ‖v i‖) :
    ‖Vector3Task3.comm (∑ i ∈ s, (w i : ℂ) • Vector3Task3.rankOne (v i)) U‖
      ≤ 2 * ε * ∑ i ∈ s, |w i| * ‖v i‖^2 := by
        -- For each $i$, apply the result from Step 1: $\|[w_i \cdot \mathrm{rankOne}(v_i), U]\| = |w_i| \cdot \|\mathrm{rankOne}(v_i), U\|$.
        have h_i : ∀ i ∈ s, ‖Vector3Task3.comm ((w i : ℂ) • Vector3Task3.rankOne (v i)) U‖ ≤ 2 * ε * |w i| * ‖v i‖ ^ 2 := by
          intros i hi
          have h_comm_bound : ‖Vector3Task3.comm ((w i : ℂ) • Vector3Task3.rankOne (v i)) U‖ = |w i| * ‖Vector3Task3.comm (Vector3Task3.rankOne (v i)) U‖ := by
            convert Vector3Task3.norm_comm_smul ( w i : ℂ ) ( Vector3Task3.rankOne ( v i ) ) U using 1;
            norm_num;
          have := Vector3Task3.rankOne_comm_bound U hU ( v i );
          exact h_comm_bound.symm ▸ le_trans ( mul_le_mul_of_nonneg_left this ( abs_nonneg _ ) ) ( by nlinarith [ abs_nonneg ( w i ), hst i, mul_le_mul_of_nonneg_right ( hst i ) ( abs_nonneg ( w i ) ), mul_le_mul_of_nonneg_right ( hst i ) ( norm_nonneg ( v i ) ) ] );
        convert le_trans ( Vector3Task3.comm_sum_bound U s fun i => ( w i : ℂ ) • Vector3Task3.rankOne ( v i ) ) ( Finset.sum_le_sum h_i ) using 1 ; simp +decide [ mul_assoc, Finset.mul_sum _ _ _ ]