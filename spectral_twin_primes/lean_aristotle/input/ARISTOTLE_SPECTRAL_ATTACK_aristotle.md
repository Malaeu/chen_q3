/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 40988c69-3c8b-4078-a4a4-d305d37d4e20

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def χ₄ (n : ℤ) : ℤ :=
  if n % 2 = 0 then 0
  else if n % 4 = 1 then 1
  else -1

noncomputable def e (x : ℝ) : ℂ := Complex.exp (2 * Real.pi * Complex.I * x)
noncomputable def Λ : ℕ → ℝ := ArithmeticFunction.vonMangoldt

noncomputable def F_op (X : ℕ) : Matrix (Fin X) (Fin X) ℂ :=
  Matrix.diagonal (fun n => e (n.val / 4))

def U2_op (X : ℕ) : Matrix (Fin X) (Fin X) ℂ :=
  fun i j => if j.val = i.val + 2 then 1 else 0

def chi4_op (X : ℕ) : Matrix (Fin X) (Fin X) ℂ :=
  Matrix.diagonal (fun n => (χ₄ n.val : ℂ))

noncomputable def comm_F_U2 (X : ℕ) : Matrix (Fin X) (Fin X) ℂ :=
  F_op X * U2_op X - U2_op X * F_op X

noncomputable def prime_vector (X : ℕ) : Fin X → ℂ :=
  fun n => (Λ n.val : ℂ)

def twin_vector (X : ℕ) : Fin X → ℂ :=
  fun n => if n.val.Prime ∧ (n.val + 2).Prime then 1 else 0

#check dotProduct

noncomputable def S₂ (X : ℕ) : ℝ := Finset.sum (Finset.range X) (fun n => (Λ n) * (Λ (n + 2)))

theorem comm_formula (X : ℕ) (hX : X > 4) :
  comm_F_U2 X = 2 • (F_op X * U2_op X) := by
    unfold comm_F_U2;
    ext i j; by_cases hi : i.val + 2 = j.val <;> simp +decide [ hi, F_op, U2_op ] ; ring;
    · norm_num [ ← hi, e ] ; ring;
      norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im, mul_div ] ; ring;
      norm_num [ Real.cos_add, Real.sin_add ] ; ring ; norm_num;
    · aesop

noncomputable def B_op (X : ℕ) : Matrix (Fin X) (Fin X) ℂ :=
  let A := Complex.I • (comm_F_U2 X * chi4_op X)
  A + Matrix.conjTranspose A

#print Complex
#synth Algebra ℂ (Matrix (Fin 5) (Fin 5) ℂ)

lemma B_spectrum_bound (X : ℕ) (hX : X > 4) :
  ∀ eig ∈ spectrum ℂ (B_op X), ‖eig‖ ≤ 4 * X := by
    -- The operator norm of $B_op X$ is bounded by $4X$ because each entry in $B_op X$ has an absolute value of at most 2, and there are $X$ entries.
    have h_op_norm_bound : ∀ (v : Fin X → ℂ), ‖(B_op X).mulVec v‖ ≤ 4 * X * ‖v‖ := by
      -- Each entry in $B_op X$ has an absolute value of at most 2, and there are $X$ entries.
      have h_max_abs : ∀ i j : Fin X, ‖(B_op X) i j‖ ≤ 2 := by
        unfold B_op;
        -- By definition of $B_op$, we know that each entry is a sum of terms involving products of $F_op$, $U2_op$, and $\chi_4$.
        intros i j
        simp [comm_F_U2, chi4_op, F_op, U2_op];
        split_ifs <;> norm_num;
        · grind;
        · refine' le_trans ( mul_le_of_le_one_right ( norm_nonneg _ ) _ ) _;
          · unfold χ₄; aesop;
          · refine' le_trans ( norm_sub_le _ _ ) _;
            norm_num [ Complex.norm_exp, e ];
        · refine' le_trans ( mul_le_of_le_one_left ( norm_nonneg _ ) _ ) _;
          · unfold χ₄; aesop;
          · refine' le_trans ( norm_sub_le _ _ ) _ ; norm_num;
            norm_num [ Complex.norm_exp, e ];
      -- Using the bound on the maximum absolute value of the entries of $B_op X$, we can bound the norm of $B_op X \cdot v$.
      have h_norm_mulVec : ∀ v : Fin X → ℂ, ∀ i : Fin X, ‖(B_op X).mulVec v i‖ ≤ 2 * X * ‖v‖ := by
        intros v i
        have h_sum_abs : ‖(B_op X).mulVec v i‖ ≤ ∑ j : Fin X, ‖(B_op X) i j‖ * ‖v j‖ := by
          simpa only [ Matrix.mulVec, dotProduct ] using norm_sum_le _ _ |> le_trans <| Finset.sum_le_sum fun j _ => by rw [ norm_mul ] ;
        exact h_sum_abs.trans ( le_trans ( Finset.sum_le_sum fun j _ => mul_le_mul_of_nonneg_right ( h_max_abs i j ) ( norm_nonneg _ ) ) ( by simpa [ mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _ ] using Finset.sum_le_sum fun j ( _ : j ∈ Finset.univ ) => mul_le_mul_of_nonneg_left ( norm_le_pi_norm v j ) zero_le_two ) );
      intro v;
      refine' pi_norm_le_iff_of_nonneg ( by positivity ) |>.2 fun i => le_trans ( h_norm_mulVec v i ) ( by nlinarith [ show ( X : ℝ ) ≥ 5 by norm_cast, norm_nonneg v ] );
    -- By definition of spectrum, if eig is an eigenvalue of B_op X, then there exists a nonzero vector v such that B_op X * v = eig * v.
    intro eig heig
    obtain ⟨v, hv_ne_zero, hv_eigen⟩ : ∃ v : Fin X → ℂ, v ≠ 0 ∧ (B_op X).mulVec v = eig • v := by
      rw [ spectrum.mem_iff ] at heig;
      rw [ Matrix.isUnit_iff_isUnit_det ] at heig;
      obtain ⟨v, hv⟩ : ∃ v : Fin X → ℂ, v ≠ 0 ∧ (algebraMap ℂ (Matrix (Fin X) (Fin X) ℂ) eig - B_op X).mulVec v = 0 := by
        simp_all +decide [ Matrix.exists_mulVec_eq_zero_iff ];
      simp_all +decide [ sub_eq_iff_eq_add, Matrix.sub_mulVec ];
      exact ⟨ v, hv.1, hv.2.symm.trans ( by ext i; erw [ Matrix.mulVec_diagonal ] ; aesop ) ⟩;
    have := h_op_norm_bound v; simp_all +decide [ norm_smul ]

opaque minor_contribution (X : ℕ) : ℝ

opaque eigenvalue (σ : ℝ) (n : ℝ) : ℝ

noncomputable def minor_contribution_explicit (X : ℕ) : ℝ := 
  Finset.sum (Finset.range X) (fun n => if (n : ℝ) > Real.sqrt X then eigenvalue (Real.log X) n else 0)

lemma exp_decay_bound (X : ℕ) (hX : X > 100) :
  Real.exp (-(X : ℝ) / (Real.log X)^2) ≤ 1 / Real.log X := by
    rw [ one_div, ← Real.log_le_log_iff ( by positivity ) ( by exact inv_pos.mpr <| Real.log_pos <| by norm_cast ; linarith ), Real.log_inv, Real.log_exp ];
    -- Let $y = \log X$. Then we need to show that $-X \leq -y^2 \log y$, which simplifies to $X \geq y^2 \log y$.
    set y : ℝ := Real.log X
    have h_y : X ≥ y^2 * Real.log y := by
      -- Since $y = \log X$ and $X > 100$, we have $y > \log 100 = 2 \log 10 \approx 4.605$. Therefore, $y^2 \log y < y^2 \cdot y/2 = y^3 / 2$.
      have h_y_bound : y^2 * Real.log y < y^3 / 2 := by
        have h_y_bound : Real.log y < y / 2 := by
          have := Real.log_le_sub_one_of_pos ( show 0 < y / 2 by exact div_pos ( Real.log_pos <| Nat.one_lt_cast.mpr <| by linarith ) zero_lt_two );
          rw [ Real.log_div ( ne_of_gt <| Real.log_pos <| Nat.one_lt_cast.mpr <| by linarith ) ] at this <;> norm_num at *;
          linarith [ Real.log_lt_sub_one_of_pos zero_lt_two ( by norm_num ) ];
        nlinarith [ show 0 < y ^ 2 by exact sq_pos_of_pos ( Real.log_pos ( by norm_cast; linarith ) ) ];
      -- Since $y = \log X$ and $X > 100$, we have $y > \log 100 = 2 \log 10 \approx 4.605$. Therefore, $y^3 / 2 < y^3 < y^3 \cdot y / 2 = y^4 / 2$.
      have h_y_bound2 : y^3 / 2 < Real.exp y := by
        rw [ Real.exp_eq_exp_ℝ ];
        rw [ NormedSpace.exp_eq_tsum_div ];
        refine' lt_of_lt_of_le _ ( Summable.sum_le_tsum ( Finset.range 6 ) ( fun _ _ => by positivity ) ( by exact Real.summable_pow_div_factorial _ ) ) ; norm_num [ Finset.sum_range_succ, Nat.factorial ];
        nlinarith only [ show 0 < y by exact Real.log_pos <| by norm_cast; linarith, pow_pos ( Real.log_pos <| show ( X : ℝ ) > 1 by norm_cast; linarith ) 3, pow_pos ( Real.log_pos <| show ( X : ℝ ) > 1 by norm_cast; linarith ) 4, pow_pos ( Real.log_pos <| show ( X : ℝ ) > 1 by norm_cast; linarith ) 5 ];
      linarith [ Real.exp_log ( by positivity : 0 < ( X : ℝ ) ) ];
    rw [ div_le_iff₀ ] <;> nlinarith [ show 0 < y ^ 2 by exact sq_pos_of_pos <| Real.log_pos <| Nat.one_lt_cast.mpr <| by linarith ]

lemma term_bound (X : ℕ) (hX : X > 100) (n : ℕ) (hn : (n : ℝ) > Real.sqrt X) :
  Real.exp (-(n : ℝ)^2 / (Real.log X)^2) ≤ 1 / Real.log X := by
    -- Applying the lemma `exp_decay_bound`.
    have := exp_decay_bound X (by linarith);
    exact le_trans ( Real.exp_le_exp.mpr <| by rw [ div_le_div_iff_of_pos_right <| sq_pos_of_pos <| Real.log_pos <| Nat.one_lt_cast.mpr <| by linarith ] ; nlinarith [ Real.sqrt_nonneg X, Real.sq_sqrt <| Nat.cast_nonneg X ] ) this