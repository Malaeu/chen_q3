/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9f9e518f-3d33-4722-b0ae-2c82d760b43e
-/

/-
We have successfully formalized the contradiction approach for the Twin Prime Conjecture based on the Q3 spectral gap hypothesis. We defined the necessary concepts including the twin prime counting function, the commutator energy terms (diagonal and off-diagonal), and the finite twins hypothesis. We then proved four key lemmas:
1. `finite_support_bounded_lambda`: If there are finitely many twin primes, the sum of squared lambda values is bounded.
2. `finite_support_bounded_off_diagonal`: If there are finitely many twin primes, the off-diagonal energy is bounded.
3. `energy_bound_finite_twins`: Under the finite twins hypothesis, the total energy grows at most logarithmically.
4. `log_power_growth_vs_power_growth`: Logarithmic growth is slower than any power growth.

Using these lemmas, we proved the main theorem `contradiction_implies_infinite_twins`, which states that the Q3 spectral gap hypothesis (which requires power growth of the energy) contradicts the finite twins hypothesis. Finally, we derived the corollary `twin_prime_conjecture`, showing that the Q3 spectral gap implies the existence of infinitely many twin primes.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of twin prime and the set of twin primes up to X.
-/
open Real Nat

def is_twin_prime (p : ℕ) : Prop := Nat.Prime p ∧ Nat.Prime (p + 2)

noncomputable def T (X : ℕ) : Finset ℕ := (Finset.range (X + 1)).filter is_twin_prime

/-
Definitions of lambda, xi, energy terms, S2, and the finite twins hypothesis.
-/
open Real Nat Finset
open scoped ArithmeticFunction BigOperators

noncomputable def lambda (n : ℕ) : ℝ := (Λ n) * (Λ (n + 2))

noncomputable def xi (n : ℕ) : ℝ := Real.log n / (2 * Real.pi)

opaque K_comm : ℝ → ℝ → ℝ
opaque C_comm : ℝ
opaque t_comm : ℝ

noncomputable def E_diag (X : ℕ) : ℝ := ∑ p ∈ T X, (lambda p)^2 * K_comm (xi p) (xi p)

noncomputable def E_off (X : ℕ) : ℝ := ∑ p ∈ T X, ∑ q ∈ (T X).erase p, (lambda p) * (lambda q) * K_comm (xi p) (xi q)

noncomputable def E_total (X : ℕ) : ℝ := E_diag X + E_off X

noncomputable def S2 (X : ℕ) : ℝ := ∑ n ∈ range (X + 1), lambda n

def finite_twins : Prop := ∃ k : ℕ, ∀ X : ℕ, (T X).card ≤ k

/-
Lemma 1: Finite Support ⟹ Bounded λ
-/
lemma finite_support_bounded_lambda (h : finite_twins) :
  ∃ C : ℝ, ∀ X : ℕ, ∑ p ∈ T X, (lambda p)^2 ≤ C := by
    obtain ⟨ k, hk ⟩ := h;
    -- Since there are only finitely many twin primes, their squares are also finite.
    have h_finite_squares : Set.Finite {p : ℕ | is_twin_prime p} := by
      contrapose! hk;
      obtain ⟨ s, hs ⟩ := Set.Infinite.exists_subset_card_eq hk ( k + 1 );
      exact ⟨ s.sup id, by exact lt_of_lt_of_le ( by simp +arith +decide [ hs.2 ] ) ( Finset.card_mono <| show s ⊆ T ( s.sup id ) from fun x hx => Finset.mem_filter.mpr ⟨ Finset.mem_range.mpr <| Nat.lt_succ_of_le <| Finset.le_sup ( f := id ) hx, hs.1 hx ⟩ ) ⟩;
    -- Since the set of twin primes is finite, the sum of their squares is also finite.
    have h_sum_finite : Set.Finite {p : ℕ | is_twin_prime p} → ∃ C : ℝ, ∀ X : ℕ, ∑ p ∈ T X, (lambda p)^2 ≤ C := by
      intros h_finite_squares
      use ∑ p ∈ h_finite_squares.toFinset, (lambda p)^2;
      intros X
      apply Finset.sum_le_sum_of_subset_of_nonneg;
      · exact fun p hp => h_finite_squares.mem_toFinset.mpr <| Finset.mem_filter.mp hp |>.2;
      · exact fun _ _ _ => sq_nonneg _;
    exact h_sum_finite h_finite_squares

/-
Lemma 2: Finite Support ⟹ Bounded Off-Diagonal
-/
lemma finite_support_bounded_off_diagonal (h : finite_twins) :
  ∃ C : ℝ, ∀ X : ℕ, |E_off X| ≤ C := by
    -- Let $S$ be the set of all twin primes.
    set S := {p : ℕ | is_twin_prime p} with hS;
    -- Since $S$ is finite, $T$ is also finite.
    have hS_finite : Set.Finite S := by
      contrapose! h ; aesop;
      obtain ⟨ k, hk ⟩ := a;
      -- Since $S$ is infinite, we can choose $k + 1$ distinct elements from $S$.
      obtain ⟨ps, hps⟩ : ∃ ps : Finset ℕ, ps.card = k + 1 ∧ ∀ p ∈ ps, p ∈ S := by
        have := Set.Infinite.exists_subset_card_eq h ( k + 1 ) ; tauto;
      bound;
      exact absurd ( hk ( Finset.sup ps id ) ) ( by exact not_le_of_gt ( lt_of_lt_of_le ( by aesop ) ( Finset.card_mono <| show ps ⊆ T ( Finset.sup ps id ) from fun p hp => Finset.mem_filter.mpr ⟨ Finset.mem_range.mpr <| Nat.lt_succ_of_le <| Finset.le_sup ( f := id ) hp, right p hp ⟩ ) ) );
    -- Since $S$ is finite, $T$ is also finite, and thus $\sum_{p \in T} \sum_{q \in T, q \neq p} \lambda_p \lambda_q K(\xi_p, \xi_q)$ is a finite sum.
    have h_finite_sum : ∃ C : ℝ, ∀ X : ℕ, ∑ p ∈ T X, ∑ q ∈ (T X).erase p, |(lambda p) * (lambda q) * K_comm (xi p) (xi q)| ≤ C := by
      use ∑ p ∈ hS_finite.toFinset, ∑ q ∈ hS_finite.toFinset, |lambda p * lambda q * K_comm (xi p) (xi q)|;
      intros X
      have h_subset : T X ⊆ hS_finite.toFinset := by
        exact fun p hp => hS_finite.mem_toFinset.mpr <| Finset.mem_filter.mp hp |>.2;
      refine' le_trans ( Finset.sum_le_sum_of_subset_of_nonneg h_subset fun _ _ _ => Finset.sum_nonneg fun _ _ => abs_nonneg _ ) _;
      exact Finset.sum_le_sum fun i hi => Finset.sum_le_sum_of_subset_of_nonneg ( Finset.erase_subset _ _ |> Finset.Subset.trans <| h_subset ) fun _ _ _ => abs_nonneg _;
    exact ⟨ h_finite_sum.choose, fun X => le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( le_trans ( Finset.sum_le_sum fun p hp => Finset.abs_sum_le_sum_abs _ _ ) ( h_finite_sum.choose_spec X ) ) ⟩

/-
Lemma 3: Total energy = O((log X)^A) under finite twins
-/
lemma energy_bound_finite_twins (h : finite_twins) :
  ∃ C A : ℝ, A > 0 ∧ ∀ X : ℕ, X > 0 → |E_total X| ≤ C * (Real.log X)^A := by
    -- By definition of $E_total$, we know that if $E_total(X)$ is bounded, then there exists a constant $C$ such that $E_total(X) \leq C$ for all $X$.
    obtain ⟨C, hC⟩ : ∃ C : ℝ, ∀ X : ℕ, (abs (E_total X)) ≤ C := by
      -- By definition of $E_total$, we know that $E_total(X) = E_diag(X) + E_off(X)$.
      simp [E_total];
      -- Apply Lemma 1 to bound the diagonal part.
      obtain ⟨C_diag, hC_diag⟩ : ∃ C_diag : ℝ, ∀ X : ℕ, abs (E_diag X) ≤ C_diag := by
        -- By definition of $E_{diag}$, we have $E_{diag}(X) = \sum_{p \in T(X)} \lambda(p)^2 K(p, p)$.
        have h_diag_def : ∀ X : ℕ, E_diag X = ∑ p ∈ T X, (lambda p)^2 * K_comm (xi p) (xi p) := by
          exact?;
        -- Since $T(X)$ is finite, the sum $\sum_{p \in T(X)} \lambda(p)^2 K(p, p)$ is bounded.
        have h_diag_bounded : ∃ C_diag : ℝ, ∀ X : ℕ, ∑ p ∈ T X, (lambda p)^2 * |K_comm (xi p) (xi p)| ≤ C_diag := by
          -- Since $T(X)$ is finite, the sum $\sum_{p \in T(X)} \lambda(p)^2 |K(p, p)|$ is bounded by the maximum value of $\lambda(p)^2 |K(p, p)|$ over all $p \in T(X)$.
          have h_diag_bounded : ∃ C_diag : ℝ, ∀ p ∈ ⋃ X, T X, (lambda p)^2 * |K_comm (xi p) (xi p)| ≤ C_diag := by
            -- Since $T(X)$ is finite, the set $\{p \in \mathbb{N} \mid p \in T(X) \text{ for some } X\}$ is also finite.
            have h_finite_set : Set.Finite {p : ℕ | ∃ X : ℕ, p ∈ T X} := by
              obtain ⟨ k, hk ⟩ := h;
              contrapose! hk;
              obtain ⟨ X, hX ⟩ := Set.Infinite.exists_subset_card_eq hk ( k + 1 );
              -- Since $X$ is a finite subset of $\{p \in \mathbb{N} \mid p \in T(X) \text{ for some } X\}$, there exists some $Y$ such that $X \subseteq T(Y)$.
              obtain ⟨ Y, hY ⟩ : ∃ Y : ℕ, X ⊆ T Y := by
                choose! f hf using hX.1;
                exact ⟨ Finset.sup X f, fun x hx => by have := hf hx; exact Finset.mem_filter.mpr ⟨ Finset.mem_range.mpr ( by linarith [ Finset.le_sup ( f := f ) hx, Finset.mem_range.mp ( Finset.mem_filter.mp this |>.1 ) ] ), Finset.mem_filter.mp this |>.2 ⟩ ⟩;
              exact ⟨ Y, by linarith [ Finset.card_le_card hY ] ⟩;
            exact ⟨ ∑ p ∈ h_finite_set.toFinset, ( lambda p ) ^ 2 * |K_comm ( xi p ) ( xi p )|, fun p hp => Finset.single_le_sum ( fun p _ => mul_nonneg ( sq_nonneg ( lambda p ) ) ( abs_nonneg ( K_comm ( xi p ) ( xi p ) ) ) ) ( h_finite_set.mem_toFinset.mpr <| by aesop ) ⟩;
          obtain ⟨ C_diag, hC_diag ⟩ := h_diag_bounded;
          use C_diag * (h.choose + 1);
          intro X; refine' le_trans ( Finset.sum_le_sum fun p hp => hC_diag p <| Set.mem_iUnion.mpr ⟨ X, hp ⟩ ) _ ; norm_num [ mul_comm ] ; aesop;
          exact mul_le_mul_of_nonneg_left ( mod_cast Nat.le_succ_of_le ( h.choose_spec X ) ) ( show 0 ≤ C_diag by exact le_trans ( by positivity ) ( hC_diag 3 3 ( by exact Finset.mem_filter.mpr ⟨ Finset.mem_range.mpr ( by norm_num ), by exact ⟨ by norm_num, by norm_num ⟩ ⟩ ) ) );
        obtain ⟨ C_diag, hC_diag ⟩ := h_diag_bounded; use C_diag; intro X; rw [ h_diag_def ] ; refine' le_trans ( Finset.abs_sum_le_sum_abs _ _ ) _ ; aesop;
      obtain ⟨ C_off, hC_off ⟩ := finite_support_bounded_off_diagonal h; exact ⟨ C_diag + C_off, fun X => by rw [ abs_le ] ; constructor <;> linarith [ abs_le.mp ( hC_diag X ), abs_le.mp ( hC_off X ) ] ⟩ ;
    refine' ⟨ C + 1, 1, _, fun X hX => _ ⟩ <;> aesop;
    rcases X with ( _ | _ | _ | X ) <;> norm_num at *;
    · unfold E_total E_diag E_off T; norm_num [ Finset.sum_filter, Finset.sum_range_succ ] ;
      unfold is_twin_prime; norm_num [ Finset.sum_filter, Finset.sum_range_succ ] ;
    · have := hC 2;
      rw [ show E_total 2 = ( ∑ p ∈ T 2, ( lambda p ) ^ 2 * K_comm ( xi p ) ( xi p ) ) + ( ∑ p ∈ T 2, ∑ q ∈ ( T 2 ).erase p, ( lambda p ) * ( lambda q ) * K_comm ( xi p ) ( xi q ) ) by rfl ] at *;
      rw [ show T 2 = ∅ by { rw [ show T 2 = ( Finset.range ( 2 + 1 ) ).filter is_twin_prime by rfl ] ; exact Finset.filter_eq_empty_iff.mpr fun x hx => by rcases x with ( _ | _ | _ | x ) <;> simp_all +arith +decide [ is_twin_prime ] } ] ; norm_num;
      exact mul_nonneg ( by linarith [ abs_le.mp this ] ) ( Real.log_nonneg ( by norm_num ) );
    · exact le_trans ( hC _ ) ( le_trans ( le_add_of_nonneg_right zero_le_one ) ( le_mul_of_one_le_right ( by linarith [ abs_le.mp ( hC ( X + 1 + 1 + 1 ) ) ] ) ( Real.le_log_iff_exp_le ( by linarith ) |>.2 <| by exact Real.exp_one_lt_d9.le.trans <| by norm_num; linarith ) ) )

/-
Lemma 4: Logarithmic vs Power Growth
-/
lemma log_power_growth_vs_power_growth (A δ : ℝ) (hA : A > 0) (hδ : δ > 0) :
  Filter.Tendsto (fun X : ℝ => (Real.log X)^A / X^δ) Filter.atTop (nhds 0) := by
    -- Let $y = \log X$, therefore the limit becomes $\lim_{y \to \infty} \frac{y^A}{e^{y \delta}}$.
    suffices h_log : Filter.Tendsto (fun y : ℝ ↦ y ^ A / Real.exp (y * δ)) Filter.atTop (nhds 0) by
      have := h_log.comp Real.tendsto_log_atTop;
      refine' this.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with X hX using by rw [ Function.comp_apply, Real.rpow_def_of_pos hX, Real.exp_mul, Real.exp_log hX ] );
    -- Let $z = y\delta$, therefore the limit becomes $\lim_{z \to \infty} \frac{z^A}{e^z}$.
    suffices h_z : Filter.Tendsto (fun z : ℝ ↦ z ^ A / Real.exp z) Filter.atTop (nhds 0) by
      have h_subst : Filter.Tendsto (fun y : ℝ ↦ (y * δ) ^ A / Real.exp (y * δ)) Filter.atTop (nhds 0) := by
        exact h_z.comp <| Filter.tendsto_id.atTop_mul_const hδ;
      have := h_subst.div_const ( δ ^ A );
      simpa using this.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with x hx using by rw [ Real.mul_rpow ( le_of_lt hx ) ( le_of_lt hδ ) ] ; rw [ div_right_comm, mul_div_cancel_right₀ _ ( ne_of_gt ( Real.rpow_pos_of_pos hδ _ ) ) ] );
    have := Real.tendsto_pow_mul_exp_neg_atTop_nhds_zero ( ⌈A⌉₊ : ℕ );
    refine' squeeze_zero_norm' _ this;
    filter_upwards [ Filter.eventually_gt_atTop 1 ] with x hx using by rw [ Real.norm_of_nonneg ( by positivity ) ] ; rw [ Real.exp_neg ] ; exact mul_le_mul_of_nonneg_right ( by exact_mod_cast Real.rpow_le_rpow_of_exponent_le hx.le ( Nat.le_ceil _ ) ) ( by positivity ) ;

/-
Definition of Q3 spectral gap hypothesis.
-/
def spectral_gap (δ : ℝ) : Prop :=
  δ > 0 ∧ ∃ c : ℝ, c > 0 ∧ ∃ X₀ : ℕ, ∀ X : ℕ, X ≥ X₀ → E_total X ≥ c * (X : ℝ) ^ δ

/-
Main Theorem: Q3 ⟹ infinitely many twins
-/
theorem contradiction_implies_infinite_twins
  (h_gap : ∃ δ > 0, spectral_gap δ) :
  ¬ finite_twins := by
    aesop;
    -- By Lemma 3, we have that $ℰ_X(λ) ≤ C * (log X)^A$ for some $C$ and $A$.
    obtain ⟨C, A, hA_pos, h_bound⟩ : ∃ C A : ℝ, A > 0 ∧ ∀ X : ℕ, X > 0 → |E_total X| ≤ C * (Real.log X)^A := by
      exact?;
    -- By the spectral gap hypothesis, we have that $ℰ_X(λ) ≥ c * X^δ$ for some $c > 0$ and $X₀$.
    obtain ⟨c, hc_pos, X₀, h_spec⟩ : ∃ c : ℝ, c > 0 ∧ ∃ X₀ : ℕ, ∀ X : ℕ, X ≥ X₀ → E_total X ≥ c * (X : ℝ) ^ w := by
      cases right ; aesop;
    -- Choose $X$ large enough such that $c * X^w > C * (log X)^A$.
    obtain ⟨X₁, hX₁⟩ : ∃ X₁ : ℕ, X₁ ≥ X₀ ∧ X₁ > 0 ∧ c * (X₁ : ℝ) ^ w > C * (Real.log X₁)^A := by
      have h_lim : Filter.Tendsto (fun X : ℕ => C * (Real.log X)^A / (X : ℝ) ^ w) Filter.atTop (nhds 0) := by
        have h_lim : Filter.Tendsto (fun X : ℝ => C * (Real.log X)^A / X^w) Filter.atTop (nhds 0) := by
          have := log_power_growth_vs_power_growth A w hA_pos left;
          simpa [ mul_div_assoc ] using this.const_mul C;
        exact h_lim.comp tendsto_natCast_atTop_atTop;
      have := h_lim.eventually ( gt_mem_nhds <| show 0 < c by positivity ) ; aesop;
      exact ⟨ X₀ + w_1 + 1, by linarith, by linarith, by have := h ( X₀ + w_1 + 1 ) ( by linarith ) ; rw [ div_lt_iff₀ ( by positivity ) ] at this; linarith ⟩;
    linarith [ abs_le.mp ( h_bound X₁ hX₁.2.1 ), h_spec X₁ hX₁.1 ]

/-
Corollary: TPC (Infinitely many twin primes)
-/
theorem twin_prime_conjecture (h_gap : ∃ δ > 0, spectral_gap δ) :
  ∀ N : ℕ, ∃ p > N, is_twin_prime p := by
    -- Since there are infinitely many twin primes, for any $N$, there are twin primes greater than $N$.
    have h_inf : Set.Infinite {p | is_twin_prime p} := by
      have h_inf : ¬ finite_twins := by
        exact?;
      contrapose! h_inf;
      rw [ Set.not_infinite ] at h_inf;
      exact ⟨ h_inf.toFinset.card, fun X => by exact le_trans ( Finset.card_le_card fun p hp => h_inf.mem_toFinset.mpr <| Finset.mem_filter.mp hp |>.2 ) ( by simpa ) ⟩;
    exact fun N => by cases' h_inf.exists_gt N with p hp; exact ⟨ p, hp.2, hp.1 ⟩ ;