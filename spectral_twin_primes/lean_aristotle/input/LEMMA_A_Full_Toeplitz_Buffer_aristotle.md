/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 648fb686-136c-4058-8c9a-00f5454cb317
-/

/-
We formalize Lemma A (Toeplitz Buffer Suppression) and its corollary.
Note that we interpret the Toeplitz bilinear form using integer differences `(j : ℤ) - k` rather than modular arithmetic `j - k` (which would correspond to a circulant matrix), as this is consistent with the standard definition of Toeplitz matrices and the separation condition provided.
The main result is `toeplitz_buffer_suppression_correct`, which bounds the bilinear form by the tail norm of the coefficients.
The corollary `tail_finite_of_decay` shows that the tail norm is finite if the coefficients decay quadratically.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Complex
#check (star : ℂ → ℂ)

open scoped BigOperators
open Complex Finset


variable {M : ℕ}

/-- Toeplitz matrix coefficients -/
structure ToeplitzCoeffs where
  coeff : ℤ → ℂ

/-- Tail norm of Fourier coefficients -/
noncomputable def tail_norm (A : ToeplitzCoeffs) (Δ : ℕ) : ℝ :=
  ∑' ℓ : ℤ, if Δ ≤ |ℓ| then ‖A.coeff ℓ‖ else 0

/-- Bilinear form from Toeplitz matrix -/
noncomputable def toeplitz_bilinear (A : ToeplitzCoeffs) (p q : Fin M → ℂ) : ℂ :=
  ∑ j : Fin M, ∑ k : Fin M, A.coeff (j - k) * p j * star (q k)

/-- Support of a vector -/
def support (p : Fin M → ℂ) : Finset (Fin M) :=
  Finset.filter (fun i => p i ≠ 0) Finset.univ

/-- Separation condition -/
def separated (I_maj I_min : Finset (Fin M)) (Δ : ℕ) : Prop :=
  ∀ j ∈ I_maj, ∀ k ∈ I_min, Δ ≤ |((j : ℤ) - k)|

/-- L2 norm of a vector -/
noncomputable def l2_norm (p : Fin M → ℂ) : ℝ := Real.sqrt (∑ i, ‖p i‖^2)

/-- Bilinear form from Toeplitz matrix (using integer difference) -/
noncomputable def toeplitz_bilinear_int (A : ToeplitzCoeffs) (p q : Fin M → ℂ) : ℂ :=
  ∑ j : Fin M, ∑ k : Fin M, A.coeff ((j : ℤ) - k) * p j * star (q k)

/-
Lemma A: The Toeplitz bilinear form restricted to separated supports is bounded by the tail norm of the coefficients times the L2 norms of the vectors.
-/
/-- LEMMA A: Toeplitz Buffer Suppression -/
theorem toeplitz_buffer_suppression_correct
    (A : ToeplitzCoeffs) (Δ : ℕ)
    (p_maj p_min : Fin M → ℂ)
    (I_maj I_min : Finset (Fin M))
    (h_supp_maj : support p_maj ⊆ I_maj)
    (h_supp_min : support p_min ⊆ I_min)
    (h_sep : separated I_maj I_min Δ)
    (h_summable : Summable (fun ℓ : ℤ => ‖A.coeff ℓ‖)) :
    ‖toeplitz_bilinear_int A p_maj p_min‖ ≤
      tail_norm A Δ * l2_norm p_maj * l2_norm p_min := by
  unfold toeplitz_bilinear_int tail_norm l2_norm;
  -- We can bound the absolute value of the sum by the sum of the absolute values.
  suffices h_abs : ‖∑ j : Fin M, ∑ k : Fin M, A.coeff ((j : ℤ) - k) * p_maj j * (star (p_min k))‖ ≤ ∑ ℓ ∈ Finset.image (fun (jk : Fin M × Fin M) => (jk.1 : ℤ) - jk.2) (Finset.univ : Finset (Fin M × Fin M)), (if Δ ≤ |ℓ| then ‖A.coeff ℓ‖ else 0) * ∑ j : Fin M, ∑ k : Fin M, (if (j : ℤ) - k = ℓ then ‖p_maj j‖ * ‖p_min k‖ else 0) by
    -- We can bound the inner sum by the product of the L2 norms of `p_maj` and `p_min`.
    have h_inner : ∀ ℓ : ℤ, ∑ j : Fin M, ∑ k : Fin M, (if (j : ℤ) - k = ℓ then ‖p_maj j‖ * ‖p_min k‖ else 0) ≤ Real.sqrt (∑ j : Fin M, ‖p_maj j‖ ^ 2) * Real.sqrt (∑ k : Fin M, ‖p_min k‖ ^ 2) := by
      intro ℓ
      have h_inner_sum : ∑ j : Fin M, ∑ k : Fin M, (if (j : ℤ) - k = ℓ then ‖p_maj j‖ * ‖p_min k‖ else 0) ≤ Real.sqrt (∑ j : Fin M, ‖p_maj j‖ ^ 2) * Real.sqrt (∑ k : Fin M, ‖p_min k‖ ^ 2) := by
        have h_inner_sum_sq : (∑ j : Fin M, ∑ k : Fin M, (if (j : ℤ) - k = ℓ then ‖p_maj j‖ * ‖p_min k‖ else 0))^2 ≤ (∑ j : Fin M, ‖p_maj j‖ ^ 2) * (∑ k : Fin M, ‖p_min k‖ ^ 2) := by
          -- We can bound the inner sum by the product of the L2 norms of `p_maj` and `p_min` using the Cauchy-Schwarz inequality.
          have h_inner_sum_sq : ∀ (u v : Fin M → ℝ), (∑ j : Fin M, ∑ k : Fin M, (if (j : ℤ) - k = ℓ then u j * v k else 0))^2 ≤ (∑ j : Fin M, u j^2) * (∑ k : Fin M, v k^2) := by
            intros u v
            have h_inner_sum_sq : (∑ j : Fin M, ∑ k : Fin M, (if (j : ℤ) - k = ℓ then u j * v k else 0))^2 ≤ (∑ j : Fin M, u j^2) * (∑ k : Fin M, v k^2) := by
              have h_inner_sum_sq : ∀ (u v : Fin M → ℝ), (∑ j : Fin M, ∑ k : Fin M, (if (j : ℤ) - k = ℓ then u j * v k else 0))^2 ≤ (∑ j : Fin M, ∑ k : Fin M, (if (j : ℤ) - k = ℓ then u j^2 else 0)) * (∑ j : Fin M, ∑ k : Fin M, (if (j : ℤ) - k = ℓ then v k^2 else 0)) := by
                intros u v
                have h_inner_sum_sq : ∀ (S : Finset (Fin M × Fin M)), (∑ p ∈ S, u p.1 * v p.2)^2 ≤ (∑ p ∈ S, u p.1^2) * (∑ p ∈ S, v p.2^2) := by
                  exact?;
                convert h_inner_sum_sq ( Finset.filter ( fun p : Fin M × Fin M => ( p.1 : ℤ ) - p.2 = ℓ ) ( Finset.univ : Finset ( Fin M × Fin M ) ) ) using 1 <;> simp +decide [ Finset.sum_filter ];
                · erw [ Finset.sum_product ];
                · erw [ Finset.sum_product, Finset.sum_product ]
              refine le_trans ( h_inner_sum_sq u v ) ?_;
              refine' mul_le_mul _ _ _ _;
              · norm_num [ Finset.sum_ite ];
                refine' Finset.sum_le_sum fun i _ => mul_le_of_le_one_left ( sq_nonneg _ ) _;
                norm_cast;
                exact Finset.card_le_one.mpr fun x hx y hy => Fin.ext <| by norm_num [ Int.subNatNat_eq_coe ] at hx hy; linarith;
              · rw [ Finset.sum_comm ];
                norm_num [ Finset.sum_ite ];
                refine' Finset.sum_le_sum fun i _ => mul_le_of_le_one_left ( sq_nonneg _ ) _;
                norm_cast;
                exact Finset.card_le_one.mpr fun x hx y hy => Fin.ext <| by norm_num [ Int.subNatNat_eq_coe ] at hx hy; linarith;
              · exact Finset.sum_nonneg fun _ _ => Finset.sum_nonneg fun _ _ => by split_ifs <;> positivity;
              · exact Finset.sum_nonneg fun _ _ => sq_nonneg _;
            exact h_inner_sum_sq;
          exact h_inner_sum_sq _ _
        simpa only [ ← Real.sqrt_mul ( Finset.sum_nonneg fun _ _ => sq_nonneg _ ) ] using Real.le_sqrt_of_sq_le h_inner_sum_sq;
      convert h_inner_sum using 1;
    refine le_trans h_abs ?_;
    refine' le_trans ( Finset.sum_le_sum fun ℓ hℓ => mul_le_mul_of_nonneg_left ( h_inner ℓ ) <| by positivity ) _;
    rw [ ← Finset.sum_mul _ _ _ ];
    rw [ mul_assoc ];
    refine' mul_le_mul_of_nonneg_right _ ( mul_nonneg ( Real.sqrt_nonneg _ ) ( Real.sqrt_nonneg _ ) );
    refine' sum_le_tsum _ _ _;
    · exact fun _ _ => by positivity;
    · exact Summable.of_nonneg_of_le ( fun _ => by positivity ) ( fun _ => by split_ifs <;> norm_num ) h_summable;
  have h_abs : ‖∑ j : Fin M, ∑ k : Fin M, A.coeff ((j : ℤ) - k) * p_maj j * (star (p_min k))‖ ≤ ∑ j : Fin M, ∑ k : Fin M, ‖A.coeff ((j : ℤ) - k)‖ * ‖p_maj j‖ * ‖p_min k‖ * (if Δ ≤ |(j : ℤ) - k| then 1 else 0) := by
    refine' le_trans ( norm_sum_le _ _ ) ( Finset.sum_le_sum fun i hi => le_trans ( norm_sum_le _ _ ) _ );
    gcongr ; aesop;
    contrapose! h_sep;
    bound;
    exact absurd ( a i ( h_supp_maj <| by unfold support; aesop ) i_1 ( h_supp_min <| by unfold support; aesop ) ) ( by norm_num; linarith );
  convert h_abs using 1;
  simp +decide [ Finset.sum_image', mul_assoc ];
  rw [ Finset.sum_image' ];
  rotate_left;
  use fun x => if Δ ≤ |(x.1 : ℤ) - x.2| then ‖A.coeff ((x.1 : ℤ) - x.2)‖ * ‖p_maj x.1‖ * ‖p_min x.2‖ else 0;
  · simp +decide [ Finset.sum_ite, Finset.mul_sum _ _ _ ];
    intro a b; split_ifs <;> simp +decide [ *, mul_assoc, Finset.sum_filter ] ;
    · erw [ Finset.sum_product ] ; congr ; ext ; aesop;
    · rw [ Finset.sum_eq_zero ] ; aesop;
  · erw [ Finset.sum_product ] ; ac_rfl

/-
If the Fourier coefficients decay as 1/k^2, then the sum of their norms converges.
-/
/-- Corollary: If Fourier coefficients decay as 1/k², tail is finite -/
theorem tail_finite_of_decay
    (A : ToeplitzCoeffs) (C : ℝ) (hC : C > 0)
    (h_decay : ∀ k : ℤ, k ≠ 0 → ‖A.coeff k‖ ≤ C / (k : ℝ)^2) :
    Summable (fun ℓ : ℤ => ‖A.coeff ℓ‖) := by
  -- We can decompose the sum into the term at `ℓ = 0` and the sum over `ℓ ≠ 0`.
  have h_decomp : Summable (fun ℓ : ℤ => ‖A.coeff ℓ‖) ↔ Summable (fun ℓ : ℤ => if ℓ = 0 then ‖A.coeff 0‖ else 0) ∧ Summable (fun ℓ : ℤ => if ℓ ≠ 0 then ‖A.coeff ℓ‖ else 0) := by
    exact ⟨ fun h => ⟨ h.of_nonneg_of_le ( fun ℓ => by positivity ) fun ℓ => by aesop, h.of_nonneg_of_le ( fun ℓ => by positivity ) fun ℓ => by aesop ⟩, fun h => by convert h.1.add h.2 using 1 ; ext ℓ ; aesop ⟩;
  refine h_decomp.mpr ⟨ ?_, ?_ ⟩;
  · exact ⟨ _, hasSum_single 0 <| by aesop ⟩;
  · have h_summable : Summable (fun ℓ : ℤ => C / (ℓ : ℝ) ^ 2) := by
      exact Summable.mul_left _ <| by simpa using Real.summable_one_div_int_pow.2 one_lt_two;
    exact Summable.of_nonneg_of_le ( fun ℓ => by positivity ) ( fun ℓ => by aesop ) h_summable