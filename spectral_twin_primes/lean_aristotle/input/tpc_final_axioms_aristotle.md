/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9ba5988c-736f-4763-84c6-fe1ff97f62f5

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check ArithmeticFunction.vonMangoldt
#check ZMod.χ₄

/-
Definitions of e(x), f(n), S₂(X), T_χ(X), F_X(α), θ(X), E(n), and bad_set(X).
-/
open Nat Real Complex BigOperators

noncomputable def e (x : ℝ) : ℂ := Complex.exp (2 * Real.pi * Complex.I * x)

noncomputable def f (n : ℕ) : ℝ := ArithmeticFunction.vonMangoldt n * (ZMod.χ₄ n : ℝ)

noncomputable def S₂ (X : ℝ) : ℝ := Finset.sum (Finset.range (Nat.floor X + 1)) (fun n => ArithmeticFunction.vonMangoldt n * ArithmeticFunction.vonMangoldt (n + 2))

noncomputable def T_χ (X : ℝ) : ℝ := Finset.sum (Finset.range (Nat.floor X + 1)) (fun n => f n * f (n + 2))

noncomputable def F_X (X : ℝ) (α : ℝ) : ℂ := Finset.sum ((Finset.range (Nat.floor X + 1)).filter Nat.Prime) (fun p => (Real.log p : ℂ) * (ZMod.χ₄ p : ℂ) * e (p * α))

noncomputable def θ (X : ℝ) : ℝ := Finset.sum ((Finset.range (Nat.floor X + 1)).filter Nat.Prime) (fun p => Real.log p)

noncomputable def E_term (n : ℕ) : ℝ := f n * f (n + 2) + ArithmeticFunction.vonMangoldt n * ArithmeticFunction.vonMangoldt (n + 2)

noncomputable def bad_set (X : ℝ) : Finset ℕ := (Finset.range (Nat.floor X + 1)).filter (fun n => E_term n ≠ 0)

/-
Axiom 1: AFM Structure. For any odd prime p > 2 such that p+2 is also prime, χ₄(p) · χ₄(p+2) = -1.
-/
theorem axiom1 (p : ℕ) (hp : p.Prime) (hp_odd : p > 2) (hp2 : (p + 2).Prime) :
  (ZMod.χ₄ p : ℝ) * (ZMod.χ₄ (p + 2) : ℝ) = -1 := by
    have := Nat.Prime.eq_two_or_odd hp ; ( have := Nat.Prime.eq_two_or_odd hp2 ; aesop );
    · rw [ ZMod.natCast_eq_zero_iff ] at heq ; have := Nat.Prime.eq_two_or_odd hp ; simp_all +decide [ Nat.dvd_prime ];
      aesop;
    · have := Nat.Prime.eq_two_or_odd hp2; simp_all +decide [ ZMod, Nat.add_mod ];
      erw [ Fin.ext_iff ] at heq ; norm_num [ Nat.add_mod ] at heq ; omega;
    · cases heq_1;
    · cases heq_1;
    · cases heq_1

/-
Axiom 2: Term-wise Identity. For twin primes n > 2, f(n) · f(n+2) = -Λ(n) · Λ(n+2).
-/
theorem axiom2 (n : ℕ) (hn : n > 2) (hp : n.Prime) (hp2 : (n + 2).Prime) :
  f n * f (n + 2) = -ArithmeticFunction.vonMangoldt n * ArithmeticFunction.vonMangoldt (n + 2) := by
    unfold f;
    have := axiom1 n hp hn hp2; ring_nf at *; aesop;

/-
Axiom 3: Resonance Identity. For any odd natural number n, χ₄(n) · e(n/4) = i.
-/
theorem axiom3 (n : ℕ) (hn : Odd n) :
  (ZMod.χ₄ n : ℂ) * e ((n : ℝ) / 4) = Complex.I := by
    cases hn ; aesop;
    · norm_cast at heq;
      erw [ ZMod.natCast_eq_zero_iff ] at heq ; exact absurd ( congr_arg ( · % 2 ) heq.choose_spec ) ( by norm_num [ Nat.add_mod, Nat.mul_mod ] );
    · replace heq := congr_arg ( fun x => x.val ) heq ; norm_num [ ZMod.val_add, ZMod.val_mul ] at heq;
      erw [ ZMod.val_natCast, ZMod.val_natCast ] at heq ; norm_num at heq ; omega;
    · unfold e;
      rw [ Complex.exp_eq_exp_re_mul_sin_add_cos ] ; norm_num ; ring_nf ; norm_num [ mul_div ];
      norm_cast ; norm_num [ mul_comm Real.pi, Real.cos_add, Real.sin_add ];
      rcases Nat.even_or_odd' w with ⟨ k, rfl | rfl ⟩ <;> norm_num [ add_mul, mul_assoc, mul_left_comm ] at *;
      · exact Complex.cos_nat_mul_two_pi k ▸ by ring;
      · norm_cast at *;
        erw [ ZMod.natCast_eq_zero_iff ] at heq ; obtain ⟨ m, hm ⟩ := heq ; replace hm := congr_arg ( · % 4 ) hm ; ring_nf at hm ; norm_num [ Nat.add_mod, Nat.mul_mod ] at hm;
    · -- Since $2w + 1 \equiv 3 \pmod{4}$, we have $w \equiv 1 \pmod{2}$, so $w = 2k + 1$ for some integer $k$.
      obtain ⟨k, rfl⟩ : ∃ k : ℕ, w = 2 * k + 1 := by
        rcases Nat.even_or_odd' w with ⟨ k, rfl | rfl ⟩ <;> ring_nf at * <;> simp_all +decide;
        simp_all +decide [ mul_assoc, ZMod ];
      unfold e; ring_nf; norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im ] ; ring;
      norm_num [ mul_assoc, mul_comm Real.pi _, mul_div ];
      norm_num [ show 3 / 2 * Real.pi = Real.pi + Real.pi / 2 by ring, Real.cos_add, Real.sin_add ]

/-
Axiom 4: Peak Value Formula. For X ≥ 2, F_X(1/4) = i · (θ(X) - log(2)).
-/
theorem axiom4 (X : ℝ) (hX : X ≥ 2) :
  F_X X (1/4) = Complex.I * (θ X - Real.log 2) := by
    unfold F_X θ;
    have h_subst : ∀ p : ℕ, p.Prime → p ≠ 2 → (ZMod.χ₄ p : ℂ) * e (p / 4) = Complex.I := by
      intro p hp hp2
      have h_odd_p : Odd p := by
        exact hp.odd_of_ne_two hp2;
      convert axiom3 p h_odd_p using 1;
    have h_split : ∑ p ∈ Finset.filter Nat.Prime (Finset.range (Nat.floor X + 1)), (Real.log p : ℂ) * (ZMod.χ₄ p : ℂ) * e (p * (1 / 4)) = ∑ p ∈ Finset.filter Nat.Prime (Finset.range (Nat.floor X + 1)) \ {2}, (Real.log p : ℂ) * Complex.I + (Real.log 2 : ℂ) * (ZMod.χ₄ 2 : ℂ) * e (2 * (1 / 4)) := by
      rw [ Finset.sum_eq_sum_diff_singleton_add ( show 2 ∈ Finset.filter Nat.Prime ( Finset.range ( ⌊X⌋₊ + 1 ) ) from Finset.mem_filter.mpr ⟨ Finset.mem_range.mpr ( Nat.lt_succ_of_le ( Nat.le_floor ( by norm_num; linarith ) ) ), by norm_num ⟩ ) ];
      exact congrArg₂ ( · + · ) ( Finset.sum_congr rfl fun p hp => by rw [ mul_assoc, ← h_subst p ( Finset.mem_filter.mp ( Finset.mem_sdiff.mp hp |>.1 ) |>.2 ) ( by aesop ) ] ; ring ) rfl;
    simp_all +decide [ Finset.sum_mul _ _ _, mul_comm ];
    rw [ Finset.sum_eq_sum_diff_singleton_add ( show 2 ∈ Finset.filter Nat.Prime ( Finset.range ( ⌊X⌋₊ + 1 ) ) from Finset.mem_filter.mpr ⟨ Finset.mem_range.mpr ( Nat.lt_succ_of_le ( Nat.le_floor ( by norm_num; linarith ) ) ), Nat.prime_two ⟩ ) ] ; norm_num [ Finset.mul_sum _ _ _, mul_sub ];
    exact Or.inr <| Or.inr rfl

/-
Axiom 5: Phase at Quarter. e(-1/2) = -1.
-/
theorem axiom5 : e (-1/2) = -1 := by
  unfold e; norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im ] ;
  norm_num [ mul_div ]

/-
Axiom 6: Main Term Sign. |F_X(1/4)|² · e(-1/2) = -|F_X(1/4)|². Using normSq to avoid potential ambiguity with abs.
-/
theorem axiom6 (X : ℝ) :
  Complex.normSq (F_X X (1/4)) * e (-1/2) = -Complex.normSq (F_X X (1/4)) := by
    rw [ show e ( -1 / 2 : ℝ ) = -1 by exact? ] ; ring

open Asymptotics Filter

#check IsBigO
#check atTop

/-
Defining the statements of Axioms 7, 8, 9, and 10 as predicates, and bundling them into a class AFM_Context. Explicitly typing X as Real to avoid ambiguity.
-/
def Axiom7_Stmt : Prop := (fun X => ‖F_X X (1/4)‖ - X) =O[atTop] (fun X => X / Real.log X)

def Axiom8_Stmt : Prop := (∀ X : ℝ, X ≥ 1 → ((Finset.range (Nat.floor X + 1)).filter (fun n => ∃ p, Nat.Prime p ∧ n = p^2)).card ≤ Real.sqrt X) ∧ (∀ X : ℝ, X ≥ 1 → ∀ k : ℕ, k ≥ 1 → ((Finset.range (Nat.floor X + 1)).filter (fun n => ∃ p, Nat.Prime p ∧ n = p^k)).card ≤ X ^ ((1 : ℝ) / k))

def Axiom9_Stmt : Prop := ∀ n, E_term n ≠ 0 → n = 2 ∨ (∃ p k, Nat.Prime p ∧ k ≥ 2 ∧ n = p^k) ∨ (∃ p k, Nat.Prime p ∧ k ≥ 2 ∧ n + 2 = p^k)

def Axiom10_Stmt : Prop := (fun X => ((bad_set X).card : ℝ)) =O[atTop] (fun X => Real.sqrt X)

class AFM_Context where
  ax7 : Axiom7_Stmt
  ax8 : Axiom8_Stmt
  ax9 : Axiom9_Stmt
  ax10 : Axiom10_Stmt

/-
Statements for Theorem A, Theorem B, Theorem C, and the Final Goal.
-/
def TheoremA_Stmt : Prop := (fun X => T_χ X + S₂ X) =O[atTop] (fun X => Real.sqrt X * (Real.log X)^2)

def TheoremB_Stmt : Prop := ∃ c > 0, ∀ᶠ X in atTop, |T_χ X| ≥ c * X

def TheoremC_Stmt : Prop := Filter.Tendsto S₂ atTop atTop

def FinalGoal_Stmt : Prop := { p : ℕ | p.Prime ∧ (p + 2).Prime }.Infinite

/-
Lemma A1: T_χ(X) + S₂(X) is equal to the sum of E(n) over the bad set.
-/
theorem LemmaA1 (X : ℝ) :
  T_χ X + S₂ X = ∑ n ∈ bad_set X, E_term n := by
    unfold bad_set E_term T_χ S₂;
    rw [ ← Finset.sum_add_distrib, Finset.sum_filter_of_ne ] ; aesop

/-
Lemma A2: |E(n)| ≤ 2 log(n) log(n+2).
Proof:
|E(n)| = |f(n)f(n+2) + Λ(n)Λ(n+2)|
       ≤ |f(n)f(n+2)| + |Λ(n)Λ(n+2)|
       = |Λ(n)χ₄(n)Λ(n+2)χ₄(n+2)| + Λ(n)Λ(n+2)
       = Λ(n)Λ(n+2)|χ₄(n)||χ₄(n+2)| + Λ(n)Λ(n+2)
       ≤ Λ(n)Λ(n+2) + Λ(n)Λ(n+2)
       = 2 Λ(n)Λ(n+2)
       ≤ 2 log(n) log(n+2).
-/
theorem LemmaA2 (n : ℕ) : |E_term n| ≤ 2 * Real.log n * Real.log (n + 2) := by
  unfold E_term; norm_cast; aesop;
  -- Since $|f(n)| \leq \Lambda(n)$ and $|f(n+2)| \leq \Lambda(n+2)$, we have $|f(n) * f(n+2)| \leq \Lambda(n) * \Lambda(n+2)$.
  have h_abs : |f n * f (n + 2)| ≤ (ArithmeticFunction.vonMangoldt n) * (ArithmeticFunction.vonMangoldt (n + 2)) := by
    -- Since $|\chi_4(n)| \leq 1$ for all $n$, we have $|f(n)| \leq \Lambda(n)$.
    have h_abs_f : ∀ n, |f n| ≤ ArithmeticFunction.vonMangoldt n := by
      intro n; unfold f; aesop;
      · rw [ abs_of_nonneg ( ArithmeticFunction.vonMangoldt_nonneg ) ];
      · rw [ abs_of_nonneg ( by exact? ) ];
    simpa only [ abs_mul ] using mul_le_mul ( h_abs_f n ) ( h_abs_f ( n + 2 ) ) ( by positivity ) ( by exact le_trans ( by positivity ) ( h_abs_f n ) );
  -- Also, $\Lambda(n) \leq \log(n)$ and $\Lambda(n+2) \leq \log(n+2)$.
  have h_lam_le_log : (ArithmeticFunction.vonMangoldt n) ≤ Real.log n ∧ (ArithmeticFunction.vonMangoldt (n + 2)) ≤ Real.log (n + 2) := by
    aesop;
    · exact?;
    · rw [ ArithmeticFunction.vonMangoldt ] ; aesop;
      · exact Real.log_le_log ( Nat.cast_pos.mpr ( Nat.minFac_pos _ ) ) ( mod_cast Nat.le_of_dvd ( Nat.succ_pos _ ) ( Nat.minFac_dvd _ ) );
      · exact Real.log_nonneg ( by linarith );
  rw [ abs_le ];
  constructor <;> nlinarith [ abs_le.mp h_abs, show 0 ≤ ( ArithmeticFunction.vonMangoldt n ) from by exact ( by rw [ ArithmeticFunction.vonMangoldt_apply ] ; positivity ), show 0 ≤ ( ArithmeticFunction.vonMangoldt ( n + 2 ) ) from by exact ( by rw [ ArithmeticFunction.vonMangoldt_apply ] ; positivity ) ]

/-
Lemma A3: For n in the bad set of X, |E(n)| is bounded by 2 log²(X+2).
-/
theorem LemmaA3 (X : ℝ) (hX : X ≥ 2) :
  ∀ n ∈ bad_set X, |E_term n| ≤ 2 * (Real.log (X + 2))^2 := by
    aesop;
    -- Apply Lemma A2 and the fact that $n \leq X$.
    have h_le : |E_term n| ≤ 2 * Real.log n * Real.log (n + 2) := by
      exact?;
    refine le_trans h_le ?_;
    rw [ pow_two ];
    rw [ mul_assoc ];
    gcongr;
    · exact Real.log_nonneg ( by linarith );
    · exact Real.log_nonneg ( by linarith );
    · contrapose! a; aesop;
      unfold bad_set at a; aesop;
    · exact le_trans ( Nat.cast_le.mpr ( Finset.mem_range_succ_iff.mp ( Finset.mem_filter.mp a |>.1 ) ) ) ( by linarith [ Nat.floor_le ( show 0 ≤ X by linarith ) ] );
    · exact le_trans ( Nat.cast_le.mpr ( Finset.mem_range_succ_iff.mp ( Finset.mem_filter.mp a |>.1 ) ) ) ( Nat.floor_le ( by positivity ) )

/-
Lemma: log²(X+2) = O(log² X) as X → ∞.
-/
lemma log_sq_shift : (fun X => (Real.log (X + 2))^2) =O[atTop] (fun X => (Real.log X)^2) := by
  rw [ Asymptotics.isBigO_iff ];
  norm_num;
  -- We can choose $c = 4$ and $a = 2$.
  use 4, 2;
  intro b hb
  have h_log : Real.log (b + 2) ≤ 2 * Real.log b := by
    rw [ ← Real.log_rpow, Real.log_le_log_iff ] <;> norm_num <;> nlinarith;
  nlinarith [ Real.log_nonneg ( by linarith : ( b + 2 ) ≥ 1 ) ]

/-
Lemma A4: The absolute value of the sum of E(n) over the bad set is bounded by the cardinality of the bad set times the bound for individual terms.
-/
theorem LemmaA4 (X : ℝ) (hX : X ≥ 2) :
  |∑ n ∈ bad_set X, E_term n| ≤ (bad_set X).card * (2 * (Real.log (X + 2))^2) := by
    exact le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( le_trans ( Finset.sum_le_sum fun x hx => LemmaA3 X hX x hx ) ( by simp +decide [ mul_assoc ] ) )

/-
Lemma A5: The bound on the error sum is O(√X log² X).
Proof:
We know (bad_set X).card = O(√X) from Axiom 10.
We know log²(X+2) = O(log² X) from log_sq_shift.
The product of Big O is Big O of the product.
So (bad_set X).card * 2 * log²(X+2) = O(√X * log² X).
-/
theorem LemmaA5 [AFM_Context] :
  (fun X => ((bad_set X).card : ℝ) * (2 * (Real.log (X + 2))^2)) =O[atTop] (fun X => Real.sqrt X * (Real.log X)^2) := by
    have := ‹AFM_Context›.ax10;
    -- Apply the lemma about the product of Big O terms.
    have h_prod : (fun X => ((bad_set X).card : ℝ)) =O[atTop] (fun X => Real.sqrt X) ∧ (fun X => (Real.log (X + 2))^2) =O[atTop] (fun X => (Real.log X)^2) := by
      exact ⟨ this, log_sq_shift ⟩;
    -- Apply the lemma about the product of Big O terms to combine the two bounds.
    have h_combined : (fun X => ((bad_set X).card : ℝ) * (Real.log (X + 2))^2) =O[atTop] (fun X => (Real.sqrt X) * (Real.log X)^2) := by
      exact h_prod.1.mul h_prod.2;
    convert h_combined.const_mul_left 2 using 2 ; ring