/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 112ce0ff-2aae-4704-9f2d-bf54561c248a

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions of spectral coordinates, index set I_K, and the heat kernel.
-/
open Real Complex Set MeasureTheory Filter Topology

variable (t K : ℝ)

/-- Spectral coordinates: α_n = log(n)/(2π) -/
def alpha (n : ℕ) : ℝ := Real.log n / (2 * Real.pi)

/-- Index set I_K = {n : α_n ∈ [-K, K]} -/
def I_K : Set ℕ := {n | alpha n ∈ Icc (-K) K}

/-- The heat kernel K_t(x, y) = (2πt)^{1/2} exp(-(x-y)²/(4t)) -/
def heat_kernel (x y : ℝ) : ℝ := (2 * Real.pi * t).sqrt * Real.exp (-(x - y)^2 / (4 * t))

/-- The kernel function k_{α_n} as a function of x -/
def k_alpha (n : ℕ) (x : ℝ) : ℝ := heat_kernel t x (alpha n)

/-
I_K is finite.
-/
lemma I_K_finite (hK : 0 < K) : (I_K K).Finite := by
  -- We'll use that $I_K$ is finite by definition.
  unfold I_K;
  unfold alpha;
  exact Set.finite_iff_bddAbove.mpr ⟨ ⌊Real.exp ( K * ( 2 * Real.pi ) ) ⌋₊, fun n hn => Nat.le_floor <| le_of_not_gt fun hn' => by have := hn.2; rw [ div_le_iff₀ ( by positivity ) ] at this; linarith [ Real.log_exp ( K * ( 2 * Real.pi ) ), Real.log_lt_log ( by positivity ) hn' ] ⟩

/-
V_K is the span of kernel vectors. It is finite dimensional.
-/
variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]

/-- V_K = span{k_{α_n} : n ∈ I_K}
    We explicitly pass the kernel function k : ℝ → H and the parameters t, K. -/
def V_K (t K : ℝ) (k : ℝ → H) : Submodule ℂ H :=
  Submodule.span ℂ {k (alpha n) | n ∈ I_K K}

/-- Dimension of V_K is finite -/
lemma dim_V_K_finite (t K : ℝ) (k : ℝ → H) (hK : 0 < K) :
  Module.Finite ℂ (V_K t K k) := by
    -- By definition of $I_K$, we know that $I_K K$ is finite.
    have h_finite_IK : Set.Finite (I_K K) := by
      exact?;
    have h_subspace : V_K t K k = Submodule.span ℂ (Set.image (fun n : ℕ => k (alpha n)) (I_K K)) := by
      exact?;
    exact h_subspace ▸ Module.Finite.span_of_finite _ ( h_finite_IK.image _ )

/-
Definitions of prime weights and rank-one operator.
-/
open Nat ArithmeticFunction

/-- Prime weight w_n = Λ(n)/√n -/
noncomputable def v_weight (n : ℕ) : ℝ := vonMangoldt n / Real.sqrt n

/-- Rank-one operator |u⟩⟨v| : x ↦ ⟪v, x⟫ • u -/
noncomputable def rankOne {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] (u v : H) : H →L[ℂ] H :=
  ContinuousLinearMap.smulRight (innerSL ℂ v) u

/-
Definitions of Prime operator T_P, Hamiltonian H, Major/Minor cores, and index sets.
-/
open BigOperators Finset

variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]

/-- The Prime operator T_P restricted to I_K
    T_P = Σ_{p ∈ I_K, p prime} w_p · |k_{α_p}⟩⟨k_{α_p}| -/
noncomputable def T_P (t K : ℝ) (k : ℝ → H) (hK : 0 < K) : H →L[ℂ] H :=
  Finset.sum (I_K_finite K hK).toFinset
    (fun n => if n.Prime then (v_weight n : ℂ) • rankOne (k (alpha n)) (k (alpha n)) else 0)

/-- Q3 Hamiltonian: H = T_A - T_P -/
noncomputable def Hamiltonian (t K : ℝ) (k : ℝ → H) (T_A : H →L[ℂ] H) (hK : 0 < K) : H →L[ℂ] H :=
  T_A - T_P t K k hK

variable (D : ℝ)

/-- Major core: M ⊂ [-K, K] (neighborhood of "resonances") -/
def MajorCore (M : Set ℝ) : Prop := M ⊆ Icc (-K) K

/-- Minor core: m = {x ∈ [-K, K] : dist(x, M) ≥ D} -/
def MinorCore (M : Set ℝ) : Set ℝ := {x ∈ Icc (-K) K | ∀ y ∈ M, |x - y| ≥ D}

/-- Index set I_M = {n ∈ I_K : α_n ∈ M} -/
def I_M (M : Set ℝ) : Set ℕ := {n ∈ I_K K | alpha n ∈ M}

/-- Index set I_m = {n ∈ I_K : α_n ∈ m} -/
def I_m (M : Set ℝ) : Set ℕ := {n ∈ I_K K | alpha n ∈ MinorCore K D M}

/-
Definitions of vectors v, v_M, v_m. Theorem 2: v_m is in V_K.
-/
open BigOperators Finset Submodule

variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]

/-- The full prime weight vector v = Σ_{n ∈ I_K} w_n · k_{α_n} -/
noncomputable def vec_v (t K : ℝ) (k : ℝ → H) (hK : 0 < K) : H :=
  ∑ n ∈ (I_K_finite K hK).toFinset, (v_weight n : ℂ) • k (alpha n)

/-- The major part v_M = Σ_{n ∈ I_M} w_n · k_{α_n} -/
noncomputable def vec_v_M (t K : ℝ) (k : ℝ → H) (M : Set ℝ) (hK : 0 < K) : H :=
  ∑ n ∈ (I_K_finite K hK).toFinset.filter (fun n => alpha n ∈ M), (v_weight n : ℂ) • k (alpha n)

/-- The minor part v_m = Σ_{n ∈ I_m} w_n · k_{α_n} -/
noncomputable def vec_v_m (t K D : ℝ) (k : ℝ → H) (M : Set ℝ) (hK : 0 < K) : H :=
  ∑ n ∈ (I_K_finite K hK).toFinset.filter (fun n => alpha n ∈ MinorCore K D M), (v_weight n : ℂ) • k (alpha n)

/-- Theorem 2: v_m ∈ V_K -/
theorem v_m_in_V_K (t K D : ℝ) (k : ℝ → H) (M : Set ℝ) (hK : 0 < K) :
  vec_v_m t K D k M hK ∈ V_K t K k := by
    exact Submodule.sum_mem _ fun n hn => Submodule.smul_mem _ _ ( Submodule.subset_span ( by aesop ) )

/-
Definition of V_M.
-/
open Complex InnerProductSpace Submodule

/-- V_M = span{k_{α_n} : n ∈ I_M} -/
def V_M {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    (t K : ℝ) (k : ℝ → H) (M : Set ℝ) : Submodule ℂ H :=
  Submodule.span ℂ (Set.image (fun n => k (alpha n)) (I_M K M))

/-
Definition of Proj.
-/
open Complex InnerProductSpace Submodule

/-- Projection operator onto a complete subspace -/
noncomputable def Proj {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    (U : Submodule ℂ H) [CompleteSpace U] : H →L[ℂ] H :=
  U.subtypeL.comp (orthogonalProjection U)

/-
Definition of V_m.
-/
open Complex InnerProductSpace Submodule

/-- V_m = span{k_{α_n} : n ∈ I_m} -/
def V_m {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    (t K D : ℝ) (k : ℝ → H) (M : Set ℝ) : Submodule ℂ H :=
  Submodule.span ℂ (Set.image (fun n => k (alpha n)) (I_m K D M))

/-
Simplified definition of Q3 Spectral Gap.
-/
open Complex InnerProductSpace Submodule

/-- Axiom (from Q3 paper): Spectral Gap -/
def Q3_Spectral_Gap {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    (t K : ℝ) (k : ℝ → H) (T_A : H →L[ℂ] H) (hK : 0 < K) (c₀ : ℝ → ℝ) : Prop :=
  True

/-
Definitions of delta_K and w_max.
-/
open Real Set

variable (t K : ℝ)

/-- Minimum separation between spectral nodes: δ_K = min |α_n - α_m| for n ≠ m in I_K -/
noncomputable def delta_K (K : ℝ) : ℝ :=
  sInf { |alpha n - alpha m| | (n ∈ I_K K) (m ∈ I_K K) (h : n ≠ m) }

/-- Maximum weight: w_max = max |w_n| for n in I_K -/
noncomputable def w_max (K : ℝ) : ℝ :=
  sSup { |v_weight n| | n ∈ I_K K }

/-
Definition of H_mM.
-/
open Complex InnerProductSpace Submodule

universe u

/-- H_mM = P_m ∘ H ∘ P_M
    Maps V_M to V_m (conceptually), but formally H → H. -/
noncomputable def H_mM {H : Type u} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    (t K D : ℝ) (k : ℝ → H) (T_A : H →L[ℂ] H) (hK : 0 < K) (M : Set ℝ)
    [CompleteSpace (V_M t K k M)] [CompleteSpace (V_m t K D k M)] : H →L[ℂ] H :=
  (Proj (V_m t K D k M)) ∘L (Hamiltonian t K k T_A hK) ∘L (Proj (V_M t K k M))

/-
Checking V_M, V_m, Proj.
-/
#check @V_M
#check @V_m
#check @Proj

/-
Definition of S_bound.
-/
open Real

/-- The bound function S(t; D) -/
noncomputable def S_bound (t K D : ℝ) : ℝ :=
  2 * Real.exp (-D^2 / (4 * t)) / (1 - Real.exp (-(delta_K K)^2 / (4 * t)))

/-
Statement of Buffer Suppression Lemma.
-/
open Complex InnerProductSpace Submodule

/-- Statement of Theorem 4 (Buffer Suppression Lemma) -/
def Buffer_Suppression_Statement {H : Type*} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    (t K D : ℝ) (k : ℝ → H) (T_A : H →L[ℂ] H) (hK : 0 < K) (M : Set ℝ)
    [CompleteSpace (V_M t K k M)] [CompleteSpace (V_m t K D k M)] : Prop :=
  ‖H_mM t K D k T_A hK M‖ ≤ w_max K * S_bound t K D

/-
Checking H_mM.
-/
#check @H_mM

/-
Definition of K_of_X.
-/
open Real

/-- Relation between K and X: K = log X / (2π) -/
noncomputable def K_of_X (X : ℝ) : ℝ := Real.log X / (2 * Real.pi)

/-
Lemma: K is positive for X > 1.
-/
lemma K_pos (X : ℝ) (h : 1 < X) : 0 < K_of_X X := by
  exact div_pos ( Real.log_pos h ) ( by positivity )

/-
I_K is finite for all K.
-/
/-- I_K is finite for any K -/
lemma I_K_finite_all (K : ℝ) : (I_K K).Finite := by
  -- The set of natural numbers n such that |log(n)/(2π)| ≤ K is finite because log(n) grows without bound as n increases.
  have h_finite : {n : ℕ | |Real.log n / (2 * Real.pi)| ≤ K}.Finite := by
    -- Since $\log(n)$ grows without bound, there exists an $N$ such that for all $n \geq N$, $\log(n) > 2\pi K$.
    obtain ⟨N, hN⟩ : ∃ N : ℕ, ∀ n ≥ N, Real.log n > 2 * Real.pi * K := by
      exact ⟨ ⌊Real.exp ( 2 * Real.pi * K ) ⌋₊ + 1, fun n hn => by simpa using Real.log_lt_log ( by positivity ) ( Nat.lt_of_floor_lt hn ) ⟩;
    exact Set.finite_iff_bddAbove.2 ⟨ N, fun n hn => not_lt.1 fun contra => absurd ( hn.out ) ( by rw [ abs_le ] ; exact fun h => by nlinarith [ hN n contra.le, Real.pi_pos, mul_div_cancel₀ ( Real.log n ) ( by positivity : ( 2 * Real.pi ) ≠ 0 ) ] ) ⟩;
  refine h_finite.subset fun x hx => ?_;
  unfold I_K at hx; aesop;
  exact abs_le.mpr ⟨ by unfold alpha at *; linarith, by unfold alpha at *; linarith ⟩