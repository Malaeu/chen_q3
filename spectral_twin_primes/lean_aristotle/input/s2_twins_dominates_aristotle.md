/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 2a5ed547-8265-4816-8619-98f4c7cc4df2

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Verify that the library's von Mangoldt function matches the user's definition.
-/
open ArithmeticFunction
open BigOperators

-- We use the library's von Mangoldt function Λ
-- Verify it matches the user's definition
theorem Λ_eq_user_def (n : ℕ) :
    Λ n = if ∃ p k, Nat.Prime p ∧ k ≥ 1 ∧ n = p^k then Real.log (n.minFac) else 0 := by
      -- By definition of Λ, we know that Λ(n) = log(p) if n is a prime power and 0 otherwise.
      simp [ArithmeticFunction.vonMangoldt];
      bound;
      · simp_all +decide [ isPrimePow_nat_iff ];
        grind;
      · exact False.elim <| h <| left.isPrimePow.pow <| by linarith;

/-
Define S₂, S₂_twins, S₂_rest, is_higher_prime_power, and prime_power_count.
-/
noncomputable def S₂ (X : ℕ) : ℝ := ∑ n ∈ Finset.range X, Λ n * Λ (n + 2)

noncomputable def S₂_twins (X : ℕ) : ℝ :=
  ∑ p ∈ Finset.filter (fun p => Nat.Prime p ∧ Nat.Prime (p + 2)) (Finset.range X),
    Λ p * Λ (p + 2)

noncomputable def S₂_rest (X : ℕ) : ℝ := S₂ X - S₂_twins X

def is_higher_prime_power (n : ℕ) : Prop :=
  ∃ p k, Nat.Prime p ∧ k ≥ 2 ∧ n = p^k

noncomputable def prime_power_count (X : ℕ) : ℕ :=
  (Finset.range (X + 1)).filter is_higher_prime_power |>.card

/-
Decompose prime_power_count into a sum over exponents k.
-/
def count_prime_powers_with_exp (X k : ℕ) : ℕ :=
  (Finset.filter (fun p => Nat.Prime p ∧ p^k ≤ X) (Finset.range (X + 1))).card

theorem prime_power_count_eq_sum (X : ℕ) :
    prime_power_count X = ∑ k ∈ Finset.Icc 2 (Nat.log 2 X), count_prime_powers_with_exp X k := by
  unfold prime_power_count;
  rw [ show Finset.filter is_higher_prime_power ( Finset.range ( X + 1 ) ) = Finset.biUnion ( Finset.Icc 2 ( Nat.log 2 X ) ) ( fun k => Finset.filter ( fun p => Nat.Prime p ∧ p ^ k ≤ X ) ( Finset.range ( X + 1 ) ) |> Finset.image fun p => p ^ k ) from ?_, Finset.card_biUnion ];
  · exact Finset.sum_congr rfl fun x hx => Finset.card_image_of_injOn fun p hp q hq h => by simpa using Nat.pow_left_injective ( by linarith [ Finset.mem_Icc.mp hx ] ) h;
  · intros k hk l hl hkl;
    rw [ Function.onFun, Finset.disjoint_left ] ; contrapose! hkl ; aesop;
    apply_fun fun x => x.factorization w at right_3 ; simp_all +decide [ Nat.factorization_pow, left_3.ne_zero, left_5.ne_zero ];
    rw [ Finsupp.single_apply ] at right_3 ; aesop;
  · ext; aesop;
    · rcases right with ⟨ p, k, hp, hk, rfl ⟩;
      refine' ⟨ k, ⟨ hk, _ ⟩, p, ⟨ _, hp, _ ⟩, rfl ⟩;
      · exact Nat.le_log_of_pow_le ( by decide ) ( by linarith [ Nat.pow_le_pow_left hp.two_le k ] );
      · exact lt_of_le_of_lt ( Nat.le_self_pow ( by linarith ) _ ) left;
      · linarith;
    · linarith;
    · exact ⟨ w_1, w, left_2, left, rfl ⟩

/-
Bound the number of prime squares by sqrt(X).
-/
theorem count_prime_powers_2_le_sqrt (X : ℕ) :
    count_prime_powers_with_exp X 2 ≤ Nat.sqrt X := by
  -- Each prime square $p^2$ corresponds to a unique prime $p$ such that $p^2 \leq X$.
  have h_prime_square_to_prime : Finset.filter (fun p => Nat.Prime p ∧ p^2 ≤ X) (Finset.range (X + 1)) ⊆ Finset.image (fun p => p) (Finset.Icc 1 (Nat.sqrt X)) := by
    intro p hp; aesop;
    · exact left_1.pos;
    · rw [ Nat.le_sqrt ] ; linarith;
  exact le_trans ( Finset.card_le_card h_prime_square_to_prime ) ( Finset.card_image_le.trans ( by simpa ) )

/-
Bound the number of prime powers with exponent k by X^(1/k).
-/
theorem count_prime_powers_bound (X k : ℕ) (hk : k ≥ 1) :
    count_prime_powers_with_exp X k ≤ Nat.floor ((X : ℝ) ^ (1 / k : ℝ)) := by
  -- The number of primes p such that p^k ≤ X is at most the number of integers n such that n^k ≤ X.
  have h_count_le : Finset.card (Finset.filter (fun p => Nat.Prime p ∧ p^k ≤ X) (Finset.range (X + 1))) ≤ Finset.card (Finset.Icc 1 (Nat.floor ((X : ℝ) ^ (1 / (k : ℝ))))) := by
    refine Finset.card_mono ?_;
    intro p hp; aesop;
    · exact left_1.pos;
    · exact Nat.le_floor <| le_trans ( by rw [ ← Real.rpow_natCast, ← Real.rpow_mul ( Nat.cast_nonneg _ ), mul_inv_cancel₀ ( by positivity ), Real.rpow_one ] ) ( Real.rpow_le_rpow ( by positivity ) ( show ( p : ℝ ) ^ k ≤ X by exact_mod_cast right ) ( by positivity ) );
  aesop

/-
Define the set of indices contributing to S2_rest.
-/
def bad_set (X : ℕ) : Finset ℕ :=
  (Finset.range X).filter (fun n => Λ n * Λ (n + 2) ≠ 0 ∧ ¬(Nat.Prime n ∧ Nat.Prime (n + 2)))

/-
Show that bad_set is contained in the union of higher prime powers and shifted higher prime powers.
-/
lemma bad_set_subset (X : ℕ) :
    bad_set X ⊆ (Finset.range (X + 1)).filter is_higher_prime_power ∪
                ((Finset.range (X + 3)).filter is_higher_prime_power).image (fun m => m - 2) := by
  intro n hn; unfold bad_set at hn; aesop;
  -- If n is in bad_set, then Λ(n) and Λ(n+2) are non-zero, so n and n+2 are prime powers.
  have h_prime_powers : (∃ p k : ℕ, Nat.Prime p ∧ k ≥ 1 ∧ n = p^k) ∧ (∃ q l : ℕ, Nat.Prime q ∧ l ≥ 1 ∧ n + 2 = q^l) := by
    have h_prime_powers : ∀ m : ℕ, Λ m ≠ 0 → ∃ p k : ℕ, Nat.Prime p ∧ k ≥ 1 ∧ m = p^k := by
      intro m hm; rw [ Λ_eq_user_def ] at hm; aesop;
    exact ⟨ h_prime_powers n left_1, h_prime_powers ( n + 2 ) right_1 ⟩;
  rcases h_prime_powers with ⟨ ⟨ p, k, hp, hk, rfl ⟩, ⟨ q, l, hq, hl, h ⟩ ⟩;
  by_cases hk2 : k ≥ 2 <;> by_cases hl2 : l ≥ 2 <;> aesop;
  · exact Or.inl ⟨ by linarith, ⟨ p, k, hp, hk2, rfl ⟩ ⟩;
  · exact Or.inl ⟨ Nat.lt_succ_of_lt left, ⟨ p, k, hp, hk2, rfl ⟩ ⟩;
  · exact Or.inr ⟨ q ^ l, ⟨ by linarith, ⟨ q, l, hq, hl2, rfl ⟩ ⟩, Nat.sub_eq_of_eq_add <| by linarith ⟩;
  · interval_cases k ; interval_cases l ; simp_all +decide

/-
Bound the cardinality of bad_set.
-/
lemma bad_set_card_bound (X : ℕ) :
    (bad_set X).card ≤ 2 * prime_power_count (X + 2) := by
  -- By bad_set_subset, bad_set X is a subset of the union of two sets:
  have h_subset : bad_set X ⊆ (Finset.range (X + 1)).filter is_higher_prime_power ∪ ((Finset.range (X + 3)).filter is_higher_prime_power).image (fun m => m - 2) := by
    exact?;
  refine le_trans ( Finset.card_le_card h_subset ) ?_;
  refine le_trans ( Finset.card_union_le _ _ ) ?_;
  refine' le_trans ( add_le_add_left ( Finset.card_image_le ) _ ) _;
  unfold prime_power_count; simp +arith +decide [ Finset.sum_range_succ ] ;
  rw [ two_mul ] ; gcongr ; norm_num

/-
S₂_rest is the sum over the bad set.
-/
lemma S2_rest_eq_sum_bad_set (X : ℕ) :
    S₂_rest X = ∑ n ∈ bad_set X, Λ n * Λ (n + 2) := by
  unfold S₂_rest bad_set; aesop;
  unfold S₂ S₂_twins;
  rw [ ← Finset.sum_sdiff <| Finset.filter_subset ( fun n => Nat.Prime n ∧ Nat.Prime ( n + 2 ) ) ( Finset.range X ) ];
  rw [ ← Finset.sum_subset ];
  rw [ add_sub_cancel_right ];
  · grind;
  · unfold ArithmeticFunction.vonMangoldt; aesop;
    contrapose! a_1; aesop;