/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 8f5f9cc6-cf31-4f4e-9d68-73f41b17985e

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Real Complex Finset MeasureTheory

#check ZMod.χ₄

/-
Definition of the exponential function e(x) = exp(2πix) and the Fourier sum F(α) = Σ_{p≤X} log(p) χ₄(p) e(pα).
-/
noncomputable def e (x : ℝ) : ℂ := Complex.exp (2 * Real.pi * Complex.I * x)

noncomputable def F (X : ℕ) (α : ℝ) : ℂ :=
  ∑ p ∈ (Finset.range (X + 1)).filter Nat.Prime, (Real.log p : ℂ) * (ZMod.χ₄ p : ℂ) * e (p * α)

/-
Definitions of Major arcs M(δ) and Minor arcs m(δ).
-/
noncomputable def M (δ : ℝ) : Set ℝ :=
  {α ∈ Set.Icc 0 1 | abs (α - 1/4) < δ ∨ abs (α - 3/4) < δ}

noncomputable def m (δ : ℝ) : Set ℝ :=
  Set.Icc 0 1 \ M δ

/-
Definitions of the integrals I(X), I_major(X), and I_minor(X) using the squared modulus.
-/
noncomputable def I (X : ℕ) : ℝ :=
  ∫ α in Set.Icc (0 : ℝ) 1, Complex.normSq (F X α)

noncomputable def I_major (X : ℕ) (δ : ℝ) : ℝ :=
  ∫ α in M δ, Complex.normSq (F X α)

noncomputable def I_minor (X : ℕ) (δ : ℝ) : ℝ :=
  ∫ α in m δ, Complex.normSq (F X α)

/-
Orthogonality of exponential functions: The integral of e((n-m)α) over [0,1] is 1 if n=m and 0 otherwise.
-/
lemma orthogonality_of_exp (n m : ℤ) :
  ∫ α in Set.Icc (0 : ℝ) 1, e ((n - m) * α) = if n = m then 1 else 0 := by
    -- We'll use the fact that the integral of $e^{i\theta}$ over $[0, 2\pi]$ is zero.
    have h_integral : ∀ k : ℤ, k ≠ 0 → ∫ α in (0 : ℝ)..1, Complex.exp (2 * Real.pi * Complex.I * k * α) = 0 := by
      -- The integral of $e^{2\pi i k \alpha}$ over $[0, 1]$ is zero for any non-zero integer $k$.
      have h_integral : ∀ k : ℤ, k ≠ 0 → ∫ α in (0 : ℝ)..1, Complex.exp (2 * Real.pi * Complex.I * k * α) = (Complex.exp (2 * Real.pi * Complex.I * k) - 1) / (2 * Real.pi * Complex.I * k) := by
        intros k hk_ne; have := @integral_exp_mul_complex 0 1; aesop;
      intro k hk_ne; rw [ h_integral k hk_ne ] ; rw [ Complex.exp_eq_one_iff.mpr ⟨ k, by ring ⟩ ] ; ring;
    split_ifs with h <;> simp_all +decide [ intervalIntegral.integral_of_le, MeasureTheory.integral_Icc_eq_integral_Ioc ];
    · unfold e; norm_num;
    · convert h_integral ( n - m ) ( sub_ne_zero.mpr <| mod_cast h ) using 3 ; norm_cast ; ring!;
      unfold e; push_cast; ring;

/-
Definition of ψ₂(X) as the sum of squared logarithms of primes up to X.
-/
noncomputable def ψ₂ (X : ℕ) : ℝ :=
  ∑ p ∈ (Finset.range (X + 1)).filter Nat.Prime, (Real.log p) ^ 2

/-
Corrected Parseval Identity: The integral of the squared modulus of F(α) equals the sum of squared logarithms of primes weighted by |χ₄(p)|².
-/
noncomputable def ψ₂_corrected (X : ℕ) : ℝ :=
  ∑ p ∈ (Finset.range (X + 1)).filter Nat.Prime, (Real.log p) ^ 2 * Complex.normSq (ZMod.χ₄ p : ℂ)

theorem parseval_identity_corrected (X : ℕ) : I X = ψ₂_corrected X := by
  -- Expand |F(α)|² as F(α) * conj(F(α)).
  have h_expand : ∀ α : ℝ, Complex.normSq (F X α) = ∑ p ∈ ((Finset.range (X + 1)).filter Nat.Prime), ∑ q ∈ ((Finset.range (X + 1)).filter Nat.Prime), (Real.log p) * (Real.log q) * (ZMod.χ₄ p) * (ZMod.χ₄ q) * Complex.exp (2 * Real.pi * Complex.I * (p - q) * α) := by
    intro α
    have h_expand : Complex.normSq (F X α) = (∑ p ∈ ((Finset.range (X + 1)).filter Nat.Prime), (Real.log p) * (ZMod.χ₄ p) * Complex.exp (2 * Real.pi * Complex.I * p * α)) * (∑ q ∈ ((Finset.range (X + 1)).filter Nat.Prime), (Real.log q) * (ZMod.χ₄ q) * Complex.exp (-2 * Real.pi * Complex.I * q * α)) := by
      unfold F; norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im ] ;
      norm_num [ Complex.normSq, Complex.exp_re, Complex.exp_im, e ];
      norm_num [ Complex.log_re, Complex.log_im ];
      norm_num [ mul_assoc, mul_comm, mul_left_comm ];
    rw [ h_expand, Finset.sum_mul ] ; congr ; ext ; rw [ Finset.mul_sum ] ; congr ; ext ; ring;
    simpa only [ sub_eq_add_neg, Complex.exp_add ] using by ring;
  -- Apply the orthogonality of exponential functions to simplify the integral.
  have h_integral : ∫ α in Set.Icc (0 : ℝ) 1, ∑ p ∈ ((Finset.range (X + 1)).filter Nat.Prime), ∑ q ∈ ((Finset.range (X + 1)).filter Nat.Prime), (Real.log p) * (Real.log q) * (ZMod.χ₄ p) * (ZMod.χ₄ q) * Complex.exp (2 * Real.pi * Complex.I * (p - q) * α) = ∑ p ∈ ((Finset.range (X + 1)).filter Nat.Prime), ∑ q ∈ ((Finset.range (X + 1)).filter Nat.Prime), (Real.log p) * (Real.log q) * (ZMod.χ₄ p) * (ZMod.χ₄ q) * if p = q then 1 else 0 := by
    have h_integral : ∀ p q : ℕ, p ∈ ((Finset.range (X + 1)).filter Nat.Prime) → q ∈ ((Finset.range (X + 1)).filter Nat.Prime) → ∫ α in Set.Icc (0 : ℝ) 1, Complex.exp (2 * Real.pi * Complex.I * (p - q) * α) = if p = q then 1 else 0 := by
      intro p q hp hq; split_ifs <;> simp_all +decide [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le zero_le_one ] ;
      have := @integral_exp_mul_complex 0 1;
      specialize @this ( 2 * Real.pi * Complex.I * ( p - q ) ) ; simp_all +decide [ Complex.exp_ne_zero, sub_eq_iff_eq_add ];
      exact Complex.exp_eq_one_iff.mpr ⟨ p - q, by push_cast; ring ⟩;
    rw [ MeasureTheory.integral_finset_sum ];
    · push_cast [ ← h_integral ];
      refine' Finset.sum_congr rfl fun p hp => _;
      rw [ MeasureTheory.integral_finset_sum ];
      · exact Finset.sum_congr rfl fun q hq => by rw [ MeasureTheory.integral_const_mul ] ; aesop;
      · exact fun q hq => Continuous.integrableOn_Icc ( by continuity );
    · exact fun _ _ => Continuous.integrableOn_Icc <| by continuity;
  unfold _root_.I ψ₂_corrected; norm_cast at *; aesop;
  convert congr_arg Complex.re h_integral using 1;
  · rw [ ← funext h_expand ];
    exact Eq.symm ( by erw [ integral_ofReal ] ; norm_cast );
  · norm_cast ; norm_num [ sq, Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im ];
    exact Finset.sum_congr rfl fun x hx => by ring;

/-
Definition of the Chebyshev theta function θ(X) as the sum of logarithms of primes up to X.
-/
noncomputable def θ (X : ℕ) : ℝ :=
  ∑ p ∈ (Finset.range (X + 1)).filter Nat.Prime, Real.log p

/-
Theorem 2a: Value of F(1/4). F(1/4) is approximately i * X.
-/
theorem F_at_quarter (X : ℕ) (hX : 2 < X) : F X (1/4) = Complex.I * (θ X - Real.log 2) := by
  -- For each odd prime $p$, $e(p/4) = i$, and for $p=2$, $e(2/4) = 1$.
  have h_exp_odd_primes : ∀ p ∈ ((Finset.range (X + 1)).filter Nat.Prime).erase 2, (ZMod.χ₄ p : ℂ) * e (p * (1 / 4 : ℝ)) = Complex.I := by
    unfold e; aesop;
    · haveI := Fact.mk right; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;
      rw [ right.dvd_iff_eq ] at heq <;> aesop;
      contradiction;
    · have := Nat.Prime.eq_two_or_odd right; aesop;
      erw [ ZMod.natCast_eq_natCast_iff ] at heq ; norm_num [ Nat.ModEq, Nat.mod_mod ] at heq ; omega;
    · -- Since $p \equiv 1 \pmod{4}$, we have $p = 4k + 1$ for some integer $k$.
      obtain ⟨k, rfl⟩ : ∃ k, p = 4 * k + 1 := by
        erw [ ZMod.natCast_eq_natCast_iff ] at heq;
        exact Nat.div_add_mod p 4 ▸ heq.symm ▸ ⟨ _, rfl ⟩;
      rw [ Complex.exp_eq_exp_re_mul_sin_add_cos ] ; norm_num ; ring_nf ; norm_num [ mul_one_div, Complex.ext_iff, Complex.exp_re, Complex.exp_im ];
      norm_cast ; norm_num [ mul_assoc, mul_comm Real.pi ];
    · rw [ ← Nat.mod_add_div p 4 ] ; norm_cast at *; simp_all +decide [ Nat.add_mod, Nat.mul_mod, ZMod ] ; ring_nf; norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im ] ;
      norm_num [ mul_assoc, mul_comm Real.pi _, mul_div ] at *;
      rw [ show p % 4 = 3 by { erw [ ← ZMod.val_natCast ] ; aesop } ] ; norm_num [ mul_div_assoc, Real.cos_three_mul, Real.sin_three_mul ] ;
  -- For each odd prime $p$, $e(p/4) = i$, and for $p=2$, $e(2/4) = 1$. Thus we can split the sum into two parts.
  have h_split_sum : F X (1 / 4 : ℝ) = ∑ p ∈ ((Finset.range (X + 1)).filter Nat.Prime).erase 2, (Real.log p : ℂ) * Complex.I := by
    rw [ Finset.sum_congr rfl fun p hp => ?_ ];
    rw [ Finset.sum_erase ];
    exact?;
    · norm_num [ ZMod.χ₄ ];
      exact Or.inl <| Or.inr rfl;
    · rw [ mul_assoc, h_exp_odd_primes p hp ];
  unfold θ; aesop;
  rw [ ← Finset.sum_erase_add _ _ ( show 2 ∈ Finset.filter Nat.Prime ( Finset.range ( X + 1 ) ) from Finset.mem_filter.mpr ⟨ Finset.mem_range.mpr ( by linarith ), by norm_num ⟩ ), mul_sub ] ; norm_num [ mul_comm, Finset.mul_sum _ _ _ ];
  rw [ mul_add, Finset.mul_sum _ _ _ ] ; ring

/-
Theorem 2b: Value of F(3/4). F(3/4) is approximately -i * X.
-/
theorem F_at_three_quarters (X : ℕ) (hX : 2 < X) : F X (3/4) = -Complex.I * (θ X - Real.log 2) := by
  have := @F_at_quarter X hX;
  unfold F at *;
  -- Notice that $e(3p/4) = e(-p/4)$ since $e(x)$ is periodic with period 1.
  have h_exp : ∀ p : ℕ, e (p * (3 / 4) : ℝ) = e (-p * (1 / 4) : ℝ) := by
    intros p
    simp [e];
    exact Complex.exp_eq_exp_iff_exists_int.mpr ⟨ p, by push_cast; ring ⟩;
  -- Notice that $e(-p/4) = \overline{e(p/4)}$ since $e(x)$ is periodic with period 1.
  have h_exp_conj : ∀ p : ℕ, e (-p * (1 / 4) : ℝ) = starRingEnd ℂ (e (p * (1 / 4) : ℝ)) := by
    unfold e; norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im ] ;
  simp_all +decide [ Complex.ext_iff ];
  simp_all +decide [ Complex.log_re, Complex.log_im, Finset.sum_add_distrib, Finset.mul_sum _ _ _, Finset.sum_mul _ _ _, sub_eq_add_neg ]

/-
Definition of the Minor Arc Bound statement as a proposition.
-/
def MinorArcBoundStatement (δ : ℝ) : Prop :=
  ∃ C η : ℝ, 0 < C ∧ 0 < η ∧ ∀ X : ℕ, X ≥ 1 → ∀ α ∈ m δ, Real.sqrt (Complex.normSq (F X α)) ≤ C * (X : ℝ) ^ (1 - η)

/-
Theorem 4: Minor Arc Integral Bound. The contribution of the minor arcs to the integral is o(X^2).
-/
theorem minor_arc_integral_bound (δ : ℝ) (hδ : 0 < δ) (h_bound : MinorArcBoundStatement δ) :
  Filter.Tendsto (fun X => I_minor X δ / (X : ℝ)^2) Filter.atTop (nhds 0) := by
    obtain ⟨ C, η, hC, hη, h_bound ⟩ := h_bound;
    -- Using the bound from h_bound, we can show that I_minor ≤ C^2 * X^(2 - 2η).
    have h_I_minor : ∀ X : ℕ, X ≥ 1 → I_minor X δ ≤ C^2 * (X : ℝ) ^ (2 - 2 * η) := by
      -- By definition of $I_{\text{minor}}$, we know that
      intro X hX
      have h_integral_bound : ∫ α in m δ, Complex.normSq (F X α) ≤ ∫ α in m δ, (C * (X : ℝ) ^ (1 - η)) ^ 2 := by
        refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
        · exact Filter.Eventually.of_forall fun α => Complex.normSq_nonneg _;
        · exact Continuous.integrableOn_Icc ( by continuity ) |> fun h => h.mono_set <| show m δ ⊆ Set.Icc 0 1 from fun x hx => hx.1;
        · filter_upwards [ MeasureTheory.ae_restrict_mem <| show MeasurableSet ( m δ ) from by exact MeasurableSet.diff ( measurableSet_Icc ) <| by exact MeasurableSet.inter ( measurableSet_Icc ) <| by exact MeasurableSet.union ( measurableSet_lt ( continuous_abs.measurable.comp <| measurable_id'.sub measurable_const ) measurable_const ) ( measurableSet_lt ( continuous_abs.measurable.comp <| measurable_id'.sub measurable_const ) measurable_const ) ] with α hα using by simpa [ Real.sq_sqrt <| Complex.normSq_nonneg _ ] using pow_le_pow_left₀ ( Real.sqrt_nonneg _ ) ( h_bound X hX α hα ) 2;
      simp +zetaDelta at *;
      refine le_trans h_integral_bound ?_;
      refine' le_trans ( mul_le_mul_of_nonneg_right ( show ( MeasureTheory.MeasureSpace.volume.real ( m δ ) ) ≤ 1 from _ ) ( by positivity ) ) _;
      · refine' le_trans ( ENNReal.toReal_mono _ _ ) _;
        exact 1;
        · norm_num;
        · exact le_trans ( MeasureTheory.measure_mono ( show m δ ⊆ Set.Icc 0 1 from fun x hx => hx.1 ) ) ( by norm_num );
        · norm_num;
      · rw [ mul_pow, ← Real.rpow_natCast, ← Real.rpow_natCast, ← Real.rpow_mul ( by positivity ) ] ; ring_nf ; norm_num;
    -- Dividing both sides of the inequality by $X^2$, we get $I_minor / X^2 \leq C^2 / X^{2\eta}$.
    have h_I_minor_div : ∀ X : ℕ, X ≥ 1 → I_minor X δ / (X : ℝ) ^ 2 ≤ C^2 / (X : ℝ) ^ (2 * η) := by
      intro X hX; convert div_le_div_of_nonneg_right ( h_I_minor X hX ) ( sq_nonneg _ ) using 1 ; rw [ Real.rpow_sub ( by positivity ), Real.rpow_mul ( by positivity ) ] ; norm_cast ; norm_num;
      rw [ eq_div_iff ( by positivity ) ] ; ring;
    exact squeeze_zero_norm' ( Filter.eventually_atTop.mpr ⟨ 1, fun X hX => by rw [ Real.norm_of_nonneg ( div_nonneg ( by exact MeasureTheory.integral_nonneg fun _ => Complex.normSq_nonneg _ ) ( sq_nonneg _ ) ) ] ; exact h_I_minor_div X hX ⟩ ) ( tendsto_const_nhds.div_atTop <| tendsto_rpow_atTop ( by positivity ) |> Filter.Tendsto.comp <| tendsto_natCast_atTop_atTop )

/-
Definition of T_χ₄(X) as the integral of |F(α)|² * e(-2α) over [0,1].
-/
noncomputable def T_χ₄ (X : ℕ) : ℂ :=
  ∫ α in Set.Icc (0 : ℝ) 1, Complex.normSq (F X α) * e (-2 * α)

/-
Definition of S₂(X) as the sum of log(p)log(p+2) for twin primes p, p+2 ≤ X+2.
-/
noncomputable def S₂ (X : ℕ) : ℝ :=
  ∑ p ∈ (Finset.range (X + 1)).filter (fun n => Nat.Prime n ∧ Nat.Prime (n + 2)), Real.log p * Real.log (p + 2)