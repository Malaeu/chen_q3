/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 442c8097-5a65-4ab4-aec3-52ab2f098179

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def χ₄ (n : ℤ) : ℤ :=
  if n % 2 = 0 then 0
  else if n % 4 = 1 then 1
  else -1

noncomputable def e (x : ℝ) : ℂ := Complex.exp (2 * Real.pi * Complex.I * x)
noncomputable def Λ : ℕ → ℝ := ArithmeticFunction.vonMangoldt

open scoped BigOperators

noncomputable def F (X : ℝ) (α : ℝ) : ℂ :=
  ∑ n ∈ Finset.range ⌊X⌋₊, (Λ n : ℂ) * (χ₄ n : ℂ) * e (n * α)

def well_spaced (S : Finset ℝ) (δ : ℝ) : Prop :=
  ∀ α ∈ S, ∀ β ∈ S, α ≠ β → |α - β| ≥ δ

open MeasureTheory

noncomputable def test_int : ℂ := ∫ x in Set.Icc (0 : ℝ) 1, (1 : ℂ)

/-
The integral of the squared magnitude of a trigonometric polynomial over [0, 1] equals the sum of the squared magnitudes of its coefficients.
-/
open MeasureTheory
open scoped BigOperators

theorem large_sieve_integral (N : ℕ) (a : ℕ → ℂ) :
  ∫ α in Set.Icc 0 1, ‖∑ n ∈ Finset.range N, a n * e (n * α)‖^2
  = ∑ n ∈ Finset.range N, ‖a n‖^2 := by
  -- This follows from the orthogonality of the exponential functions.
  have h_ortho : ∀ n m : ℕ, n ≠ m → ∫ α in Set.Icc (0 : ℝ) 1, Complex.exp (2 * Real.pi * Complex.I * (n - m) * α) = 0 := by
    intro n m hnm
    have h_integral : ∫ α in (Set.Icc (0 : ℝ) 1), Complex.exp (2 * Real.pi * Complex.I * (n - m) * α) = (1 / (2 * Real.pi * Complex.I * (n - m))) * (Complex.exp (2 * Real.pi * Complex.I * (n - m)) - 1) := by
      rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le zero_le_one ];
      have := @integral_exp_mul_complex 0 1;
      simpa [ div_eq_inv_mul ] using this ( show ( 2 * Real.pi * Complex.I * ( n - m ) : ℂ ) ≠ 0 from mul_ne_zero ( mul_ne_zero ( mul_ne_zero two_ne_zero ( Complex.ofReal_ne_zero.mpr Real.pi_ne_zero ) ) Complex.I_ne_zero ) ( sub_ne_zero.mpr <| Nat.cast_injective.ne hnm ) );
    rw [ h_integral, Complex.exp_eq_one_iff.mpr ⟨ n - m, by push_cast; ring ⟩ ] ; norm_num;
  -- By Fubini's theorem, we can interchange the order of summation and integration.
  have h_fubini : ∫ α in Set.Icc (0 : ℝ) 1, ‖∑ n ∈ Finset.range N, a n * Complex.exp (2 * Real.pi * Complex.I * n * α)‖ ^ 2 = ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N, a n * starRingEnd ℂ (a m) * ∫ α in Set.Icc (0 : ℝ) 1, Complex.exp (2 * Real.pi * Complex.I * (n - m) * α) := by
    have h_fubini : ∫ α in Set.Icc (0 : ℝ) 1, ‖∑ n ∈ Finset.range N, a n * Complex.exp (2 * Real.pi * Complex.I * n * α)‖ ^ 2 = ∫ α in Set.Icc (0 : ℝ) 1, ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N, a n * starRingEnd ℂ (a m) * Complex.exp (2 * Real.pi * Complex.I * (n - m) * α) := by
      have h_fubini : ∀ α ∈ Set.Icc (0 : ℝ) 1, ‖∑ n ∈ Finset.range N, a n * Complex.exp (2 * Real.pi * Complex.I * n * α)‖ ^ 2 = ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N, a n * starRingEnd ℂ (a m) * Complex.exp (2 * Real.pi * Complex.I * (n - m) * α) := by
        intro α hα
        have h_expand : ‖∑ n ∈ Finset.range N, a n * Complex.exp (2 * Real.pi * Complex.I * n * α)‖ ^ 2 = (∑ n ∈ Finset.range N, a n * Complex.exp (2 * Real.pi * Complex.I * n * α)) * (∑ m ∈ Finset.range N, starRingEnd ℂ (a m) * Complex.exp (-2 * Real.pi * Complex.I * m * α)) := by
          have h_expand : ∀ z : ℂ, ‖z‖ ^ 2 = z * starRingEnd ℂ z := by
            norm_num [ Complex.mul_conj, Complex.normSq_eq_norm_sq ];
          convert h_expand _ using 2;
          simp +decide [ Complex.ext_iff, Complex.exp_re, Complex.exp_im ];
        exact h_expand.trans ( by rw [ Finset.sum_mul ] ; exact Finset.sum_congr rfl fun _ _ => by rw [ Finset.mul_sum ] ; exact Finset.sum_congr rfl fun _ _ => by rw [ mul_mul_mul_comm ] ; rw [ ← Complex.exp_add ] ; ring );
      convert MeasureTheory.setIntegral_congr_fun measurableSet_Icc h_fubini using 1;
      convert integral_ofReal.symm ; norm_cast;
    rw [ h_fubini, MeasureTheory.integral_finset_sum ];
    · exact Finset.sum_congr rfl fun _ _ => by rw [ MeasureTheory.integral_finset_sum _ fun _ _ => Continuous.integrableOn_Icc ( by exact Continuous.mul ( continuous_const.mul continuous_const ) ( Complex.continuous_exp.comp <| by continuity ) ) ] ; exact Finset.sum_congr rfl fun _ _ => by rw [ MeasureTheory.integral_const_mul ] ;
    · exact fun _ _ => Continuous.integrableOn_Icc <| by continuity;
  convert congr_arg Complex.re h_fubini using 1;
  · unfold e; norm_num;
    ac_rfl;
  · rw [ Finset.sum_congr rfl fun i hi => Finset.sum_eq_single i ( fun j hj => ?_ ) ( ?_ ) ] <;> aesop;
    norm_num [ Complex.normSq, Complex.sq_norm ]

/-
The sum of the squared coefficients of F is bounded by 2 * X * log X for X >= 2.
-/
open scoped BigOperators

noncomputable def F_coeff (X : ℝ) (n : ℕ) : ℂ := (Λ n : ℂ) * (χ₄ n : ℂ)

lemma F_coeff_L2 (X : ℝ) (hX : X ≥ 2) :
  ∑ n ∈ Finset.range ⌊X⌋₊, ‖F_coeff X n‖^2 ≤ 2 * X * Real.log X := by
  unfold F_coeff;
  -- Let's simplify the expression inside the sum.
  suffices h_simp : ∑ n ∈ Finset.range (Nat.floor X), (ArithmeticFunction.vonMangoldt n) ^ 2 ≤ 2 * X * Real.log X by
    refine' le_trans ( Finset.sum_le_sum fun i hi => _ ) h_simp;
    unfold χ₄; aesop;
  -- We'll use the fact that $\sum_{n \leq X} \Lambda(n)^2 \leq \sum_{p^k \leq X} \log^2 p$.
  have h_sum_le : ∑ n ∈ Finset.range (Nat.floor X), (ArithmeticFunction.vonMangoldt n) ^ 2 ≤ ∑ p ∈ Finset.filter Nat.Prime (Finset.range (Nat.floor X + 1)), ∑ k ∈ Finset.Ico 1 (Nat.log p (Nat.floor X) + 1), (Real.log p) ^ 2 := by
    have h_sum_le : ∀ n ∈ Finset.range (Nat.floor X), (ArithmeticFunction.vonMangoldt n) ^ 2 ≤ ∑ p ∈ Finset.filter Nat.Prime (Finset.range (Nat.floor X + 1)), if ∃ k : ℕ, 1 ≤ k ∧ p^k = n then (Real.log p) ^ 2 else 0 := by
      intro n hn; by_cases h : ∃ p : ℕ, Nat.Prime p ∧ ∃ k : ℕ, 1 ≤ k ∧ p ^ k = n <;> aesop;
      · rw [ Finset.sum_eq_single w ] <;> aesop;
        · rw [ ArithmeticFunction.vonMangoldt_apply ] ; aesop;
          · rw [ Nat.Prime.pow_minFac ] <;> aesop;
          · positivity;
        · exact False.elim <| h _ left_1 rfl;
        · have := congr_arg ( ·.factorization ( b : ℕ ) ) a_3 ; norm_num at this ; aesop;
        · linarith [ Nat.pow_le_pow_right left.one_lt.le left_1, Nat.pow_le_pow_left left.two_le x ];
      · rw [ ArithmeticFunction.vonMangoldt ] ; aesop;
        · rw [ isPrimePow_nat_iff ] at h_1 ; aesop;
          exact False.elim <| h w left w_1 left_1 rfl;
        · exact Finset.sum_nonneg fun _ _ => by positivity;
    refine le_trans ( Finset.sum_le_sum h_sum_le ) ?_;
    rw [ Finset.sum_comm ];
    gcongr ; aesop;
    rw [ Finset.sum_ite ] ; aesop;
    refine' mul_le_mul_of_nonneg_right _ ( sq_nonneg _ );
    refine' mod_cast le_trans ( Finset.card_le_card _ ) _;
    exact Finset.image ( fun k => i ^ k ) ( Finset.Ico 1 ( Nat.log i ⌊X⌋₊ + 1 ) );
    · intro x hx; aesop;
      exact ⟨ w, ⟨ left_2, Nat.lt_succ_of_le ( Nat.le_log_of_pow_le right.one_lt left_1.le ) ⟩, rfl ⟩;
    · exact Finset.card_image_le.trans ( by simpa );
  -- We'll use the fact that $\sum_{p^k \leq X} \log^2 p \leq \sum_{p \leq X} \log^2 p \cdot \log_p X$.
  have h_sum_le' : ∑ p ∈ Finset.filter Nat.Prime (Finset.range (Nat.floor X + 1)), ∑ k ∈ Finset.Ico 1 (Nat.log p (Nat.floor X) + 1), (Real.log p) ^ 2 ≤ ∑ p ∈ Finset.filter Nat.Prime (Finset.range (Nat.floor X + 1)), (Real.log p) ^ 2 * (Real.log (Nat.floor X) / Real.log p) := by
    gcongr ; aesop;
    rw [ mul_comm ];
    exact mul_le_mul_of_nonneg_left ( by rw [ le_div_iff₀ ( Real.log_pos <| Nat.one_lt_cast.mpr right.one_lt ) ] ; nth_rw 1 [ ← Real.log_pow ] ; exact Real.log_le_log ( by exact pow_pos ( Nat.cast_pos.mpr right.pos ) _ ) <| mod_cast Nat.pow_log_le_self _ <| Nat.ne_of_gt <| Nat.floor_pos.mpr <| by linarith ) <| sq_nonneg _;
  -- We'll use the fact that $\sum_{p \leq X} \log^2 p \cdot \log_p X \leq \sum_{p \leq X} \log X \cdot \log p$.
  have h_sum_le'' : ∑ p ∈ Finset.filter Nat.Prime (Finset.range (Nat.floor X + 1)), (Real.log p) ^ 2 * (Real.log (Nat.floor X) / Real.log p) ≤ ∑ p ∈ Finset.filter Nat.Prime (Finset.range (Nat.floor X + 1)), Real.log (Nat.floor X) * Real.log p := by
    exact Finset.sum_le_sum fun p hp => by rw [ mul_div, div_le_iff₀ ( Real.log_pos <| mod_cast Nat.Prime.one_lt <| Finset.mem_filter.mp hp |>.2 ) ] ; nlinarith only [ Real.log_pos <| show ( p : ℝ ) > 1 from mod_cast Nat.Prime.one_lt <| Finset.mem_filter.mp hp |>.2 ] ;
  -- We'll use the fact that $\sum_{p \leq X} \log p \leq X \log 4$.
  have h_sum_log_le : ∑ p ∈ Finset.filter Nat.Prime (Finset.range (Nat.floor X + 1)), Real.log p ≤ Nat.floor X * Real.log 4 := by
    -- We'll use the fact that $\sum_{p \leq X} \log p \leq X \log 4$ follows from the Prime Number Theorem.
    have h_prime_number_theorem : ∀ n : ℕ, ∑ p ∈ Finset.filter Nat.Prime (Finset.range (n + 1)), Real.log p ≤ n * Real.log 4 := by
      -- We'll use the fact that $\sum_{p \leq n} \log p \leq n \log 4$ follows from the Prime Number Theorem.
      intros n
      have h_prime_number_theorem : ∏ p ∈ Finset.filter Nat.Prime (Finset.range (n + 1)), p ≤ 4 ^ n := by
        induction' n using Nat.strong_induction_on with n ih;
        -- Consider two cases: $n$ is even and $n$ is odd.
        by_cases hn_even : Even n;
        · obtain ⟨ k, rfl ⟩ := even_iff_two_dvd.mp hn_even;
          -- By the properties of primes, we know that $\prod_{p \leq 2k} p \leq \prod_{p \leq k} p \cdot \binom{2k}{k}$.
          have h_prod_le : ∏ p ∈ Finset.filter Nat.Prime (Finset.range (2 * k + 1)), p ≤ (∏ p ∈ Finset.filter Nat.Prime (Finset.range (k + 1)), p) * Nat.choose (2 * k) k := by
            have h_prod_le : ∏ p ∈ Finset.filter Nat.Prime (Finset.Icc (k + 1) (2 * k)), p ≤ Nat.choose (2 * k) k := by
              have h_prod_le : ∀ p ∈ Finset.filter Nat.Prime (Finset.Icc (k + 1) (2 * k)), p ∣ Nat.choose (2 * k) k := by
                simp +zetaDelta at *;
                intro p hp₁ hp₂ hp₃; have := @Nat.Prime.dvd_choose p; aesop;
                exact this ( by linarith ) ( by omega ) ( by linarith );
              refine' Nat.le_of_dvd ( Nat.choose_pos ( by linarith ) ) ( Nat.dvd_trans _ ( Nat.prod_primeFactors_dvd _ ) );
              apply_rules [ Finset.prod_dvd_prod_of_subset ];
              intro p hp; specialize h_prod_le p hp; aesop;
              exact absurd a <| Nat.ne_of_gt <| Nat.choose_pos <| by linarith;
            have h_prod_le : ∏ p ∈ Finset.filter Nat.Prime (Finset.range (2 * k + 1)), p = (∏ p ∈ Finset.filter Nat.Prime (Finset.range (k + 1)), p) * (∏ p ∈ Finset.filter Nat.Prime (Finset.Icc (k + 1) (2 * k)), p) := by
              erw [ Finset.prod_filter, Finset.prod_filter, Finset.prod_filter ];
              erw [ Finset.prod_range_mul_prod_Ico _ ( by linarith ) ];
            exact h_prod_le.symm ▸ Nat.mul_le_mul_left _ ‹_›;
          -- By the properties of binomial coefficients, we know that $\binom{2k}{k} \leq 4^k$.
          have h_binom_le : Nat.choose (2 * k) k ≤ 4 ^ k := by
            rw [ show 4 ^ k = ( 2 : ℕ ) ^ ( 2 * k ) by norm_num [ pow_mul ] ];
            rw [ ← Nat.sum_range_choose ] ; exact Finset.single_le_sum ( fun x _ => Nat.zero_le _ ) ( Finset.mem_range.mpr ( by linarith ) );
          rcases k with ( _ | k ) <;> simp_all +decide [ pow_mul' ];
          exact h_prod_le.trans ( by rw [ pow_two ] ; exact Nat.mul_le_mul ( ih _ <| by linarith ) h_binom_le );
        · -- Since $n$ is odd, we can write $n = 2k + 1$ for some integer $k$.
          obtain ⟨k, rfl⟩ : ∃ k, n = 2 * k + 1 := by
            exact n.even_or_odd.resolve_left hn_even;
          -- By the properties of primes, we know that $\prod_{k+1 < p \leq 2k+1} p \leq \binom{2k+1}{k}$.
          have h_prod_le_binom : ∏ p ∈ Finset.filter Nat.Prime (Finset.Icc (k + 2) (2 * k + 1)), p ≤ Nat.choose (2 * k + 1) k := by
            have h_prime_prod : ∀ p ∈ Finset.filter Nat.Prime (Finset.Icc (k + 2) (2 * k + 1)), p ∣ Nat.choose (2 * k + 1) k := by
              aesop;
              apply_mod_cast right.dvd_choose;
              · linarith;
              · omega;
              · linarith;
            refine' Nat.le_of_dvd ( Nat.choose_pos ( by linarith ) ) ( Nat.dvd_trans _ ( Nat.prod_primeFactors_dvd _ ) );
            apply_rules [ Finset.prod_dvd_prod_of_subset ];
            intro p hp; specialize h_prime_prod p hp; aesop;
            exact absurd a <| Nat.ne_of_gt <| Nat.choose_pos <| by linarith;
          -- By the properties of primes, we know that $\prod_{p \leq k+1} p \leq 4^{k+1}$.
          have h_prod_le_four_pow : ∏ p ∈ Finset.filter Nat.Prime (Finset.range (k + 2)), p ≤ 4 ^ (k + 1) := by
            rcases k with ( _ | k ) <;> simp_all +arith +decide;
          -- By the properties of primes, we know that $\prod_{p \leq 2k+1} p = \prod_{p \leq k+1} p \cdot \prod_{k+1 < p \leq 2k+1} p$.
          have h_prod_split : ∏ p ∈ Finset.filter Nat.Prime (Finset.range (2 * k + 2)), p = (∏ p ∈ Finset.filter Nat.Prime (Finset.range (k + 2)), p) * (∏ p ∈ Finset.filter Nat.Prime (Finset.Icc (k + 2) (2 * k + 1)), p) := by
            erw [ Finset.prod_filter, Finset.prod_filter, Finset.prod_filter ];
            erw [ Finset.prod_range_mul_prod_Ico _ ( by linarith ) ];
          -- By the properties of binomial coefficients, we know that $\binom{2k+1}{k} \leq 2^{2k}$.
          have h_binom_le : Nat.choose (2 * k + 1) k ≤ 2 ^ (2 * k) := by
            exact?;
          norm_num [ pow_mul ] at *;
          exact h_prod_split.symm ▸ le_trans ( Nat.mul_le_mul h_prod_le_four_pow h_prod_le_binom ) ( by rw [ show 4 ^ ( 2 * k + 1 ) = 4 ^ ( k + 1 ) * 4 ^ k by ring ] ; exact Nat.mul_le_mul_left _ h_binom_le );
      rw [ ← Real.log_prod ] <;> norm_cast <;> aesop;
      rw [ ← Real.log_rpow ] <;> norm_cast;
      exact Real.log_le_log ( Finset.prod_pos fun p hp => Nat.cast_pos.mpr <| Nat.Prime.pos <| Finset.mem_filter.mp hp |>.2 ) <| by rw [ ← Nat.cast_prod ] ; exact_mod_cast h_prime_number_theorem;
    exact h_prime_number_theorem _;
  -- We'll use the fact that $\log 4 \leq 2$.
  have h_log4_le : Real.log 4 ≤ 2 := by
    rw [ show ( 4 : ℝ ) = 2 ^ 2 by norm_num, Real.log_pow ] ; norm_num ; linarith [ Real.log_le_sub_one_of_pos zero_lt_two ];
  refine le_trans h_sum_le <| le_trans h_sum_le' <| le_trans h_sum_le'' ?_;
  rw [ ← Finset.mul_sum _ _ _ ];
  refine le_trans ( mul_le_mul_of_nonneg_left h_sum_log_le <| Real.log_nonneg <| Nat.one_le_cast.mpr <| Nat.floor_pos.mpr <| by linarith ) ?_;
  refine le_trans ( mul_le_mul_of_nonneg_left ( mul_le_mul_of_nonneg_left h_log4_le <| Nat.cast_nonneg _ ) <| Real.log_nonneg <| Nat.one_le_cast.mpr <| Nat.floor_pos.mpr <| by linarith ) ?_;
  nlinarith [ Nat.floor_le ( show 0 ≤ X by linarith ), Real.log_nonneg ( show ( ⌊X⌋₊ : ℝ ) ≥ 1 by exact Nat.one_le_cast.mpr ( Nat.floor_pos.mpr ( by linarith ) ) ), Real.log_le_log ( Nat.cast_pos.mpr ( Nat.floor_pos.mpr ( by linarith ) ) ) ( show ( ⌊X⌋₊ : ℝ ) ≤ X by exact Nat.floor_le ( by linarith ) ) ]

/-
The integral of the squared magnitude of F over [0, 1] is bounded by 2 * X * log X for X >= 2.
-/
open scoped BigOperators

theorem F_parseval (X : ℝ) (hX : X ≥ 2) :
  ∫ α in Set.Icc 0 1, ‖F X α‖^2 ≤ 2 * X * Real.log X := by
  -- By definition of $F$, we know that its squared magnitude is the sum of the squared magnitudes of its coefficients.
  have hF_sq : ∫ α in Set.Icc (0 : ℝ) 1, ‖F X α‖^2 = ∑ n ∈ Finset.range ⌊X⌋₊, ‖F_coeff X n‖^2 := by
    apply large_sieve_integral;
  exact hF_sq ▸ F_coeff_L2 X hX

/-
The magnitude of the integral of |F|^2 * Re(e(-2alpha)) over minor arcs is bounded by the integral of |F|^2.
-/
open MeasureTheory

opaque is_minor (α X : ℝ) : Prop

lemma minor_oscillation_bound (X : ℝ) (hX : X > 100)
    (h_meas : MeasurableSet {α | is_minor α X}) :
  ‖∫ α in {α | is_minor α X ∧ 0 ≤ α ∧ α ≤ 1}, ‖F X α‖^2 * (e (-2 * α)).re‖
  ≤ ∫ α in {α | is_minor α X ∧ 0 ≤ α ∧ α ≤ 1}, ‖F X α‖^2 := by
  refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm _ ) ( MeasureTheory.integral_mono_of_nonneg _ _ _ );
  · exact Filter.Eventually.of_forall fun x => norm_nonneg _;
  · -- The function $F$ is continuous, hence its square is integrable.
    have h_cont : Continuous (fun α => ‖F X α‖^2) := by
      refine' Continuous.pow _ _;
      refine' continuous_norm.comp _;
      refine' continuous_finset_sum _ fun i hi => _;
      exact Continuous.mul ( continuous_const ) ( Complex.continuous_exp.comp <| by continuity );
    exact Continuous.integrableOn_Icc h_cont |> fun h => h.mono_set fun x hx => ⟨ hx.2.1, hx.2.2 ⟩;
  · norm_num [ Complex.exp_re, Complex.exp_im ];
    filter_upwards [ ] with α using mul_le_of_le_one_right ( sq_nonneg _ ) ( by rw [ show ( e ( - ( 2 * α ) ) |> Complex.re ) = Real.cos ( 2 * Real.pi * ( - ( 2 * α ) ) ) by unfold e; norm_num [ Complex.exp_re ] ] ; exact Real.abs_cos_le_one _ )