/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 0cca0326-7abf-44d4-a6b6-0800bcf393f9
-/

/-
We have analyzed the spectral gap problem for the twin-flow operator.
We disproved the conjecture `kernel_implies_zero_on_twins` by constructing a counterexample based on prime triplets.
Specifically, we showed that for X >= 8, the vector supported on the prime triplet (3, 5, 7) with values v_3 = 1, v_5 = 0, v_7 = 1 is in the kernel of the commutator [H_twin, Ξ].
This contradicts the claim that kernel vectors must vanish on twin primes.
The existence of such "dark states" (vectors in the kernel supported on twin components) suggests that the spectral gap condition might not hold as simply as hypothesized, or requires excluding these specific subspaces.
The formal proof is contained in `kernel_implies_zero_on_twins_false_existential`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def is_prime (n : ℕ) : Bool := decide (Nat.Prime n)

def P (X : ℕ) : Matrix (Fin X) (Fin X) ℝ :=
  Matrix.diagonal (fun i => if is_prime (i.val + 1) then 1 else 0)

def S2 (X : ℕ) : Matrix (Fin X) (Fin X) ℝ :=
  fun i j => if j.val = i.val + 2 then 1 else 0

def H_twin (X : ℕ) : Matrix (Fin X) (Fin X) ℝ :=
  P X * S2 X * P X + P X * (S2 X).transpose * P X

def Xi (X : ℕ) : Matrix (Fin X) (Fin X) ℝ :=
  Matrix.diagonal (fun i => (i.val + 1 : ℝ))

def matComm {X : ℕ} (H Ξ : Matrix (Fin X) (Fin X) ℝ) : Matrix (Fin X) (Fin X) ℝ :=
  H * Ξ - Ξ * H

/-
The commutator of the twin-flow operator and the position operator has entries ±2 on twin edges.
-/
lemma commutator_twin_coefficient (X : ℕ) (p : ℕ)
  (hp : Nat.Prime p) (hp2 : Nat.Prime (p + 2)) (hpX : p + 2 < X) :
  let C := matComm (H_twin X) (Xi X)
  C ⟨p-1, by
    omega⟩ ⟨p+1, by
    linarith⟩ = 2 ∨
  C ⟨p+1, by
    linarith⟩ ⟨p-1, by
    omega⟩ = -2 := by
  unfold H_twin Xi matComm;
  unfold P S2; norm_num [ Matrix.mul_apply ];
  norm_num [ Finset.sum_add_distrib, mul_add, add_mul, Finset.mul_sum _ _ _, Finset.sum_mul, Finset.sum_ite, Finset.filter_ne', Finset.filter_eq', Matrix.one_apply, Matrix.diagonal_apply ];
  rcases p with ( _ | _ | p ) <;> norm_num [ is_prime ] at *;
  split_ifs <;> ring_nf <;> norm_num [ hp, hp2 ]

/-
For X >= 8, the vector supported on the prime triplet (3, 5, 7) is in the kernel of the commutator.
-/
def v_triplet (X : ℕ) : Fin X → ℝ :=
  fun i => if i.val = 2 then 1 else if i.val = 6 then 1 else 0

theorem triplet_in_kernel (X : ℕ) (hX : X ≥ 8) :
  Matrix.mulVec (matComm (H_twin X) (Xi X)) (v_triplet X) = 0 := by
  unfold matComm H_twin Xi v_triplet;
  ext i;
  norm_num [ Matrix.mulVec, dotProduct ];
  rw [ Finset.sum_eq_add ( ⟨ 2, by linarith ⟩ : Fin X ) ( ⟨ 6, by linarith ⟩ : Fin X ) ] <;> norm_num;
  · unfold P S2; norm_num [ Matrix.mul_apply ] ;
    norm_num [ Finset.sum_ite, Matrix.diagonal ];
    rcases i with ⟨ _ | _ | _ | _ | _ | _ | _ | _ | _ | i, hi ⟩ <;> norm_num <;> norm_cast;
  · intro c hc₁ hc₂; split_ifs <;> simp_all +decide [ Fin.ext_iff ] ;

/-
There exists a vector in the kernel and a twin prime pair such that the vector is non-zero on the twin prime indices. This disproves the claim that kernel vectors must vanish on twins.
-/
def safe_get {X : ℕ} (v : Fin X → ℝ) (i : ℕ) : ℝ :=
  if h : i < X then v ⟨i, h⟩ else 0

theorem kernel_implies_zero_on_twins_false_existential (X : ℕ) (hX : X ≥ 8) :
  ∃ (v : Fin X → ℝ), Matrix.mulVec (matComm (H_twin X) (Xi X)) v = 0 ∧
  ∃ p, Nat.Prime p ∧ Nat.Prime (p + 2) ∧ p + 2 < X ∧
  (safe_get v (p-1) ≠ 0 ∨ safe_get v (p+1) ≠ 0) := by
  refine' ⟨ v_triplet X, _, 3, _ ⟩ <;> simp_all +decide;
  · exact?;
  · simp +decide [ safe_get, v_triplet ];
    constructor <;> linarith