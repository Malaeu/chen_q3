/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 6363f4fb-2d22-4738-8ded-fd1d1b391500

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions of g_vec, S₂, and B_op. comm_op and chi4_op are opaque for now.
-/
open scoped ArithmeticFunction
open BigOperators
open Matrix

noncomputable def g_vec (X : ℕ) : Fin X → ℂ := fun n => (Λ n.val : ℂ)

noncomputable def S₂ (X : ℕ) : ℝ := ∑ n ∈ Finset.range X, Λ n * Λ (n + 2)

opaque comm_op (X : ℕ) : Matrix (Fin X) (Fin X) ℂ
opaque chi4_op (X : ℕ) : Matrix (Fin X) (Fin X) ℂ

noncomputable def B_op (X : ℕ) : Matrix (Fin X) (Fin X) ℂ := 
  let A := comm_op X * chi4_op X
  Complex.I • A + (Complex.I • A)ᴴ

open Matrix

variable {n : Type*} [Fintype n] [DecidableEq n]
variable (A : Matrix n n ℂ) (hA : A.IsHermitian)

#check hA.eigenvalues
#check hA.eigenvectorUnitary

/-
B_op is a Hermitian matrix.
-/
lemma B_is_hermitian (X : ℕ) : (B_op X).IsHermitian := by
  rw [ show B_op X = Complex.I • ( comm_op X * chi4_op X ) + ( Complex.I • ( comm_op X * chi4_op X ) ) ᴴ by rfl ] ; simp +decide [ add_comm, Matrix.IsHermitian ]

/-
Definitions of inner product and squared norm for vectors in C^n, using explicit sum to avoid potential namespace issues.
-/
open Matrix
open BigOperators

noncomputable def inner_prod {n : ℕ} (v w : Fin n → ℂ) : ℂ := ∑ i, (star (v i)) * (w i)

noncomputable def norm_sq {n : ℕ} (v : Fin n → ℂ) : ℝ := (inner_prod v v).re

/-
Projection operator onto the positive eigenspace of B.
-/
open Matrix

noncomputable def pos_proj (X : ℕ) : Matrix (Fin X) (Fin X) ℂ :=
  let hB := B_is_hermitian X
  let U : Matrix (Fin X) (Fin X) ℂ := hB.eigenvectorUnitary
  let D := hB.eigenvalues
  let P_diag := diagonal (fun i => if D i ≥ 0 then (1 : ℂ) else 0)
  U * P_diag * Uᴴ

/-
Structure capturing the assumptions of the user's strategy: the key identity, the projection property, and the eigenvalue growth.
-/
open Matrix
open BigOperators

structure StrategyAssumptions (X : ℕ) where
  (key_identity : inner_prod (g_vec X) (B_op X *ᵥ g_vec X) = 4 * (S₂ X : ℂ))
  (prime_projects_positive : norm_sq ((pos_proj X) *ᵥ (g_vec X)) > norm_sq ((1 - pos_proj X) *ᵥ (g_vec X)))
  (eigenvalue_growth : ∃ k : ℝ, k > 0 ∧ (Finset.univ.filter (fun i => (B_is_hermitian X).eigenvalues i > 3.9)).card ≥ k * Real.log X)

/-
Definition of the twin prime Gram matrix as provided by the user.
-/
open Matrix

noncomputable def twin_gram (X : ℕ) : Matrix (Fin X) (Fin X) ℝ :=
  fun i j => if i.val.Prime ∧ j.val.Prime ∧ |(i : ℤ) - (j : ℤ)| = 2 
             then Real.log i.val * Real.log j.val else 0

/-
Definition of the Strong Twin Prime Conjecture as S₂(X) ≥ 0.1 * √X.
-/
open Matrix
open BigOperators

def StrongTwinPrimeConjecture (X : ℕ) : Prop := S₂ X ≥ (1/10) * Real.sqrt X

/-
The twin prime sum S₂(X) is non-negative.
-/
open Matrix
open BigOperators

theorem S2_nonneg (X : ℕ) : S₂ X ≥ 0 := by
  exact Finset.sum_nonneg fun n _ => mul_nonneg ( by exact? ) ( by exact? )

/-
The twin prime Gram matrix is symmetric.
-/
open Matrix
open BigOperators

theorem twin_gram_is_symmetric (X : ℕ) : (twin_gram X).IsSymm := by
  unfold twin_gram;
  ext i j; aesop;
  · ring;
  · cases abs_cases ( ( j : ℤ ) - i ) <;> cases abs_cases ( ( i : ℤ ) - j ) <;> omega;
  · cases abs_cases ( ( i : ℤ ) - j ) <;> cases abs_cases ( ( j : ℤ ) - i ) <;> omega