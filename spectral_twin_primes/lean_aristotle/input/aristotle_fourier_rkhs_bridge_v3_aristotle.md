/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b75bc4c0-33da-49d1-8ded-ff33e14cb85e

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators Real Nat Classical Pointwise

-- Basic definitions
noncomputable def S₂ (N : ℕ) : ℝ :=
  ∑ n ∈ Finset.range (N + 1), ArithmeticFunction.vonMangoldt n * ArithmeticFunction.vonMangoldt (n + 2)

noncomputable def ξ (p : ℕ) : ℝ := Real.log p / (2 * Real.pi)

def is_twin_prime (p : ℕ) : Prop := Nat.Prime p ∧ Nat.Prime (p + 2)

noncomputable def T (X : ℕ) : Finset ℕ := (Finset.range (X + 1)).filter is_twin_prime

noncomputable def lambda (p : ℕ) : ℝ := ArithmeticFunction.vonMangoldt p * ArithmeticFunction.vonMangoldt (p + 2)

-- Simplified kernel for diagonal: K_comm(ξ_p, ξ_p) = K_diag(p)
noncomputable def K_diag (t : ℝ) (p : ℕ) : ℝ :=
  2 * Real.pi * t  -- Simplified: at diagonal, Gaussian factors = 1

-- Diagonal energy
noncomputable def ℰ_diag (X : ℕ) (t : ℝ) : ℝ :=
  ∑ p ∈ T X, (lambda p)^2 * K_diag t p

-- Full energy (abstract)
opaque ℰ_full : ℕ → ℝ → ℝ

theorem S₂_split (X : ℕ) : S₂ X = ∑ p ∈ T X, lambda p + ∑ n ∈ Finset.range (X + 1), if ¬is_twin_prime n then ArithmeticFunction.vonMangoldt n * ArithmeticFunction.vonMangoldt (n + 2) else 0 := by
  -- By definition of $S₂$, we can split the sum into two parts: one over twin primes and the other over non-twin primes.
  have h_split : S₂ X = ∑ p ∈ Finset.filter is_twin_prime (Finset.range (X + 1)), (ArithmeticFunction.vonMangoldt p) * (ArithmeticFunction.vonMangoldt (p + 2)) + ∑ p ∈ Finset.filter (fun p => ¬is_twin_prime p) (Finset.range (X + 1)), (ArithmeticFunction.vonMangoldt p) * (ArithmeticFunction.vonMangoldt (p + 2)) := by
    -- Apply the Finset.sum_filter_add_sum_filter_not theorem to split the sum into two parts.
    rw [Finset.sum_filter_add_sum_filter_not];
    rfl;
  -- The sum over the non-twin primes is the same as the sum over all n in the range where n is not a twin prime, but only including the terms where Λ(n) * Λ(n+2) is non-zero.
  simp [h_split, Finset.sum_ite];
  rfl

theorem K_diag_lower_bound (t : ℝ) (ht : t > 0) (p : ℕ) :
  K_diag t p ≥ 2 * Real.pi * t := by
  unfold K_diag
  linarith

lemma lambda_eq_log_mul_log {p : ℕ} (hp : is_twin_prime p) :
  lambda p = Real.log p * Real.log (p + 2) := by
    -- By definition of the von Mangoldt function, we know that $\Lambda(p) = \log p$ and $\Lambda(p+2) = \log(p+2)$ for prime $p$.
    have h_vonMangoldt : ArithmeticFunction.vonMangoldt p = Real.log p ∧ ArithmeticFunction.vonMangoldt (p + 2) = Real.log (p + 2) := by
      norm_num [ ArithmeticFunction.vonMangoldt, hp.1, hp.2 ];
      -- Since $p$ is prime, we have $\Lambda(p) = \log p$ and $\Lambda(p+2) = \log (p+2)$.
      have h_prime : IsPrimePow p ∧ IsPrimePow (p + 2) := by
        exact ⟨ hp.1.isPrimePow, hp.2.isPrimePow ⟩;
      aesop;
    exact h_vonMangoldt.1.symm ▸ h_vonMangoldt.2.symm ▸ rfl

lemma twin_prime_ge_3 {p : ℕ} (hp : is_twin_prime p) : p ≥ 3 := by
  -- Since $p$ is a prime number, the smallest possible value for $p$ is $2$. However, if $p = 2$, then $p + 2 = 4$, which is not prime. Therefore, $p$ must be at least $3$.
  by_cases hp2 : p = 2;
  · -- Since $p = 2$ is not a twin prime, this leads to a contradiction.
    simp [hp2, is_twin_prime] at hp;
    -- Since 4 is not a prime number, this leads to a contradiction.
    norm_num at hp;
  · -- Since $p$ is a prime number and $p \neq 2$, the smallest possible value for $p$ is $3$.
    apply Nat.succ_le_of_lt; exact lt_of_le_of_ne (Nat.Prime.two_le hp.1) (Ne.symm hp2)

lemma lambda_ge_const {p : ℕ} (hp : is_twin_prime p) :
  lambda p ≥ (Real.log 3)^2 := by
    -- Since $p$ is a twin prime, $p \geq 3$, thus $\log p \geq \log 3$.
    have h_log_p : Real.log p ≥ Real.log 3 := by
      exact Real.log_le_log ( by norm_num ) ( mod_cast hp.1.two_le.lt_of_ne' <| by rintro rfl; exact absurd hp.2 <| by decide );
    -- Since $p$ is a twin prime, $p \geq 3$, thus $\log (p + 2) \geq \log 3$.
    have h_log_p_plus_2 : Real.log (p + 2) ≥ Real.log 3 := by
      exact Real.log_le_log ( by norm_num ) ( by linarith [ show ( p : ℝ ) ≥ 3 by norm_cast; exact hp.1.two_le.lt_of_ne' <| by rintro rfl; exact absurd hp.2 <| by norm_num ] );
    -- Substitute the expression for $\lambda p$ from the definition.
    have h_lambda_eq : lambda p = Real.log p * Real.log (p + 2) := by
      exact?;
    nlinarith [ Real.log_pos ( show ( 3 : ℝ ) > 1 by norm_num ) ]

noncomputable def S₂_twins (X : ℕ) : ℝ := ∑ p ∈ T X, lambda p

theorem diag_lower_bound_twins (t : ℝ) (ht : t > 0) :
  ∃ C > 0, ∀ X, ℰ_diag X t ≥ C * S₂_twins X := by
    refine' ⟨ 2 * Real.pi * t * ( Real.log 3 ) ^ 2, mul_pos ( mul_pos ( by positivity ) ht ) ( sq_pos_of_pos <| Real.log_pos <| by norm_num ), fun X => _ ⟩;
    rw [ show ℰ_diag X t = ∑ p ∈ T X, ( lambda p ) ^ 2 * ( 2 * Real.pi * t ) from ?_ ];
    · rw [ show S₂_twins X = ∑ p ∈ T X, ( lambda p ) from ?_ ];
      · rw [ Finset.mul_sum _ _ _ ];
        exact Finset.sum_le_sum fun x hx => by nlinarith [ show 0 ≤ 2 * Real.pi * t * lambda x by exact mul_nonneg ( mul_nonneg ( by positivity ) ht.le ) ( show 0 ≤ lambda x by exact mul_nonneg ( ArithmeticFunction.vonMangoldt_nonneg ) ( ArithmeticFunction.vonMangoldt_nonneg ) ), show lambda x ≥ Real.log 3 ^ 2 by exact lambda_ge_const ( Finset.mem_filter.mp hx |>.2 ) ] ;
      · unfold S₂_twins T lambda; aesop;
    · exact Finset.sum_congr rfl fun p hp => by rw [ show K_diag t p = 2 * Real.pi * t by exact rfl ] ;

noncomputable def S₂_non_twins (X : ℕ) : ℝ :=
  ∑ n ∈ Finset.range (X + 1), if ¬is_twin_prime n then ArithmeticFunction.vonMangoldt n * ArithmeticFunction.vonMangoldt (n + 2) else 0

lemma S₂_split_restate (X : ℕ) : S₂ X = S₂_twins X + S₂_non_twins X := by
  rw [S₂_split, S₂_twins, S₂_non_twins]

def diag_dom_prop (t : ℝ) : Prop :=
  ∀ X, ℰ_full X t ≥ ℰ_diag X t

def S₂_twins_dominates_prop : Prop :=
  ∃ c > 0, ∃ X₀, ∀ X ≥ X₀, S₂_twins X ≥ c * S₂ X

def S₂_twins_dominates_stmt : Prop :=
  ∃ c > 0, ∃ X₀, ∀ X ≥ X₀, S₂_twins X ≥ c * S₂ X

theorem diag_lower_bound (t : ℝ) (ht : t > 0) (h_dom : S₂_twins_dominates_stmt) :
  ∃ C > 0, ∃ X₀ : ℕ, ∀ X ≥ X₀, ℰ_diag X t ≥ C * S₂ X := by
  -- Unpack the dominance hypothesis
  obtain ⟨c, hc_pos, X₀_dom, h_comp⟩ := h_dom
  -- Use the lower bound for the diagonal energy in terms of the twin prime sum
  obtain ⟨C_twins, hC_twins_pos, h_diag_twins⟩ := diag_lower_bound_twins t ht
  -- Combine the bounds
  use C_twins * c
  constructor
  · exact mul_pos hC_twins_pos hc_pos
  use X₀_dom
  intro X hX
  calc ℰ_diag X t ≥ C_twins * S₂_twins X := h_diag_twins X
    _ ≥ C_twins * (c * S₂ X) := by
      gcongr
      exact h_comp X (le_trans (by
      -- The inequality $X₀_dom \leq X₀_dom$ is trivially true.
      apply le_refl) hX) -- Need to handle X₀ vs X₀_dom, actually h_diag_twins holds for all X
    _ = (C_twins * c) * S₂ X := by ring

def diag_dom_stmt : Prop :=
  ∀ t > 0, t < 1 → ∀ X, ℰ_full X t ≥ ℰ_diag X t

theorem fourier_rkhs_lower (t : ℝ) (ht : t > 0) (ht_small : t < 1)
  (h_diag_dom : diag_dom_stmt) (h_twins_dom : S₂_twins_dominates_stmt) :
  ∃ C > 0, ∃ X₀ : ℕ, ∀ X ≥ X₀, ℰ_full X t ≥ C * S₂ X := by
  -- 1. Get diag_lower_bound
  obtain ⟨C, hC_pos, X₀, h_diag_bound⟩ := diag_lower_bound t ht h_twins_dom
  -- 2. Apply diag_dom
  use C, hC_pos, X₀
  intro X hX
  calc ℰ_full X t ≥ ℰ_diag X t := h_diag_dom t ht ht_small X
    _ ≥ C * S₂ X := h_diag_bound X hX

#check diag_dom_stmt
#check S₂_twins_dominates_stmt

theorem sum_G_upper (t : ℝ) (ht : t > 0) (N : ℕ) :
  ∑ i ∈ Finset.range N, ∑ j ∈ Finset.range N, Real.sqrt (2 * Real.pi * t) * Real.exp (-(i - j : ℝ)^2 / (8 * t)) ≤ (N : ℝ)^2 * Real.sqrt (2 * Real.pi * t) := by
    -- Since the exponential term is always positive and the square root term is a constant, we can factor out the square root term and sum the exponentials.
    have h_sum_exp : ∑ i ∈ Finset.range N, ∑ j ∈ Finset.range N, Real.exp (-((i : ℝ) - j) ^ 2 / (8 * t)) ≤ N^2 := by
      exact le_trans ( Finset.sum_le_sum fun i hi => Finset.sum_le_sum fun j hj => Real.exp_le_one_iff.mpr <| by rw [ div_le_iff₀ <| by positivity ] ; nlinarith ) <| by norm_num ; nlinarith;
    simpa only [ ← Finset.mul_sum _ _ _, ← Finset.sum_mul ] using by nlinarith [ Real.sqrt_nonneg ( 2 * Real.pi * t ) ] ;

theorem finite_twins_bounded_lambda :
  (∃ k : ℕ, ∀ X : ℕ, (T X).card ≤ k) →
  ∃ C : ℝ, ∀ X : ℕ, ∑ p ∈ T X, (lambda p)^2 ≤ C := by
    unfold lambda T at * ; aesop;
    -- Since the number of twin primes is finite, the sum over twin primes is also finite.
    have h_finite : Set.Finite {p : ℕ | is_twin_prime p} := by
      contrapose! h;
      obtain ⟨ p, hp ⟩ := Set.Infinite.exists_subset_card_eq h ( w + 1 );
      exact ⟨ p.sup id, lt_of_lt_of_le ( by aesop ) ( Finset.card_mono <| show p ⊆ Finset.filter is_twin_prime ( Finset.range ( p.sup id + 1 ) ) from fun x hx => Finset.mem_filter.mpr ⟨ Finset.mem_range.mpr <| Nat.lt_succ_of_le <| Finset.le_sup ( f := id ) hx, hp.1 hx ⟩ ) ⟩;
    use ∑ p ∈ h_finite.toFinset, ( ArithmeticFunction.vonMangoldt p * ArithmeticFunction.vonMangoldt ( p + 2 ) ) ^ 2;
    exact fun X => Finset.sum_le_sum_of_subset_of_nonneg ( fun x hx => by aesop ) fun _ _ _ => sq_nonneg _