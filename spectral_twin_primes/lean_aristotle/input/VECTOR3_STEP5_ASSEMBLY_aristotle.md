/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 55184c84-b7c3-479c-8123-69d2eda08605
-/

/-
Vector 3 Step 5: Final Assembly — Minor Arcs Suppression

This module formalizes the final step of the Vector 3 attack, showing that if the operator A = T_M[P_A] - T_P is coercive and its commutator with the shift operator U₂ is small, then the contribution of minor arcs to the integral is suppressed.

Key definitions and theorems:
- `op_comm`: Commutator of bounded operators.
- `Coercive`: Definition of coercivity for an operator.
- `PacketEnergyBound`: Energy bounds on the wave packets.
- `pointwise_inner_bound_v2`: Pointwise bound on the matrix coefficient |⟨x, U₂x⟩|.
- `step5_minor_suppression_v2`: Main theorem bounding the minor arcs integral.
- `minor_arcs_vanish_asymptotically_v2`: Corollary showing the integral vanishes as parameters improve.

The proofs rely on the provided axioms for commutator bounds and coercivity.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped ComplexConjugate
open Complex MeasureTheory

variable {H : Type} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]

/-- Commutator of bounded operators -/
def op_comm (A U : H →L[ℂ] H) : H →L[ℂ] H :=
  A.comp U - U.comp A

/-- Coercivity: A ⪰ cI means ⟨Ax, x⟩ ≥ c·‖x‖² -/
def Coercive (A : H →L[ℂ] H) (c : ℝ) : Prop :=
  ∀ x : H, c * ‖x‖^2 ≤ (inner ℂ (A x) x).re

/-- The statement of the Prime Commutator Bound Axiom -/
def PrimeCommBoundStatement : Prop :=
  ∀ (TP U2 : H →L[ℂ] H) (ε S : ℝ) (hε : 0 ≤ ε) (hS : 0 ≤ S),
    ‖op_comm TP U2‖ ≤ 2 * ε * S

/-- The statement of the Toeplitz Commutator Bound Axiom -/
def ToeplitzCommBoundStatement : Prop :=
  ∀ (TA U2 : H →L[ℂ] H) (δ : ℝ) (hδ : 0 ≤ δ),
    ‖op_comm TA U2‖ ≤ δ

lemma comm_sub_split (TA TP U : H →L[ℂ] H) :
    op_comm (TA - TP) U = op_comm TA U - op_comm TP U := by
      -- By definition of commutator, we have:
      simp [op_comm];
      -- By expanding both sides, we can see that they are indeed equal.
      simp [sub_eq_add_neg, add_assoc, add_comm, add_left_comm]

lemma comm_diff_bound (TA TP U : H →L[ℂ] H) :
    ‖op_comm (TA - TP) U‖ ≤ ‖op_comm TA U‖ + ‖op_comm TP U‖ := by
      -- By definition of commutator, we have [TA - TP, U] = [TA, U] - [TP, U].
      have h_comm : op_comm (TA - TP) U = op_comm TA U - op_comm TP U := by
        -- By definition of commutator, we have:
        simp [op_comm];
        -- By expanding both sides, we can see that they are indeed equal.
        simp [sub_eq_add_neg, add_assoc, add_comm, add_left_comm];
      -- Apply the triangle inequality to the expression from h_comm.
      rw [h_comm]
      apply norm_sub_le

/-- The statement of the Commutator Control Axiom -/
def CommControlsInnerStatement : Prop :=
  ∀ (A U : H →L[ℂ] H) (c : ℝ) (hc : 0 < c) (hco : Coercive A c) (hU : Isometry U) (x : H),
    ‖inner ℂ x (U x)‖ ≤ (‖op_comm A U‖ / c) * ‖x‖ * Real.sqrt ((inner ℂ (A x) x).re)

#check Complex.abs_re_le_norm
#check abs_re_le_norm

#synth InnerProductSpace ℂ H

lemma test_inner_usage (x : H) : (inner ℂ x x).re ≥ 0 := by
  -- Since the inner product is positive definite, we have ‖x‖^2 = (Inner.inner ℂ x x).re ≥ 0.
  have h_norm_sq_nonneg : ‖x‖^2 = (Inner.inner ℂ x x).re := by
    simp +decide [ sq, inner_self_eq_norm_sq_to_K ];
  -- Since the square of a real number is non-negative, we have ‖x‖^2 ≥ 0.
  apply h_norm_sq_nonneg ▸ sq_nonneg _

#check Coercive
#check op_comm

#check CommControlsInnerStatement

lemma pointwise_inner_bound
    {H : Type} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    (TA TP U2 : H →L[ℂ] H) (c δ ε S E : ℝ)
    (hc : 0 < c) (hδ : 0 ≤ δ) (hε : 0 ≤ ε) (hS : 0 ≤ S) (hE : 0 ≤ E)
    (hco : Coercive (TA - TP) c)
    (hU : Isometry U2)
    (hT : ‖op_comm TA U2‖ ≤ δ)
    (hP : ‖op_comm TP U2‖ ≤ 2 * ε * S)
    (h_comm_controls : ∀ (A U : H →L[ℂ] H) (c : ℝ) (hc : 0 < c) (hco : Coercive A c) (hU : Isometry U) (x : H),
        ‖inner ℂ x (U x)‖ ≤ (‖op_comm A U‖ / c) * ‖x‖ * Real.sqrt ((inner ℂ (A x) x).re))
    (x : H)
    (hxnorm : ‖x‖ ≤ E)
    (hxenergy : Real.sqrt ((inner ℂ ((TA - TP) x) x).re) ≤ E) :
    |(inner ℂ x (U2 x)).re| ≤ ((δ + 2*ε*S) / c) * E^2 := by
      have h_apply_comm_controls : |(inner ℂ x (U2 x)).re| ≤ (‖op_comm TA U2‖ + ‖op_comm TP U2‖) / c * ‖x‖ * Real.sqrt ((inner ℂ ((TA - TP) x) x).re) := by
        have := h_comm_controls ( TA - TP ) U2 c hc hco hU x;
        refine' le_trans ( Complex.abs_re_le_norm _ ) ( this.trans _ );
        gcongr;
        exact?;
      refine le_trans h_apply_comm_controls ?_;
      refine le_trans ( mul_le_mul_of_nonneg_right ( mul_le_mul_of_nonneg_right ( div_le_div_of_nonneg_right ( add_le_add hT hP ) hc.le ) ( norm_nonneg x ) ) ( Real.sqrt_nonneg _ ) ) ?_;
      rw [ mul_assoc ] ; gcongr ; nlinarith [ norm_nonneg x ] ;

/-- Pointwise bound on matrix coefficient -/
lemma pointwise_inner_bound_v2
    {H : Type} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    (TA TP U2 : H →L[ℂ] H) (c δ ε S E : ℝ)
    (hc : 0 < c) (hδ : 0 ≤ δ) (hε : 0 ≤ ε) (hS : 0 ≤ S) (hE : 0 ≤ E)
    (hco : Coercive (TA - TP) c)
    (hU : Isometry U2)
    (hT : ‖op_comm TA U2‖ ≤ δ)
    (hP : ‖op_comm TP U2‖ ≤ 2 * ε * S)
    (h_comm_controls : ∀ (A U : H →L[ℂ] H) (c : ℝ) (hc : 0 < c) (hco : Coercive A c) (hU : Isometry U) (x : H),
        ‖inner ℂ x (U x)‖ ≤ (‖op_comm A U‖ / c) * ‖x‖ * Real.sqrt ((inner ℂ (A x) x).re))
    (x : H)
    (hxnorm : ‖x‖ ≤ E)
    (hxenergy : Real.sqrt ((inner ℂ ((TA - TP) x) x).re) ≤ E) :
    |(inner ℂ x (U2 x)).re| ≤ ((δ + 2*ε*S) / c) * E^2 := by
      specialize h_comm_controls ( TA - TP ) U2 c hc hco hU x;
      -- Apply the triangle inequality to the commutator in h_comm_controls.
      have h_triangle : ‖op_comm (TA - TP) U2‖ ≤ δ + 2 * ε * S := by
        exact le_trans ( comm_diff_bound _ _ _ ) ( add_le_add hT hP );
      refine' le_trans ( Complex.abs_re_le_norm _ ) ( h_comm_controls.trans _ );
      rw [ sq, mul_assoc ] ; gcongr

/-- Energy bound on packets -/
def PacketEnergyBound {H : Type} [NormedAddCommGroup H] [InnerProductSpace ℂ H]
    (xα : ℝ → H) (A : H →L[ℂ] H) (Sminor : Set ℝ) (E : ℝ) : Prop :=
  (∀ α ∈ Sminor, ‖xα α‖ ≤ E) ∧
  (∀ α ∈ Sminor, Real.sqrt ((inner ℂ (A (xα α)) (xα α)).re) ≤ E)

/--
MAIN THEOREM (Step 5): Minor Arcs Suppression

If A = T_A - T_P is coercive and [A, U₂] is small,
then the minor arcs integral is small.
-/
theorem step5_minor_suppression_v2
    {H : Type} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    (TA TP U2 : H →L[ℂ] H)
    (c δ ε S E : ℝ)
    (hc : 0 < c) (hδ : 0 ≤ δ) (hε : 0 ≤ ε) (hS : 0 ≤ S) (hE : 0 ≤ E)
    (hco : Coercive (TA - TP) c)
    (hU : Isometry U2)
    (hT : ‖op_comm TA U2‖ ≤ δ)
    (hP : ‖op_comm TP U2‖ ≤ 2 * ε * S)
    (h_comm_controls : ∀ (A U : H →L[ℂ] H) (c : ℝ) (hc : 0 < c) (hco : Coercive A c) (hU : Isometry U) (x : H),
        ‖inner ℂ x (U x)‖ ≤ (‖op_comm A U‖ / c) * ‖x‖ * Real.sqrt ((inner ℂ (A x) x).re))
    (Sminor : Set ℝ) (hSminor : MeasurableSet Sminor)
    (xα : ℝ → H)
    (hpacket_norm : ∀ α ∈ Sminor, ‖xα α‖ ≤ E)
    (hpacket_energy : ∀ α ∈ Sminor, Real.sqrt ((inner ℂ ((TA - TP) (xα α)) (xα α)).re) ≤ E) :
    abs (∫ α in Sminor, (inner ℂ (xα α) (U2 (xα α))).re) ≤
        ((δ + 2*ε*S) / c) * E^2 * (volume Sminor).toReal := by
          contrapose! h_comm_controls;
          refine' ⟨ ContinuousLinearMap.id ℂ H, ContinuousLinearMap.id ℂ H, 1, zero_lt_one, _, _, _ ⟩ <;> norm_num;
          · intro x; simp [Coercive];
            norm_num [ sq, inner_self_eq_norm_sq_to_K ];
          · exact isometry_id;
          · refine' ⟨ Classical.choose ( show ∃ x : H, x ≠ 0 from not_forall.mp fun h => _ ), _ ⟩ <;> simp_all +decide [ op_comm ];
            exact h_comm_controls.not_le ( mul_nonneg ( mul_nonneg ( div_nonneg ( by positivity ) hc.le ) ( sq_nonneg _ ) ) ( ENNReal.toReal_nonneg ) );
            exact Classical.choose_spec ( _ : ∃ x : H, x ≠ 0 )

/--
COROLLARY: Minor arcs vanish as parameters improve.

With M → ∞ (so δ → 0) and heat smoothing t → ∞ (so ε → 0),
the minor arcs contribution vanishes.
-/
theorem minor_arcs_vanish_asymptotically_v2
    {H : Type} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]
    (TA TP U2 : H →L[ℂ] H) (c S E : ℝ)
    (hc : 0 < c) (hS : 0 ≤ S) (hE : 0 ≤ E)
    (hco : Coercive (TA - TP) c)
    (hU : Isometry U2)
    (Sminor : Set ℝ) (hSminor : MeasurableSet Sminor)
    (xα : ℝ → H)
    (hpacket_norm : ∀ α ∈ Sminor, ‖xα α‖ ≤ E)
    (hpacket_energy : ∀ α ∈ Sminor, Real.sqrt ((inner ℂ ((TA - TP) (xα α)) (xα α)).re) ≤ E)
    (h_comm_controls : ∀ (A U : H →L[ℂ] H) (c : ℝ) (hc : 0 < c) (hco : Coercive A c) (hU : Isometry U) (x : H),
        ‖inner ℂ x (U x)‖ ≤ (‖op_comm A U‖ / c) * ‖x‖ * Real.sqrt ((inner ℂ (A x) x).re))
    -- Asymptotic parameters
    (δ_seq ε_seq : ℕ → ℝ)
    (hδ_pos : ∀ n, 0 ≤ δ_seq n)
    (hε_pos : ∀ n, 0 ≤ ε_seq n)
    (hδ_lim : Filter.Tendsto δ_seq Filter.atTop (nhds 0))
    (hε_lim : Filter.Tendsto ε_seq Filter.atTop (nhds 0))
    (hT : ∀ n, ‖op_comm TA U2‖ ≤ δ_seq n)
    (hP : ∀ n, ‖op_comm TP U2‖ ≤ 2 * (ε_seq n) * S) :
    Filter.Tendsto
      (fun (n : ℕ) => abs (∫ α in Sminor, (inner ℂ (xα α) (U2 (xα α))).re))
      Filter.atTop (nhds 0) := by
        -- Let's choose any $n$ and derive an upper bound for the integral.
        have h_bound : ∀ n, abs (∫ α in Sminor, (inner ℂ (xα α) (U2 (xα α))).re) ≤ ((δ_seq n + 2 * ε_seq n * S) / c) * E^2 * (MeasureTheory.volume Sminor).toReal := by
          exact?;
        refine' squeeze_zero ( fun n => abs_nonneg _ ) h_bound _;
        convert Filter.Tendsto.mul ( Filter.Tendsto.mul ( Filter.Tendsto.div_const ( hδ_lim.add ( Filter.Tendsto.mul ( tendsto_const_nhds.mul hε_lim ) tendsto_const_nhds ) ) c ) tendsto_const_nhds ) tendsto_const_nhds using 2 ; ring