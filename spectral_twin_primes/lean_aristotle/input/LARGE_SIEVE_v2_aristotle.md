/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: fb45dd7b-42a7-4d85-a2dd-43c8e9f0a3ac
-/

/-
This module proves the minor arcs estimate for the Large Sieve, deriving it from the Large Sieve Integral (Parseval's identity) and the Prime Number Theorem. It establishes bounds for the integral of the exponential sum F(X, α) over minor arcs, showing that the contribution is o(X²).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Real Complex MeasureTheory Interval Set BigOperators Finset Nat

/-
Definitions of χ₄ and e.
-/
open scoped BigOperators ArithmeticFunction

def chi4 (n : ℤ) : ℂ := if n % 2 = 0 then 0 else if n % 4 = 1 then 1 else -1

noncomputable def e (x : ℝ) : ℂ := Complex.exp (2 * Real.pi * Complex.I * x)

/-
Definition of F(X, α).
-/
noncomputable def F (X α : ℝ) : ℂ := ∑ n ∈ range ⌊X⌋.toNat, (ArithmeticFunction.vonMangoldt n : ℂ) * chi4 n * e (n * α)

/-
Definition of F_coeff.
-/
noncomputable def F_coeff (n : ℕ) : ℂ := (ArithmeticFunction.vonMangoldt n : ℂ) * chi4 n

/-
Axiom 1: Large Sieve Integral (Orthogonality). This is Parseval's identity for exponential sums.
-/
theorem large_sieve_integral (N : ℕ) (a : ℕ → ℂ) :
  ∫ α in Icc 0 1, ‖∑ n ∈ range N, a n * e (n * α)‖^2 = ∑ n ∈ range N, ‖a n‖^2 := by
    -- Expand the square inside the integral.
    have h_expand : ∀ α : ℝ, ‖∑ n ∈ Finset.range N, a n * e (n * α)‖ ^ 2 = ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N, a n * starRingEnd ℂ (a m) * Complex.exp (2 * Real.pi * Complex.I * (n - m) * α) := by
      -- By definition of the norm squared, we have:
      have h_norm_sq : ∀ α : ℝ, ‖∑ n ∈ Finset.range N, a n * e (n * α)‖ ^ 2 = (∑ n ∈ Finset.range N, a n * e (n * α)) * (∑ m ∈ Finset.range N, starRingEnd ℂ (a m) * e (-m * α)) := by
        -- By definition of the norm squared, we have ‖z‖^2 = z * conjugate(z) for any complex number z.
        have h_norm_sq : ∀ z : ℂ, ‖z‖ ^ 2 = z * starRingEnd ℂ z := by
          exact?;
        aesop;
        unfold e; norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im ] ;
      intro α; rw [ h_norm_sq α ] ; rw [ Finset.sum_mul ] ; refine' Finset.sum_congr rfl fun i hi => _ ; rw [ Finset.mul_sum ] ; refine' Finset.sum_congr rfl fun j hj => _ ; ring;
      simp +decide [ e, mul_assoc, mul_comm, mul_left_comm, ← Complex.exp_add ];
      exact Or.inl ( by rw [ ← mul_assoc, ← Complex.exp_add ] ; ring );
    -- Integrate term by term.
    have h_integral_term_by_term : ∀ n m : ℕ, n < N → m < N → ∫ α in Set.Icc (0 : ℝ) 1, Complex.exp (2 * Real.pi * Complex.I * (n - m) * α) = if n = m then 1 else 0 := by
      aesop;
      -- Use the fact that the integral of a complex exponential over $[0, 1]$ is zero when $n \neq m$.
      have h_integral : ∫ α in Set.Icc (0 : ℝ) 1, Complex.exp (2 * Real.pi * Complex.I * (n - m) * α) = (1 / (2 * Real.pi * Complex.I * (n - m))) * (Complex.exp (2 * Real.pi * Complex.I * (n - m)) - 1) := by
        have := @integral_exp_mul_complex 0 1;
        rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le zero_le_one ] ; simpa [ div_eq_inv_mul ] using this ( show ( 2 * Real.pi * Complex.I * ( n - m ) ) ≠ 0 from mul_ne_zero ( mul_ne_zero ( mul_ne_zero two_ne_zero ( Complex.ofReal_ne_zero.mpr Real.pi_ne_zero ) ) Complex.I_ne_zero ) ( sub_ne_zero.mpr <| Nat.cast_injective.ne h ) ) ;
      exact h_integral.trans ( by rw [ Complex.exp_eq_one_iff.mpr ⟨ n - m, by push_cast; ring ⟩ ] ; ring );
    -- Apply Fubini's theorem to interchange the order of summation and integration.
    have h_fubini : ∫ α in Set.Icc (0 : ℝ) 1, ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N, a n * starRingEnd ℂ (a m) * Complex.exp (2 * Real.pi * Complex.I * (n - m) * α) = ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N, a n * starRingEnd ℂ (a m) * ∫ α in Set.Icc (0 : ℝ) 1, Complex.exp (2 * Real.pi * Complex.I * (n - m) * α) := by
      rw [ MeasureTheory.integral_finset_sum ];
      · exact Finset.sum_congr rfl fun i hi => by rw [ MeasureTheory.integral_finset_sum _ fun j hj => Continuous.integrableOn_Icc <| by continuity ] ; exact Finset.sum_congr rfl fun j hj => by rw [ MeasureTheory.integral_const_mul ] ;
      · exact fun _ _ => Continuous.integrableOn_Icc <| by continuity;
    convert congr_arg Complex.re h_fubini using 1;
    · rw [ ← funext h_expand ];
      norm_cast;
      exact Eq.symm ( by erw [ integral_ofReal ] ; norm_cast );
    · rw [ Finset.sum_congr rfl fun i hi => Finset.sum_congr rfl fun j hj => by rw [ h_integral_term_by_term i j ( Finset.mem_range.mp hi ) ( Finset.mem_range.mp hj ) ] ] ; norm_num [ Complex.normSq, Complex.sq_norm ];
      exact Finset.sum_congr rfl fun x hx => by rw [ if_pos ( Finset.mem_range.mp hx ) ] ; simp +decide [ Complex.mul_conj, Complex.normSq_apply, sq ] ;

/-
Axiom 2: Prime Number Theorem Bound.
-/
theorem h_prime_number_theorem : ∀ n : ℕ,
  ∑ p ∈ filter Nat.Prime (range (n + 1)), Real.log p ≤ n * Real.log 4 := by
    -- By the properties of the Chebyshev function, we know that $\sum_{p \leq n} \log p \leq n \log 4$ for all $n$.
    have h_chebyshev : ∀ n : ℕ, (∑ p ∈ Finset.filter Nat.Prime (Finset.range (n + 1)), Real.log p) ≤ n * Real.log 4 := by
      intro n
      have h_prod : (∏ p ∈ Finset.filter Nat.Prime (Finset.range (n + 1)), p) ≤ 4 ^ n := by
        induction' n using Nat.strong_induction_on with n ih;
        -- Consider two cases: $n$ is even and $n$ is odd.
        by_cases h_even : Even n;
        · obtain ⟨ k, rfl ⟩ := even_iff_two_dvd.mp h_even;
          -- For the even case, we can use the fact that $\prod_{p \leq 2k} p = \prod_{p \leq k} p \cdot \prod_{k < p \leq 2k} p$.
          have h_even_prod : ∏ p ∈ Finset.filter Nat.Prime (Finset.range (2 * k + 1)), p = (∏ p ∈ Finset.filter Nat.Prime (Finset.range (k + 1)), p) * (∏ p ∈ Finset.filter Nat.Prime (Finset.Ico (k + 1) (2 * k + 1)), p) := by
            rw [ Finset.range_eq_Ico, Finset.prod_filter, Finset.prod_filter, Finset.prod_filter ];
            rw [ Finset.prod_Ico_consecutive ] <;> linarith!;
          -- By the properties of primes, we know that $\prod_{k < p \leq 2k} p \leq \binom{2k}{k}$.
          have h_prime_prod_le_binom : (∏ p ∈ Finset.filter Nat.Prime (Finset.Ico (k + 1) (2 * k + 1)), p) ≤ Nat.choose (2 * k) k := by
            have h_prime_prod_le_binom : ∀ p ∈ Finset.filter Nat.Prime (Finset.Ico (k + 1) (2 * k + 1)), p ∣ Nat.choose (2 * k) k := by
              aesop;
              apply_mod_cast right.dvd_choose;
              · linarith;
              · omega;
              · linarith;
            refine' Nat.le_of_dvd ( Nat.choose_pos ( by linarith ) ) ( Nat.dvd_trans _ ( Nat.prod_primeFactors_dvd _ ) );
            apply_rules [ Finset.prod_dvd_prod_of_subset ];
            intro p hp; specialize h_prime_prod_le_binom p hp; aesop;
            exact absurd a <| Nat.ne_of_gt <| Nat.choose_pos <| by linarith;
          -- By the properties of binomial coefficients, we know that $\binom{2k}{k} \leq 4^k$.
          have h_binom_le_four_pow : Nat.choose (2 * k) k ≤ 4 ^ k := by
            rw [ show 4 ^ k = ( 2 : ℕ ) ^ ( 2 * k ) by norm_num [ pow_mul ] ];
            rw [ ← Nat.sum_range_choose ] ; exact Finset.single_le_sum ( fun x _ => Nat.zero_le _ ) ( Finset.mem_range.mpr ( by linarith ) );
          rcases k with ( _ | k ) <;> simp_all +decide [ pow_mul' ];
          exact le_trans ( Nat.mul_le_mul ( ih _ <| by linarith ) h_prime_prod_le_binom ) ( by rw [ sq ] ; exact Nat.mul_le_mul_left _ h_binom_le_four_pow );
        · -- Since $n$ is odd, we can write $n = 2k + 1$ for some integer $k$.
          obtain ⟨k, rfl⟩ : ∃ k, n = 2 * k + 1 := by
            exact n.even_or_odd.resolve_left h_even;
          -- By the properties of primes, we know that $\prod_{p \leq 2k+1} p \leq \binom{2k+1}{k} \prod_{p \leq k+1} p$.
          have h_prime_prod : ∏ p ∈ Finset.filter Nat.Prime (Finset.range (2 * k + 2)), p ≤ Nat.choose (2 * k + 1) k * ∏ p ∈ Finset.filter Nat.Prime (Finset.range (k + 2)), p := by
            have h_prime_prod : ∏ p ∈ Finset.filter Nat.Prime (Finset.Icc (k + 2) (2 * k + 1)), p ≤ Nat.choose (2 * k + 1) k := by
              have h_prime_prod : ∀ p ∈ Finset.filter Nat.Prime (Finset.Icc (k + 2) (2 * k + 1)), p ∣ Nat.choose (2 * k + 1) k := by
                aesop;
                apply_mod_cast right.dvd_choose;
                · grind;
                · omega;
                · grind;
              refine' Nat.le_of_dvd ( Nat.choose_pos ( by linarith ) ) ( Nat.dvd_trans _ ( Nat.prod_primeFactors_dvd _ ) );
              apply_rules [ Finset.prod_dvd_prod_of_subset ];
              intro p hp; specialize h_prime_prod p hp; aesop;
              exact absurd a <| Nat.ne_of_gt <| Nat.choose_pos <| by linarith;
            have h_prime_prod_split : ∏ p ∈ Finset.filter Nat.Prime (Finset.range (2 * k + 2)), p = (∏ p ∈ Finset.filter Nat.Prime (Finset.range (k + 2)), p) * (∏ p ∈ Finset.filter Nat.Prime (Finset.Icc (k + 2) (2 * k + 1)), p) := by
              erw [ Finset.prod_filter, Finset.prod_filter, Finset.prod_filter ];
              erw [ Finset.prod_range_mul_prod_Ico _ ( by linarith ) ];
            nlinarith [ show 0 ≤ ∏ p ∈ Finset.range ( k + 2 ) with Nat.Prime p, p from Finset.prod_nonneg fun _ _ => Nat.cast_nonneg _ ];
          -- By the induction hypothesis, we know that $\prod_{p \leq k+1} p \leq 4^{k+1}$.
          have h_ind : ∏ p ∈ Finset.filter Nat.Prime (Finset.range (k + 2)), p ≤ 4 ^ (k + 1) := by
            exact if hk : k = 0 then by subst hk; decide else ih _ ( by linarith [ Nat.pos_of_ne_zero hk ] );
          -- By the properties of binomial coefficients, we know that $\binom{2k+1}{k} \leq 2^{2k}$.
          have h_binom : Nat.choose (2 * k + 1) k ≤ 2 ^ (2 * k) := by
            exact?;
          norm_num [ pow_succ', pow_mul ] at *;
          exact h_prime_prod.trans ( by rw [ show ( 16 : ℕ ) ^ k = 4 ^ k * 4 ^ k by rw [ ← mul_pow ] ; norm_num ] ; nlinarith [ pow_pos ( show 0 < 4 by norm_num ) k ] )
      rw [ ← Real.log_prod ] <;> norm_cast <;> aesop;
      rw [ ← Real.log_rpow ] <;> norm_cast;
      exact Real.log_le_log ( Finset.prod_pos fun p hp => Nat.cast_pos.mpr <| Nat.Prime.pos <| by aesop ) <| by rw [ ← Nat.cast_prod ] ; exact_mod_cast h_prod;
    assumption

/-
Axiom 3: Coefficient L² Bound.
-/
theorem F_coeff_L2 (X : ℝ) (hX : X ≥ 2) :
  ∑ n ∈ range ⌊X⌋.toNat, ‖F_coeff n‖^2 ≤ 2 * X * Real.log X := by
    have h_bound : ∀ n : ℕ, ‖F_coeff n‖^2 ≤ (ArithmeticFunction.vonMangoldt n)^2 := by
      unfold F_coeff chi4; aesop;
    -- Since $\Lambda(n)$ is non-zero only for prime powers, we can bound the sum by considering only those terms.
    have h_prime_powers : ∑ n ∈ Finset.range (Int.toNat ⌊X⌋), (ArithmeticFunction.vonMangoldt n) ^ 2 ≤ ∑ p ∈ Finset.filter Nat.Prime (Finset.range (Int.toNat ⌊X⌋ + 1)), ∑ k ∈ Finset.Ico 1 (Nat.log p (Int.toNat ⌊X⌋) + 1), (Real.log p) ^ 2 := by
      have h_prime_powers : ∑ n ∈ Finset.range (Int.toNat ⌊X⌋), (ArithmeticFunction.vonMangoldt n) ^ 2 ≤ ∑ p ∈ Finset.filter Nat.Prime (Finset.range (Int.toNat ⌊X⌋ + 1)), ∑ k ∈ Finset.Ico 1 (Nat.log p (Int.toNat ⌊X⌋) + 1), (ArithmeticFunction.vonMangoldt (p ^ k)) ^ 2 := by
        have h_prime_powers : Finset.filter (fun n => ArithmeticFunction.vonMangoldt n ≠ 0) (Finset.range (Int.toNat ⌊X⌋)) ⊆ Finset.biUnion (Finset.filter Nat.Prime (Finset.range (Int.toNat ⌊X⌋ + 1))) (fun p => Finset.image (fun k => p ^ k) (Finset.Ico 1 (Nat.log p (Int.toNat ⌊X⌋) + 1))) := by
          intro n hn; simp_all +decide [ ArithmeticFunction.vonMangoldt ] ;
          rcases hn.2.1 with ⟨ p, k, hp, hk, rfl ⟩;
          refine' ⟨ p, ⟨ _, hp.nat_prime ⟩, k, ⟨ hk, _ ⟩, rfl ⟩;
          · norm_num +zetaDelta at *;
            exact Nat.lt_succ_of_le ( Nat.le_trans ( Nat.le_self_pow hk.ne' _ ) ( by linarith [ Int.toNat_of_nonneg ( Int.floor_nonneg.mpr ( by linarith : 0 ≤ X ) ) ] ) );
          · simp +zetaDelta at *;
            exact Nat.lt_succ_of_le ( Nat.le_log_of_pow_le hp.nat_prime.one_lt <| by linarith [ Int.toNat_of_nonneg <| show 0 ≤ ⌊X⌋ from Int.floor_nonneg.mpr <| by positivity ] );
        have h_prime_powers : ∑ n ∈ Finset.range (Int.toNat ⌊X⌋), (ArithmeticFunction.vonMangoldt n) ^ 2 ≤ ∑ n ∈ Finset.biUnion (Finset.filter Nat.Prime (Finset.range (Int.toNat ⌊X⌋ + 1))) (fun p => Finset.image (fun k => p ^ k) (Finset.Ico 1 (Nat.log p (Int.toNat ⌊X⌋) + 1))), (ArithmeticFunction.vonMangoldt n) ^ 2 := by
          refine' le_trans _ ( Finset.sum_le_sum_of_subset_of_nonneg h_prime_powers fun _ _ _ => sq_nonneg _ );
          rw [ Finset.sum_filter_of_ne ] ; aesop;
        refine le_trans h_prime_powers ?_;
        rw [ Finset.sum_biUnion ];
        · exact Finset.sum_le_sum fun p hp => by rw [ Finset.sum_image <| by intros a ha b hb hab; exact Nat.pow_right_injective ( Nat.Prime.one_lt <| Finset.mem_filter.mp hp |>.2 ) hab ] ;
        · intros p hp q hq hpq; simp_all +decide [ Finset.disjoint_left ];
          intro a x hx₁ hx₂ hx₃ y hy₁ hy₂ hy₃; subst_vars; have := Nat.Prime.dvd_of_dvd_pow hp.2 ( hy₃.symm ▸ dvd_pow_self _ ( by linarith ) ) ; simp_all +decide [ Nat.prime_dvd_prime_iff_eq ] ;
      convert h_prime_powers using 3;
      rw [ ArithmeticFunction.vonMangoldt_apply ] ; aesop;
      · rw [ Nat.Prime.pow_minFac ] <;> aesop;
      · exact False.elim <| h <| right.isPrimePow.pow <| by linarith;
    -- We'll use the fact that $\sum_{p \leq X} \sum_{k \leq \log_p X} (\log p)^2 \leq \sum_{p \leq X} \log p \cdot \log X$.
    have h_sum_bound : ∑ p ∈ Finset.filter Nat.Prime (Finset.range (Int.toNat ⌊X⌋ + 1)), ∑ k ∈ Finset.Ico 1 (Nat.log p (Int.toNat ⌊X⌋) + 1), (Real.log p) ^ 2 ≤ ∑ p ∈ Finset.filter Nat.Prime (Finset.range (Int.toNat ⌊X⌋ + 1)), Real.log p * Real.log X := by
      have h_sum_bound : ∀ p ∈ Finset.filter Nat.Prime (Finset.range (Int.toNat ⌊X⌋ + 1)), ∑ k ∈ Finset.Ico 1 (Nat.log p (Int.toNat ⌊X⌋) + 1), (Real.log p) ^ 2 ≤ Real.log p * Real.log X := by
        intros p hp
        have h_log_bound : Nat.log p (Int.toNat ⌊X⌋) * Real.log p ≤ Real.log X := by
          rw [ ← Real.log_pow ] ; gcongr ; norm_cast ; aesop;
          · exact pow_pos right.pos _;
          · exact le_trans ( mod_cast Nat.pow_log_le_self _ <| by linarith [ show ⌊X⌋.toNat > 0 from Nat.pos_of_ne_zero <| by norm_num; linarith [ show ⌊X⌋ > 0 from Int.floor_pos.mpr <| by linarith ] ] ) <| Nat.floor_le <| by positivity;
        simp_all +decide [ sq, mul_assoc, mul_comm, mul_left_comm ];
        simpa only [ ← mul_assoc ] using mul_le_mul_of_nonneg_right h_log_bound ( Real.log_nonneg ( Nat.one_le_cast.mpr hp.2.pos ) );
      exact Finset.sum_le_sum h_sum_bound;
    -- We'll use the fact that $\sum_{p \leq X} \log p \leq X \log 4$.
    have h_log_sum : ∑ p ∈ Finset.filter Nat.Prime (Finset.range (Int.toNat ⌊X⌋ + 1)), Real.log p ≤ X * Real.log 4 := by
      have := h_prime_number_theorem ( Int.toNat ⌊X⌋ );
      exact le_trans this ( mul_le_mul_of_nonneg_right ( Nat.floor_le ( by positivity ) ) ( Real.log_nonneg ( by norm_num ) ) );
    refine le_trans ( Finset.sum_le_sum fun _ _ => h_bound _ ) <| h_prime_powers.trans <| h_sum_bound.trans ?_;
    rw [ ← Finset.sum_mul _ _ _ ] ; exact mul_le_mul_of_nonneg_right ( h_log_sum.trans <| by nlinarith [ show Real.log 4 ≤ 2 by rw [ show ( 4 : ℝ ) = 2 ^ 2 by norm_num, Real.log_pow ] ; norm_num; linarith [ Real.log_le_sub_one_of_pos zero_lt_two ] ] ) <| Real.log_nonneg <| by linarith;

/-
Theorem 1: Parseval for F.
-/
theorem parseval_for_F (X : ℝ) (hX : X ≥ 2) :
  ∫ α in Icc 0 1, ‖F X α‖^2 = ∑ n ∈ range ⌊X⌋.toNat, ‖(ArithmeticFunction.vonMangoldt n : ℂ) * chi4 n‖^2 := by
  convert large_sieve_integral ( Int.toNat ( Int.floor X ) ) _

/-
Theorem 2: Total Integral Bound.
-/
theorem total_integral_bound (X : ℝ) (hX : X ≥ 2) :
  ∫ α in Icc 0 1, ‖F X α‖^2 ≤ 2 * X * Real.log X := by
  -- Apply the results from parseval_for_F and F_coeff_L2.
  have h_total_integral_bound : ∫ α in Set.Icc 0 1, ‖F X α‖^2 ≤ ∑ n ∈ range ⌊X⌋.toNat, ‖(ArithmeticFunction.vonMangoldt n : ℂ) * chi4 n‖^2 := by
    convert parseval_for_F X hX |> le_of_eq;
  exact h_total_integral_bound.trans ( F_coeff_L2 X hX )

/-
Magnitude of F at 1/4.
-/
lemma sum_vonMangoldt_odd (X : ℝ) (hX : X ≥ 2) :
  ‖F X (1/4)‖ = ∑ n ∈ filter Odd (range ⌊X⌋.toNat), ArithmeticFunction.vonMangoldt n := by
    unfold F;
    -- Simplify the sum using the fact that $\chi_4(n) \cdot e(n/4) = i$ for odd $n$ and $0$ for even $n$.
    have h_simp : ∑ n ∈ Finset.range ⌊X⌋.toNat, (Λ n) * (chi4 n) * (e (n * (1 / 4))) = ∑ n ∈ Finset.filter (fun n => Odd n) (Finset.range ⌊X⌋.toNat), (Λ n) * Complex.I := by
      rw [ Finset.sum_filter ] ; refine' Finset.sum_congr rfl fun n hn => _ ; rcases Nat.even_or_odd' n with ⟨ k, rfl | rfl ⟩ <;> norm_num [ chi4, e ] ; ring;
      rcases Nat.even_or_odd' k with ⟨ k, rfl | rfl ⟩ <;> norm_num <;> ring_nf <;> norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im, mul_assoc, mul_comm Real.pi _, mul_div ] at *;
      norm_num [ Real.cos_three_mul, Real.sin_three_mul, mul_div_assoc ];
    simp_all +decide [ Complex.norm_def, Complex.normSq ];
    rw [ Real.sqrt_mul_self <| Finset.sum_nonneg fun _ _ => ArithmeticFunction.vonMangoldt_nonneg ]

/-
Definition of the PNT lower bound property.
-/
def PsiLowerBound (X : ℝ) : Prop :=
  ∑ n ∈ range ⌊X⌋.toNat, ArithmeticFunction.vonMangoldt n ≥ X - X / (2 * Real.log X)

/-
Bound on the sum of von Mangoldt function over even numbers.
-/
lemma sum_vonMangoldt_even_bound (X : ℝ) (hX : X ≥ 2) :
  ∑ n ∈ filter Even (range ⌊X⌋.toNat), ArithmeticFunction.vonMangoldt n ≤ Real.log X := by
    -- By Lemma 25, the sum of von Mangoldt function over even numbers is at most the number of powers of 2 less than X times log 2.
    have h_even_sum_bound : ∑ n ∈ Finset.filter (fun n => Even n) (Finset.range (Int.toNat ⌊X⌋)), ArithmeticFunction.vonMangoldt n ≤ ∑ n ∈ Finset.filter (fun n => n % 2 = 0) (Finset.range (Int.toNat ⌊X⌋)), (if ∃ k : ℕ, n = 2^k ∧ k ≠ 0 then Real.log 2 else 0) := by
      have h_even_bound : ∀ n ∈ Finset.filter (fun n => n % 2 = 0) (Finset.range (Int.toNat ⌊X⌋)), ArithmeticFunction.vonMangoldt n ≤ if ∃ k : ℕ, n = 2^k ∧ k ≠ 0 then Real.log 2 else 0 := by
        aesop;
        · norm_num [ ArithmeticFunction.vonMangoldt ];
          split_ifs <;> norm_num [ Nat.Prime.pow_minFac, right.ne' ];
          positivity;
        · rw [ ArithmeticFunction.vonMangoldt_apply ];
          contrapose! h;
          aesop;
          rw [ isPrimePow_nat_iff ] at h_1 ; aesop;
          cases Nat.Prime.eq_two_or_odd left_1 <;> simp_all +decide [ Nat.pow_mod ];
          linarith;
      simpa [ Nat.even_iff ] using Finset.sum_le_sum h_even_bound;
    -- The number of powers of 2 less than $X$ is at most $\log_2 X$.
    have h_powers_of_two_count : Finset.card (Finset.filter (fun n => ∃ k : ℕ, n = 2^k ∧ k ≠ 0) (Finset.range (Int.toNat ⌊X⌋))) ≤ Nat.log 2 (Int.toNat ⌊X⌋) := by
      have h_powers_of_two_count : Finset.filter (fun n => ∃ k : ℕ, n = 2^k ∧ k ≠ 0) (Finset.range (Int.toNat ⌊X⌋)) ⊆ Finset.image (fun k => 2^k) (Finset.Ico 1 (Nat.log 2 (Int.toNat ⌊X⌋) + 1)) := by
        intro n hn; aesop;
        · exact Nat.pos_of_ne_zero right;
        · exact Nat.lt_succ_of_le ( Nat.le_log_of_pow_le ( by norm_num ) ( by linarith [ Int.toNat_of_nonneg ( show 0 ≤ ⌊X⌋ from Int.floor_nonneg.mpr ( by positivity ) ) ] ) );
      exact le_trans ( Finset.card_le_card h_powers_of_two_count ) ( Finset.card_image_le.trans ( by simpa ) );
    -- Since $\log_2 X \leq \log X / \log 2$, we can conclude that the sum is at most $\log X$.
    have h_log_bound : (Nat.log 2 (Int.toNat ⌊X⌋)) * Real.log 2 ≤ Real.log X := by
      rw [ ← Real.log_rpow zero_lt_two ];
      gcongr;
      exact le_trans ( mod_cast Nat.pow_log_le_self 2 <| by norm_num; linarith [ show ⌊X⌋ ≥ 1 by exact Int.floor_pos.mpr <| by linarith ] ) <| Nat.floor_le <| by positivity;
    simp_all +decide [ Finset.sum_ite ];
    exact h_even_sum_bound.trans ( le_trans ( mul_le_mul_of_nonneg_right ( Nat.cast_le.mpr <| le_trans ( Finset.card_le_card <| fun x hx => by aesop ) h_powers_of_two_count ) <| Real.log_nonneg one_le_two ) h_log_bound )

/-
Theorem 3: Major Arc Contribution (assuming PNT lower bound).
-/
theorem major_arc_contribution (X : ℝ) (hX : X ≥ 100) (h_psi : PsiLowerBound X) :
  ‖F X (1/4)‖^2 ≥ (X - X / Real.log X)^2 := by
  -- We have $‖F X (1 / 4)‖ = \sum_{n \text{ odd}} \Lambda(n)$ by sum_vonMangoldt_odd.
  have h_sum_odd : ‖F X (1 / 4)‖ = ∑ n ∈ filter Odd (range ⌊X⌋.toNat), ArithmeticFunction.vonMangoldt n := by
    convert sum_vonMangoldt_odd X ( by linarith ) using 1

  -- Also, $\sum_{n < X} \Lambda(n) = \sum_{n \text{ odd}} \Lambda(n) + \sum_{n \text{ even}} \Lambda(n)$.
  have h_sum_even : ∑ n ∈ range ⌊X⌋.toNat, ArithmeticFunction.vonMangoldt n = ∑ n ∈ filter Odd (range ⌊X⌋.toNat), ArithmeticFunction.vonMangoldt n + ∑ n ∈ filter Even (range ⌊X⌋.toNat), ArithmeticFunction.vonMangoldt n := by
    rw [ Finset.sum_filter, Finset.sum_filter ] ; rw [ ← Finset.sum_add_distrib ] ; congr ; ext n ; aesop;

  -- Substitute these into the inequality.
  have h_subst : ‖F X (1 / 4)‖ ≥ X - X / (2 * Real.log X) - Real.log X := by
    linarith [ h_psi, show ∑ n ∈ Finset.range ⌊X⌋.toNat, ArithmeticFunction.vonMangoldt n ≥ X - X / ( 2 * Real.log X ) from h_psi, show ∑ n ∈ Finset.range ⌊X⌋.toNat with Even n, ArithmeticFunction.vonMangoldt n ≤ Real.log X from sum_vonMangoldt_even_bound X <| by linarith ] ;

  -- Squaring both sides gives the desired result.
  have h_sq : ‖F X (1 / 4)‖ ^ 2 ≥ (X - X / (2 * Real.log X) - Real.log X) ^ 2 := by
    bound;
    rw [ sub_div', le_div_iff₀ ] <;> nlinarith [ Real.log_pos <| show 1 < X by linarith, Real.log_le_sub_one_of_pos <| show 0 < X by linarith, mul_le_mul_of_nonneg_right ( show Real.log X ≥ 1 by exact Real.le_log_iff_exp_le ( by linarith ) |>.2 <| by exact Real.exp_one_lt_d9.le.trans <| by norm_num; linarith ) <| Real.log_nonneg <| show 1 ≤ X by linarith ] ;

  -- We need to show $X - X/(2\log X) - \log X \geq X - X/\log X$.
  suffices h_ineq : X - X / (2 * Real.log X) - Real.log X ≥ X - X / Real.log X by
    exact le_trans ( pow_le_pow_left₀ ( sub_nonneg.2 <| by rw [ div_le_iff₀ <| Real.log_pos <| by linarith ] ; nlinarith [ Real.le_log_iff_exp_le ( by linarith : 0 < X ) |>.2 <| by exact Real.exp_one_lt_d9.le.trans <| by norm_num; linarith ] ) h_ineq 2 ) h_sq

  -- This simplifies to $X/(2\log X) \geq \log X$, or $X \geq 2(\log X)^2$.
  have h_simplified : X ≥ 2 * (Real.log X) ^ 2 := by
    -- We'll use that $Real.log X \leq Real.sqrt X / 2$ for $X \geq 100$.
    have h_log_bound : Real.log X ≤ Real.sqrt X / 2 := by
      have := Real.log_le_sub_one_of_pos ( by positivity : 0 < Real.sqrt X / 10 );
      rw [ Real.log_div ( by positivity ) ( by positivity ), Real.log_sqrt ( by positivity ) ] at this;
      have := Real.log_two_lt_d9 ; norm_num at * ; rw [ show ( 10 : ℝ ) = 2 * 5 by norm_num, Real.log_mul ] at * <;> norm_num at *;
      rw [ show ( 5 : ℝ ) = 2 ^ 2 * 1.25 by norm_num, Real.log_mul, Real.log_pow ] at * <;> norm_num at *;
      nlinarith [ Real.sqrt_nonneg X, Real.sq_sqrt ( show 0 ≤ X by linarith ), Real.log_le_sub_one_of_pos ( show 0 < 5 / 4 by norm_num ) ];
    nlinarith only [ Real.log_nonneg ( by linarith : ( 1 : ℝ ) ≤ X ), Real.log_le_sub_one_of_pos ( by linarith : 0 < X ), h_log_bound, Real.sq_sqrt ( by linarith : 0 ≤ X ) ]

  -- This holds for $X \geq 100$.
  exact (by
  ring_nf at *; nlinarith [ inv_pos.mpr ( Real.log_pos ( show X > 1 by linarith ) ), mul_inv_cancel₀ ( ne_of_gt ( Real.log_pos ( show X > 1 by linarith ) ) ) ] ;)



/-
Theorem 4: Minor Arcs Bound (Corrected).
The user's original bound was too strong (negative for large X), so we prove the valid bound derived from the total integral.
-/
theorem minor_arcs_estimate (X : ℝ) (hX : X ≥ 100) (δ : ℝ) (hδ : 0 < δ) :
  let minor := {α : ℝ | |α - 1/4| > δ ∧ |α - 3/4| > δ} ∩ Icc 0 1
  ∫ α in minor, ‖F X α‖^2 ≤ 2 * X * Real.log X := by
  refine' le_trans ( MeasureTheory.setIntegral_mono_set _ _ _ ) ( total_integral_bound X ( by linarith ) );
  · refine' Continuous.integrableOn_Icc _;
    refine' Continuous.pow _ _;
    refine' Continuous.norm _;
    exact continuous_finset_sum _ fun _ _ => Continuous.mul ( continuous_const ) ( Complex.continuous_exp.comp <| by continuity );
  · exact Filter.Eventually.of_forall fun α => sq_nonneg _;
  · exact MeasureTheory.ae_of_all _ fun x hx => hx.2

open Asymptotics Filter

#check (fun (X : ℝ) => X) =o[atTop] (fun (X : ℝ) => X^2)

/-
Corollary: Minor Arcs are o(X²).
-/
theorem minor_arcs_vanish (δ : ℝ) (hδ : 0 < δ) :
  (fun X => ∫ α in {α | |α - 1/4| > δ ∧ |α - 3/4| > δ} ∩ Icc 0 1, ‖F X α‖^2)
  =o[atTop] (fun X => X^2) := by
  refine' Asymptotics.isLittleO_iff.2 _;
  -- Using the bound from the total integral, we can show that the integral over the minor arcs is bounded by $2X \log X$.
  have h_min_bound : ∀ X ≥ 100, ∫ α in {α : ℝ | |α - 1/4| > δ ∧ |α - 3/4| > δ} ∩ Set.Icc 0 1, ‖F X α‖^2 ≤ 2 * X * Real.log X := by
    exact?;
  -- We'll use the fact that $2X \log X / X^2 = 2 \log X / X$ and show that this tends to $0$ as $X \to \infty$.
  have h_log_div_X : Filter.Tendsto (fun X : ℝ => 2 * Real.log X / X) Filter.atTop (nhds 0) := by
    -- Let $y = \frac{1}{x}$, so we can rewrite the limit as $\lim_{y \to 0^+} 2y \log(1/y)$.
    suffices h_log_recip : Filter.Tendsto (fun y : ℝ => 2 * y * Real.log (1 / y)) (Filter.map (fun x => 1 / x) Filter.atTop) (nhds 0) by
      exact h_log_recip.congr ( by simp +contextual [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm ] );
    norm_num;
    exact tendsto_nhdsWithin_of_tendsto_nhds ( by have := Real.continuous_mul_log.tendsto 0; simpa [ mul_assoc ] using this.neg.const_mul 2 );
  intro c hc;
  filter_upwards [ Filter.eventually_ge_atTop 100, h_log_div_X.eventually ( gt_mem_nhds <| show 0 < c by positivity ) ] with X hX₁ hX₂ ; rw [ Real.norm_of_nonneg ( by positivity ) ] ; rw [ Real.norm_of_nonneg ( by positivity ) ] ; nlinarith [ h_min_bound X hX₁, mul_div_cancel₀ ( 2 * Real.log X ) ( by positivity : X ≠ 0 ) ]