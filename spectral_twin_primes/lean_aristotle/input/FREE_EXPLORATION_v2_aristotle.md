/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 3d7c623a-e13e-4e8d-a4e3-5f73ff41c9a9
-/

/-
Formalized the Circle Method approach to the Twin Prime Conjecture. Defined `CircleMethodContext` to bundle the axioms. Proved `T_split_complete` showing the decomposition of the singular series. Proved `S2_lower_bound_from_resonance` establishing the lower bound on the singular series. Finally, proved `TPC_from_circle_method` showing that the Twin Prime Conjecture follows from the Circle Method estimates.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Set MeasureTheory intervalIntegral Filter Real

opaque CircleMethodProps : Type
opaque CircleMethodEstimates_Tight : Type
opaque integrand (X : ℝ) : ℝ → ℂ
opaque T_chi4 (X : ℝ) : ℂ
opaque Minor (X : ℝ) : ℂ
opaque Major (X : ℝ) : ℂ
opaque S2 (X : ℝ) : ℝ
opaque TPC : Prop

opaque minor_arcs (X : ℝ) : Set ℝ
opaque major_arcs (X : ℝ) : Set ℝ

structure CircleMethodContext where
  arcs_union : ∀ X : ℝ, minor_arcs X ∪ major_arcs X = Icc 0 1
  arcs_disjoint : ∀ X : ℝ, Disjoint (minor_arcs X) (major_arcs X)
  measurable_minor : ∀ X : ℝ, MeasurableSet (minor_arcs X)
  measurable_major : ∀ X : ℝ, MeasurableSet (major_arcs X)
  Minor_def : ∀ X : ℝ, Minor X = ∫ α in minor_arcs X, integrand X α
  Major_def : ∀ X : ℝ, Major X = ∫ α in major_arcs X, integrand X α
  intervalIntegral_eq_setIntegral_Icc : ∀ f : ℝ → ℂ, ∀ a b : ℝ, a ≤ b → ∫ x in a..b, f x = ∫ x in Ioc a b, f x
  setIntegral_Ioc_eq_setIntegral_Icc : ∀ {a b : ℝ} {f : ℝ → ℂ}, ∫ x in Ioc a b, f x = ∫ x in Icc a b, f x
  continuous_integrand : ∀ X : ℝ, Continuous (integrand X)
  integrable_integrand : ∀ X : ℝ, IntegrableOn (integrand X) (Icc 0 1) volume
  T_eq_integral_Icc : ∀ X : ℝ, T_chi4 X = ∫ α in Icc 0 1, integrand X α
  arithmetic_bound_tight : ∀ X > 100, 1 + X/(log X)^2 ≤ X/log X
  minor_arcs_bound : (props : CircleMethodProps) → (ests : CircleMethodEstimates_Tight) → ∀ X > 100, ‖Minor X‖ ≤ X / log X

/-
Minor and Major arcs are subsets of [0, 1].
-/
lemma minor_subset_Icc (ctx : CircleMethodContext) (X : ℝ) : minor_arcs X ⊆ Icc 0 1 := by
  rw [← ctx.arcs_union X]
  exact subset_union_left

lemma major_subset_Icc (ctx : CircleMethodContext) (X : ℝ) : major_arcs X ⊆ Icc 0 1 := by
  rw [← ctx.arcs_union X]
  exact subset_union_right

/-
Integrand is integrable on Minor and Major arcs.
-/
lemma integrable_minor (ctx : CircleMethodContext) (X : ℝ) : IntegrableOn (integrand X) (minor_arcs X) volume := by
  apply IntegrableOn.mono_set (ctx.integrable_integrand X) (minor_subset_Icc ctx X)

lemma integrable_major (ctx : CircleMethodContext) (X : ℝ) : IntegrableOn (integrand X) (major_arcs X) volume := by
  apply IntegrableOn.mono_set (ctx.integrable_integrand X) (major_subset_Icc ctx X)

/-
T splits into Minor + Major integrals over the respective arcs.
-/
theorem T_split_complete (ctx : CircleMethodContext) (props : CircleMethodProps) (X : ℝ) :
  T_chi4 X = Minor X + Major X := by
  rw [ctx.T_eq_integral_Icc X]
  rw [← ctx.arcs_union X]
  rw [setIntegral_union (ctx.arcs_disjoint X) (ctx.measurable_major X) (integrable_minor ctx X) (integrable_major ctx X)]
  rw [ctx.Minor_def X, ctx.Major_def X]

/-
S2 is bounded below by X/log^2, derived from Major arcs resonance dominating the error term.
-/
lemma norm_sub_le_implies_norm_ge {A B : ℂ} {K : ℝ} {c C : ℝ}
  (hA : ‖A‖ ≥ c * K)
  (h_diff : ‖A - B‖ ≤ C * K) :
  ‖B‖ ≥ (c - C) * K := by
    linarith [ norm_sub_norm_le A B ]

theorem S2_lower_bound_from_resonance
  (ctx : CircleMethodContext)
  (props : CircleMethodProps)
  (ests : CircleMethodEstimates_Tight)
  (h_S2_nonneg : ∀ X, S2 X ≥ 0)
  (h_major : ∃ C > 0, ∀ X > 100, ‖Major X - (-(S2 X : ℂ))‖ ≤ C * (X / (log X)^2))
  (h_resonance : ∃ c > 0, ∀ X > 100, ‖Major X‖ ≥ c * (X / (log X)^2))
  (h_constants : ∃ C c, (∀ X > 100, ‖Major X - (-(S2 X : ℂ))‖ ≤ C * (X / (log X)^2)) ∧
                        (∀ X > 100, ‖Major X‖ ≥ c * (X / (log X)^2)) ∧
                        c > C) :
  ∃ c > 0, ∀ X > 100, S2 X ≥ c * X / (log X)^2 := by
    aesop;
    -- By combining the inequalities from left_2 and right_2, we can derive that $S2(X) \geq (c - C) * (X / \log X^2)$ for some $c > C$.
    have h_combined : ∀ X > 100, S2 X ≥ (w_3 - w_2) * (X / Real.log X ^ 2) := by
      intros X hX
      have h_norm : ‖Major X + S2 X‖ ≤ w_2 * (X / Real.log X ^ 2) := left_2 X hX
      have h_norm_major : ‖Major X‖ ≥ w_3 * (X / Real.log X ^ 2) := left_3 X hX
      have h_norm_sub : ‖Major X + S2 X - Major X‖ ≥ w_3 * (X / Real.log X ^ 2) - w_2 * (X / Real.log X ^ 2) := by
        have := norm_sub_le ( Major X + S2 X ) ( Major X + S2 X - Major X ) ; aesop;
        linarith [ left_3 X hX, left_2 X hX ];
      norm_num at *;
      linarith [ abs_of_nonneg ( h_S2_nonneg X ) ];
    exact ⟨ w_3 - w_2, sub_pos.mpr right_2, fun X hX => by simpa only [ mul_div_assoc ] using h_combined X hX ⟩

/-
If ‖A‖ ≥ cK and ‖A - B‖ ≤ CK, then ‖B‖ ≥ (c - C)K.
-/
lemma norm_sub_le_implies_norm_ge_aux {E : Type*} [NormedAddCommGroup E] {A B : E} {K : ℝ} {c C : ℝ}
  (hA : ‖A‖ ≥ c * K)
  (h_diff : ‖A - B‖ ≤ C * K) :
  ‖B‖ ≥ (c - C) * K := by
  have h_tri : ‖A‖ - ‖B‖ ≤ ‖A - B‖ := norm_sub_norm_le A B
  linarith

/-
The Twin Prime Conjecture follows from the Circle Method if S2 grows linearly and the error terms are controlled.
-/
theorem TPC_from_circle_method
  (ctx : CircleMethodContext)
  (props : CircleMethodProps)
  (ests : CircleMethodEstimates_Tight)
  (h_S2_linear : ∃ c > 0, ∀ X > 100, S2 X ≥ c * X)
  (h_major_approx : ∃ C > 0, ∀ X > 100, ‖Major X - (-(S2 X : ℂ))‖ ≤ C * (X / (log X)^2))
  (h_infinite_twins : (∀ B, ∃ X, ‖T_chi4 X‖ > B) → TPC)
  (h_TPC_iff : TPC ↔ ∀ N : ℕ, ∃ p : ℕ, p > N ∧ p.Prime ∧ (p + 2).Prime) :
  ∀ N : ℕ, ∃ p : ℕ, p > N ∧ p.Prime ∧ (p + 2).Prime := by
  rw [← h_TPC_iff]
  apply h_infinite_twins
  intro B
  obtain ⟨c, hc_pos, h_S2⟩ := h_S2_linear
  obtain ⟨C, hC_pos, h_maj⟩ := h_major_approx
  -- We want to find X such that ‖T_chi4 X‖ > B
  -- ‖T_chi4 X‖ ≥ S2 X - error - |Minor|
  -- S2 X ≥ cX
  -- error ≤ C X / log^2 X
  -- |Minor| ≤ X / log X
  -- So ‖T_chi4 X‖ ≥ cX - ... which goes to infinity.
  -- Use the triangle inequality and bounds to show that ‖T_chi4 X‖ is unbounded.
  have h_unbounded : ∀ X : ℝ, X > 100 → ‖T_chi4 X‖ ≥ S2 X - C * (X / (Real.log X)^2) - X / (Real.log X) := by
    intro X hX
    have h_triangle : ‖T_chi4 X‖ ≥ ‖Major X‖ - ‖Minor X‖ := by
      have := T_split_complete ctx props X;
      have := norm_sub_le ( T_chi4 X ) ( Minor X ) ; aesop;
    have := norm_sub_le ( Major X + ( S2 X : ℂ ) ) ( Major X ) ; aesop;
    linarith [ abs_le.mp this, h_maj X hX, show ‖Minor X‖ ≤ X / Real.log X from by simpa [ abs_div, abs_of_pos ( show 0 < X by linarith ), abs_of_pos ( show 0 < Real.log X by exact Real.log_pos <| by linarith ) ] using ctx.minor_arcs_bound props ests X hX ];
  -- Use the fact that $S2 X \geq c * X$ to show that $S2 X - C * (X / \log^2 X) - X / \log X$ tends to infinity as $X \to \infty$.
  have h_tends_to_infinity : Filter.Tendsto (fun X : ℝ => c * X - C * (X / (Real.log X)^2) - X / (Real.log X)) Filter.atTop Filter.atTop := by
    -- We can factor out $X$ and use the fact that $\frac{1}{\log^2 X}$ and $\frac{1}{\log X}$ tend to $0$ as $X \to \infty$.
    have h_factor : Filter.Tendsto (fun X : ℝ => X * (c - C / (Real.log X)^2 - 1 / Real.log X)) Filter.atTop Filter.atTop := by
      -- We can use the fact that $c - C / (\log X)^2 - 1 / \log X$ tends to $c$ as $X \to \infty$.
      have h_limit : Filter.Tendsto (fun X : ℝ => c - C / (Real.log X)^2 - 1 / Real.log X) Filter.atTop (nhds c) := by
        exact le_trans ( Filter.Tendsto.sub ( tendsto_const_nhds.sub ( tendsto_const_nhds.div_atTop ( Filter.Tendsto.comp ( Filter.tendsto_pow_atTop ( by positivity ) ) ( Real.tendsto_log_atTop ) ) ) ) ( tendsto_const_nhds.div_atTop ( Real.tendsto_log_atTop ) ) ) ( by norm_num );
      apply_rules [ Filter.tendsto_id.atTop_mul, h_limit ];
    exact h_factor.congr fun x => by ring;
  have := h_tends_to_infinity.eventually_gt_atTop B; have := this.and ( Filter.eventually_gt_atTop 100 ) ; obtain ⟨ X, hX₁, hX₂ ⟩ := this.exists; exact ⟨ X, lt_of_lt_of_le ( by linarith [ h_S2 X hX₂ ] ) ( h_unbounded X hX₂ ) ⟩ ;