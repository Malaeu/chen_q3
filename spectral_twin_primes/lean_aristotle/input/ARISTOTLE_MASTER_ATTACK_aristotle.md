/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a52aeaf3-4be0-4de6-85bc-b58d37ecfa4e

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators

-- Character mod 4
def χ₄ (n : ℤ) : ℤ :=
  if n % 2 = 0 then 0 else if n % 4 = 1 then 1 else -1

-- Exponential
noncomputable def e (x : ℝ) : ℂ := Complex.exp (2 * Real.pi * Complex.I * x)

-- Von Mangoldt
noncomputable def Λ : ℕ → ℝ := ArithmeticFunction.vonMangoldt

open Finset

-- The exponential sum
noncomputable def F (X : ℝ) (α : ℝ) : ℂ :=
  Finset.sum (Finset.range ⌊X⌋₊) (fun n => (Λ n : ℂ) * (χ₄ n : ℂ) * e (n * α))

-- Minor arcs
def is_minor (α : ℝ) (X : ℝ) (δ : ℝ) : Prop :=
  |α - 1/4| ≥ δ ∧ |α - 3/4| ≥ δ

-- The correlation sum
noncomputable def T_χ₄ (X : ℝ) : ℝ :=
  Finset.sum (Finset.range ⌊X⌋₊) (fun n => Λ n * χ₄ n * Λ (n+2) * χ₄ (n+2))

-- Twin prime count
noncomputable def S₂ (X : ℝ) : ℝ :=
  Finset.sum (Finset.range ⌊X⌋₊) (fun n => Λ n * Λ (n+2))

noncomputable def primes_up_to (X : ℝ) : Finset ℕ :=
  (Finset.range (⌊X⌋₊ + 1)).filter Nat.Prime

theorem resonance_identity (n : ℕ) (h : n % 2 = 1) :
  (χ₄ n : ℂ) * e (n / 4) = Complex.I := by
    unfold χ₄ e;
    norm_cast ; aesop;
    · rw [ ← Nat.mod_add_div n 4, h_1 ] ; norm_num ; ring;
      norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im, mul_assoc, mul_comm Real.pi _, mul_div ];
    · rw [ ← Nat.mod_add_div n 4 ] ; norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im, mul_div ] at *;
      rw [ ← Nat.mod_mod_of_dvd n ( by decide : 2 ∣ 4 ) ] at h; have := Nat.mod_lt n zero_lt_four; interval_cases n % 4 <;> norm_num at * ; ring_nf ; norm_num [ mul_div, mul_assoc, mul_comm Real.pi _, mul_left_comm ] ;
      norm_num [ ( by ring : 3 / 2 * Real.pi = Real.pi + Real.pi / 2 ), Real.cos_add, Real.sin_add ]

theorem afm_structure (p : ℕ) (hp : p.Prime) (hp2 : (p+2).Prime) (h : p > 2) :
  χ₄ p * χ₄ (p+2) = -1 := by
    unfold χ₄;
    -- Since $p$ is an odd prime greater than 2, $p \mod 4$ must be either 1 or 3.
    have h_mod4 : (p : ℤ) % 4 = 1 ∨ (p : ℤ) % 4 = 3 := by
      cases Nat.Prime.eq_two_or_odd hp <;> omega;
    grind

theorem main_term_negative (X : ℝ) (hX : X > 100) :
  (‖F X (1/4)‖^2 * (e (-1/2)).re) < 0 := by
    -- The real part of $e(-1/2)$ is $\cos(\pi) = -1$, which is negative.
    have h_e_neg : (e (-1 / 2)).re = Real.cos Real.pi := by
      -- By definition of $e$, we have $e(-1/2) = \exp(2\pi i \cdot (-1/2))$.
      simp [e];
      norm_num [ Complex.exp_re, mul_div ];
    by_cases h : ‖F X ( 1 / 4 )‖ = 0 <;> aesop;
    -- If $F(X, 1/4) = 0$, then the sum $\sum_{n \leq X} \Lambda(n) \chi_4(n) e(n/4)$ must be zero.
    have h_sum_zero : ∑ n ∈ Finset.range ⌊X⌋₊, (Λ n : ℂ) * (χ₄ n : ℂ) * e (n / 4) = 0 := by
      convert h using 1;
    -- Since $\chi_4(n) e(n/4) = i$ for odd $n$, the sum $\sum_{n \leq X} \Lambda(n) \chi_4(n) e(n/4)$ simplifies to $\sum_{n \leq X} \Lambda(n) i$.
    have h_sum_simplified : ∑ n ∈ Finset.range ⌊X⌋₊, (Λ n : ℂ) * (χ₄ n : ℂ) * e (n / 4) = ∑ n ∈ Finset.filter (fun n => n % 2 = 1) (Finset.range ⌊X⌋₊), (Λ n : ℂ) * Complex.I := by
      rw [ Finset.sum_filter, Finset.sum_congr rfl ] ; aesop;
      · rw [ mul_assoc, ← resonance_identity x ( by simpa [ ← Nat.odd_iff, parity_simps ] using h_1 ) ];
      · unfold χ₄; norm_cast; aesop;
    simp_all +decide [ Complex.ext_iff, Finset.sum_ite ];
    rw [ Finset.sum_eq_zero_iff_of_nonneg ] at h_sum_zero <;> aesop;
    · have := h_sum_zero 3 ( by exact Nat.le_floor <| by norm_num; linarith ) rfl;
      -- Since $\Lambda(3) = \log(3)$ and $\log(3) \neq 0$, this leads to a contradiction.
      have h_contra : Λ 3 = Real.log 3 := by
        unfold Λ;
        norm_num [ ArithmeticFunction.vonMangoldt ];
        exact fun h => False.elim <| h <| by native_decide;
      linarith [ Real.log_pos ( by norm_num : ( 3 : ℝ ) > 1 ) ];
    · exact ( by rw [ show Λ i = ArithmeticFunction.vonMangoldt i by rfl ] ; exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact by rw [ ArithmeticFunction.vonMangoldt_apply ] ; positivity ) ) ) ) ) ) ) ) ) ) ) ) )

theorem T_equals_neg_S2 (X : ℝ) (hX : X > 0) :
  |T_χ₄ X - (-S₂ X)| ≤ 10 := by
  -- Therefore, $|T_χ₄ X - (-S₂ X)| = \sum_{n \text{ even}} \Lambda(n) \Lambda(n+2)$.
  have h_diff : |T_χ₄ X - (-S₂ X)| = ∑ n ∈ Finset.range (Nat.floor X), if n % 2 = 0 then Λ n * Λ (n + 2) else 0 := by
    unfold T_χ₄ S₂;
    -- By definition of $χ₄$, we know that $χ₄(n) * χ₄(n+2) = -1$ if $n$ is odd and $χ₄(n) * χ₄(n+2) = 0$ if $n$ is even.
    have h_char : ∀ n : ℕ, (χ₄ n : ℝ) * (χ₄ (n + 2) : ℝ) = if n % 2 = 0 then 0 else -1 := by
      unfold χ₄; aesop;
      all_goals omega;
    simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ];
    simp_all +decide [ ← mul_assoc, ← Finset.sum_add_distrib ];
    rw [ abs_of_nonneg ] <;> norm_num [ Finset.sum_add_distrib ];
    · rw [ ← Finset.sum_add_distrib ] ; congr ; ext ; aesop;
    · rw [ ← Finset.sum_add_distrib ];
      exact Finset.sum_nonneg fun x hx => by split_ifs <;> nlinarith [ show 0 ≤ Λ x * Λ ( x + 2 ) by exact mul_nonneg ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact by { unfold Λ; aesop } ) ) ) ) ) ) ) ) ) ) ) ) ) ) ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact by { unfold Λ; aesop } ) ) ) ) ) ) ) ) ) ) ) ) ) ] ;
  -- The only even $n$ for which $\Lambda(n) \Lambda(n+2)$ is non-zero is $n=2$ (since $n$ and $n+2$ must be powers of 2).
  have h_even_contribution : ∀ n ∈ Finset.range (Nat.floor X), n % 2 = 0 → (Λ n) * (Λ (n + 2)) = if n = 2 then (Real.log 2) * (Real.log 2) else 0 := by
    unfold Λ; aesop;
    · norm_num [ ArithmeticFunction.vonMangoldt ];
      rw [ if_pos, if_pos ];
      · native_decide +revert;
      · native_decide +revert;
    · unfold ArithmeticFunction.vonMangoldt; aesop;
      contrapose! h; aesop;
      cases left ; cases left_1 ; aesop;
      cases left.nat_prime.eq_two_or_odd <;> simp_all +decide [ Nat.pow_mod ];
      have := congr_arg ( · % 4 ) right_3 ; rcases w_2 with ( _ | _ | w_2 ) <;> rcases w_3 with ( _ | _ | w_3 ) <;> norm_num [ Nat.pow_succ', ← mul_assoc, Nat.pow_mul, Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] at *;
      · have := Nat.Prime.eq_two_or_odd left_1.nat_prime; simp_all +decide [ Nat.add_mod, Nat.mul_mod ] ;
      · have := Nat.mod_lt w_1 zero_lt_four; interval_cases w_1 % 4 <;> norm_num at *;
        rcases Nat.even_or_odd' w_3 with ⟨ k, rfl | rfl ⟩ <;> norm_num [ Nat.pow_add, Nat.pow_mul, Nat.mul_mod, Nat.pow_mod ] at *;
  simp_all +decide [ Finset.sum_ite ];
  split_ifs <;> nlinarith [ Real.log_nonneg one_le_two, Real.log_le_sub_one_of_pos zero_lt_two ]

noncomputable def S_sum (X : ℝ) (θ : ℝ) : ℂ :=
  Finset.sum (Finset.range ⌊X⌋₊) (fun n => (Λ n : ℂ) * e (n * θ))

lemma F_eq_S_diff (X : ℝ) (α : ℝ) :
  F X α = (S_sum X (α + 1/4) - S_sum X (α - 1/4)) / (2 * Complex.I) := by
    unfold F S_sum;
    rw [ ← Finset.sum_sub_distrib, Finset.sum_div ];
    refine Finset.sum_congr rfl fun n hn => ?_;
    rcases Nat.even_or_odd' n with ⟨ k, rfl | rfl ⟩ <;> norm_num [ χ₄, Complex.ext_iff, Complex.exp_re, Complex.exp_im ] ; ring;
    · norm_num [ Complex.exp_re, Complex.exp_im, e ] ; ring ; norm_num;
      norm_num [ Real.sin_add, Real.cos_add, mul_assoc, mul_comm Real.pi ];
    · rcases Nat.even_or_odd' k with ⟨ k, rfl | rfl ⟩ <;> push_cast <;> ring_nf <;> norm_num [ Complex.normSq, Complex.div_re, Complex.div_im, Complex.exp_re, Complex.exp_im ];
      · unfold e; norm_num [ Complex.exp_re, Complex.exp_im ] ; ring;
        norm_num [ Real.sin_add, Real.sin_sub, Real.cos_add, Real.cos_sub, mul_assoc, mul_comm Real.pi ] ; ring_nf ; norm_num;
        norm_num [ mul_div ];
        ring;
      · unfold e; norm_num [ Complex.exp_re, Complex.exp_im ] ; ring;
        norm_num [ ( by ring : Real.pi * ( 3 / 2 ) = Real.pi / 2 + Real.pi ), ( by ring : Real.pi * ( -3 / 2 ) = - ( Real.pi / 2 ) - Real.pi ), Real.sin_add, Real.sin_sub, Real.cos_add, Real.cos_sub ] ; ring_nf;
        norm_num [ mul_assoc, mul_comm Real.pi ]

lemma orthogonality_integral (k : ℤ) :
  ∫ α in (0:ℝ)..1, e (k * α) = if k = 0 then 1 else 0 := by
    split_ifs <;> simp_all +decide [ Complex.exp_ne_zero, intervalIntegral.integral_comp_mul_left ];
    · -- By definition of $e$, we have $e(0) = \exp(2\pi i \cdot 0) = \exp(0) = 1$.
      simp [e];
    · -- The integral of $e^{2\pi i x}$ over $[0, k]$ is zero because it is a periodic function with period 1.
      have h_integral_zero : ∀ k : ℤ, k ≠ 0 → ∫ x in (0 : ℝ)..k, Complex.exp (2 * Real.pi * Complex.I * x) = 0 := by
        intro k hk_ne; have := @integral_exp_mul_complex 0 ( k : ℝ ) ; aesop;
        exact sub_eq_zero_of_eq ( Complex.exp_eq_one_iff.mpr ⟨ k, by ring ⟩ );
      convert h_integral_zero k ‹_› using 1

noncomputable def coeff (n : ℕ) : ℂ := (Λ n : ℂ) * (χ₄ n : ℂ)

lemma norm_sq_F_expansion (X : ℝ) (α : ℝ) :
  ‖F X α‖^2 = ∑ n ∈ Finset.range ⌊X⌋₊, ∑ m ∈ Finset.range ⌊X⌋₊, coeff n * coeff m * e ((n - m) * α) := by
    have h_expand : ‖F X α‖ ^ 2 = (∑ n ∈ Finset.range ⌊X⌋₊, coeff n * e (n * α)) * (∑ m ∈ Finset.range ⌊X⌋₊, coeff m * e (-m * α)) := by
      have h_expand : ‖F X α‖^2 = (F X α) * (starRingEnd ℂ (F X α)) := by
        rw [ Complex.mul_conj, Complex.normSq_eq_norm_sq, Complex.ofReal_pow ];
      convert h_expand using 2;
      unfold coeff F e; norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im ] ;
    -- By expanding the product of the two sums, we can see that it is equal to the double sum.
    rw [h_expand];
    simp +decide only [sum_mul, mul_assoc, sub_mul];
    simp +decide only [e, mul_assoc, mul_left_comm, Finset.mul_sum _ _ _, sub_eq_add_neg];
    exact Finset.sum_congr rfl fun _ _ => Finset.sum_congr rfl fun _ _ => by push_cast; rw [ ← Complex.exp_add ] ; ring;

lemma integral_e_n_m_minus_2 (n m : ℕ) :
  ∫ α in (0:ℝ)..1, e ((n - m - 2) * α) = if n = m + 2 then 1 else 0 := by
    have h_integral : ∀ k : ℤ, ∫ α in (0:ℝ)..1, e (k * α) = if k = 0 then 1 else 0 := by
      bound;
      · -- The integral of the constant function 1 over the interval [0, 1] is just the length of the interval, which is 1.
        simp [e];
      · have := @orthogonality_integral;
        aesop;
    specialize h_integral ( ( n - m - 2 ) : ℤ ) ; aesop;
    -- Rearrange the equation $n - m - 2 = 0$ to get $n = m + 2$.
    linarith