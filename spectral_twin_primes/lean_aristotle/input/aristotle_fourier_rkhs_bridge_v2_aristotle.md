/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ad1d306c-a6e3-43ab-b2cf-7250c6b27db3

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

noncomputable def S₂ (N : ℕ) : ℝ :=
  ∑ n ∈ Finset.range (N + 1), ArithmeticFunction.vonMangoldt n * ArithmeticFunction.vonMangoldt (n + 2)

noncomputable def ξ (p : ℕ) : ℝ := Real.log p / (2 * Real.pi)

noncomputable def w (r : ℕ) : ℝ := 2 * ArithmeticFunction.vonMangoldt r / Real.sqrt r

noncomputable def G (t δ : ℝ) : ℝ := Real.sqrt (2 * Real.pi * t) * Real.exp (-δ^2 / (8 * t))

def is_twin_prime (p : ℕ) : Prop := Nat.Prime p ∧ Nat.Prime (p + 2)

noncomputable def T (X : ℕ) : Finset ℕ := (Finset.range (X + 1)).filter is_twin_prime

noncomputable def K_comm (X : ℕ) (t : ℝ) (u v : ℝ) : ℝ :=
  ∑ r ∈ Finset.range (X + 1), ∑ s ∈ Finset.range (X + 1),
    w r * w s * G t (u - ξ r) * G t (v - ξ s) * G t (ξ s - ξ r) * ((u - ξ s) * (v - ξ r) / 4 + t)

noncomputable def lambda (p : ℕ) : ℝ := ArithmeticFunction.vonMangoldt p * ArithmeticFunction.vonMangoldt (p + 2)

noncomputable def ℰ_X (X : ℕ) (t : ℝ) : ℝ :=
  ∑ p ∈ T X, ∑ q ∈ T X, lambda p * lambda q * K_comm X t (ξ p) (ξ q)

noncomputable def ℰ_X_diag (X : ℕ) (t : ℝ) : ℝ :=
  ∑ p ∈ T X, (lambda p)^2 * K_comm X t (ξ p) (ξ p)

noncomputable def S₂_twin (X : ℕ) : ℝ :=
  ∑ n ∈ Finset.range (X + 1), if is_twin_prime n then ArithmeticFunction.vonMangoldt n * ArithmeticFunction.vonMangoldt (n + 2) else 0

noncomputable def S₂_rest (X : ℕ) : ℝ :=
  ∑ n ∈ Finset.range (X + 1), if is_twin_prime n then 0 else ArithmeticFunction.vonMangoldt n * ArithmeticFunction.vonMangoldt (n + 2)

def S₂_split_stmt : Prop := ∀ (X : ℕ), S₂ X = S₂_twin X + S₂_rest X

def lemma1_stmt : Prop := ∀ (t : ℝ) (ht : t > 0)
  (h_diag_dom : ∀ X, ℰ_X X t ≥ ℰ_X_diag X t)
  (h_diag_bound : ∃ C > 0, ∃ X₀ : ℕ, ∀ X ≥ X₀, ℰ_X_diag X t ≥ C * S₂ X),
  ∃ C₁ > 0, ∃ X₀ : ℕ, ∀ X ≥ X₀, ℰ_X X t ≥ C₁ * S₂ X

def K_comm_PSD_stmt : Prop := ∀ (X : ℕ) (t : ℝ) (ht : t > 0) (c : ℕ → ℝ),
  ∑ p ∈ T X, ∑ q ∈ T X, c p * c q * K_comm X t (ξ p) (ξ q) ≥ 0

/-
S₂ is the sum of S₂_twin and S₂_rest.
-/
theorem S₂_split (X : ℕ) : S₂ X = S₂_twin X + S₂_rest X := by
  unfold S₂ S₂_twin S₂_rest
  rw [← Finset.sum_add_distrib]
  apply Finset.sum_congr rfl
  intro x _
  by_cases h : is_twin_prime x
  · simp [h]
  · simp [h]

/-
Axiom provided by the user.
-/
theorem lemma1 (t : ℝ) (ht : t > 0)
  (h_diag_dom : ∀ X, ℰ_X X t ≥ ℰ_X_diag X t)
  (h_diag_bound : ∃ C > 0, ∃ X₀ : ℕ, ∀ X ≥ X₀, ℰ_X_diag X t ≥ C * S₂ X) :
  ∃ C₁ > 0, ∃ X₀ : ℕ, ∀ X ≥ X₀, ℰ_X X t ≥ C₁ * S₂ X := by
    exact ⟨ h_diag_bound.choose, h_diag_bound.choose_spec.1, h_diag_bound.choose_spec.2.choose, fun X hX => le_trans ( h_diag_bound.choose_spec.2.choose_spec X hX ) ( h_diag_dom X ) ⟩

/-
Definition: The kernel is non-negative for all pairs of twin primes.
-/
def K_comm_nonneg_stmt (t : ℝ) : Prop :=
  ∀ X : ℕ, ∀ p ∈ T X, ∀ q ∈ T X, K_comm X t (ξ p) (ξ q) ≥ 0

/-
The total energy dominates the diagonal energy (assuming non-negative kernel).
-/
theorem diag_dominance (t : ℝ) (ht : t > 0) (ht_small : t < 1)
  (h_nonneg : K_comm_nonneg_stmt t) :
  ∀ X, ℰ_X X t ≥ ℰ_X_diag X t := by
    unfold ℰ_X ℰ_X_diag; aesop;
    -- Since $K_{\text{comm}}(X,t)(\xi_p,\xi_q) \geq 0$ for all $p, q \in T_X$, we can apply the non-negativity of the kernel to each term in the double sum.
    have h_nonneg_term : ∀ p ∈ T X, ∀ q ∈ T X, 0 ≤ (lambda p) * (lambda q) * K_comm X t (ξ p) (ξ q) := by
      bound;
      · refine' mul_nonneg _ _ <;> aesop;
      · exact mul_nonneg ( ArithmeticFunction.vonMangoldt_nonneg ) ( ArithmeticFunction.vonMangoldt_nonneg );
      · exact h_nonneg X p a q a_1;
    exact Finset.sum_le_sum fun p hp => by simpa only [ sq ] using Finset.single_le_sum ( fun q hq => h_nonneg_term p hp q hq ) hp;