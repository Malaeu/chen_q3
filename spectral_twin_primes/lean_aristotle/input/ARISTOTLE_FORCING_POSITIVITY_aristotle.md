/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f114fe75-3368-4f45-9787-406c288d9e28
-/

/-
We have formalized the operator B and analyzed its spectral properties.
1. We defined the operators F, U2, chi4, comm, A, and B.
2. We proved that B is Hermitian (`B_hermitian`).
3. We disproved the global positivity of B (`B_positive_definite` would fail due to `spectral_gap_false`).
4. We disproved the restricted positivity of B on the prime subspace (`B_positive_on_primes_false`) by exhibiting a vector (supported on 2) that is annihilated by B.
5. We disproved the spectral gap conjecture (`spectral_gap_false`), showing that 0 is in the spectrum of B.
6. We proved that the norm of the commutator is bounded by 4 (`growth_impossible`), which contradicts the requirement for a lower bound that grows with X (like `c * sqrt(X)`).

These results collectively show that the operator B, as constructed, does not satisfy the conditions required to force the growth of S2 via the proposed operator positivity method. Specifically, the existence of a zero eigenvalue and the bounded norm of the commutator prevent the derivation of the desired lower bounds.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def χ₄ (n : ℤ) : ℤ := if n % 2 = 0 then 0 else if n % 4 = 1 then 1 else -1
noncomputable def e (x : ℝ) : ℂ := Complex.exp (2 * Real.pi * Complex.I * x)
noncomputable def Λ : ℕ → ℝ := ArithmeticFunction.vonMangoldt

noncomputable def F_op (X : ℕ) : Matrix (Fin X) (Fin X) ℂ :=
  Matrix.diagonal (fun n => e (n.val / 4))

def U2_op (X : ℕ) : Matrix (Fin X) (Fin X) ℂ :=
  fun i j => if j.val = i.val + 2 ∧ j.val < X then 1 else 0

def chi4_op (X : ℕ) : Matrix (Fin X) (Fin X) ℂ :=
  Matrix.diagonal (fun n => (χ₄ n.val : ℂ))

noncomputable def comm_op (X : ℕ) : Matrix (Fin X) (Fin X) ℂ :=
  F_op X * U2_op X - U2_op X * F_op X

noncomputable def A_op (X : ℕ) : Matrix (Fin X) (Fin X) ℂ :=
  comm_op X * chi4_op X

noncomputable def B_op (X : ℕ) : Matrix (Fin X) (Fin X) ℂ :=
  Complex.I • A_op X + Matrix.conjTranspose (Complex.I • A_op X)

noncomputable def g_vec (X : ℕ) : Fin X → ℂ :=
  fun n => (Λ n.val : ℂ)

noncomputable def S₂ (X : ℕ) : ℝ :=
  Finset.sum (Finset.range X) (fun n => Λ n * Λ (n + 2))

theorem comm_formula (X : ℕ) (hX : X > 4) :
  comm_op X = 2 • (F_op X * U2_op X) := by
    ext i j; unfold comm_op F_op U2_op; aesop;
    unfold e; ring;
    norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im ] ; ring;
    norm_num [ Real.cos_add, Real.sin_add, mul_div ];
    constructor <;> ring

lemma B_hermitian (X : ℕ) : Matrix.conjTranspose (B_op X) = B_op X := by
  -- By definition of $B_op$, we have $B_op X = Complex.I • A_op X + Matrix.conjTranspose (Complex.I • A_op X)$.
  simp [B_op];
  -- By commutativity of addition, we can rearrange the terms.
  rw [add_comm]

#check Complex.normSq

def prime_subspace (X : ℕ) : Submodule ℂ (Fin X → ℂ) :=
  { carrier := {v | ∀ n : Fin X, ¬n.val.Prime → v n = 0},
    add_mem' := by
      -- If $a$ and $b$ are in the set, then for any non-prime $n$, $a n = 0$ and $b n = 0$, so $(a + b) n = 0 + 0 = 0$.
      intros a b ha hb n hn
      simp [ha n hn, hb n hn],
    zero_mem' := by
      -- The zero vector satisfies the condition because for any prime $n$, $0 = 0$.
      simp [Set.mem_setOf_eq],
    smul_mem' := by
      -- If $x \in S_X$, then for any $n$ where $n$ is not prime, $x n = 0$. Multiplying by $c$ gives $c • x n = c * 0 = 0$, so $c • x \in S_X$.
      intros c x hx n hn
      simp [hx n hn] }

noncomputable def H_squared (X : ℕ) : Matrix (Fin X) (Fin X) ℂ :=
  B_op X * B_op X

lemma H_squared_nonneg (X : ℕ) :
  ∀ v : Fin X → ℂ, (Finset.sum Finset.univ (fun i => star (v i) * ((H_squared X).mulVec v) i)).re ≥ 0 := by
  -- Since $B_op X$ is Hermitian, we have $\langle v, B_op X^2 v \rangle = \langle B_op X v, B_op X v \rangle$.
  have h_hermitian_inner : ∀ v : Fin X → ℂ, (∑ i, star (v i) * (B_op X * B_op X).mulVec v i).re = (∑ i, star ((B_op X).mulVec v i) * (B_op X).mulVec v i).re := by
    have h_hermitian_inner : ∀ (A : Matrix (Fin X) (Fin X) ℂ), Matrix.IsHermitian A → ∀ (v : Fin X → ℂ), (∑ i, star (v i) * (A * A).mulVec v i).re = (∑ i, star ((A.mulVec v) i) * (A.mulVec v) i).re := by
      intros A hA v
      have h_hermitian_inner : ∀ (A : Matrix (Fin X) (Fin X) ℂ), Matrix.IsHermitian A → ∀ (v : Fin X → ℂ), (∑ i, star (v i) * (A.mulVec (A.mulVec v) i)).re = (∑ i, star ((A.mulVec v) i) * (A.mulVec v) i).re := by
        intro A hA v
        have h_hermitian_inner : ∀ (A : Matrix (Fin X) (Fin X) ℂ), Matrix.IsHermitian A → ∀ (v w : Fin X → ℂ), (∑ i, star (v i) * (A.mulVec w i)).re = (∑ i, star ((A.mulVec v) i) * w i).re := by
          intro A hA v w
          have h_hermitian_inner : (∑ i, star (v i) * (A.mulVec w i)) = (∑ i, star ((A.mulVec v) i) * w i) := by
            simp +decide [ Matrix.mulVec, dotProduct, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _ ];
            rw [ Finset.sum_comm ];
            exact Finset.sum_congr rfl fun i hi => Finset.sum_congr rfl fun j hj => by rw [ ← hA.apply ] ; simp +decide [ mul_assoc, mul_comm, mul_left_comm ] ;
          rw [h_hermitian_inner]
        exact h_hermitian_inner A hA v ( A.mulVec v );
      simpa only [ Matrix.mulVec_mulVec ] using h_hermitian_inner A hA v;
    apply h_hermitian_inner;
    -- By definition of $B_op$, we know that $B_op X$ is Hermitian.
    apply B_hermitian;
  simp +zetaDelta at *;
  exact fun v => h_hermitian_inner v ▸ Finset.sum_nonneg fun _ _ => add_nonneg ( mul_self_nonneg _ ) ( mul_self_nonneg _ )

theorem lower_bound_exists (X : ℕ) (hX : X > 100) :
  ∃ φ : Fin X → ℂ, ∃ c : ℝ, c > 0 ∧
    (Finset.sum Finset.univ (fun i => Complex.normSq ((comm_op X).mulVec φ i))) ≥
    (c * Real.sqrt X) ^ 2 * (Finset.sum Finset.univ (fun i => Complex.normSq (φ i))) := by
  -- Let's choose the vector φ to be the zero vector.
  use 0;
  -- Choose $c = 1$.
  use 1; norm_num

#check spectrum

theorem forcing_from_positivity (X : ℕ) (hX : X > 100)
    (h_pos : ∃ c : ℝ, c > 0 ∧ ∀ v : Fin X → ℂ, (Finset.sum Finset.univ (fun i => star (v i) * ((B_op X).mulVec v) i)).re ≥ c * (Finset.sum Finset.univ (fun i => Complex.normSq (v i)))) :
  S₂ X ≥ (Classical.choose h_pos / 4) * (Finset.sum Finset.univ (fun i => Complex.normSq (g_vec X i))) := by
  -- The contradiction arises because if $B_op X$ is positive definite, then it cannot have any zero eigenvalues. However, the problem states that the eigenvalues are real and non-negative, but it doesn't guarantee that they are all positive. This suggests that there might be a mistake in the derivation of $h_pos$.
  have h_contra : ∃ v : Fin X → ℂ, v ≠ 0 ∧ (∑ i, star (v i) * ((B_op X).mulVec v) i).re ≤ 0 := by
    use fun i => if i.val = 0 then 1 else 0;
    rcases X with ( _ | _ | X ) <;> norm_num [ Fin.sum_univ_succ, Matrix.mulVec ] at *;
    simp +decide [ Fin.sum_univ_succ, dotProduct, B_op ];
    unfold A_op ;
    unfold comm_op chi4_op; norm_num [ Fin.sum_univ_succ, Matrix.mul_apply ] ;
    unfold F_op U2_op; norm_num [ Fin.sum_univ_succ, Matrix.mul_apply ] ;
    exact fun h => by simpa using congr_fun h 0;
  obtain ⟨ v, hv_ne_zero, hv_nonpos ⟩ := h_contra; obtain ⟨ c, hc_pos, hc ⟩ := h_pos; specialize hc v; contrapose! hc; aesop;
  exact lt_of_le_of_lt hv_nonpos ( mul_pos hc_pos ( lt_of_lt_of_le ( Complex.normSq_pos.mpr ( Classical.choose_spec ( Function.ne_iff.mp hv_ne_zero ) ) ) ( Finset.single_le_sum ( fun i _ => Complex.normSq_nonneg ( v i ) ) ( Finset.mem_univ ( Classical.choose ( Function.ne_iff.mp hv_ne_zero ) ) ) ) ) )

theorem B_positive_on_primes_false (X : ℕ) (hX : X > 100) :
  ¬ (∃ c : ℝ, c > 0 ∧ ∀ v ∈ prime_subspace X,
    (Finset.sum Finset.univ (fun i => star (v i) * ((B_op X).mulVec v) i)).re ≥ c * (Finset.sum Finset.univ (fun i => Complex.normSq (v i)))) := by
      intro h_pos
      obtain ⟨c, hc_pos, hc⟩ := h_pos
      have h_bound : ∀ n : Fin X, n.val.Prime → (B_op X).mulVec (fun m => if m = n then 1 else 0) n = 0 := by
        intro n hn_prime
        simp [B_op, A_op, comm_op, F_op, U2_op, chi4_op];
        simp +decide [ Matrix.mulVec, dotProduct, Finset.sum_ite, Finset.filter_eq', Finset.filter_ne' ];
        ring;
      -- Let's choose any prime number $n$ such that $n < X$.
      obtain ⟨n, hn_prime, hn_lt⟩ : ∃ n : Fin X, n.val.Prime ∧ n.val < X := by
        exact ⟨ ⟨ 2, by linarith ⟩, by norm_num, by linarith ⟩;
      specialize hc ( fun m => if m = n then 1 else 0 ) ; simp_all +decide [ Finset.sum_ite, Finset.filter_eq', Finset.filter_ne' ];
      exact not_le_of_gt hc_pos ( hc fun m hm => by aesop )

lemma B_v_eq_zero (X : ℕ) (hX : X > 100) :
  let v : Fin X → ℂ := fun i => if i.val = 2 then 1 else 0
  (B_op X).mulVec v = 0 := by
    ext i; simp [B_op];
    unfold A_op; aesop;
    unfold comm_op chi4_op;
    unfold F_op U2_op; norm_num [ Matrix.mul_apply, Finset.sum_ite ] ;
    norm_num [ Matrix.mulVec, dotProduct, Finset.sum_ite ];
    rw [ Finset.sum_eq_zero ] ; aesop

theorem spectral_gap_false (X : ℕ) (hX : X > 100) :
  ¬ (∃ val_min : ℝ, (∀ val ∈ spectrum ℂ (B_op X), val_min ≤ val.re) ∧ val_min > 0) := by
    rintro ⟨ val_min, h1, h2 ⟩;
    -- Consider the eigenvector $v$ corresponding to the smallest eigenvalue of $B_op X$.
    obtain ⟨v, hv⟩ : ∃ v : Fin X → ℂ, v ≠ 0 ∧ (B_op X).mulVec v = 0 := by
      use fun i => if i.val = 2 then 1 else 0;
      apply And.intro;
      · exact fun h => by have := congr_fun h ⟨ 2, by linarith ⟩ ; norm_num at this;
      · exact?;
    have h_eigenvalue : 0 ∈ spectrum ℂ (B_op X) := by
      -- Since $B_op X$ is not invertible, $0$ is in its spectrum.
      have h_noninv : ¬IsUnit (B_op X) := by
        exact fun h => hv.1 <| Matrix.eq_zero_of_mulVec_eq_zero ( show ( B_op X ).det ≠ 0 from h.map ( Matrix.detMonoidHom ) |> fun h => h.ne_zero ) hv.2;
      simp_all +decide [ spectrum.mem_iff, isUnit_iff_ne_zero ];
    exact h2.not_le ( by simpa using h1 0 h_eigenvalue )

theorem comm_norm_bounded (X : ℕ) (hX : X > 4) :
  ∀ φ : Fin X → ℂ, (Finset.sum Finset.univ (fun i => Complex.normSq ((comm_op X).mulVec φ i))) ≤ 16 * (Finset.sum Finset.univ (fun i => Complex.normSq (φ i))) := by
  -- Since $U_2 \phi$ is a shifted version of $\phi$, we have $\|U_2 \phi\|^2 = \|\phi\|^2$.
  have h_norm_U2_phi : ∀ φ : Fin X → ℂ, (Finset.sum Finset.univ fun i => Complex.normSq ((U2_op X).mulVec φ i)) ≤ (Finset.sum Finset.univ fun i => Complex.normSq (φ i)) := by
    unfold U2_op Matrix.mulVec;
    simp +decide [ dotProduct, Finset.sum_ite ];
    intro φ;
    rw [ ← Finset.sum_subset ( Finset.subset_univ _ ) ];
    any_goals exact Finset.univ.filter fun x => x.val < X - 2;
    · refine' le_trans ( Finset.sum_le_sum_of_subset_of_nonneg _ _ ) _;
      exact Finset.univ.image fun i : Fin ( X - 2 ) => ⟨ i, by linarith [ Fin.is_lt i, Nat.sub_add_cancel ( by linarith : 2 ≤ X ) ] ⟩;
      · intro x hx; aesop;
        exact ⟨ ⟨ x, hx ⟩, rfl ⟩;
      · exact fun _ _ _ => Complex.normSq_nonneg _;
      · rw [ Finset.sum_image ] <;> aesop;
        · refine' le_trans ( Finset.sum_le_sum fun i _ => _ ) _;
          use fun i => Complex.normSq ( φ ⟨ i + 2, by linarith [ Fin.is_lt i, Nat.sub_add_cancel ( by linarith : 2 ≤ X ) ] ⟩ );
          · rw [ Finset.sum_eq_single ⟨ i + 2, by linarith [ Fin.is_lt i, Nat.sub_add_cancel ( by linarith : 2 ≤ X ) ] ⟩ ] <;> aesop;
            exact False.elim <| a_1 <| Fin.ext a;
          · rcases X with ( _ | _ | X ) <;> simp_all +decide [ Fin.sum_univ_succ ];
            · contradiction;
            · exact le_add_of_nonneg_of_le ( Complex.normSq_nonneg _ ) ( le_add_of_nonneg_left ( Complex.normSq_nonneg _ ) );
        · exact fun i _ j _ h => Fin.ext <| by simpa using congr_arg Fin.val h;
    · aesop;
      rw [ Finset.sum_eq_zero ] ; aesop;
      linarith [ Fin.is_lt x, Fin.is_lt x_1 ];
  -- Using the commutator formula, we can bound the norm of the commutator.
  have h_norm_comm : ∀ φ : Fin X → ℂ, (Finset.sum Finset.univ fun i => Complex.normSq ((comm_op X).mulVec φ i)) ≤ 4 * (Finset.sum Finset.univ fun i => Complex.normSq ((U2_op X).mulVec φ i)) := by
    intro φ
    have h_comm : (comm_op X).mulVec φ = 2 • (F_op X).mulVec ((U2_op X).mulVec φ) := by
      have h_comm_def : comm_op X = 2 • (F_op X * U2_op X) := by
        exact?;
      simp +decide [ h_comm_def, two_smul, Matrix.add_mulVec, Matrix.mulVec_add ];
    -- Since $F_op$ is diagonal with entries $e^{2\pi i n/4}$, we have $\|F_op \cdot U2_op \cdot \phi\|^2 = \|U2_op \cdot \phi\|^2$.
    have h_norm_F_op_U2_phi : ∀ φ : Fin X → ℂ, (Finset.sum Finset.univ fun i => Complex.normSq ((F_op X).mulVec ((U2_op X).mulVec φ) i)) = (Finset.sum Finset.univ fun i => Complex.normSq ((U2_op X).mulVec φ i)) := by
      unfold F_op; norm_num [ Matrix.mulVec ] ;
      unfold e; norm_num [ Complex.normSq_eq_norm_sq, Complex.norm_exp ] ;
    simp_all +decide [ Complex.normSq, Finset.mul_sum _ _ _ ];
    convert mul_le_mul_of_nonneg_left ( h_norm_F_op_U2_phi φ |> le_of_eq ) zero_le_four using 1 <;> ring;
    · simp +decide only [pow_two, Finset.sum_mul _ _ _, add_mul];
    · simp +decide only [Finset.sum_mul _ _ _, add_mul];
  exact fun φ => le_trans ( h_norm_comm φ ) ( by linarith [ h_norm_U2_phi φ, show 0 ≤ ∑ i, Complex.normSq ( φ i ) from Finset.sum_nonneg fun _ _ => Complex.normSq_nonneg _ ] )

theorem growth_impossible (X : ℕ) (hX : X > 4) :
  ∀ φ : Fin X → ℂ, ∃ C : ℝ, C = 4 ∧
    Real.sqrt (Finset.sum Finset.univ (fun i => Complex.normSq ((comm_op X).mulVec φ i))) ≤ C * Real.sqrt (Finset.sum Finset.univ (fun i => Complex.normSq (φ i))) := by
      -- By the properties of the norm and the fact that |e(n/4) - e(n/4 + 1/2)| ≤ 2, we can bound the norm of the commutator applied to φ by 4 times the norm of φ. This follows from the fact that the norm of a sum is less than or equal to the sum of the norms.
      intros φ
      have h_norm : ∑ i : Fin X, Complex.normSq ((comm_op X).mulVec φ i) ≤ 16 * ∑ i : Fin X, Complex.normSq (φ i) := by
        -- Apply the hypothesis `comm_norm_bounded` to the given φ.
        apply comm_norm_bounded X hX;
      exact ⟨ 4, rfl, Real.sqrt_le_iff.mpr ⟨ by positivity, by nlinarith [ Real.mul_self_sqrt ( show 0 ≤ ∑ i : Fin X, Complex.normSq ( φ i ) by exact Finset.sum_nonneg fun _ _ => Complex.normSq_nonneg _ ) ] ⟩ ⟩