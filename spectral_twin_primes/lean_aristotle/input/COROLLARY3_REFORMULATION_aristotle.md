/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 293e3cb4-905b-4fc1-aadf-53e685710d51
-/

/-
We have successfully analyzed the "Matrix Coefficient Control via Commutators" problem.

1.  **Counterexample:** We formally proved `corollary_3_counterexample`, showing that the original claim is false. The counterexample uses $H = \mathbb{C}$, $A = I$, $U = I$, and $c = 1$. In this case, $[A, U] = 0$, so the claimed bound is 0, but $|\langle x, Ux \rangle| = \|x\|^2$, which is non-zero for $x \neq 0$. This demonstrates that coercivity of $A$ and smallness of $[A, U]$ are insufficient to bound matrix coefficients without further assumptions on $U$ (e.g., that $U$ is far from the identity).

2.  **Correct Formulations:**
    *   **Energy Conservation:** We proved `correct_A_expectation_change`, showing that if $[A, U]$ is small, then the "energy" $\langle x, Ax \rangle$ is approximately conserved under $U$: $|\langle Ux, A(Ux) \rangle - \langle x, Ax \rangle| \le 2 \|[A, U]\| \|x\|^2$.
    *   **Approximate Eigenvectors:** We proved `approx_eigenvector`, showing that $U$ maps eigenvectors of $A$ to approximate eigenvectors: $\|(A - \mu I) Uv\| \le \|[A, U]\| \|v\|$.
    *   **Spectral Bound:** We proved `spectral_commutator_bound`, which bounds the deviation of $Uv$ from being an eigenvector of $A$ (scaled by $\mu^{-1}$) by the commutator norm.
    *   **Eigenspace Stability:** We proved `eigenvector_stability`, demonstrating that if $x$ is an eigenvector of $A$ and $A$ has a spectral gap $g$ around the eigenvalue, then the component of $Ux$ orthogonal to $x$ is bounded by $\|[A, U]\| \|x\| / g$.
    *   **Decomposition:** We proved `alt_C`, a trivial but useful identity decomposing $\langle x, Ux \rangle$.

3.  **Disproof of Alternative D:** We attempted to prove `alt_D` (Energy inequality) but found it to be false (disproved by the ATP with $A=I, U=-I$).

**Conclusion for TPC Application:**
The smallness of $\|[A, U]\|$ implies that $U$ almost commutes with $A$, meaning $U$ approximately preserves the eigenspaces of $A$. It does *not* directly imply that $\langle x, Ux \rangle$ is small. For the "minor arcs" suppression, one likely needs to combine the commutator bound with the specific spectral properties of $U$ (e.g., that $U$ has no fixed points or moves states away from the "bad" low-energy subspace of $A$, if such a subspace existed and was distinct from the high-energy part). Since $A$ is coercive, all states are "high energy", so the suppression must come from the oscillatory nature of $U$ itself, not just its relation to $A$.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped BigOperators Real Nat ComplexConjugate
open Complex

variable {H : Type} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]

/-- Commutator of bounded operators -/
def commOp (A U : H →L[ℂ] H) : H →L[ℂ] H :=
  A * U - U * A

/-- The FALSE original claim (for reference) -/
def false_corollary_3 (A U : H →L[ℂ] H) (c : ℝ) : Prop :=
  (∀ x, (inner ℂ x (A x)).re ≥ c * ‖x‖^2) →  -- A coercive
  (Isometry U) →
  (∀ x, |(inner ℂ x (U x)).re| ≤ (‖commOp A U‖ / c) * ‖x‖ * Real.sqrt (inner ℂ x (A x)).re)

#check EuclideanSpace

#print InnerProductSpace

/-- What IS true about commutator control -/
theorem commutator_energy_control
    (A U : H →L[ℂ] H) (hU : Isometry U) (x : H) :
    ‖inner ℂ x (commOp A U x)‖ ≤ ‖commOp A U‖ * ‖x‖^2 := by
  -- This is just the definition of operator norm
  calc ‖inner ℂ x (commOp A U x)‖
      ≤ ‖x‖ * ‖commOp A U x‖ := norm_inner_le_norm _ _
    _ ≤ ‖x‖ * (‖commOp A U‖ * ‖x‖) := by
        gcongr
        exact ContinuousLinearMap.le_opNorm _ _
    _ = ‖commOp A U‖ * ‖x‖^2 := by ring

#check IsSelfAdjoint

/-- Correct version: commutator controls A-expectation change under U -/
theorem correct_A_expectation_change
    (A U : H →L[ℂ] H) (hA : IsSelfAdjoint A) (hU : Isometry U) (x : H) :
    ‖inner ℂ (U x) (A (U x)) - inner ℂ x (A x)‖ ≤ 2 * ‖commOp A U‖ * ‖x‖^2 := by
  -- This should be provable
  -- By the properties of the inner product and the commutator, we can rewrite the difference of the inner products as ⟨Ux, (AU - UA)x⟩.
  have h_inner_diff : inner ℂ (U x) (A (U x)) - inner ℂ x (A x) = inner ℂ (U x) ((commOp A U) x) := by
    simp [commOp];
    -- Since $U$ is an isometry, we have $\langle Ux, Uy \rangle = \langle x, y \rangle$ for all $x, y \in H$.
    have h_isometry : ∀ x y : H, inner ℂ (U x) (U y) = inner ℂ x y := by
      intro x y; have := hU.dist_eq x y; simp_all +decide [ dist_eq_norm, inner_sub_left, inner_sub_right ] ;
      have := hU.dist_eq ( x + y ) 0; simp_all +decide [ norm_add_sq_real, norm_sub_sq_real ] ;
      have := hU.dist_eq ( x + Complex.I • y ) 0; simp_all +decide [ norm_add_sq_real, norm_sub_sq_real ] ;
      -- By expanding the norms using the inner product, we can derive that the inner products of Ux and Uy must equal those of x and y. Specifically, we have:
      have h_inner_eq : ‖U x + U y‖^2 = ‖U x‖^2 + ‖U y‖^2 + 2 * (inner ℂ (U x) (U y)).re ∧ ‖x + y‖^2 = ‖x‖^2 + ‖y‖^2 + 2 * (inner ℂ x y).re := by
        norm_num [ @norm_add_sq ℂ ];
        constructor <;> ring;
      have h_inner_eq : ‖U x + Complex.I • U y‖^2 = ‖U x‖^2 + ‖U y‖^2 + 2 * (inner ℂ (U x) (Complex.I • U y)).re ∧ ‖x + Complex.I • y‖^2 = ‖x‖^2 + ‖y‖^2 + 2 * (inner ℂ x (Complex.I • y)).re := by
        simp +decide [ @norm_add_sq ℂ, @norm_smul ℂ, inner_add_left, inner_add_right, inner_smul_left, inner_smul_right ];
        constructor <;> ring;
      have := hU.dist_eq x 0; have := hU.dist_eq y 0; simp_all +decide [ norm_eq_sqrt_real_inner ] ;
      simp_all +decide [ Complex.ext_iff ];
    rw [ h_isometry ];
  -- By the properties of the inner product and the commutator, we can bound the norm of the inner product.
  have h_inner_bound : ‖inner ℂ (U x) ((commOp A U) x)‖ ≤ ‖U x‖ * ‖(commOp A U) x‖ := by
    exact norm_inner_le_norm _ _;
  have := hU.dist_eq x 0; aesop;
  exact h_inner_bound.trans ( by nlinarith [ norm_nonneg x, norm_nonneg ( commOp A U x ), ContinuousLinearMap.le_opNorm ( commOp A U ) x ] )

#check (norm : ℂ → ℝ)

theorem corollary_3_counterexample :
    ∃ (H : Type) (inst1 : NormedAddCommGroup H) (inst2 : InnerProductSpace ℂ H) (inst3 : CompleteSpace H)
      (A U : H →L[ℂ] H) (c : ℝ) (hc : 0 < c),
    (∀ x, (inner ℂ x (A x)).re ≥ c * ‖x‖^2) ∧
    (Isometry U) ∧
    (∃ x, ‖inner ℂ x (U x)‖ > (‖commOp A U‖ / c) * ‖x‖ * Real.sqrt (inner ℂ x (A x)).re) := by
      refine' ⟨ ℂ, _, _, _, 1, 1, 1, _, _, _, _ ⟩ <;> norm_num;
      all_goals try infer_instance;
      · norm_num [ ← sq, Complex.normSq, Complex.sq_norm ];
      · exact isometry_id;
      · refine' ⟨ 1, _ ⟩ ; norm_num [ commOp ]

theorem approx_eigenvector (A U : H →L[ℂ] H) (v : H) (μ : ℂ)
    (hv : A v = μ • v) :
    ‖(A - μ • ContinuousLinearMap.id ℂ H) (U v)‖ ≤ ‖commOp A U‖ * ‖v‖ := by
  -- Proof: (A - μ) U v = A U v - μ U v = (U A + [A, U]) v - U (μ v) = U (A v - μ v) + [A, U] v = [A, U] v
  -- By definition of commutator, we have $(A - \mu)U v = [A, U] v + UA v$.
  have h_comm : (A - μ • ContinuousLinearMap.id ℂ H) (U v) = (commOp A U) v + U (A v) - μ • U v := by
    simp +decide [ commOp ];
  -- Substitute hv into the expression to simplify it.
  have h_simp : (A - μ • ContinuousLinearMap.id ℂ H) (U v) = (commOp A U) v := by
    aesop;
  exact h_simp.symm ▸ ContinuousLinearMap.le_opNorm _ _

theorem spectral_commutator_bound (A U : H →L[ℂ] H) (hA : IsSelfAdjoint A) (hU : Isometry U)
    (μ : ℂ) (v : H) (hv : A v = μ • v) (hμ : μ ≠ 0) :
    ‖U v - (μ⁻¹ • A (U v))‖ ≤ ‖commOp A U‖ * ‖v‖ / ‖μ‖ := by
  -- We want to bound ‖U v - 1/μ A (U v)‖
  -- Note: A (U v) = U (A v) + [A, U] v = U (μ v) + [A, U] v = μ U v + [A, U] v
  -- So 1/μ A (U v) = U v + 1/μ [A, U] v
  -- Thus U v - 1/μ A (U v) = - 1/μ [A, U] v
  -- Norm is 1/|μ| ‖[A, U] v‖ ≤ 1/|μ| ‖[A, U]‖ ‖v‖
  have h_norm_bound : ‖A (U v) - μ • U v‖ ≤ ‖commOp A U‖ * ‖v‖ := by
    have h_norm_bound : ‖(A - μ • ContinuousLinearMap.id ℂ H) (U v)‖ ≤ ‖commOp A U‖ * ‖v‖ := by
      exact?;
    aesop;
  -- By simplifying, we can see that ‖U v - μ⁻¹ • A (U v)‖ = ‖μ⁻¹ • (μ • U v - A (U v))‖ = |μ⁻¹| * ‖μ • U v - A (U v)‖.
  have h_simplified : ‖U v - μ⁻¹ • A (U v)‖ = ‖μ⁻¹ • (μ • U v - A (U v))‖ := by
    simp +decide [ smul_sub, hμ ];
  rw [ h_simplified, norm_smul, norm_inv ];
  simpa only [ div_eq_inv_mul, norm_sub_rev ] using mul_le_mul_of_nonneg_left h_norm_bound ( inv_nonneg.mpr ( norm_nonneg μ ) )

#check Submodule.orthogonalProjection

theorem eigenvector_stability (A U : H →L[ℂ] H) (hA : IsSelfAdjoint A) (x : H) (μ : ℂ) (g : ℝ)
    (hg : 0 < g)
    (heig : A x = μ • x)
    (hgap : ∀ y, inner ℂ x y = 0 → ‖(A - μ • ContinuousLinearMap.id ℂ H) y‖ ≥ g * ‖y‖) :
    let K := Submodule.span ℂ {x}
    let P_perp := (Submodule.orthogonalProjection Kᗮ : H →L[ℂ] Kᗮ)
    ‖P_perp (U x)‖ ≤ ‖commOp A U‖ * ‖x‖ / g := by
  -- By definition of orthogonal projection, we have $(A - \mu I) P_{\perp} U x = (A - \mu I) U x$.
  have h_proj : (A - μ • ContinuousLinearMap.id ℂ H) (Submodule.orthogonalProjection (Submodule.span ℂ {x})ᗮ (U x)) = (A - μ • ContinuousLinearMap.id ℂ H) (U x) := by
    -- Since $P_{\perp} U x$ is in the orthogonal complement of $span \{x\}$, we have $A (P_{\perp} U x) = \mu P_{\perp} U x$.
    have h_A_proj : ∀ (y : H), y ∈ Submodule.span ℂ {x} → A y = μ • y := by
      intro y hy; rw [ Submodule.mem_span_singleton ] at hy; obtain ⟨ c, rfl ⟩ := hy; simp +decide [ *, smul_smul ] ;
      rw [ mul_comm ];
    simp_all +decide [ Submodule.starProjection_eq_self_iff ];
    simp +decide [ smul_sub, sub_sub ];
  -- Apply the spectral gap bound to get $\|A - \mu I) P_{\perp} U x\| \geq g \|P_{\perp} U x\|$.
  have h_spectral : ‖(A - μ • ContinuousLinearMap.id ℂ H) (Submodule.orthogonalProjection (Submodule.span ℂ {x})ᗮ (U x))‖ ≥ g * ‖Submodule.orthogonalProjection (Submodule.span ℂ {x})ᗮ (U x)‖ := by
    apply hgap;
    exact Submodule.mem_orthogonal_singleton_iff_inner_right.mp ( Submodule.coe_mem _ );
  -- Using the triangle inequality and the commutator bound, we have $\|A U x - U A x\| \leq \|commOp A U\| \|x\|$.
  have h_triangle : ‖A (U x) - U (A x)‖ ≤ ‖commOp A U‖ * ‖x‖ := by
    exact ContinuousLinearMap.le_opNorm ( commOp A U ) x;
  rw [ le_div_iff₀' hg ];
  simp_all +decide [ norm_sub_rev ];
  exact h_spectral.trans h_triangle

theorem alt_C (A U : H →L[ℂ] H) (hA : IsSelfAdjoint A) (hU : Isometry U)
    (c : ℝ) (hA_coercive : ∀ x, (inner ℂ x (A x)).re ≥ c * ‖x‖^2)
    (x : H) :
    inner ℂ x (U x) = inner ℂ x ((U - ContinuousLinearMap.id ℂ H) x) + (‖x‖^2 : ℂ) := by
      -- By linearity of the inner product, we can split the inner product into two parts.
      simp [inner_sub_left, inner_self_eq_norm_sq_to_K]

#check ContinuousLinearMap.IsPositive