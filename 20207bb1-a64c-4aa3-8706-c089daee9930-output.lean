/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 20207bb1-a64c-4aa3-8706-c089daee9930
-/

/-
Formalization of the Fourier Decay Bound for the Archimedean Symbol.

This module defines the Archimedean symbol's Fourier coefficients `A_coeff` as the convolution of the Fejér kernel `Fejer_coeff` and the Heat kernel `Heat_coeff`. It defines the tail constant `C_tail` as the supremum of the scaled coefficients.

The main theorems are:
- `fourier_decay`: Establishes the decay bound `‖A_coeff N t k‖ ≤ C_tail N t / k^2`.
- `buffer_from_decay`: Proves that the buffer width `buffer_width` is sufficient to suppress the tail sum of the coefficients below `eps`.

Helper lemmas `bddAbove_A_coeff_mul_sq`, `tail_sum_inv_sq_bound`, and `arithmetic_bound` are included to support the proofs.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check fourierCoeff

#check fourierCoeffOn

/-
Definitions of BesselI (model), Fejer_coeff, Heat_coeff, and A_coeff.
-/
/-- Modified Bessel function of the first kind (model) -/
noncomputable def BesselI (k : ℤ) (t : ℝ) : ℝ :=
  (t / 2) ^ (Int.natAbs k) / (Nat.factorial (Int.natAbs k))

/-- Fejér kernel coefficients -/
noncomputable def Fejer_coeff (N : ℕ) (k : ℤ) : ℝ :=
  if |k| < N then 1 - (|k| : ℝ) / N else 0

/-- Heat kernel coefficients -/
noncomputable def Heat_coeff (t : ℝ) (k : ℤ) : ℝ :=
  Real.exp (-t) * BesselI k t

/-- Fourier coefficients of archimedean symbol -/
noncomputable def A_coeff (N : ℕ) (t : ℝ) (k : ℤ) : ℂ :=
  Finset.sum (Finset.Icc (-(N : ℤ)) (N : ℤ)) (fun j => (Fejer_coeff N j : ℂ) * (Heat_coeff t (k - j) : ℂ))

#check iSup

/-
Definition of C_tail as the supremum of the scaled Fourier coefficients.
-/
/-- Tail constant -/
noncomputable def C_tail (N : ℕ) (t : ℝ) : ℝ :=
  ⨆ k : {x : ℤ // x ≠ 0}, ‖A_coeff N t k‖ * (k : ℝ)^2

/-
The set of values ‖A_coeff N t k‖ * k^2 for non-zero integers k is bounded above.
-/
/-- The sequence of scaled Fourier coefficients is bounded -/
theorem bddAbove_A_coeff_mul_sq (N : ℕ) (t : ℝ) :
  BddAbove (Set.range (fun k : {x : ℤ // x ≠ 0} => ‖A_coeff N t k‖ * (k : ℝ)^2)) := by
  -- The sum of the coefficients is finite, and each term in the sum is continuous. Therefore, the function is bounded.
  have h_bounded : ∃ M : ℝ, ∀ k : ℤ, k ≠ 0 → ‖A_coeff N t k‖ * (k : ℝ) ^ 2 ≤ M := by
    -- Since $|k| \geq N+1$ implies $|j| < N$, we have $|k+j| \leq 2N$.
    have h_bound : ∀ k : ℤ, k ≠ 0 → ‖A_coeff N t k‖ * (k : ℝ) ^ 2 ≤ (∑ j ∈ Finset.Icc (-N : ℤ) N, (1 - |j| / (N : ℝ)) * Real.exp (-t) * |(t / 2) ^ (Int.natAbs (k - j)) / (Nat.factorial (Int.natAbs (k - j)))|) * (k : ℝ) ^ 2 := by
      intros k hk_nonzero
      simp [A_coeff];
      gcongr ; norm_cast ; aesop;
      refine' le_trans ( Finset.abs_sum_le_sum_abs _ _ ) _ ; refine' Finset.sum_le_sum fun i hi => _ ; unfold Fejer_coeff Heat_coeff ; aesop;
      · unfold BesselI; norm_num [ Rat.mkRat_eq_div ] ; ring_nf; norm_num;
        rw [ abs_of_nonneg ( sub_nonneg.mpr <| by rw [ ← div_eq_mul_inv ] ; exact div_le_one_of_le₀ ( mod_cast by linarith [ abs_lt.mp h ] ) <| by positivity ) ] ; ring_nf ; norm_num;
      · norm_num [ Rat.mkRat_eq_div ];
        exact mul_nonneg ( mul_nonneg ( sub_nonneg.2 <| div_le_one_of_le₀ ( mod_cast by cases abs_cases i <;> linarith ) <| by positivity ) <| Real.exp_nonneg _ ) <| abs_nonneg _;
    -- Since $|k| \geq N+1$ implies $|j| < N$, we have $|k+j| \leq 2N$. Thus, each term in the sum is bounded.
    have h_term_bound : ∀ j ∈ Finset.Icc (-N : ℤ) N, ∃ M_j : ℝ, ∀ k : ℤ, k ≠ 0 → k ∉ Finset.Icc (-N + j : ℤ) (N + j : ℤ) → (1 - |j| / (N : ℝ)) * Real.exp (-t) * |(t / 2) ^ (Int.natAbs (k - j)) / (Nat.factorial (Int.natAbs (k - j)))| * (k : ℝ) ^ 2 ≤ M_j := by
      intro j hj
      have h_term_bound_aux : Filter.Tendsto (fun k : ℤ => (1 - |j| / (N : ℝ)) * Real.exp (-t) * |(t / 2) ^ (Int.natAbs (k - j)) / (Nat.factorial (Int.natAbs (k - j)))| * (k : ℝ) ^ 2) Filter.atTop (nhds 0) ∧ Filter.Tendsto (fun k : ℤ => (1 - |j| / (N : ℝ)) * Real.exp (-t) * |(t / 2) ^ (Int.natAbs (k - j)) / (Nat.factorial (Int.natAbs (k - j)))| * (k : ℝ) ^ 2) Filter.atBot (nhds 0) := by
        have h_term_bound_aux : Filter.Tendsto (fun k : ℕ => (1 - |j| / (N : ℝ)) * Real.exp (-t) * |(t / 2) ^ k / (Nat.factorial k)| * (k + j : ℝ) ^ 2) Filter.atTop (nhds 0) := by
          have h_term_bound_aux : Filter.Tendsto (fun k : ℕ => |(t / 2) ^ k / (Nat.factorial k)| * (k : ℝ) ^ 2) Filter.atTop (nhds 0) := by
            have h_term_bound_aux : Summable (fun k : ℕ => |(t / 2) ^ k / (Nat.factorial k)| * (k : ℝ) ^ 2) := by
              refine' summable_of_ratio_norm_eventually_le _ _;
              exact 3 / 4;
              · norm_num;
              · norm_num [ abs_div, abs_mul, abs_of_nonneg, Nat.factorial_succ ];
                refine' ⟨ ⌈4 * |t|⌉₊ + 1, fun n hn => _ ⟩ ; rw [ div_mul_eq_mul_div, div_mul_eq_mul_div ] ; rw [ div_le_iff₀ ] <;> ring <;> norm_cast <;> norm_num;
                · norm_num [ Nat.factorial_ne_zero ];
                  nlinarith [ show ( n : ℝ ) ≥ ⌈4 * |t|⌉₊ + 1 by exact_mod_cast hn, Nat.le_ceil ( 4 * |t| ), show ( 0 : ℝ ) ≤ |t| ^ n * ( 1 / 2 ) ^ n by positivity, show ( 0 : ℝ ) ≤ |t| ^ n * ( 1 / 2 ) ^ n * n by positivity, show ( 0 : ℝ ) ≤ |t| ^ n * ( 1 / 2 ) ^ n * n ^ 2 by positivity ];
                · positivity;
            convert h_term_bound_aux.tendsto_atTop_zero;
          have h_term_bound_aux : Filter.Tendsto (fun k : ℕ => |(t / 2) ^ k / (Nat.factorial k)| * ((k : ℝ) + j) ^ 2) Filter.atTop (nhds 0) := by
            have h_term_bound_aux : Filter.Tendsto (fun k : ℕ => |(t / 2) ^ k / (Nat.factorial k)| * (k : ℝ) ^ 2 * (1 + j / (k : ℝ)) ^ 2) Filter.atTop (nhds 0) := by
              simpa using h_term_bound_aux.mul ( Filter.Tendsto.pow ( tendsto_const_nhds.add ( tendsto_const_nhds.mul tendsto_inverse_atTop_nhds_zero_nat ) ) 2 );
            refine h_term_bound_aux.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with k hk; rw [ show ( k : ℝ ) + j = k * ( 1 + j / k ) by rw [ mul_add, mul_div_cancel₀ _ ( by positivity ) ] ; ring ] ; rw [ mul_pow ] ; ring );
          convert h_term_bound_aux.const_mul ( ( 1 - |j| / N : ℝ ) * Real.exp ( -t ) ) using 2 <;> ring;
        have h_term_bound_aux_bot : Filter.Tendsto (fun k : ℕ => (1 - |j| / (N : ℝ)) * Real.exp (-t) * |(t / 2) ^ k / (Nat.factorial k)| * (-k + j : ℝ) ^ 2) Filter.atTop (nhds 0) := by
          have h_term_bound_aux_bot : Filter.Tendsto (fun k : ℕ => (1 - |j| / (N : ℝ)) * Real.exp (-t) * |(t / 2) ^ k / (Nat.factorial k)| * (k : ℝ) ^ 2) Filter.atTop (nhds 0) := by
            have h_term_bound_aux_bot : Filter.Tendsto (fun k : ℕ => (1 - |j| / (N : ℝ)) * Real.exp (-t) * |(t / 2) ^ k / (Nat.factorial k)| * (k + j : ℝ) ^ 2 * (k / (k + j)) ^ 2) Filter.atTop (nhds 0) := by
              have h_term_bound_aux_bot : Filter.Tendsto (fun k : ℕ => (k : ℝ) / (k + j)) Filter.atTop (nhds 1) := by
                exact?;
              simpa using h_term_bound_aux.mul ( h_term_bound_aux_bot.pow 2 );
            refine h_term_bound_aux_bot.congr' ?_;
            filter_upwards [ Filter.eventually_gt_atTop ( Int.natAbs j ) ] with k hk;
            field_simp;
            rw [ mul_div_cancel_right₀ _ ( by norm_cast; cases abs_cases j <;> linarith ) ];
          have h_term_bound_aux_bot : Filter.Tendsto (fun k : ℕ => (1 - |j| / (N : ℝ)) * Real.exp (-t) * |(t / 2) ^ k / (Nat.factorial k)| * (k : ℝ) ^ 2 * (1 - 2 * j / (k : ℝ) + j ^ 2 / (k : ℝ) ^ 2)) Filter.atTop (nhds 0) := by
            simpa using h_term_bound_aux_bot.mul ( Filter.Tendsto.add ( tendsto_const_nhds.sub ( tendsto_const_nhds.mul tendsto_inverse_atTop_nhds_zero_nat ) ) ( tendsto_const_nhds.mul ( tendsto_inverse_atTop_nhds_zero_nat.pow 2 ) ) );
          refine h_term_bound_aux_bot.congr' ?_;
          filter_upwards [ Filter.eventually_gt_atTop 0 ] with k hk;
          field_simp [hk]
          ring;
        constructor;
        · rw [ Filter.tendsto_atTop' ] at *;
          intro s hs; rcases h_term_bound_aux s hs with ⟨ a, ha ⟩ ; use a + j; intros b hb; convert ha ( Int.natAbs ( b - j ) ) ( by cases abs_cases ( b - j ) <;> linarith ) using 1 ; simp +decide [ abs_of_nonneg ( by linarith : 0 ≤ b - j ) ] ;
        · rw [ Filter.tendsto_atBot' ];
          intro s hs; rcases Filter.eventually_atTop.mp ( h_term_bound_aux_bot.eventually hs ) with ⟨ M, hM ⟩ ; use -M + j; intro k hk; specialize hM ( Int.natAbs ( k - j ) ) ; aesop;
          convert hM ( by omega ) using 1 ; rw [ abs_of_nonpos ( by norm_cast; linarith : ( k : ℝ ) - j ≤ 0 ) ] ; ring;
      have := h_term_bound_aux.1.eventually ( ge_mem_nhds zero_lt_one ) ; have := h_term_bound_aux.2.eventually ( ge_mem_nhds zero_lt_one ) ; aesop;
      use Max.max 1 ( ∑ k ∈ Finset.Icc w_1 w, ( 1 - |( j : ℝ )| / N ) * Real.exp ( -t ) * |( t / 2 ) ^ ( Int.natAbs ( k - j ) ) / ( Nat.factorial ( Int.natAbs ( k - j ) ) )| * ( k : ℝ ) ^ 2 ) ; aesop;
      by_cases hk : k ≤ w_1 ∨ k ≥ w;
      · cases hk <;> [ exact Or.inl ( h_1 k ‹_› ) ; exact Or.inl ( h k ‹_› ) ];
      · exact Or.inr ( le_trans ( by aesop ) ( Finset.single_le_sum ( fun x _ => mul_nonneg ( mul_nonneg ( mul_nonneg ( sub_nonneg.mpr <| div_le_one_of_le₀ ( mod_cast abs_le.mpr ⟨ by linarith, by linarith ⟩ ) <| by positivity ) <| Real.exp_nonneg _ ) <| abs_nonneg _ ) <| sq_nonneg _ ) <| Finset.mem_Icc.mpr ⟨ by push_neg at hk; linarith, by push_neg at hk; linarith ⟩ ) );
    choose! M hM using h_term_bound;
    -- Let $M$ be the maximum of the $M_j$ values.
    use ∑ j ∈ Finset.Icc (-N : ℤ) N, M j + ∑ k ∈ Finset.Icc (-2 * N : ℤ) (2 * N), ‖A_coeff N t k‖ * (k : ℝ) ^ 2;
    intro k hk; by_cases hk' : k ∈ Finset.Icc ( -2 * N : ℤ ) ( 2 * N ) <;> simp_all +decide [ Finset.sum_mul _ _ _ ] ;
    · refine' le_add_of_nonneg_of_le ( Finset.sum_nonneg fun _ _ => _ ) _;
      · contrapose! hM;
        refine' ⟨ _, _, _, 2 * N + 1, _, _, hM.trans_le _ ⟩ <;> norm_num at * <;> try linarith;
        · exact fun _ => by linarith;
        · exact mul_nonneg ( mul_nonneg ( mul_nonneg ( sub_nonneg.2 <| div_le_one_of_le₀ ( mod_cast abs_le.2 ⟨ by linarith, by linarith ⟩ ) <| by positivity ) <| Real.exp_nonneg _ ) <| abs_nonneg _ ) <| sq_nonneg _;
      · exact Finset.single_le_sum ( fun x _ => mul_nonneg ( norm_nonneg _ ) ( sq_nonneg _ ) ) ( Finset.mem_Icc.mpr ⟨ by linarith, by linarith ⟩ );
    · refine le_trans ( h_bound k hk ) ?_;
      refine le_trans ( Finset.sum_le_sum fun i hi => hM i ( Finset.mem_Icc.mp hi |>.1 ) ( Finset.mem_Icc.mp hi |>.2 ) k hk ?_ ) ?_;
      · exact fun hi' => by linarith [ Finset.mem_Icc.mp hi, hk' ( by linarith [ Finset.mem_Icc.mp hi ] ) ] ;
      · exact le_add_of_nonneg_right <| Finset.sum_nonneg fun _ _ => mul_nonneg ( norm_nonneg _ ) <| sq_nonneg _;
  exact ⟨ h_bounded.choose, Set.forall_mem_range.mpr fun k => h_bounded.choose_spec k k.2 ⟩

/-
The Fourier Decay Theorem follows directly from the definition of C_tail as the supremum of the scaled coefficients.
-/
/-- Fourier Decay Theorem -/
theorem fourier_decay (N : ℕ) (t : ℝ) (ht : 0 < t) (k : ℤ) (hk : k ≠ 0) :
  ‖A_coeff N t k‖ ≤ C_tail N t / (k : ℝ)^2 := by
    rw [ le_div_iff₀ ( by positivity ) ];
    convert le_ciSup ( bddAbove_A_coeff_mul_sq N t ) ⟨ k, hk ⟩ using 1

/-
Definition of buffer_width.
-/
/-- Buffer formula -/
noncomputable def buffer_width (K : ℝ) (eps : ℝ) (N : ℕ) (t : ℝ) : ℕ :=
  1 + Nat.ceil (2 * C_tail N t / eps)

/-
The sum of 1/k^2 for integers k with |k| >= M is bounded by 2/(M-1) for M >= 2.
-/
/-- Bound on the tail sum of inverse squares -/
lemma tail_sum_inv_sq_bound (M : ℕ) (hM : 2 ≤ M) :
  ∑' k : {k : ℤ // |k| ≥ M}, (1 : ℝ) / (k : ℝ)^2 ≤ 2 / (M - 1) := by
  -- We can bound the sum $\sum_{k \geq M} \frac{1}{k^2}$ by an integral. Specifically, $\sum_{k \geq M} \frac{1}{k^2} \leq \sum_{k \geq M} \frac{1}{(k-1)k} = \sum_{k \geq M} \left(\frac{1}{k-1} - \frac{1}{k}\right)$.
  have integral_bound : ∑' (k : ℤ), (if M ≤ |k| then (1 : ℝ) / (k : ℝ) ^ 2 else 0) ≤ ∑' (k : ℕ), (1 : ℝ) / ((k + M) : ℝ) ^ 2 + ∑' (k : ℕ), (1 : ℝ) / ((k + M) : ℝ) ^ 2 := by
    -- We can split the sum into two parts: one over positive integers and one over negative integers.
    have h_split : ∑' (k : ℤ), (if M ≤ |k| then (1 : ℝ) / (k : ℝ) ^ 2 else 0) = ∑' (k : ℕ), (if M ≤ k then (1 : ℝ) / ((k : ℝ) ^ 2) else 0) + ∑' (k : ℕ), (if M ≤ k then (1 : ℝ) / ((k : ℝ) ^ 2) else 0) := by
      rw [ ← Equiv.tsum_eq ( Equiv.intEquivNat.symm ) ] ; aesop;
      rw [ ← tsum_even_add_odd ] <;> norm_num [ Equiv.intEquivNat ];
      · norm_num [ Equiv.intEquivNatSumNat ];
        rw [ eq_comm, Summable.tsum_eq_zero_add ];
        · norm_num [ Int.negSucc_eq, abs_of_nonpos ];
          exact tsum_congr fun n => by split_ifs <;> ring <;> norm_cast at * ;
        · exact Summable.of_nonneg_of_le ( fun k => by positivity ) ( fun k => by aesop ) ( Real.summable_nat_pow_inv.2 one_lt_two );
      · refine' Summable.of_nonneg_of_le ( fun k => _ ) ( fun k => _ ) ( Real.summable_one_div_nat_pow.2 one_lt_two ) <;> aesop;
        positivity;
      · norm_num [ Equiv.intEquivNatSumNat ];
        exact Summable.of_nonneg_of_le ( fun n => by positivity ) ( fun n => by split_ifs <;> first | positivity | rw [ inv_le_comm₀ ] <;> norm_num <;> ring <;> nlinarith ) ( summable_nat_add_iff 1 |>.2 <| Real.summable_one_div_nat_pow.2 one_lt_two );
    aesop;
    rw [ ← Summable.sum_add_tsum_nat_add M ];
    · rw [ Finset.sum_eq_zero ] <;> aesop;
    · exact Summable.of_nonneg_of_le ( fun k => by positivity ) ( fun k => by aesop ) ( Real.summable_nat_pow_inv.2 one_lt_two );
  -- We can bound the sum $\sum_{k \geq M} \frac{1}{k^2}$ by an integral. Specifically, $\sum_{k \geq M} \frac{1}{k^2} \leq \sum_{k \geq M} \frac{1}{(k-1)k} = \sum_{k \geq M} \left(\frac{1}{k-1} - \frac{1}{k}\right) \leq \frac{1}{M-1}$.
  have integral_bound : ∑' (k : ℕ), (1 : ℝ) / ((k + M) : ℝ) ^ 2 ≤ ∑' (k : ℕ), (1 : ℝ) / ((k + M - 1) * (k + M) : ℝ) := by
    refine' Summable.tsum_le_tsum _ _ _;
    · exact fun k => one_div_le_one_div_of_le ( by nlinarith only [ show ( M : ℝ ) ≥ 2 by norm_cast ] ) ( by nlinarith only [ show ( M : ℝ ) ≥ 2 by norm_cast ] );
    · exact_mod_cast summable_nat_add_iff M |>.2 <| Real.summable_one_div_nat_pow.2 one_lt_two;
    · ring_nf;
      exact Summable.of_nonneg_of_le ( fun k => inv_nonneg.2 <| by nlinarith only [ show ( M : ℝ ) ≥ 2 by norm_cast ] ) ( fun k => by rw [ inv_le_comm₀ ] <;> norm_num <;> ring <;> nlinarith only [ show ( M : ℝ ) ≥ 2 by norm_cast ] ) <| summable_nat_add_iff 1 |>.2 <| Real.summable_one_div_nat_pow.2 one_lt_two;
  -- We can bound the sum $\sum_{k \geq M} \frac{1}{(k-1)k}$ by $\frac{1}{M-1}$.
  have sum_bound : ∑' (k : ℕ), (1 : ℝ) / ((k + M - 1) * (k + M) : ℝ) = 1 / (M - 1) := by
    -- We can bound the sum $\sum_{k \geq M} \frac{1}{(k-1)k}$ by $\frac{1}{M-1}$ using the fact that it is a telescoping series.
    have telescoping_series : ∀ N : ℕ, ∑ k ∈ Finset.range N, (1 : ℝ) / ((k + M - 1) * (k + M) : ℝ) = 1 / (M - 1) - 1 / (N + M - 1) := by
      intro N; induction N <;> simp_all +decide [ Finset.sum_range_succ ];
      ring;
      nlinarith only [ inv_pos.mpr ( by linarith [ ( by norm_cast : ( 2 : ℝ ) ≤ M ) ] : 0 < ( -1 + M : ℝ ) ), inv_pos.mpr ( by linarith [ ( by norm_cast : ( 2 : ℝ ) ≤ M ) ] : 0 < ( -1 + M + ↑‹ℕ› : ℝ ) ), inv_pos.mpr ( by linarith [ ( by norm_cast : ( 2 : ℝ ) ≤ M ) ] : 0 < ( M + ↑‹ℕ› : ℝ ) ), mul_inv_cancel₀ ( by linarith [ ( by norm_cast : ( 2 : ℝ ) ≤ M ) ] : ( -1 + M : ℝ ) ≠ 0 ), mul_inv_cancel₀ ( by linarith [ ( by norm_cast : ( 2 : ℝ ) ≤ M ) ] : ( -1 + M + ↑‹ℕ› : ℝ ) ≠ 0 ), mul_inv_cancel₀ ( by linarith [ ( by norm_cast : ( 2 : ℝ ) ≤ M ) ] : ( M + ↑‹ℕ› : ℝ ) ≠ 0 ) ];
    -- Taking the limit of the telescoping series as $N$ approaches infinity, we get the desired result.
    have limit_telescoping_series : Filter.Tendsto (fun N : ℕ => ∑ k ∈ Finset.range N, (1 : ℝ) / ((k + M - 1) * (k + M) : ℝ)) Filter.atTop (nhds (1 / (M - 1))) := by
      aesop;
      exact le_trans ( tendsto_const_nhds.sub <| tendsto_inv_atTop_zero.comp <| Filter.tendsto_atTop_add_const_right _ _ <| Filter.tendsto_atTop_add_const_right _ _ tendsto_natCast_atTop_atTop ) <| by norm_num;
    refine' tendsto_nhds_unique ( Summable.hasSum ( by exact ( by { by_contra h; exact not_tendsto_atTop_of_tendsto_nhds ( limit_telescoping_series ) <| by exact not_summable_iff_tendsto_nat_atTop_of_nonneg ( fun _ => one_div_nonneg.mpr <| mul_nonneg ( sub_nonneg.mpr <| by norm_cast; linarith ) <| by positivity ) |>.1 h } ) ) |> HasSum.tendsto_sum_nat ) limit_telescoping_series;
  convert le_trans ‹_› ( add_le_add integral_bound integral_bound ) using 1 <;> aesop;
  · erw [ tsum_eq_tsum_of_ne_zero_bij ];
    use fun x => ⟨ x, by
      aesop ⟩
    all_goals generalize_proofs at *;
    · aesop_cat;
    · intro x hx; aesop;
    · aesop;
  · ring

/-- Buffer suppression from decay -/
theorem buffer_from_decay (N : ℕ) (t : ℝ) (m : ℕ) (eps : ℝ) (heps : 0 < eps) (K : ℝ) :
  let Δ := buffer_width K eps N t
  ∑' k : {k : ℤ // |k| ≥ m + Δ}, ‖A_coeff N t k‖ ≤ eps := by
  -- By definition of C_tail, we know that for all k ≠ 0, ‖A_coeff N t k‖ ≤ C_tail N t / k^2.
  have h_fourier_decay : ∀ k : ℤ, k ≠ 0 → ‖A_coeff N t k‖ ≤ C_tail N t / (k : ℝ)^2 := by
    have := @fourier_decay N t;
    cases lt_trichotomy t 0 <;> aesop;
    · rw [ le_div_iff₀ ( by positivity ) ];
      apply le_csSup;
      · convert bddAbove_A_coeff_mul_sq N t;
      · exact ⟨ ⟨ k, a ⟩, rfl ⟩;
    · rw [ le_div_iff₀ ];
      · refine' le_trans _ ( le_ciSup _ ⟨ k, a ⟩ );
        · norm_num;
        · convert bddAbove_A_coeff_mul_sq N 0;
      · positivity;
  -- Let's choose any $M \geq m + \Delta$.
  have h_sum_bound : ∀ M : ℕ, M ≥ m + 1 + Nat.ceil (2 * C_tail N t / eps) → ∑' k : {k : ℤ // |k| ≥ M}, ‖A_coeff N t k‖ ≤ C_tail N t * (2 / (M - 1)) := by
    intro M hM;
    have h_tail_bound : ∑' k : {k : ℤ // |k| ≥ M}, ‖A_coeff N t k‖ ≤ C_tail N t * ∑' k : {k : ℤ // |k| ≥ M}, (1 : ℝ) / (k : ℝ)^2 := by
      rw [ ← tsum_mul_left ];
      refine' Summable.tsum_le_tsum _ _ _;
      · aesop;
      · refine' Summable.of_nonneg_of_le ( fun k => norm_nonneg _ ) ( fun k => h_fourier_decay _ _ ) _;
        · aesop;
        · have h_summable : Summable (fun k : ℤ => (1 : ℝ) / (k : ℝ)^2) := by
            exact Real.summable_one_div_int_pow.2 one_lt_two;
          simpa using Summable.mul_left _ ( h_summable.comp_injective Subtype.coe_injective );
      · -- The sum of 1/k^2 over all integers k is a convergent p-series with p=2.
        have h_pseries : Summable (fun k : ℤ => (1 : ℝ) / (k : ℝ)^2) := by
          exact Real.summable_one_div_int_pow.2 one_lt_two;
        exact Summable.mul_left _ <| h_pseries.comp_injective Subtype.coe_injective;
    refine le_trans h_tail_bound ?_;
    by_cases hM_ge_2 : 2 ≤ M;
    · have := tail_sum_inv_sq_bound M hM_ge_2;
      exact mul_le_mul_of_nonneg_left this <| by exact Real.iSup_nonneg fun _ => mul_nonneg ( norm_nonneg _ ) <| sq_nonneg _;
    · interval_cases M <;> norm_num at *;
      cases m <;> norm_num at *;
      · exact mul_nonpos_of_nonpos_of_nonneg ( by rw [ div_le_iff₀ heps ] at hM; linarith ) ( tsum_nonneg fun _ => by positivity );
      · linarith;
  convert le_trans ( h_sum_bound ( m + 1 + ⌈2 * C_tail N t / eps⌉₊ ) ( by linarith ) ) _ using 1;
  · unfold buffer_width; aesop;
    rw [ add_assoc ];
  · by_cases h : C_tail N t = 0 <;> simp_all +decide [ div_eq_mul_inv ];
    · linarith;
    · field_simp;
      rw [ div_le_iff₀ ] <;> nlinarith [ Nat.le_ceil ( C_tail N t * 2 / eps ), mul_div_cancel₀ ( C_tail N t * 2 ) heps.ne', show ( 0 : ℝ ) < C_tail N t from lt_of_le_of_ne ( by exact Real.iSup_nonneg fun _ => mul_nonneg ( norm_nonneg _ ) ( sq_nonneg _ ) ) ( Ne.symm h ) ]

/-
If M is at least 1 + ceil(2C/eps), then 2C/(M-1) is at most eps.
-/
/-- Arithmetic bound for buffer width -/
lemma arithmetic_bound (C eps : ℝ) (hC : 0 ≤ C) (heps : 0 < eps) (M : ℕ)
  (hM : M ≥ 1 + Nat.ceil (2 * C / eps)) :
  C * (2 / (M - 1)) ≤ eps := by
  rcases M with ( _ | _ | M ) <;> norm_num at *;
  · positivity;
  · rw [ mul_div, div_le_iff₀ ] <;> nlinarith [ Nat.le_ceil ( 2 * C / eps ), mul_div_cancel₀ ( 2 * C ) heps.ne.symm, show ( ⌈2 * C / eps⌉₊ : ℝ ) + 1 ≤ M + 2 by norm_cast; linarith ]

/-
The buffer suppression theorem states that the sum of the magnitudes of the Fourier coefficients for indices greater than or equal to m + Δ is bounded by epsilon.
-/
/-- Buffer suppression from decay -/
theorem buffer_suppression (N : ℕ) (t : ℝ) (m : ℕ) (eps : ℝ) (heps : 0 < eps) (K : ℝ) :
  let Δ := buffer_width K eps N t
  ∑' k : {k : ℤ // |k| ≥ m + Δ}, ‖A_coeff N t k‖ ≤ eps := by
  exact?