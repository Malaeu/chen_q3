/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f8cd9fb7-b136-4836-8ec3-27769f908664
-/

/-
We define the A3 system parameters and properties as a typeclass `A3System`, encapsulating the opaque functions `M_threshold` and `omega_PA` and their monotonicity properties. We define `gap`, `c_arch`, and `c_star` in terms of these parameters. We prove that `c_arch` is monotone non-decreasing (`c_arch_mono_real`), that `c_star` equals `c_arch 1` (`c_star_eq_c_arch_one`), and that `c_star` is positive (`c_star_pos`). Finally, we prove the main theorem `a3_global_arch_floor` showing a uniform positive lower bound for `c_arch(K)` for all `K ≥ 1`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Redefining A3System and dependent functions, with c_star defined as the infimum over the subtype {K // 1 ≤ K}.
-/
class A3System where
  M_threshold : ℝ → ℕ
  omega_PA : ℝ → ℝ
  min_P_A : ℝ
  M_threshold_mono : Monotone M_threshold
  M_threshold_pos : ∀ K, 0 < M_threshold K
  omega_PA_mono : Monotone omega_PA
  a3_k1_floor : min_P_A - 4 * omega_PA (Real.pi / M_threshold 1) > 0

open A3System

variable [A3System]

noncomputable def gap (K : ℝ) : ℝ := 4 * omega_PA (Real.pi / M_threshold K)

noncomputable def c_arch (K : ℝ) : ℝ := min_P_A - gap K

noncomputable def c_star : ℝ := ⨅ k : {K // 1 ≤ K}, c_arch k

/-
c_arch is monotonically non-decreasing on the entire real line.
-/
lemma c_arch_mono_real : Monotone c_arch := by
  intros a b hab;
  -- By the properties of the infimum, we have that $c_arch a \leq c_arch b$ if and only if for all $\epsilon > 0$, there exists $K \in {K // 1 ≤ K}$ such that $c_arch K < c_arch b + \epsilon$.
  unfold c_arch;
  unfold gap;
  bound;
  · -- Since $M_threshold$ is monotone increasing, we have $M_threshold a \leq M_threshold b$.
    have hM : inst.M_threshold a ≤ inst.M_threshold b := by
      exact inst.M_threshold_mono hab;
    exact inst.omega_PA_mono ( div_le_div_of_nonneg_left Real.pi_pos.le ( Nat.cast_pos.mpr <| inst.M_threshold_pos _ ) <| mod_cast hM );
  · norm_num

/-
c_star is equal to c_arch(1).
-/
lemma c_star_eq_c_arch_one : c_star = c_arch 1 := by
  -- First, let's unfold the definition of `c_arch`.
  unfold c_arch c_star;
  unfold gap c_arch;
  unfold gap;
  refine' le_antisymm _ _;
  · refine' csInf_le _ _;
    · refine' ⟨ _, Set.forall_mem_range.2 fun k => _ ⟩;
      exact ‹A3System›.min_P_A - 4 * ‹A3System›.omega_PA ( Real.pi / ( ‹A3System›.M_threshold 1 : ℝ ) );
      bound;
      · refine' inst.omega_PA_mono _;
        gcongr;
        · exact Nat.cast_pos.mpr ( inst.M_threshold_pos 1 );
        · exact inst.M_threshold_mono ( mod_cast property );
      · norm_num;
    · exact ⟨ ⟨ 1, by norm_num ⟩, by norm_num ⟩;
  · refine' le_csInf _ _;
    · exact ⟨ _, ⟨ ⟨ 1, by norm_num ⟩, rfl ⟩ ⟩;
    · aesop;
      rw [ sub_add_eq_add_sub, le_sub_iff_add_le ];
      gcongr;
      exact inst.omega_PA_mono ( div_le_div_of_nonneg_left ( by positivity ) ( by norm_cast; linarith [ inst.M_threshold_pos 1 ] ) ( mod_cast inst.M_threshold_mono ( Nat.one_le_cast.mpr left ) ) )

/-
c_star is strictly positive.
-/
lemma c_star_pos : c_star > 0 := by
  rw [c_star_eq_c_arch_one]
  unfold c_arch gap
  exact a3_k1_floor

/-
For all K >= 1, c_arch(K) >= c_arch(1) and c_arch(1) > 0.
-/
theorem a3_global_arch_floor (K : ℝ) (hK : K ≥ 1) : c_arch K ≥ c_arch 1 ∧ c_arch 1 > 0 := by
  constructor
  · apply c_arch_mono_real hK
  · rw [← c_star_eq_c_arch_one]
    exact c_star_pos