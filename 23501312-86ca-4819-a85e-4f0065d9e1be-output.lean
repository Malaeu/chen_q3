/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 23501312-86ca-4819-a85e-4f0065d9e1be

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

noncomputable def FejerKernel (B : ℝ) (x : ℝ) : ℝ := max 0 (1 - |x| / B)

noncomputable def HeatKernel (t : ℝ) (x : ℝ) : ℝ :=
  (4 * Real.pi * t) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / (4 * t))

def W_K (K : ℝ) : Set (ℝ → ℝ) :=
  {Φ | ContinuousOn Φ (Set.Icc (-K) K) ∧
       Function.support Φ ⊆ Set.Icc (-K) K ∧
       Even Φ ∧
       ∀ x, 0 ≤ Φ x}

noncomputable def Atom (B t τ : ℝ) (x : ℝ) : ℝ :=
  FejerKernel B (x - τ) * HeatKernel t (x - τ) +
  FejerKernel B (x + τ) * HeatKernel t (x + τ)

def AtomSet (K : ℝ) : Set (ℝ → ℝ) :=
  {g | ∃ B > 0, ∃ t > 0, ∃ τ ∈ Set.Icc (-K) K, g = Atom B t τ}

def AtomCone_K (K : ℝ) : Set (ℝ → ℝ) :=
  Convex.toCone (convexHull ℝ (AtomSet K)) (convex_convexHull ℝ (AtomSet K))

def diff_set (Φ : ℝ → ℝ) (g : ℝ → ℝ) (K : ℝ) : Set ℝ :=
  (fun x ↦ |Φ x - g x|) '' Set.Icc (-K) K

def IsDenseInWK (K : ℝ) : Prop :=
  ∀ Φ ∈ W_K K, ∀ ε > 0, ∃ g ∈ AtomCone_K K, sSup (diff_set Φ g K) < ε

noncomputable def real_convolution (f g : ℝ → ℝ) (x : ℝ) : ℝ := ∫ t, f t * g (x - t)

lemma HeatKernel_integral (t : ℝ) (ht : t > 0) : ∫ x, HeatKernel t x = 1 := by
  -- The integral of the Gaussian function over the entire real line is equal to 1.
  have h_gauss_integral : ∫ x, Real.exp (-x^2 / (4 * t)) = Real.sqrt (4 * Real.pi * t) := by
    -- Apply the Gaussian integral theorem with $a = \frac{1}{4t}$.
    have h_gauss : ∫ x, Real.exp (-x^2 / (4 * t)) = Real.sqrt (Real.pi / (1 / (4 * t))) := by
      convert integral_gaussian ( 1 / ( 4 * t ) ) using 1 ; norm_num [ div_eq_inv_mul ];
    exact h_gauss.trans ( by rw [ div_div_eq_mul_div ] ; ring );
  -- Substitute the definition of the HeatKernel into the integral.
  have h_integral : ∫ x, HeatKernel t x = (4 * Real.pi * t) ^ (-(1:ℝ)/2) * ∫ x, Real.exp (-x^2 / (4 * t)) := by
    rw [ ← MeasureTheory.integral_const_mul ];
    exact?;
  -- Substitute the known value of the Gaussian integral into the expression for the HeatKernel integral.
  rw [h_integral, h_gauss_integral];
  rw [ Real.sqrt_eq_rpow, ← Real.rpow_add ] <;> norm_num ; positivity

lemma HeatKernel_mass_concentration (δ : ℝ) (hδ : δ > 0) :
  Filter.Tendsto (fun t => ∫ x in {y | |y| > δ}, HeatKernel t x)
    (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
      -- By definition of $HeatKernel$, we know that
      have h_heat_kernel : ∀ t > 0, ∫ x in {y | abs y > δ}, HeatKernel t x = ∫ x in {y | abs y > δ / Real.sqrt t}, (4 * Real.pi) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / 4) := by
        intro t ht_pos
        have h_subst : ∀ {f : ℝ → ℝ}, ∫ x in {y | abs y > δ}, f x = ∫ x in {y | abs y > δ / Real.sqrt t}, f (Real.sqrt t * x) * Real.sqrt t := by
          intro f
          have h_subst : ∫ x in {y | abs y > δ}, f x = ∫ x in (Set.image (fun x => Real.sqrt t * x) {y | abs y > δ / Real.sqrt t}), f x := by
            congr with x ; aesop;
            · use x / Real.sqrt t;
              exact ⟨ by rw [ abs_div, abs_of_pos ( Real.sqrt_pos.mpr ht_pos ) ] ; gcongr, mul_div_cancel₀ _ ( ne_of_gt ( Real.sqrt_pos.mpr ht_pos ) ) ⟩;
            · rwa [ abs_of_pos ( Real.sqrt_pos.mpr ht_pos ), div_lt_iff₀' ( Real.sqrt_pos.mpr ht_pos ) ] at *;
          rw [ h_subst, MeasureTheory.integral_image_eq_integral_abs_deriv_smul ] <;> norm_num [ ht_pos.le ];
          any_goals intro x hx; exact HasDerivAt.hasDerivWithinAt ( by simpa using HasDerivAt.const_mul ( Real.sqrt t ) ( hasDerivAt_id x ) );
          · norm_num [ mul_comm, abs_of_pos ( Real.sqrt_pos.mpr ht_pos ) ];
          · exact measurableSet_Ioi.mem.comp measurable_norm;
          · exact fun x hx y hy hxy => mul_left_cancel₀ ( ne_of_gt ( Real.sqrt_pos.mpr ht_pos ) ) hxy;
        convert h_subst using 1;
        unfold HeatKernel; norm_num [ ht_pos.le, ht_pos.ne', mul_assoc, mul_comm, mul_left_comm, div_eq_mul_inv, Real.rpow_neg, Real.rpow_two, Real.pi_pos.le ] ;
        norm_num [ Real.rpow_neg_eq_inv_rpow, mul_pow, mul_assoc, mul_comm, mul_left_comm, ht_pos.le, ht_pos.ne' ];
        norm_num [ ← mul_assoc, ← Real.sqrt_eq_rpow, ht_pos.le, ht_pos.ne', Real.pi_pos.le, Real.pi_pos.ne', mul_comm, mul_left_comm, mul_assoc, Real.sqrt_mul, Real.sqrt_inv ];
      -- As $t \to 0$, $\delta / \sqrt{t} \to \infty$, so the integral over $|x| > \delta / \sqrt{t}$ tends to zero.
      have h_lim_zero : Filter.Tendsto (fun t => ∫ x in {y | abs y > δ / Real.sqrt t}, (4 * Real.pi) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / 4)) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
        -- The integral of the Gaussian function over the set where |x| > δ / sqrt(t) tends to zero as δ / sqrt(t) tends to infinity.
        have h_gauss_tail : Filter.Tendsto (fun M => ∫ x in {y | abs y > M}, (4 * Real.pi) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / 4)) (Filter.atTop) (nhds 0) := by
          have h_gauss_tail : Filter.Tendsto (fun M => ∫ x in Set.univ, (4 * Real.pi) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / 4) * (if abs x > M then 1 else 0)) Filter.atTop (nhds 0) := by
            have h_gauss_tail : Filter.Tendsto (fun M => ∫ x in Set.univ, (4 * Real.pi) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / 4) * (if abs x > M then 1 else 0)) Filter.atTop (nhds (∫ x in Set.univ, (4 * Real.pi) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / 4) * 0)) := by
              refine' MeasureTheory.tendsto_integral_filter_of_dominated_convergence _ _ _ _ _ <;> norm_num +zetaDelta at *;
              refine' fun x => ( 4 * Real.pi ) ^ ( - ( 1 / 2 ) : ℝ ) * Real.exp ( -x ^ 2 / 4 );
              · exact ⟨ 0, fun t ht => Measurable.aestronglyMeasurable ( by exact Measurable.ite ( measurableSet_lt measurable_const ( measurable_norm ) ) ( by exact Continuous.measurable ( by continuity ) ) measurable_const ) ⟩;
              · exact ⟨ 0, fun t ht => Filter.Eventually.of_forall fun x => by split_ifs <;> rw [ abs_of_nonneg ] <;> positivity ⟩;
              · exact MeasureTheory.Integrable.const_mul ( by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) ) _;
              · filter_upwards [ ] with x using tendsto_const_nhds.congr' ( by filter_upwards [ Filter.eventually_gt_atTop |x| ] with n hn; split_ifs <;> linarith );
            aesop;
          convert h_gauss_tail using 2 ; norm_num [ ← MeasureTheory.integral_indicator, Set.indicator_apply ];
          rw [ ← MeasureTheory.integral_indicator ] <;> norm_num [ Set.indicator ];
          exact measurableSet_Ioi.mem.comp measurable_norm;
        refine h_gauss_tail.comp ?_;
        refine' Filter.Tendsto.const_mul_atTop hδ _;
        refine' Filter.Tendsto.inv_tendsto_nhdsGT_zero _;
        refine' Filter.Tendsto.inf _ _ <;> simpa using Real.continuous_sqrt.tendsto 0;
      exact Filter.Tendsto.congr' ( Filter.eventuallyEq_of_mem self_mem_nhdsWithin fun t ht => by rw [ h_heat_kernel t ht ] ) h_lim_zero

lemma HeatKernel_nonneg (t : ℝ) (ht : t > 0) (x : ℝ) : 0 ≤ HeatKernel t x := by
  -- The exponential function is always positive, and the term $(4\pi t)^{-1/2}$ is also positive since $t > 0$. Therefore, their product is positive.
  apply mul_nonneg; exact Real.rpow_nonneg (by positivity) _; exact Real.exp_nonneg _

lemma FejerKernel_bounds (B : ℝ) (hB : B > 0) (x : ℝ) :
  0 ≤ FejerKernel B x ∧ FejerKernel B x ≤ 1 := by
    -- By definition of FejerKernel, we have FejerKernel B x = max 0 (1 - |x| / B).
    simp [FejerKernel];
    -- Since $B > 0$, we have $|x| / B \geq 0$ for all $x$.
    apply div_nonneg; exact abs_nonneg x; exact hB.le

lemma FejerKernel_approx_one (K : ℝ) (B : ℝ) (hB : B > K) (x : ℝ) (hx : x ∈ Set.Icc (-K) K) :
  1 - K / B ≤ FejerKernel B x := by
    -- Since $|x| \leq K$ and $B > K$, we have $|x| / B \leq K / B$.
    have h_abs : |x| / B ≤ K / B := by
      gcongr ; cases abs_cases x <;> linarith [ hx.1, hx.2 ];
      cases abs_cases x <;> linarith [ hx.1, hx.2 ];
    -- Since $|x| / B \leq K / B$, we have $1 - |x| / B \geq 1 - K / B$.
    have h_ineq : 1 - |x| / B ≥ 1 - K / B := by
      linarith;
    -- By definition of FejerKernel, we have FejerKernel B x = max 0 (1 - |x| / B).
    have h_fejer_def : FejerKernel B x = max 0 (1 - |x| / B) := by
      exact?;
    exact h_fejer_def ▸ le_trans h_ineq ( le_max_right _ _ )

lemma exists_compact_extension (K : ℝ) (hK : K > 0) (Φ : ℝ → ℝ)
    (hΦ : ContinuousOn Φ (Set.Icc (-K) K)) :
  ∃ Ψ : ℝ → ℝ, Continuous Ψ ∧ HasCompactSupport Ψ ∧ ∀ x ∈ Set.Icc (-K) K, Ψ x = Φ x := by
    -- By the Tietze extension theorem, we can extend Φ to a continuous function on ℝ.
    obtain ⟨Ψ, hΨ⟩ : ∃ Ψ : ℝ → ℝ, Continuous Ψ ∧ ∀ x ∈ Set.Icc (-K) K, Ψ x = Φ x := by
      have := @ContinuousMap.exists_extension;
      specialize this ( show Topology.IsClosedEmbedding ( fun x : Set.Icc ( -K ) K => x : Set.Icc ( -K ) K → ℝ ) from ?_ ) ( ContinuousMap.mk ( fun x : Set.Icc ( -K ) K => Φ x ) <| by
                          exact continuousOn_iff_continuous_restrict.mp hΦ )
      generalize_proofs at *
      all_goals generalize_proofs at *;
      · exact?;
      · exact ⟨ _, this.choose.continuous, fun x hx => by simpa using congr_arg ( fun f => f ⟨ x, hx ⟩ ) this.choose_spec ⟩;
    -- To ensure that Ψ has compact support, we can multiply it by a bump function that is 1 on [-K, K] and smoothly goes to zero outside this interval.
    obtain ⟨φ, hφ⟩ : ∃ φ : ℝ → ℝ, Continuous φ ∧ (∀ x ∈ Set.Icc (-K) K, φ x = 1) ∧ (∀ x, |x| > K + 1 → φ x = 0) ∧ (∀ x, 0 ≤ φ x ∧ φ x ≤ 1) := by
      refine' ⟨ fun x => if |x| ≤ K then 1 else if |x| ≥ K + 1 then 0 else 1 - ( |x| - K ) / ( K + 1 - K ), _, _, _, _ ⟩ <;> aesop;
      any_goals linarith [ abs_nonneg x ];
      · apply_rules [ Continuous.if_le, Continuous.sub, Continuous.mul, continuous_const, continuous_abs ];
        · intros; linarith;
        · grind;
      · cases abs_cases x <;> linarith;
      · cases abs_cases x <;> linarith;
    refine' ⟨ fun x => φ x * Ψ x, _, _, _ ⟩;
    · exact hφ.1.mul hΨ.1;
    · rw [ hasCompactSupport_iff_eventuallyEq ];
      norm_num [ Filter.EventuallyEq ];
      exact ⟨ ⟨ -K - 2, fun x hx => Or.inl <| hφ.2.2.1 x <| by cases abs_cases x <;> linarith ⟩, ⟨ K + 2, fun x hx => Or.inl <| hφ.2.2.1 x <| by cases abs_cases x <;> linarith ⟩ ⟩;
    · grind

lemma HeatKernel_approx_identity_uniform (f : ℝ → ℝ) (hf_cont : Continuous f)
    (hf_supp : HasCompactSupport f) (ε : ℝ) (hε : ε > 0) :
  ∃ t₀ > 0, ∀ t ∈ Set.Ioo 0 t₀, ∀ x, |real_convolution f (HeatKernel t) x - f x| < ε := by
    -- Since $f$ is continuous with compact support, it is uniformly continuous. Therefore, for any $\epsilon > 0$, there exists a $\delta > 0$ such that $|x - y| < \delta$ implies $|f(x) - f(y)| < \epsilon$.
    obtain ⟨δ, hδ_pos, hδ⟩ : ∃ δ > 0, ∀ x y, |x - y| < δ → |f x - f y| < ε / 2 := by
      have h_unif_cont : UniformContinuous f := by
        exact?;
      exact Metric.uniformContinuous_iff.mp h_unif_cont ( ε / 2 ) ( half_pos hε );
    -- Using the fact that the heat kernel is normalized, we can bound the integral.
    have h_integral_bound : ∀ t > 0, ∀ x, |real_convolution f (HeatKernel t) x - f x| ≤ ∫ y, HeatKernel t y * |f (x - y) - f x| := by
      -- Using the fact that the heat kernel is normalized, we can rewrite the convolution as an integral.
      have h_convolution_integral : ∀ t > 0, ∀ x, real_convolution f (HeatKernel t) x - f x = ∫ y, HeatKernel t y * (f (x - y) - f x) := by
        intro t ht x;
        simp +decide [ mul_sub, MeasureTheory.integral_sub ];
        rw [ MeasureTheory.integral_sub ];
        · simp +decide [ mul_comm, MeasureTheory.integral_const_mul, MeasureTheory.integral_mul_const, real_convolution ];
          simp +decide [ mul_comm, MeasureTheory.integral_const_mul, MeasureTheory.integral_mul_const, HeatKernel_integral t ht ];
          rw [ ← MeasureTheory.integral_sub_left_eq_self ] ; congr ; ext ; ring;
        · -- Since $f$ is continuous with compact support, it is bounded. Let $M$ be an upper bound for $|f|$.
          obtain ⟨M, hM⟩ : ∃ M, ∀ x, |f x| ≤ M := by
            have := hf_supp.exists_bound_of_continuous hf_cont;
            tauto;
          -- Since $f$ is bounded and the heat kernel is integrable, their product is also integrable.
          have h_integrable : MeasureTheory.Integrable (fun y => HeatKernel t y) MeasureTheory.MeasureSpace.volume := by
            have h_integrable : ∫ y, HeatKernel t y = 1 := by
              exact?;
            exact MeasureTheory.integrable_of_integral_eq_one h_integrable;
          refine' MeasureTheory.Integrable.mono' ( h_integrable.norm.mul_const M ) _ _;
          · exact MeasureTheory.AEStronglyMeasurable.mul ( h_integrable.aestronglyMeasurable ) ( hf_cont.comp ( continuous_const.sub continuous_id' ) |> Continuous.aestronglyMeasurable );
          · filter_upwards [ ] using fun y => by rw [ norm_mul ] ; exact mul_le_mul_of_nonneg_left ( hM _ ) ( norm_nonneg _ ) ;
        · refine' MeasureTheory.Integrable.mul_const _ _;
          exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht );
      intro t ht x; rw [ h_convolution_integral t ht x ] ; refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm ( _ : ℝ → ℝ ) ) _;
      norm_num [ abs_mul, abs_of_nonneg, HeatKernel_nonneg t ht ];
    -- Using the fact that the heat kernel is normalized, we can bound the integral further.
    have h_integral_bound_further : ∀ t > 0, ∀ x, ∫ y, HeatKernel t y * |f (x - y) - f x| ≤ (∫ y in {y | |y| < δ}, HeatKernel t y * (ε / 2)) + (∫ y in {y | |y| ≥ δ}, HeatKernel t y * (2 * SupSet.sSup (Set.image (fun x => |f x|) (Set.univ)))) := by
      intros t ht x
      have h_integral_bound_further : ∫ y, HeatKernel t y * |f (x - y) - f x| ≤ ∫ y, HeatKernel t y * (if |y| < δ then ε / 2 else 2 * (SupSet.sSup (Set.image (fun x => |f x|) (Set.univ)))) := by
        refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
        · exact Filter.Eventually.of_forall fun y => mul_nonneg ( by exact le_of_lt ( by exact mul_pos ( Real.rpow_pos_of_pos ( by positivity ) _ ) ( Real.exp_pos _ ) ) ) ( abs_nonneg _ );
        · refine' MeasureTheory.Integrable.mono' _ _ _;
          refine' fun y => HeatKernel t y * ( ε / 2 + 2 * SupSet.sSup ( Set.image ( fun x => |f x| ) Set.univ ) );
          · refine' MeasureTheory.Integrable.mul_const _ _;
            exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht );
          · refine' Measurable.aestronglyMeasurable _;
            exact Measurable.mul ( by exact Measurable.mul ( by exact Measurable.pow_const ( by exact measurable_const.mul measurable_const ) _ ) ( by exact Real.continuous_exp.measurable.comp ( by exact Measurable.div_const ( by exact Measurable.neg ( by exact measurable_id.pow_const 2 ) ) _ ) ) ) ( by exact Measurable.ite ( measurableSet_lt ( measurable_norm ) measurable_const ) measurable_const measurable_const );
          · filter_upwards [ ] with y ; split_ifs <;> rw [ Real.norm_of_nonneg ] <;> nlinarith [ show 0 ≤ HeatKernel t y from by unfold HeatKernel; positivity, show 0 ≤ SupSet.sSup ( ( fun x => |f x| ) '' Set.univ ) from by apply_rules [ Real.sSup_nonneg ] ; rintro _ ⟨ x, -, rfl ⟩ ; exact abs_nonneg _ ];
        · filter_upwards [ ] with y;
          split_ifs;
          · exact mul_le_mul_of_nonneg_left ( le_of_lt ( hδ _ _ ( by simpa using ‹|y| < δ› ) ) ) ( by unfold HeatKernel; positivity );
          · refine' mul_le_mul_of_nonneg_left _ ( HeatKernel_nonneg t ht y );
            simp +zetaDelta at *;
            exact le_trans ( abs_sub _ _ ) ( by linarith [ show |f ( x - y )| ≤ SupSet.sSup ( Set.range fun x => |f x| ) from le_csSup ( by exact ( hf_supp.abs.isCompact_range hf_cont.abs ).bddAbove ) ( Set.mem_range_self _ ), show |f x| ≤ SupSet.sSup ( Set.range fun x => |f x| ) from le_csSup ( by exact ( hf_supp.abs.isCompact_range hf_cont.abs ).bddAbove ) ( Set.mem_range_self _ ) ] );
      convert h_integral_bound_further using 1;
      rw [ ← MeasureTheory.integral_indicator, ← MeasureTheory.integral_indicator ];
      · rw [ ← MeasureTheory.integral_add ] ; congr ; ext y ; by_cases hy : |y| < δ <;> simp +decide [ hy ];
        · rw [ MeasureTheory.integrable_indicator_iff ];
          · refine' MeasureTheory.Integrable.integrableOn _;
            refine' MeasureTheory.Integrable.mul_const _ _;
            exact MeasureTheory.integrable_of_integral_eq_one ( HeatKernel_integral t ht );
          · exact measurableSet_lt measurable_norm measurable_const;
        · -- Since the heat kernel is integrable and the set where |y| ≥ δ is measurable, the product is integrable.
          have h_integrable : MeasureTheory.Integrable (fun y => HeatKernel t y * (2 * SupSet.sSup (Set.image (fun x => |f x|) Set.univ))) MeasureTheory.MeasureSpace.volume := by
            have h_integrable : MeasureTheory.Integrable (fun y => HeatKernel t y) MeasureTheory.MeasureSpace.volume := by
              have h_integrable : ∫ y, HeatKernel t y = 1 := by
                exact?;
              exact MeasureTheory.integrable_of_integral_eq_one h_integrable;
            exact h_integrable.mul_const _;
          exact MeasureTheory.Integrable.indicator h_integrable ( measurableSet_le measurable_const ( measurable_norm ) );
      · exact measurableSet_le measurable_const measurable_norm;
      · exact measurableSet_lt measurable_norm measurable_const;
    -- Using the fact that the integral of the heat kernel over the entire real line is 1, we can simplify the expression.
    have h_integral_simplified : ∀ t > 0, (∫ y in {y | |y| < δ}, HeatKernel t y * (ε / 2)) + (∫ y in {y | |y| ≥ δ}, HeatKernel t y * (2 * SupSet.sSup (Set.image (fun x => |f x|) (Set.univ)))) ≤ (ε / 2) + (2 * SupSet.sSup (Set.image (fun x => |f x|) (Set.univ))) * (∫ y in {y | |y| ≥ δ}, HeatKernel t y) := by
      intro t ht; rw [ MeasureTheory.integral_mul_const, MeasureTheory.integral_mul_const ] ; norm_num [ mul_comm ] ;
      refine' mul_le_of_le_one_right ( by positivity ) _;
      refine' le_trans ( MeasureTheory.setIntegral_le_integral _ _ ) _;
      · exact MeasureTheory.Integrable.const_mul ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact by simpa [ div_eq_inv_mul ] using ( integrable_exp_neg_mul_sq ( by positivity ) ) ) ) ) ) ) ) ) _;
      · exact Filter.Eventually.of_forall fun x => by unfold HeatKernel; positivity;
      · rw [ show ∫ x : ℝ, HeatKernel t x = 1 from by simpa using HeatKernel_integral t ht ];
    -- Using the fact that the integral of the heat kernel over the entire real line is 1, we can simplify the expression further.
    have h_integral_final : Filter.Tendsto (fun t => ∫ y in {y | |y| ≥ δ}, HeatKernel t y) (nhdsWithin 0 (Set.Ioi 0)) (nhds 0) := by
      convert HeatKernel_mass_concentration δ hδ_pos using 1;
      ext t; rw [ MeasureTheory.setIntegral_congr_set ] ; aesop;
      rw [ MeasureTheory.ae_eq_set ];
      constructor <;> rw [ MeasureTheory.measure_eq_zero_iff_ae_notMem ] <;> aesop;
      · filter_upwards [ MeasureTheory.measure_eq_zero_iff_ae_notMem.mp ( MeasureTheory.measure_singleton ( δ ) ), MeasureTheory.measure_eq_zero_iff_ae_notMem.mp ( MeasureTheory.measure_singleton ( -δ ) ) ] with x hx₁ hx₂ using fun hx₃ => lt_of_le_of_ne hx₃ ( by cases abs_cases x <;> cases lt_or_gt_of_ne hx₁ <;> cases lt_or_gt_of_ne hx₂ <;> linarith );
      · exact Filter.Eventually.of_forall fun x hx => le_of_lt hx;
    have := Metric.tendsto_nhdsWithin_nhds.mp ( h_integral_final.const_mul ( 2 * SupSet.sSup ( ( fun x => |f x| ) '' Set.univ ) ) ) ( ε / 2 ) ( half_pos hε );
    obtain ⟨ t₀, ht₀_pos, ht₀ ⟩ := this; exact ⟨ t₀, ht₀_pos, fun t ht x => lt_of_le_of_lt ( h_integral_bound t ht.1 x ) ( lt_of_le_of_lt ( h_integral_bound_further t ht.1 x ) ( lt_of_le_of_lt ( h_integral_simplified t ht.1 ) ( by linarith [ abs_lt.mp ( ht₀ ht.1 ( by simpa [ abs_of_pos ht.1 ] using ht.2 ) ) ] ) ) ) ⟩ ;

lemma uniform_riemann_sum (a b : ℝ) (hab : a < b) (X : Set ℝ) (hX : IsCompact X)
    (F : ℝ → ℝ → ℝ) (hF : ContinuousOn (Function.uncurry F) (X ×ˢ Set.Icc a b))
    (ε : ℝ) (hε : ε > 0) :
  ∃ (s : Finset ℝ) (w : ℝ → ℝ), (∀ y ∈ s, w y > 0) ∧ (∀ y ∈ s, y ∈ Set.Icc a b) ∧
  ∀ x ∈ X, |(∫ y in Set.Icc a b, F x y) - ∑ y ∈ s, w y * F x y| < ε := by
    -- Since $F$ is continuous on the compact set $X \times [a, b]$, it is uniformly continuous.
    obtain ⟨δ, hδ⟩ : ∃ δ > 0, ∀ x₁ x₂ y₁ y₂, x₁ ∈ X → x₂ ∈ X → y₁ ∈ Set.Icc a b → y₂ ∈ Set.Icc a b → |x₁ - x₂| < δ → |y₁ - y₂| < δ → |F x₁ y₁ - F x₂ y₂| < ε / (1 + b - a) := by
      have h_unif_cont : UniformContinuousOn (Function.uncurry F) (X ×ˢ Set.Icc a b) := by
        exact ( isCompact_iff_compactSpace.mpr <| by have := hX; exact ( isCompact_iff_compactSpace.mp <| this.prod <| CompactIccSpace.isCompact_Icc ) ) |> fun h => h.uniformContinuousOn_of_continuous hF;
      rcases Metric.uniformContinuousOn_iff.mp h_unif_cont ( ε / ( 1 + b - a ) ) ( div_pos hε ( by linarith ) ) with ⟨ δ, hδ, H ⟩ ; use δ ; aesop;
      exact H x₁ y₁ a_1 a_3 a_4 x₂ y₂ a_2 a_5 a_6 ( by simpa [ Prod.dist_eq ] using max_lt a_7 a_8 );
    -- Choose a partition of $[a, b]$ into subintervals of length less than $\delta$.
    obtain ⟨n, hn⟩ : ∃ n : ℕ, n > 0 ∧ (b - a) / n < δ := by
      exact ⟨ ⌊ ( b - a ) / δ⌋₊ + 1, Nat.succ_pos _, by rw [ div_lt_iff₀ ] <;> push_cast <;> nlinarith [ Nat.lt_floor_add_one ( ( b - a ) / δ ), mul_div_cancel₀ ( b - a ) hδ.1.ne' ] ⟩;
    refine' ⟨ Finset.image ( fun i : ℕ => a + i * ( b - a ) / n ) ( Finset.range n ), fun y => ( b - a ) / n, _, _, _ ⟩ <;> aesop;
    · exact div_nonneg ( mul_nonneg ( Nat.cast_nonneg _ ) ( sub_nonneg.mpr hab.le ) ) ( Nat.cast_nonneg _ );
    · rw [ add_div', div_le_iff₀ ] <;> nlinarith [ show ( w : ℝ ) + 1 ≤ n by norm_cast ];
    · -- By the properties of the integral, we can approximate it by the sum of the integrals over each subinterval.
      have h_integral_approx : ∫ y in Set.Icc a b, F x y = ∑ i ∈ Finset.range n, ∫ y in (a + i * (b - a) / n).. (a + (i + 1) * (b - a) / n), F x y := by
        rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le hab.le ];
        symm;
        convert intervalIntegral.sum_integral_adjacent_intervals _ <;> norm_num [ left_1.ne' ];
        intro k hk;
        -- Since $F$ is continuous on $X \times [a, b]$, for any fixed $x \in X$, $F(x, y)$ is continuous in $y$. Therefore, $F(x, y)$ is continuous on $[a, b]$, and hence integrable on any subinterval of $[a, b]$.
        have h_cont : ContinuousOn (fun y => F x y) (Set.Icc a b) := by
          exact hF.comp ( continuousOn_const.prodMk continuousOn_id ) fun y hy => ⟨ a_1, hy ⟩;
        apply_rules [ ContinuousOn.intervalIntegrable, h_cont ];
        exact h_cont.mono ( by rw [ Set.uIcc_of_le ( by nlinarith [ show ( k : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( k : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( k : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ] ; exact Set.Icc_subset_Icc ( by nlinarith [ show ( k : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( k : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( k : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ( by nlinarith [ show ( k : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( k : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( k : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) );
      -- By the properties of the integral, we can approximate it by the sum of the integrals over each subinterval, using the fact that $F$ is continuous on the compact set $X \times [a, b]$.
      have h_integral_approx : ∀ i ∈ Finset.range n, |∫ y in (a + i * (b - a) / n).. (a + (i + 1) * (b - a) / n), F x y - F x (a + i * (b - a) / n)| ≤ (b - a) / n * ε / (1 + b - a) := by
        intro i hi; rw [ intervalIntegral.integral_of_le ( by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp hi ], mul_div_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( i : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ] ; aesop;
        refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm ( _ : ℝ → ℝ ) ) ( le_trans ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _ );
        use fun y => ε / ( 1 + b - a );
        · exact Filter.Eventually.of_forall fun _ => norm_nonneg _;
        · norm_num;
        · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with y hy ; specialize right x x y ( a + i * ( b - a ) / n ) ; aesop;
          exact le_of_lt ( right ( by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ( by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( i + 1 : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ( by exact div_nonneg ( mul_nonneg ( Nat.cast_nonneg _ ) ( sub_nonneg.mpr hab.le ) ) ( Nat.cast_nonneg _ ) ) ( by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ( abs_lt.mpr ⟨ by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( i + 1 : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), div_mul_cancel₀ ( b - a ) ( by positivity : ( n : ℝ ) ≠ 0 ) ], by nlinarith [ show ( i : ℝ ) + 1 ≤ n by norm_cast, mul_div_cancel₀ ( ( i : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( i + 1 : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), div_mul_cancel₀ ( b - a ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ⟩ ) );
        · norm_num [ add_mul, div_eq_mul_inv ];
          rw [ max_eq_left ( by exact mul_nonneg ( sub_nonneg.2 hab.le ) ( inv_nonneg.2 ( Nat.cast_nonneg _ ) ) ) ] ; ring_nf; norm_num;
      -- By the properties of the integral, we can approximate it by the sum of the integrals over each subinterval, using the fact that $F$ is continuous on the compact set $X \times [a, b]$, and the length of each subinterval is $(b - a) / n$.
      have h_integral_approx : |∑ i ∈ Finset.range n, ∫ y in (a + i * (b - a) / n).. (a + (i + 1) * (b - a) / n), F x y - F x (a + i * (b - a) / n)| ≤ n * (b - a) / n * ε / (1 + b - a) := by
        exact le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( le_trans ( Finset.sum_le_sum h_integral_approx ) ( by norm_num; ring_nf; norm_num ) );
      rw [ Finset.sum_image ] <;> aesop;
      · convert lt_of_le_of_lt h_integral_approx _ using 1;
        · rw [ ← Finset.sum_sub_distrib, Finset.sum_congr rfl ] ; intros ; rw [ intervalIntegral.integral_sub ] <;> norm_num;
          · exact Or.inl <| by ring;
          · -- Since $F$ is continuous on the compact set $X \times [a, b]$, for each fixed $x \in X$, the function $F x$ is continuous on $[a, b]$.
            have h_cont : ContinuousOn (fun y => F x y) (Set.Icc a b) := by
              exact hF.comp ( continuousOn_const.prodMk continuousOn_id ) fun y hy => ⟨ a_1, hy ⟩;
            apply_rules [ ContinuousOn.intervalIntegrable, h_cont ];
            exact h_cont.mono ( by rw [ Set.uIcc_of_le ( by nlinarith [ show ( ↑‹ℕ› : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp ‹_› ], mul_div_cancel₀ ( ( ↑‹ℕ› : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( ↑‹ℕ› : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ] ; exact Set.Icc_subset_Icc ( by nlinarith [ show ( ↑‹ℕ› : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp ‹_› ], mul_div_cancel₀ ( ( ↑‹ℕ› : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( ↑‹ℕ› : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) ( by nlinarith [ show ( ↑‹ℕ› : ℝ ) + 1 ≤ n by norm_cast; linarith [ Finset.mem_range.mp ‹_› ], mul_div_cancel₀ ( ( ↑‹ℕ› : ℝ ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ), mul_div_cancel₀ ( ( ( ↑‹ℕ› : ℝ ) + 1 ) * ( b - a ) ) ( by positivity : ( n : ℝ ) ≠ 0 ) ] ) );
        · rw [ mul_div_cancel_left₀ _ ( by positivity ), div_lt_iff₀ ] <;> nlinarith;
      · -- To prove injectivity, assume $f(i) = f(j)$ for $i, j \in \{0, 1, \ldots, n-1\}$.
        intro i hi j hj hij
        field_simp at hij;
        exact_mod_cast ( by nlinarith [ show ( i : ℝ ) < n by exact_mod_cast hi, show ( j : ℝ ) < n by exact_mod_cast hj ] : ( i : ℝ ) = j )

lemma convolution_approx_by_sum (K : ℝ) (hK : K > 0) (f : ℝ → ℝ)
    (hf_cont : ContinuousOn f (Set.Icc (-K) K))
    (hf_supp : Function.support f ⊆ Set.Icc (-K) K)
    (hf_nonneg : ∀ x, 0 ≤ f x) (t : ℝ) (ht : t > 0) (ε : ℝ) (hε : ε > 0) :
  ∃ (s : Finset ℝ) (w : ℝ → ℝ), (∀ y ∈ s, w y ≥ 0) ∧ (∀ y ∈ s, y ∈ Set.Icc (-K) K) ∧
  ∀ x ∈ Set.Icc (-K) K, |real_convolution f (HeatKernel t) x - ∑ y ∈ s, w y * HeatKernel t (x - y)| < ε := by
    have := @uniform_riemann_sum;
    specialize this (-K) K (by linarith) (Set.Icc (-K) K) (by
    exact CompactIccSpace.isCompact_Icc) (fun x y => f y * HeatKernel t (x - y)) (by
    refine' ContinuousOn.mul _ _;
    · exact hf_cont.comp continuousOn_snd fun x hx => hx.2;
    · refine' ContinuousOn.mul _ _;
      · exact continuousOn_const;
      · fun_prop) ε hε;
    obtain ⟨ s, w, hw₁, hw₂, hw₃ ⟩ := this; use s, fun y => w y * f y; aesop;
    convert hw₃ x a a_1 using 1;
    simp +decide only [mul_assoc];
    rw [ MeasureTheory.setIntegral_eq_integral_of_forall_compl_eq_zero ] ; aesop;
    exact fun y hy => mul_eq_zero_of_left ( Classical.not_not.1 fun h => hy <| hf_supp y h ) _

lemma fejer_sum_approx (K : ℝ) (hK : K > 0) (t : ℝ) (ht : t > 0) (s : Finset ℝ)
    (w : ℝ → ℝ) (hw_nonneg : ∀ y ∈ s, w y ≥ 0) (hs_subset : ∀ y ∈ s, y ∈ Set.Icc (-K) K)
    (ε : ℝ) (hε : ε > 0) :
  ∃ B > 0, ∀ x ∈ Set.Icc (-K) K,
  |∑ y ∈ s, w y * Atom B t y x - (∑ y ∈ s, w y * HeatKernel t (x - y) +
    ∑ y ∈ s, w y * HeatKernel t (x + y))| < ε := by
      -- Since the Fejer kernel is continuous and compactly supported, as $B \to \infty$, $FejerKernel B x \to 1$ uniformly on $[-K, K]$.
      have h_fejer_uniform : Filter.Tendsto (fun B => sSup (Set.image (fun x => |FejerKernel B x - 1|) (Set.Icc (-2 * K) (2 * K)))) Filter.atTop (nhds 0) := by
        -- Since $FejerKernel B x = 1 - |x| / B$ for $x \in [-B, B]$, we have $|FejerKernel B x - 1| = |x| / B$.
        have h_fejer_uniform : ∀ B > 2 * K, ∀ x ∈ Set.Icc (-2 * K) (2 * K), |FejerKernel B x - 1| ≤ 2 * K / B := by
          aesop;
          rw [ show FejerKernel B x = 1 - |x| / B by exact (by
                exact max_eq_right ( sub_nonneg_of_le ( div_le_one_of_le₀ ( by cases abs_cases x <;> linarith ) ( by linarith ) ) )) ];
          rw [ abs_le ] ; constructor <;> cases abs_cases x <;> nlinarith [ div_mul_cancel₀ ( |x| ) ( by linarith : B ≠ 0 ), div_mul_cancel₀ ( 2 * K ) ( by linarith : B ≠ 0 ) ];
        have h_fejer_uniform : ∀ B > 2 * K, sSup (Set.image (fun x => |FejerKernel B x - 1|) (Set.Icc (-2 * K) (2 * K))) ≤ 2 * K / B := by
          exact fun B hB => csSup_le ( Set.Nonempty.image _ <| Set.nonempty_Icc.mpr <| by linarith ) <| Set.forall_mem_image.mpr <| h_fejer_uniform B hB;
        exact squeeze_zero_norm' ( Filter.eventually_atTop.mpr ⟨ 2 * K + 1, fun B hB => by rw [ Real.norm_of_nonneg ( by apply_rules [ Real.sSup_nonneg ] ; aesop ) ] ; exact h_fejer_uniform B <| by linarith ⟩ ) <| tendsto_const_nhds.div_atTop Filter.tendsto_id;
      -- Using the uniform convergence of the Fejer kernel, we can bound the difference.
      have h_bound : ∀ B > 0, ∀ x ∈ Set.Icc (-K) K, |∑ y ∈ s, w y * (FejerKernel B (x - y) * HeatKernel t (x - y) + FejerKernel B (x + y) * HeatKernel t (x + y)) - (∑ y ∈ s, w y * HeatKernel t (x - y) + ∑ y ∈ s, w y * HeatKernel t (x + y))| ≤ ∑ y ∈ s, w y * (|FejerKernel B (x - y) - 1| * HeatKernel t (x - y) + |FejerKernel B (x + y) - 1| * HeatKernel t (x + y)) := by
        intros B hB x hx
        have h_bound : ∀ y ∈ s, |w y * (FejerKernel B (x - y) * HeatKernel t (x - y) + FejerKernel B (x + y) * HeatKernel t (x + y)) - (w y * HeatKernel t (x - y) + w y * HeatKernel t (x + y))| ≤ w y * (|FejerKernel B (x - y) - 1| * HeatKernel t (x - y) + |FejerKernel B (x + y) - 1| * HeatKernel t (x + y)) := by
          intro y hy; rw [ abs_le ] ; constructor <;> cases abs_cases ( FejerKernel B ( x - y ) - 1 ) <;> cases abs_cases ( FejerKernel B ( x + y ) - 1 ) <;> nlinarith [ hw_nonneg y hy, show 0 ≤ w y * HeatKernel t ( x - y ) by exact mul_nonneg ( hw_nonneg y hy ) ( HeatKernel_nonneg t ht _ ), show 0 ≤ w y * HeatKernel t ( x + y ) by exact mul_nonneg ( hw_nonneg y hy ) ( HeatKernel_nonneg t ht _ ) ] ;
        simpa only [ ← Finset.sum_add_distrib, Finset.sum_sub_distrib ] using Finset.abs_sum_le_sum_abs _ _ |> le_trans <| Finset.sum_le_sum h_bound;
      -- Using the uniform convergence of the Fejer kernel, we can bound the sum.
      have h_sum_bound : ∀ B > 0, ∀ x ∈ Set.Icc (-K) K, ∑ y ∈ s, w y * (|FejerKernel B (x - y) - 1| * HeatKernel t (x - y) + |FejerKernel B (x + y) - 1| * HeatKernel t (x + y)) ≤ (∑ y ∈ s, w y * (HeatKernel t (x - y) + HeatKernel t (x + y))) * (sSup (Set.image (fun x => |FejerKernel B x - 1|) (Set.Icc (-2 * K) (2 * K)))) := by
        intros B hB x hx
        have h_term_bound : ∀ y ∈ s, |FejerKernel B (x - y) - 1| ≤ sSup (Set.image (fun x => |FejerKernel B x - 1|) (Set.Icc (-2 * K) (2 * K))) ∧ |FejerKernel B (x + y) - 1| ≤ sSup (Set.image (fun x => |FejerKernel B x - 1|) (Set.Icc (-2 * K) (2 * K))) := by
          intros y hy;
          exact ⟨ le_csSup ( by exact ( IsCompact.bddAbove ( isCompact_Icc.image_of_continuousOn ( by exact ContinuousOn.abs ( by exact ContinuousOn.sub ( by exact ContinuousOn.congr ( show ContinuousOn ( fun x => max 0 ( 1 - |x| / B ) ) ( Set.Icc ( -2 * K ) ( 2 * K ) ) from ContinuousOn.sup continuousOn_const <| ContinuousOn.sub continuousOn_const <| ContinuousOn.div_const ( continuousOn_id.abs ) _ ) fun x hx => rfl ) continuousOn_const ) ) ) ) ) <| Set.mem_image_of_mem _ <| by constructor <;> linarith [ hx.1, hx.2, hs_subset y hy |>.1, hs_subset y hy |>.2 ], le_csSup ( by exact ( IsCompact.bddAbove ( isCompact_Icc.image_of_continuousOn ( by exact ContinuousOn.abs ( by exact ContinuousOn.sub ( by exact ContinuousOn.congr ( show ContinuousOn ( fun x => max 0 ( 1 - |x| / B ) ) ( Set.Icc ( -2 * K ) ( 2 * K ) ) from ContinuousOn.sup continuousOn_const <| ContinuousOn.sub continuousOn_const <| ContinuousOn.div_const ( continuousOn_id.abs ) _ ) fun x hx => rfl ) continuousOn_const ) ) ) ) ) <| Set.mem_image_of_mem _ <| by constructor <;> linarith [ hx.1, hx.2, hs_subset y hy |>.1, hs_subset y hy |>.2 ] ⟩;
        rw [ Finset.sum_mul _ _ _ ] ; exact Finset.sum_le_sum fun y hy => by nlinarith only [ h_term_bound y hy, hw_nonneg y hy, show 0 ≤ w y * HeatKernel t ( x - y ) by exact mul_nonneg ( hw_nonneg y hy ) ( HeatKernel_nonneg t ht _ ), show 0 ≤ w y * HeatKernel t ( x + y ) by exact mul_nonneg ( hw_nonneg y hy ) ( HeatKernel_nonneg t ht _ ) ] ;
      -- Using the fact that the sum of the weights is finite, we can bound the sum.
      have h_sum_finite : ∃ M > 0, ∀ x ∈ Set.Icc (-K) K, ∑ y ∈ s, w y * (HeatKernel t (x - y) + HeatKernel t (x + y)) ≤ M := by
        have h_sum_finite : ContinuousOn (fun x => ∑ y ∈ s, w y * (HeatKernel t (x - y) + HeatKernel t (x + y))) (Set.Icc (-K) K) := by
          unfold HeatKernel;
          fun_prop;
        obtain ⟨ M, hM ⟩ := IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) h_sum_finite;
        exact ⟨ Max.max M 1, by positivity, fun x hx => le_trans ( le_abs_self _ ) ( le_trans ( hM x hx ) ( le_max_left _ _ ) ) ⟩;
      -- Using the fact that the supremum of |FejerKernel B x - 1| tends to 0, we can find a B such that this supremum is less than ε/M.
      obtain ⟨B, hB_pos, hB_sup⟩ : ∃ B > 0, sSup (Set.image (fun x => |FejerKernel B x - 1|) (Set.Icc (-2 * K) (2 * K))) < ε / h_sum_finite.choose := by
        have := h_fejer_uniform.eventually ( gt_mem_nhds <| show 0 < ε / h_sum_finite.choose from div_pos hε <| h_sum_finite.choose_spec.1 ) ; have := this.and ( Filter.eventually_gt_atTop 0 ) ; obtain ⟨ B, hB₁, hB₂ ⟩ := this.exists; exact ⟨ B, hB₂, hB₁ ⟩ ;
      refine' ⟨ B, hB_pos, fun x hx => lt_of_le_of_lt ( h_bound B hB_pos x hx ) ( lt_of_le_of_lt ( h_sum_bound B hB_pos x hx ) _ ) ⟩;
      exact lt_of_le_of_lt ( mul_le_mul_of_nonneg_right ( h_sum_finite.choose_spec.2 x hx ) ( by apply_rules [ Real.sSup_nonneg ] ; rintro _ ⟨ y, hy, rfl ⟩ ; exact abs_nonneg _ ) ) ( by rw [ lt_div_iff₀ ( h_sum_finite.choose_spec.1 ) ] at hB_sup; linarith )

lemma sum_atoms_in_cone (K : ℝ) (s : Finset ℝ) (w : ℝ → ℝ) (hw : ∀ y ∈ s, 0 ≤ w y)
    (B : ℝ) (hB : B > 0) (t : ℝ) (ht : t > 0) (hs : ∀ y ∈ s, y ∈ Set.Icc (-K) K)
    (h_sum_pos : ∑ y ∈ s, w y > 0) :
  (fun x => ∑ y ∈ s, w y * Atom B t y x) ∈ AtomCone_K K := by
    -- Since each Atom B t y is in AtomSet K, their sum with non-negative coefficients is in the convex hull of AtomSet K.
    have h_convex : ∑ y ∈ s, (w y / ∑ y ∈ s, w y) • Atom B t y ∈ convexHull ℝ (AtomSet K) := by
      rw [ convexHull_eq ];
      refine' ⟨ _, s, fun y => w y / ∑ y ∈ s, w y, fun y => Atom B t y, _, _, _, _ ⟩ <;> simp_all +decide [ Finset.centerMass ];
      · exact fun y hy => div_nonneg ( hw y hy ) h_sum_pos.le;
      · rw [ ← Finset.sum_div, div_self h_sum_pos.ne' ];
      · exact fun y hy => ⟨ B, hB, t, ht, y, hs y hy, rfl ⟩;
      · rw [ ← Finset.sum_div _ _ _, div_self h_sum_pos.ne', inv_one, one_smul ];
    simp_all +decide [ div_eq_inv_mul, Finset.mul_sum _ _ _ ];
    convert ( Convex.mem_toCone _ ).mpr _ using 1;
    refine' ⟨ ∑ y ∈ s, w y, h_sum_pos, _, h_convex, _ ⟩ ; ext x ; simp +decide [ Finset.mul_sum _ _ _, mul_assoc, mul_left_comm, mul_comm, h_sum_pos.ne' ]

lemma even_convolution (f g : ℝ → ℝ) (hf : Even f) (hg : Even g) :
  Even (real_convolution f g) := by
    -- Since $f$ and $g$ are even, their convolution is also even. We can define $r$ as $(1/2) \times$ the integral of $f(t)g(x-t)$.
    use fun x => (1 / 2) * real_convolution f g x;
    -- By definition of convolution, we can split the integral into two parts and factor out the constant 1/2.
    funext x; simp [real_convolution]; ring

lemma exists_even_compact_extension (K : ℝ) (hK : K > 0) (Φ : ℝ → ℝ)
    (hΦ_cont : ContinuousOn Φ (Set.Icc (-K) K))
    (hΦ_even : Even Φ) :
  ∃ Ψ : ℝ → ℝ, Continuous Ψ ∧ HasCompactSupport Ψ ∧ Even Ψ ∧ ∀ x ∈ Set.Icc (-K) K, Ψ x = Φ x := by
    -- By the Tietze extension theorem, we can extend Φ to a continuous function on the entire real line.
    obtain ⟨Ψ, hΨ_cont, hΨ_ext⟩ : ∃ Ψ : ℝ → ℝ, Continuous Ψ ∧ ∀ x ∈ Set.Icc (-K) K, Ψ x = Φ x := by
      -- By the existence lemma, there exists a continuous function Ψ with compact support such that Ψ x = Φ x for all x in [-K, K].
      obtain ⟨Ψ, hΨ_cont, hΨ_compact, hΨ_eq⟩ := exists_compact_extension K hK Φ hΦ_cont;
      use Ψ;
    -- Define Ψ' as Ψ multiplied by an even function that is 1 on [-K, K] and 0 outside a larger interval. For example, we can use a bump function.
    obtain ⟨η, hη_cont, hη_compact, hη_even, hη_one⟩ : ∃ η : ℝ → ℝ, Continuous η ∧ HasCompactSupport η ∧ Even η ∧ ∀ x ∈ Set.Icc (-K) K, η x = 1 := by
      -- Define η as a bump function that is 1 on [-K, K] and 0 outside [-K-1, K+1].
      obtain ⟨η, hη_cont, hη_compact, hη_one⟩ : ∃ η : ℝ → ℝ, Continuous η ∧ HasCompactSupport η ∧ ∀ x, |x| ≤ K → η x = 1 ∧ ∀ x, |x| ≥ K + 1 → η x = 0 := by
        refine' ⟨ fun x => if |x| ≤ K then 1 else if |x| ≥ K + 1 then 0 else ( K + 1 - |x| ) / ( K + 1 - K ), _, _, _ ⟩ <;> norm_num;
        · apply_rules [ Continuous.if_le, Continuous.sub, Continuous.add, continuous_const, continuous_abs ];
          · exact fun x hx => by linarith;
          · aesop;
        · rw [ hasCompactSupport_iff_eventuallyEq ];
          norm_num [ Filter.EventuallyEq ];
          exact ⟨ ⟨ -K - 2, fun x hx => by split_ifs <;> cases abs_cases x <;> linarith ⟩, ⟨ K + 2, fun x hx => by split_ifs <;> cases abs_cases x <;> linarith ⟩ ⟩;
        · exact fun x hx => ⟨ fun hx' => False.elim <| hx'.not_le hx, fun x hx => by split_ifs <;> linarith ⟩;
      use fun x => η x * η (-x);
      aesop;
      · exact hη_cont.mul ( hη_cont.comp <| ContinuousNeg.continuous_neg );
      · rw [ hasCompactSupport_iff_eventuallyEq ] at *;
        filter_upwards [ hη_compact ] with x hx using mul_eq_zero_of_left hx _;
      · exact ⟨ fun x => η x * η ( -x ) / 2, by ext; simp +decide [ mul_comm ] ⟩;
      · rw [ hη_one x ( abs_le.mpr ⟨ by linarith, by linarith ⟩ ) |>.1, hη_one ( -x ) ( abs_le.mpr ⟨ by linarith, by linarith ⟩ ) |>.1, one_mul ];
    refine' ⟨ fun x => η x * Ψ x, hη_cont.mul hΨ_cont, _, _, _ ⟩ <;> aesop;
    · exact hη_compact.mono fun x hx => by aesop;
    · exact ⟨ fun x => η x * Ψ x / 2, by ext x; simp +decide [ two_mul ] ⟩

lemma HeatKernel_even (t : ℝ) : Even (HeatKernel t) := by
  -- The HeatKernel is even because the exponential function is even.
  use fun x => (4 * Real.pi * t) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / (4 * t)) / 2;
  -- By definition of HeatKernel, we have HeatKernel t x = (4 * π * t) ^ (-(1:ℝ)/2) * Real.exp (-x^2 / (4 * t)).
  funext x; simp [HeatKernel]