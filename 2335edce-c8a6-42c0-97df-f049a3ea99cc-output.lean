/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 2335edce-c8a6-42c0-97df-f049a3ea99cc

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Primes up to N
-/
def primes_up_to (N : ℕ) : Finset ℕ :=
  (Finset.range (N+1)).filter Nat.Prime

/-
Exponential sum with α = ln(6)
-/
noncomputable def S_primes_ln6 (N : ℕ) : ℂ :=
  Finset.sum (primes_up_to N) (fun p => Complex.exp (2 * Real.pi * Complex.I * p * Real.log 6))

/-
Checking norm function and notation
-/
#check (norm : ℂ → ℝ)
#check (‖(0 : ℂ)‖ : ℝ)

/-
All primes p > 3 satisfy p ≡ 1 or 5 (mod 6).
-/
lemma mod6_primes (p : ℕ) (hp : p.Prime) (hp3 : p > 3) : p % 6 = 1 ∨ p % 6 = 5 := by
  by_contra h;
  have := Nat.Prime.eq_two_or_odd hp; ( have := Nat.dvd_of_mod_eq_zero ( show p % 3 = 0 by omega ) ; rw [ hp.dvd_iff_eq ] at this <;> aesop_cat; )

/-
Exponential sum restricted to primes congruent to r mod 6
-/
noncomputable def S_primes_ln6_mod (r : ℕ) (N : ℕ) : ℂ :=
  Finset.sum ((primes_up_to N).filter (fun p => p % 6 = r)) (fun p => Complex.exp (2 * Real.pi * Complex.I * p * Real.log 6))

/-
Decomposition of the exponential sum into residue classes mod 6 plus correction terms for primes 2 and 3.
-/
lemma S_decomposition (N : ℕ) (hN : N ≥ 3) :
  S_primes_ln6 N = S_primes_ln6_mod 1 N + S_primes_ln6_mod 5 N +
  Complex.exp (2 * Real.pi * Complex.I * 2 * Real.log 6) +
  Complex.exp (2 * Real.pi * Complex.I * 3 * Real.log 6) := by
  unfold S_primes_ln6 S_primes_ln6_mod; simp +decide [ Finset.sum_filter, add_assoc ] ;
  -- We'll use the fact that primes greater than 3 are either congruent to 1 or -1 modulo 6.
  have h_mod6 : ∀ p ∈ primes_up_to N \ {2, 3}, p % 6 = 1 ∨ p % 6 = 5 := by
    -- Let's choose any prime $p$ greater than 3.
    intro p hp
    have hp_gt_3 : p > 3 := by
      contrapose! hp; interval_cases p <;> simp_all +decide ;
      · exact fun h => by have := Finset.mem_filter.mp h; norm_num at this;
      · exact fun h => by have := Finset.mem_filter.mp h; norm_num at this;
    have := mod6_primes p ( by unfold primes_up_to at hp; aesop ) hp_gt_3; aesop;
  -- We can split the sum into the sum over primes congruent to 1 modulo 6, the sum over primes congruent to 5 modulo 6, and the sum over primes congruent to 2 modulo 6.
  have h_split : ∑ x ∈ primes_up_to N, (Complex.exp (2 * (↑Real.pi : ℂ) * Complex.I * (↑x : ℂ) * Complex.log 6)) =
      (∑ x ∈ primes_up_to N \ {2, 3}, (Complex.exp (2 * (↑Real.pi : ℂ) * Complex.I * (↑x : ℂ) * Complex.log 6))) +
      (Complex.exp (2 * (↑Real.pi : ℂ) * Complex.I * 2 * Complex.log 6)) +
      (Complex.exp (2 * (↑Real.pi : ℂ) * Complex.I * 3 * Complex.log 6)) := by
        rw [ ← Finset.sum_sdiff <| show { 2, 3 } ⊆ primes_up_to N from ?_ ];
        · norm_num [ add_assoc ];
        · simp +arith +decide [ Finset.insert_subset_iff ];
          exact ⟨ Finset.mem_filter.mpr ⟨ Finset.mem_range.mpr ( by linarith ), by norm_num ⟩, Finset.mem_filter.mpr ⟨ Finset.mem_range.mpr ( by linarith ), by norm_num ⟩ ⟩;
  -- We can split the sum into the sum over primes congruent to 1 modulo 6 and the sum over primes congruent to 5 modulo 6.
  have h_split_mod6 : ∑ x ∈ primes_up_to N \ {2, 3}, (Complex.exp (2 * (↑Real.pi : ℂ) * Complex.I * (↑x : ℂ) * Complex.log 6)) =
      (∑ x ∈ primes_up_to N \ {2, 3}, if x % 6 = 1 then (Complex.exp (2 * (↑Real.pi : ℂ) * Complex.I * (↑x : ℂ) * Complex.log 6)) else 0) +
      (∑ x ∈ primes_up_to N \ {2, 3}, if x % 6 = 5 then (Complex.exp (2 * (↑Real.pi : ℂ) * Complex.I * (↑x : ℂ) * Complex.log 6)) else 0) := by
        simpa only [ ← Finset.sum_add_distrib ] using Finset.sum_congr rfl fun x hx => by rcases h_mod6 x hx with h | h <;> norm_num [ h ] ;
  simp_all +decide [ Finset.sum_ite ];
  simp +decide [ ← add_assoc, Finset.sum_filter ];
  rw [ ← Finset.sum_sdiff ( show { 2, 3 } ⊆ primes_up_to N from by { intro x hx; fin_cases hx <;> exact Finset.mem_filter.mpr ⟨ Finset.mem_range.mpr <| by linarith, by norm_num ⟩ } ), ← Finset.sum_sdiff ( show { 2, 3 } ⊆ primes_up_to N from by { intro x hx; fin_cases hx <;> exact Finset.mem_filter.mpr ⟨ Finset.mem_range.mpr <| by linarith, by norm_num ⟩ } ) ] ; norm_num [ Finset.sum_pair ] ;

#check Transcendental

/-
If e is transcendental, then 6 ln 6 is irrational.
-/
lemma irrational_6_ln_6_of_transcendental_e (h : Transcendental ℚ (Real.exp 1)) : Irrational (6 * Real.log 6) := by
  by_contra h_contra
  obtain ⟨p', q', hpq1', hpq2'⟩ : ∃ p' q' : ℕ, p' > 0 ∧ q' > 0 ∧ q' * Real.log (6 : ℝ) = p' := by
    obtain ⟨p, q, hpq1, hpq2⟩ : ∃ p q : ℤ, p > 0 ∧ q > 0 ∧ q * Real.log (6 : ℝ) = p := by
      obtain ⟨ p, hp ⟩ := Classical.not_not.mp h_contra;
      exact ⟨ p.num, p.den * 6, by exact_mod_cast Rat.num_pos.mpr ( show 0 < p by exact_mod_cast hp.symm ▸ mul_pos ( by norm_num ) ( Real.log_pos ( by norm_num ) ) ), by positivity, by push_cast [ Rat.cast_def ] at *; nlinarith [ Real.log_pos ( show ( 6 : ℝ ) > 1 by norm_num ), ( by norm_cast; exact p.pos : 0 < ( p.den : ℝ ) ), mul_div_cancel₀ ( p.num : ℝ ) ( by positivity : ( p.den : ℝ ) ≠ 0 ) ] ⟩;
    cases p <;> cases q <;> aesop;
  -- Then $e^{p'} = 6^{q'}$, which implies that $e$ is algebraic (root of $X^{p'} - 6^{q'} = 0$), contradicting the assumption that $e$ is transcendental.
  have h_algebraic : (Real.exp 1) ^ p' = 6 ^ q' := by
    rw [ ← Real.rpow_natCast, ← Real.rpow_natCast, Real.rpow_def_of_pos, Real.rpow_def_of_pos ] <;> norm_num ; linarith;
    positivity;
  exact h ( by exact ⟨ Polynomial.X ^ p' - Polynomial.C ( 6 ^ q' : ℚ ), by exact Polynomial.X_pow_sub_C_ne_zero ( by linarith ) _, by aesop ⟩ )