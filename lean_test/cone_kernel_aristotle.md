/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: dad24643-db59-487c-a2d8-695141aa9169
-/

/-
Formalization of the Cone-Kernel Separation Lemma.
We define the matrix A and the positive cone, and prove that any vector in the positive cone is not in the kernel of A.
This confirms the user's request that the intersection of the positive cone (excluding zero) and the kernel is empty.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of the matrix A where A_{pq} = (ξ_q - ξ_p) * K_{pq}
-/
def A_mat {N : ℕ} (ξ : Fin N → ℝ) (K : Matrix (Fin N) (Fin N) ℝ) : Matrix (Fin N) (Fin N) ℝ :=
  Matrix.of (fun p q => (ξ q - ξ p) * K p q)

/-
Checking for Matrix.IsSymm and StrictMono definitions
-/
#check Matrix.IsSymm
#check StrictMono

/-
Definition of the positive cone (non-negative vectors excluding zero)
-/
def PositiveCone {N : ℕ} (v : Fin N → ℝ) : Prop := (∀ i, 0 ≤ v i) ∧ v ≠ 0

/-
Checking Matrix.mulVec type
-/
#check (Matrix.mulVec : Matrix (Fin 3) (Fin 3) ℝ → (Fin 3 → ℝ) → (Fin 3 → ℝ))

/-
Prove that the intersection of the positive cone and the kernel of A is {0}.
-/
theorem cone_kernel_separation {N : ℕ} (hN : 1 < N) (ξ : Fin N → ℝ) (K : Matrix (Fin N) (Fin N) ℝ)
  (hξ : StrictMono ξ) (hK_symm : K.IsSymm) (hK_pos : ∀ p q, p ≠ q → 0 < K p q) :
  ∀ v, PositiveCone v → Matrix.mulVec (A_mat ξ K) v ≠ 0 := by
    intro v hv h; have := hv.1; unfold A_mat at h; simp_all +decide [ funext_iff, Matrix.mulVec, dotProduct ] ;
    -- Choose $p^* \in S$ with maximum $\xi_{p^*}$.
    obtain ⟨p_star, hp_star⟩ : ∃ p_star, v p_star > 0 ∧ ∀ p, v p > 0 → ξ p ≤ ξ p_star := by
      obtain ⟨p_star, hp_star⟩ : ∃ p_star, v p_star > 0 := by
        exact not_forall_not.mp fun contra => hv.2 <| funext fun i => le_antisymm ( le_of_not_gt fun hi => contra i hi ) ( this i );
      have := Finset.exists_max_image ( Finset.univ.filter fun p => v p > 0 ) ( fun p => ξ p ) ⟨ p_star, Finset.mem_filter.mpr ⟨ Finset.mem_univ _, hp_star ⟩ ⟩ ; aesop;
    -- Consider $(A\lambda)_{p^*} = \sum_q (\xi_q - \xi_{p^*}) K_{p^*q} \lambda_q$.
    have h_sum_p_star : ∑ q, (ξ q - ξ p_star) * (K p_star q) * v q = 0 := by
      exact h p_star;
    -- Since $K_{p^* q} > 0$ for $q \neq p^*$ and $v_q \geq 0$, the only way for the sum to be zero is if $(ξ q - ξ p_star) * v q = 0$ for all $q$.
    have h_zero_terms : ∀ q, (ξ q - ξ p_star) * v q = 0 := by
      -- Since $K_{p^* q} > 0$ for $q \neq p^*$ and $v_q \geq 0$, each term $(ξ q - ξ p_star) * K_{p^* q} * v q$ is non-positive.
      have h_nonpos_terms : ∀ q, (ξ q - ξ p_star) * (K p_star q) * v q ≤ 0 := by
        intro q; by_cases hq : q = p_star <;> aesop;
        by_cases hq_pos : 0 < v q;
        · exact mul_nonpos_of_nonpos_of_nonneg ( mul_nonpos_of_nonpos_of_nonneg ( sub_nonpos.mpr ( right _ hq_pos ) ) ( le_of_lt ( hK_pos _ _ ( Ne.symm hq ) ) ) ) ( le_of_lt hq_pos );
        · norm_num [ show v q = 0 by linarith [ this q ] ];
      simp +zetaDelta at *;
      exact fun q => Classical.or_iff_not_imp_left.2 fun hq => by_contra fun hq' => absurd ( h_sum_p_star ▸ Finset.sum_lt_sum ( fun a _ => h_nonpos_terms a ) ⟨ q, Finset.mem_univ q, lt_of_le_of_ne ( h_nonpos_terms q ) ( mul_ne_zero ( mul_ne_zero ( sub_ne_zero_of_ne <| by aesop ) <| ne_of_gt <| if h : p_star = q then by aesop else hK_pos _ _ h ) hq' ) ⟩ ) ( by norm_num ) ;
    -- Since $v_q \geq 0$ and $(ξ q - ξ p_star) * v q = 0$, it follows that $v_q = 0$ for all $q \neq p^*$.
    have h_v_zero : ∀ q, q ≠ p_star → v q = 0 := by
      exact fun q hq => eq_zero_of_ne_zero_of_mul_left_eq_zero ( sub_ne_zero_of_ne <| hξ.injective.ne hq ) <| h_zero_terms q;
    specialize h ( if p_star = ⟨ 0, by linarith ⟩ then ⟨ 1, by linarith ⟩ else ⟨ 0, by linarith ⟩ ) ; simp_all +decide [ Finset.sum_eq_single p_star ] ;
    split_ifs at h <;> simp_all +decide [ sub_eq_iff_eq_add, hξ.injective.eq_iff ];
    · exact absurd ( h.resolve_right hp_star.1.ne' ) ( ne_of_gt ( hK_pos _ _ ( by norm_num ) ) );
    · exact absurd ( h.resolve_right hp_star.1.ne' ) ( ne_of_gt ( hK_pos _ _ ( Ne.symm ‹_› ) ) )