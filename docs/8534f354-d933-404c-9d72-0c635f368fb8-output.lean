/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 8534f354-d933-404c-9d72-0c635f368fb8

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Checking if ZMod.χ₄ matches the user's definition of χ₄.
-/
#check ZMod.χ₄
#check ZMod.χ₄_nat_eq_if_mod_four

/-
Defining the twisted von Mangoldt function f, the twin sum T_χ, and the standard twin sum S₂.
-/
open scoped ArithmeticFunction
open BigOperators Finset

noncomputable def f (n : ℕ) : ℝ := Λ n * (ZMod.χ₄ n : ℝ)

noncomputable def T_χ (X : ℕ) : ℝ := ∑ n ∈ range (X + 1), f n * f (n + 2)

noncomputable def S₂ (X : ℕ) : ℝ := ∑ n ∈ range (X + 1), Λ n * Λ (n + 2)

/-
Theorem 1: For any odd prime p > 2 such that p+2 is also prime, χ₄(p) · χ₄(p+2) = -1.
-/
theorem afm_structure (p : ℕ) (hp : p.Prime) (hp2 : (p + 2).Prime) (h_gt_2 : p > 2) :
  ZMod.χ₄ p * ZMod.χ₄ (p + 2) = -1 := by
    have := Nat.Prime.eq_two_or_odd hp; aesop;
    · rw [ ZMod.natCast_zmod_eq_zero_iff_dvd ] at heq ; exact absurd ( Nat.dvd_trans ( by decide : 2 ∣ 4 ) heq ) ( by rw [ Nat.dvd_prime hp ] ; aesop );
    · erw [ ZMod.eq_iff_modEq_nat ] at heq ; norm_num [ Nat.ModEq ] at heq ; ( rw [ ← Nat.mod_add_div p 4 ] at * ; have := Nat.mod_lt p four_pos ; interval_cases p % 4 <;> norm_num at *; );
      omega

/-
Theorem 4: χ₄ is completely multiplicative: χ₄(mn) = χ₄(m) · χ₄(n) for all m, n ∈ ℕ.
-/
theorem chi4_multiplicative (m n : ℕ) : ZMod.χ₄ (m * n) = ZMod.χ₄ m * ZMod.χ₄ n := by
  exact?

/-
Theorem 5: χ₄(n+4) = χ₄(n) for all n ∈ ℕ.
-/
theorem chi4_periodic (n : ℕ) : ZMod.χ₄ (n + 4) = ZMod.χ₄ n := by
  cases n <;> simp_all +decide [ ZMod, Fin.add_def ]

/-
For twin primes n > 2, f(n)f(n+2) = -Λ(n)Λ(n+2).
-/
theorem term_wise_eq (n : ℕ) (h_gt_2 : n > 2) (hp : n.Prime) (hp2 : (n + 2).Prime) :
  f n * f (n + 2) = - (Λ n * Λ (n + 2)) := by
    unfold f;
    have := afm_structure n hp hp2 h_gt_2; norm_cast at *; ring_nf at *; aesop;

/-
The error term vanishes for twin primes n > 2.
-/
noncomputable def error_term (n : ℕ) : ℝ := f n * f (n + 2) - (- Λ n * Λ (n + 2))

theorem error_term_zero_of_twin_prime (n : ℕ) (h_gt_2 : n > 2) (hp : n.Prime) (hp2 : (n + 2).Prime) :
  error_term n = 0 := by
    unfold error_term ; rw [ term_wise_eq n h_gt_2 hp hp2 ] ; ring;

/-
The error term is non-zero only for n=2 or higher prime powers.
-/
theorem error_term_support (n : ℕ) (h : error_term n ≠ 0) :
  n = 2 ∨ (IsPrimePow n ∧ ¬ n.Prime) ∨ (IsPrimePow (n + 2) ∧ ¬ (n + 2).Prime) := by
    -- By assumption, there exists an $n$ such that $f(n) * f(n + 2) + \Lambda(n) * \Lambda(n + 2) \neq 0$.
    apply Classical.byContradiction
    intro h_contra;
    -- Since $n$ is not equal to 2 and neither $n$ nor $n+2$ are prime powers, both $n$ and $n+2$ must be prime numbers.
    have h_prime : Nat.Prime n ∧ Nat.Prime (n + 2) := by
      unfold error_term at h;
      unfold f at h;
      norm_num [ ArithmeticFunction.vonMangoldt ] at h;
      split_ifs at h <;> simp_all +decide;
    -- Since $n$ and $n+2$ are both prime numbers greater than 2, we can apply the theorem `term_wise_eq`.
    have h_term_wise_eq : f n * f (n + 2) = - (Λ n * Λ (n + 2)) := by
      apply term_wise_eq n (by
      rcases n with ( _ | _ | _ | n ) <;> simp_all +arith +decide) h_prime.left h_prime.right;
    exact h ( by unfold error_term; linear_combination h_term_wise_eq )

/-
The number of proper prime powers up to X is O(√X).
-/
def IsProperPrimePow (n : ℕ) : Prop := IsPrimePow n ∧ ¬ n.Prime

noncomputable def proper_prime_powers_count (X : ℕ) : ℕ := (Finset.range (X + 1)).filter IsProperPrimePow |>.card

theorem proper_prime_powers_count_bound :
  (fun (X : ℕ) => (proper_prime_powers_count X : ℝ)) =O[Filter.atTop] (fun (X : ℕ) => Real.sqrt X) := by
    -- The number of proper prime powers up to X is bounded by the sum of the number of prime powers for each exponent k ≥ 2.
    have h_sum_bound : ∀ X : ℕ, (proper_prime_powers_count X : ℝ) ≤ ∑ k ∈ Finset.Ico 2 (Nat.log 2 X + 1), (X : ℝ) ^ (1 / (k : ℝ)) := by
      intro X;
      -- Let's count the number of proper prime powers up to $X$ by considering each prime $p$ and exponent $k \geq 2$.
      have h_count : proper_prime_powers_count X ≤ ∑ p ∈ Finset.filter Nat.Prime (Finset.Icc 2 X), ∑ k ∈ Finset.Ico 2 (Nat.log p X + 1), 1 := by
        -- Each proper prime power $p^k$ is counted in the sum $\sum_{p \leq X} \sum_{k=2}^{\log_p X} 1$.
        have h_count : Finset.filter (fun n => IsPrimePow n ∧ ¬n.Prime) (Finset.Icc 2 X) ⊆ Finset.biUnion (Finset.filter Nat.Prime (Finset.Icc 2 X)) (fun p => Finset.image (fun k => p^k) (Finset.Ico 2 (Nat.log p X + 1))) := by
          intro n hn; aesop;
          obtain ⟨ p, k, hp, hk, rfl ⟩ := left_1;
          refine' ⟨ p, ⟨ ⟨ hp.nat_prime.two_le, _ ⟩, hp.nat_prime ⟩, k, ⟨ _, _ ⟩, rfl ⟩;
          · exact le_trans ( Nat.le_self_pow hk.ne' _ ) right_1;
          · exact le_of_not_gt fun h => right <| by interval_cases k ; simpa using hp.nat_prime;
          · exact Nat.lt_succ_of_le ( Nat.le_log_of_pow_le hp.nat_prime.one_lt right_1 );
        have h_card : Finset.card (Finset.filter (fun n => IsPrimePow n ∧ ¬n.Prime) (Finset.Icc 2 X)) ≤ ∑ p ∈ Finset.filter Nat.Prime (Finset.Icc 2 X), Finset.card (Finset.image (fun k => p^k) (Finset.Ico 2 (Nat.log p X + 1))) := by
          exact le_trans ( Finset.card_le_card h_count ) ( Finset.card_biUnion_le );
        convert h_card using 2;
        · unfold proper_prime_powers_count;
          congr 1 with ( _ | _ | n ) <;> simp +arith +decide [ IsProperPrimePow ];
          · simp +decide [ IsPrimePow ];
            aesop;
          · exact?;
        · rw [ Finset.card_image_of_injective _ fun a b h => Nat.pow_right_injective ( Nat.Prime.one_lt <| by aesop ) h ] ; norm_num;
      -- For each prime $p$ and exponent $k \geq 2$, there is at most one prime power $p^k \leq X$.
      have h_prime_power_bound : ∀ p ∈ Finset.filter Nat.Prime (Finset.Icc 2 X), ∑ k ∈ Finset.Ico 2 (Nat.log p X + 1), 1 ≤ ∑ k ∈ Finset.Ico 2 (Nat.log 2 X + 1), (if p ^ k ≤ X then 1 else 0) := by
        intros p hp
        have h_prime_power_bound : Finset.Ico 2 (Nat.log p X + 1) ⊆ Finset.filter (fun k => p ^ k ≤ X) (Finset.Ico 2 (Nat.log 2 X + 1)) := by
          intro k hk; aesop;
          · refine' right_1.trans_le _;
            gcongr;
            norm_num;
          · exact Nat.pow_le_of_le_log ( by linarith ) ( by linarith );
        rw [ ← Finset.sum_filter ];
        exact Finset.sum_le_sum_of_subset h_prime_power_bound;
      -- By interchanging the order of summation, we can bound the sum over primes $p$ and exponents $k \geq 2$ by the sum over exponents $k \geq 2$ and primes $p$ such that $p^k \leq X$.
      have h_interchange : ∑ p ∈ Finset.filter Nat.Prime (Finset.Icc 2 X), ∑ k ∈ Finset.Ico 2 (Nat.log 2 X + 1), (if p ^ k ≤ X then 1 else 0) ≤ ∑ k ∈ Finset.Ico 2 (Nat.log 2 X + 1), ∑ p ∈ Finset.filter Nat.Prime (Finset.Icc 2 X), (if p ^ k ≤ X then 1 else 0) := by
        rw [ Finset.sum_comm ];
      -- For each exponent $k \geq 2$, the number of primes $p$ such that $p^k \leq X$ is at most $X^{1/k}$.
      have h_prime_bound : ∀ k ∈ Finset.Ico 2 (Nat.log 2 X + 1), ∑ p ∈ Finset.filter Nat.Prime (Finset.Icc 2 X), (if p ^ k ≤ X then 1 else 0) ≤ (X : ℝ) ^ (1 / (k : ℝ)) := by
        intros k hk
        have h_prime_bound : Finset.card (Finset.filter (fun p => p ^ k ≤ X) (Finset.filter Nat.Prime (Finset.Icc 2 X))) ≤ Nat.floor ((X : ℝ) ^ (1 / (k : ℝ))) := by
          simp +zetaDelta at *;
          exact le_trans ( Finset.card_le_card <| show Finset.filter ( fun p => p ^ k ≤ X ) ( Finset.filter Nat.Prime ( Finset.Icc 2 X ) ) ⊆ Finset.Icc 2 ( Nat.floor ( ( X : ℝ ) ^ ( k : ℝ ) ⁻¹ ) ) from fun p hp => Finset.mem_Icc.mpr ⟨ Nat.Prime.two_le <| Finset.mem_filter.mp ( Finset.mem_filter.mp hp |>.1 ) |>.2, Nat.le_floor <| by exact le_trans ( by rw [ ← Real.rpow_natCast, ← Real.rpow_mul ( Nat.cast_nonneg _ ), mul_inv_cancel₀ ( by norm_cast; linarith ), Real.rpow_one ] ) ( Real.rpow_le_rpow ( by positivity ) ( show ( p : ℝ ) ^ k ≤ X from mod_cast Finset.mem_filter.mp hp |>.2 ) <| by positivity ) ⟩ ) <| by simpa;
        aesop;
        exact le_trans ( Nat.cast_le.mpr h_prime_bound ) ( Nat.floor_le ( by positivity ) );
      refine le_trans ( Nat.cast_le.mpr h_count ) ?_;
      refine le_trans ?_ ( le_trans ( Nat.cast_le.mpr h_interchange ) ?_ );
      · exact_mod_cast Finset.sum_le_sum h_prime_power_bound;
      · simpa using Finset.sum_le_sum h_prime_bound;
    -- The term for $k=2$ is $\sqrt{X}$, and the sum for $k \geq 3$ is bounded by $X^{1/3} \log_2(X)$.
    have h_term_bound : ∀ X : ℕ, X ≥ 2 → (∑ k ∈ Finset.Ico 2 (Nat.log 2 X + 1), (X : ℝ) ^ (1 / (k : ℝ))) ≤ Real.sqrt X + Real.logb 2 X * (X : ℝ) ^ (1 / 3 : ℝ) := by
      -- For $k \geq 3$, the term $(X : ℝ) ^ (1 / (k : ℝ))$ is bounded above by $(X : ℝ) ^ (1 / 3 : ℝ)$.
      have h_term_bound_ge_3 : ∀ X : ℕ, X ≥ 2 → ∑ k ∈ Finset.Ico 3 (Nat.log 2 X + 1), (X : ℝ) ^ (1 / (k : ℝ)) ≤ Real.logb 2 X * (X : ℝ) ^ (1 / 3 : ℝ) := by
        intros X hX
        have h_term_bound_ge_3 : ∀ k ∈ Finset.Ico 3 (Nat.log 2 X + 1), (X : ℝ) ^ (1 / (k : ℝ)) ≤ (X : ℝ) ^ (1 / 3 : ℝ) := by
          exact fun k hk => Real.rpow_le_rpow_of_exponent_le ( by norm_cast; linarith ) ( by gcongr ; norm_cast ; linarith [ Finset.mem_Ico.mp hk ] );
        refine le_trans ( Finset.sum_le_sum h_term_bound_ge_3 ) ?_;
        norm_num;
        gcongr;
        rw [ Real.le_logb_iff_rpow_le ] <;> norm_cast;
        · exact Nat.pow_le_of_le_log ( by linarith ) ( by omega );
        · linarith;
      intro X hX; specialize h_term_bound_ge_3 X hX; rcases n : Nat.log 2 X with ( _ | _ | k ) <;> simp_all +decide [ Finset.sum_Ico_eq_sub ] ;
      · linarith;
      · positivity;
      · norm_num [ Finset.sum_range_succ ] at *;
        rw [ Real.sqrt_eq_rpow ] ; linarith;
    -- Since $\log_2(X) \cdot X^{1/3}$ grows slower than $\sqrt{X}$, we can conclude that the sum is $O(\sqrt{X})$.
    have h_log_growth : Filter.Tendsto (fun X : ℕ => (Real.logb 2 X * (X : ℝ) ^ (1 / 3 : ℝ)) / Real.sqrt X) Filter.atTop (nhds 0) := by
      -- We can simplify the expression inside the limit.
      suffices h_simplified : Filter.Tendsto (fun X : ℕ => Real.logb 2 X / (X : ℝ) ^ (1 / 6 : ℝ)) Filter.atTop (nhds 0) by
        convert h_simplified using 2 ; norm_num [ Real.sqrt_eq_rpow ] ; ring;
        rw [ show ( 1 / 6 : ℝ ) = 1 / 2 - 1 / 3 by norm_num, Real.rpow_sub' ] <;> norm_num ; ring;
      -- Let $y = \ln x$, therefore the expression becomes $\frac{y}{e^{y/6}}$.
      suffices h_log : Filter.Tendsto (fun y : ℝ => y / Real.exp (y / 6)) Filter.atTop (nhds 0) by
        have h_log : Filter.Tendsto (fun X : ℕ => Real.log X / Real.exp (Real.log X / 6)) Filter.atTop (nhds 0) := by
          exact h_log.comp ( Real.tendsto_log_atTop.comp tendsto_natCast_atTop_atTop );
        convert h_log.const_mul ( 1 / Real.log 2 ) using 2 <;> norm_num [ Real.logb, Real.rpow_def_of_pos ] ; ring;
        norm_num [ Real.rpow_def_of_nonneg ];
        grind;
      -- Let $z = \frac{y}{6}$, therefore the expression becomes $\frac{6z}{e^z}$.
      suffices h_z : Filter.Tendsto (fun z : ℝ => 6 * z / Real.exp z) Filter.atTop (nhds 0) by
        convert h_z.comp ( Filter.tendsto_id.atTop_mul_const ( by norm_num : 0 < ( 6⁻¹ : ℝ ) ) ) using 2 ; norm_num ; ring;
      simpa [ mul_div_assoc, Real.exp_neg ] using tendsto_const_nhds.mul ( Real.tendsto_pow_mul_exp_neg_atTop_nhds_zero 1 );
    rw [ Asymptotics.isBigO_iff ];
    have := h_log_growth.eventually ( gt_mem_nhds zero_lt_one ) ; aesop;
    exact ⟨ 2, w + 2, fun n hn => by rw [ abs_of_nonneg ( Real.sqrt_nonneg _ ) ] ; have := h n ( by linarith ) ; rw [ div_lt_one ( Real.sqrt_pos.mpr ( Nat.cast_pos.mpr ( by linarith ) ) ) ] at this; nlinarith [ h_sum_bound n, h_term_bound n ( by linarith ), Real.sqrt_nonneg n, Real.sq_sqrt ( Nat.cast_nonneg n ) ] ⟩

/-
Theorem 2: T_χ(X) = -S₂(X) + O(√X · log²X).
-/
theorem identity_a_twin_sum_relation :
  (fun (X : ℕ) => T_χ X - (-S₂ X)) =O[Filter.atTop] (fun (X : ℕ) => Real.sqrt X * (Real.log X)^2) := by
    -- We can bound the sum by considering the maximum possible value of each error term.
    have h_error_bound : ∃ C > 0, ∀ X : ℕ, 6 ≤ X → abs (∑ n ∈ Finset.range (X + 1), (f n * f (n + 2) - -(Λ n * Λ (n + 2)))) ≤ C * Real.sqrt (X : ℝ) * (Real.log (X : ℝ))^2 := by
      -- The number of proper prime powers up to X is bounded by 1 + 2 * proper_prime_powers_count(X+2).
      have h_proper_primes_bound : ∃ C > 0, ∀ X : ℕ, 6 ≤ X → (∑ n ∈ Finset.range (X + 1), (if error_term n ≠ 0 then 1 else 0)) ≤ C * Real.sqrt (X : ℝ) := by
        -- Let $C$ be a constant such that the number of proper prime powers up to $X$ is bounded by $C \sqrt{X}$.
        obtain ⟨C, hC_pos, hC_bound⟩ : ∃ C > 0, ∀ X : ℕ, 6 ≤ X → (proper_prime_powers_count (X + 2) : ℝ) ≤ C * Real.sqrt (X : ℝ) := by
          have h_proper_prime_powers_count_bound : ∃ C > 0, ∀ X : ℕ, 6 ≤ X → (proper_prime_powers_count X : ℝ) ≤ C * Real.sqrt X := by
            have := proper_prime_powers_count_bound;
            rw [ Asymptotics.isBigO_iff' ] at this;
            aesop;
            use Max.max w ( ∑ X ∈ Finset.Icc 6 w_1, ( proper_prime_powers_count X : ℝ ) / Real.sqrt X );
            aesop;
            by_cases hX : X ≤ w_1;
            · rw [ ← div_le_iff₀ ( Real.sqrt_pos.mpr ( Nat.cast_pos.mpr ( by linarith ) ) ) ];
              exact le_max_of_le_right ( Finset.single_le_sum ( fun x hx => div_nonneg ( Nat.cast_nonneg _ ) ( Real.sqrt_nonneg _ ) ) ( Finset.mem_Icc.mpr ⟨ by linarith, hX ⟩ ) );
            · exact le_trans ( h X ( by linarith ) ) ( by rw [ abs_of_nonneg ( Real.sqrt_nonneg _ ) ] ; exact mul_le_mul_of_nonneg_right ( le_max_left _ _ ) ( Real.sqrt_nonneg _ ) );
          aesop;
          refine' ⟨ w * Real.sqrt 3, mul_pos left ( Real.sqrt_pos.mpr zero_lt_three ), fun X hX => le_trans ( right _ ( by linarith ) ) _ ⟩ ; norm_num;
          rw [ mul_assoc, ← Real.sqrt_mul ( by positivity ) ] ; exact mul_le_mul_of_nonneg_left ( Real.sqrt_le_sqrt <| by nlinarith [ ( by norm_cast : ( 6 :ℝ ) ≤ X ) ] ) left.le;
        -- By definition of error_term, we know that error_term n ≠ 0 only if n is a proper prime power or n+2 is a proper prime power.
        have h_error_term_nonzero : ∀ X : ℕ, 6 ≤ X → (∑ n ∈ Finset.range (X + 1), (if error_term n ≠ 0 then 1 else 0)) ≤ proper_prime_powers_count (X + 2) + proper_prime_powers_count (X + 2) + 1 := by
          intros X hX
          have h_error_term_nonzero : ∀ n ∈ Finset.range (X + 1), error_term n ≠ 0 → n = 2 ∨ IsProperPrimePow n ∨ IsProperPrimePow (n + 2) := by
            intros n hn h_nonzero
            have h_cases : n = 2 ∨ IsPrimePow n ∧ ¬n.Prime ∨ IsPrimePow (n + 2) ∧ ¬(n + 2).Prime := by
              exact?;
            aesop;
          -- Let's count the number of $n$ in the range $0$ to $X$ such that $n$ is a proper prime power or $n+2$ is a proper prime power.
          have h_count : Finset.card (Finset.filter (fun n => IsProperPrimePow n ∨ IsProperPrimePow (n + 2)) (Finset.range (X + 1))) ≤ proper_prime_powers_count (X + 2) + proper_prime_powers_count (X + 2) := by
            have h_count : Finset.card (Finset.filter (fun n => IsProperPrimePow n) (Finset.range (X + 1))) ≤ proper_prime_powers_count (X + 2) ∧ Finset.card (Finset.filter (fun n => IsProperPrimePow (n + 2)) (Finset.range (X + 1))) ≤ proper_prime_powers_count (X + 2) := by
              constructor;
              · exact Finset.card_mono <| fun x hx => Finset.mem_filter.mpr ⟨ Finset.mem_range.mpr <| by linarith [ Finset.mem_range.mp <| Finset.mem_filter.mp hx |>.1 ], Finset.mem_filter.mp hx |>.2 ⟩;
              · have h_count : Finset.card (Finset.filter (fun n => IsProperPrimePow (n + 2)) (Finset.range (X + 1))) ≤ Finset.card (Finset.filter IsProperPrimePow (Finset.Ico 2 (X + 3))) := by
                  have h_count : Finset.card (Finset.filter (fun n => IsProperPrimePow (n + 2)) (Finset.range (X + 1))) ≤ Finset.card (Finset.image (fun n => n + 2) (Finset.filter (fun n => IsProperPrimePow (n + 2)) (Finset.range (X + 1)))) := by
                    rw [ Finset.card_image_of_injective _ ( add_left_injective 2 ) ];
                  exact h_count.trans ( Finset.card_le_card <| Finset.image_subset_iff.mpr fun n hn => Finset.mem_filter.mpr ⟨ Finset.mem_Ico.mpr ⟨ by linarith [ Finset.mem_range.mp ( Finset.mem_filter.mp hn |>.1 ) ], by linarith [ Finset.mem_range.mp ( Finset.mem_filter.mp hn |>.1 ) ] ⟩, Finset.mem_filter.mp hn |>.2 ⟩ );
                refine le_trans h_count ?_;
                refine Finset.card_mono ?_;
                exact fun x hx => Finset.mem_filter.mpr ⟨ Finset.mem_range.mpr ( by linarith [ Finset.mem_Ico.mp ( Finset.mem_filter.mp hx |>.1 ) ] ), Finset.mem_filter.mp hx |>.2 ⟩;
            exact le_trans ( Finset.card_le_card ( show Finset.filter ( fun n => IsProperPrimePow n ∨ IsProperPrimePow ( n + 2 ) ) ( Finset.range ( X + 1 ) ) ⊆ Finset.filter ( fun n => IsProperPrimePow n ) ( Finset.range ( X + 1 ) ) ∪ Finset.filter ( fun n => IsProperPrimePow ( n + 2 ) ) ( Finset.range ( X + 1 ) ) from fun x hx => by aesop ) ) ( Finset.card_union_le _ _ ) |> le_trans <| add_le_add h_count.1 h_count.2;
          aesop;
          rw [ Finset.sum_ite ];
          simp +zetaDelta at *;
          exact le_trans ( Finset.card_le_card ( show Finset.filter ( fun x => ¬error_term x = 0 ) ( Finset.range ( X + 1 ) ) ⊆ Finset.filter ( fun x => IsProperPrimePow x ∨ IsProperPrimePow ( x + 2 ) ) ( Finset.range ( X + 1 ) ) ∪ { 2 } from fun x hx => by specialize h_error_term_nonzero x ( Finset.mem_range.mp ( Finset.mem_filter.mp hx |>.1 ) ) ( Finset.mem_filter.mp hx |>.2 ) ; aesop ) ) ( by exact le_trans ( Finset.card_union_le _ _ ) ( by norm_num; linarith ) );
        refine' ⟨ 2 * C + 1, by positivity, fun X hX => _ ⟩;
        norm_num +zetaDelta at *;
        nlinarith [ hC_bound X hX, h_error_term_nonzero X hX, show ( ∑ x ∈ Finset.range ( X + 1 ), if error_term x = 0 then 0 else 1 : ℝ ) ≤ proper_prime_powers_count ( X + 2 ) + proper_prime_powers_count ( X + 2 ) + 1 by exact_mod_cast h_error_term_nonzero X hX, Real.sqrt_nonneg X, Real.sq_sqrt <| Nat.cast_nonneg X, show ( X : ℝ ) ≥ 6 by norm_cast ];
      -- The absolute value of each error term is bounded by 2 * log(X+2)^2.
      have h_error_term_bound : ∃ C > 0, ∀ X : ℕ, 6 ≤ X → ∀ n ∈ Finset.range (X + 1), abs (f n * f (n + 2) - -(Λ n * Λ (n + 2))) ≤ C * (Real.log (X + 2))^2 * (if error_term n ≠ 0 then 1 else 0) := by
        -- The absolute value of each error term is bounded by 2 * log(X+2)^2 because |f(n)| ≤ log(X+2) and |f(n+2)| ≤ log(X+2).
        have h_error_term_bound : ∀ X : ℕ, 6 ≤ X → ∀ n ∈ Finset.range (X + 1), abs (f n * f (n + 2)) ≤ (Real.log (X + 2))^2 ∧ abs (Λ n * Λ (n + 2)) ≤ (Real.log (X + 2))^2 := by
          -- Since $|\Lambda(n)| \leq \log(X+2)$ for all $n \leq X$, we have $|\Lambda(n) \Lambda(n+2)| \leq (\log(X+2))^2$.
          have h_lambda_bound : ∀ X : ℕ, 6 ≤ X → ∀ n ∈ Finset.range (X + 1), abs (Λ n) ≤ Real.log (X + 2) ∧ abs (Λ (n + 2)) ≤ Real.log (X + 2) := by
            aesop;
            · rw [ abs_of_nonneg ( ArithmeticFunction.vonMangoldt_nonneg ) ];
              by_cases hn : n = 0;
              · aesop;
                exact Real.log_nonneg ( by linarith );
              · -- Since $n \neq 0$, we have $\Lambda(n) \leq \log(n)$.
                have h_lambda_le_log : (Λ n : ℝ) ≤ Real.log n := by
                  exact?;
                exact h_lambda_le_log.trans ( Real.log_le_log ( by positivity ) ( by norm_cast; linarith ) );
            · rw [ ArithmeticFunction.vonMangoldt_apply ] ; aesop;
              · rw [ abs_of_nonneg ( Real.log_nonneg ( mod_cast Nat.minFac_pos _ ) ) ] ; exact Real.log_le_log ( mod_cast Nat.minFac_pos _ ) ( mod_cast by linarith [ Nat.minFac_le ( by linarith : 0 < n + 2 ) ] );
              · exact Real.log_nonneg ( by linarith );
          intro X hX n hn; specialize h_lambda_bound X hX n hn; simp_all +decide [ abs_mul, sq ] ;
          bound;
          · unfold f;
            rw [ abs_mul ];
            exact le_trans ( mul_le_of_le_one_right ( abs_nonneg _ ) ( mod_cast by have := ZMod.χ₄ n; have := ZMod.χ₄ ( n + 2 ) ; have := ZMod.χ₄ ( n + 4 ) ; have := ZMod.χ₄ ( n + 6 ) ; norm_num at * ; aesop ) ) left;
          · unfold f; aesop;
            · exact Real.log_nonneg ( by linarith );
            · exact Real.log_nonneg ( by linarith );
          · linarith;
          · linarith;
        use 2, by norm_num, fun X hX n hn => ?_ ; specialize h_error_term_bound X hX n hn ; aesop;
        · unfold error_term at h; aesop;
        · exact abs_le.mpr ⟨ by linarith [ abs_le.mp ( show |f n * f ( n + 2 )| ≤ Real.log ( X + 2 ) ^ 2 by simpa only [ abs_mul ] using left ), abs_le.mp ( show |( Λ n ) * ( Λ ( n + 2 ) )| ≤ Real.log ( X + 2 ) ^ 2 by simpa only [ abs_mul ] using right ) ], by linarith [ abs_le.mp ( show |f n * f ( n + 2 )| ≤ Real.log ( X + 2 ) ^ 2 by simpa only [ abs_mul ] using left ), abs_le.mp ( show |( Λ n ) * ( Λ ( n + 2 ) )| ≤ Real.log ( X + 2 ) ^ 2 by simpa only [ abs_mul ] using right ) ] ⟩;
      obtain ⟨ C₁, hC₁_pos, hC₁_bound ⟩ := h_proper_primes_bound; obtain ⟨ C₂, hC₂_pos, hC₂_bound ⟩ := h_error_term_bound; use C₁ * C₂ * 4; aesop;
      -- Applying the bounds on the number of proper prime powers and the error term, we get:
      have h_sum_bound : abs (∑ n ∈ Finset.range (X + 1), (f n * f (n + 2) + Λ n * Λ (n + 2))) ≤ C₂ * (Real.log (X + 2))^2 * (∑ n ∈ Finset.range (X + 1), (if error_term n ≠ 0 then 1 else 0)) := by
        rw [ Finset.mul_sum _ _ _ ];
        exact le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( Finset.sum_le_sum fun i hi => by specialize hC₂_bound X a i ( Finset.mem_range.mp hi ) ; aesop );
      -- We can bound the logarithmic term $(\log(X+2))^2$ by $4(\log X)^2$ for $X \geq 6$.
      have h_log_bound : (Real.log (X + 2))^2 ≤ 4 * (Real.log X)^2 := by
        have h_log_bound : Real.log (X + 2) ≤ 2 * Real.log X := by
          rw [ ← Real.log_rpow, Real.log_le_log_iff ] <;> norm_cast <;> nlinarith;
        nlinarith only [ h_log_bound, Real.log_nonneg ( by norm_cast; linarith : ( X:ℝ ) + 2 ≥ 1 ), Real.log_nonneg ( by norm_cast; linarith : ( X:ℝ ) ≥ 1 ) ];
      refine le_trans h_sum_bound ?_;
      refine le_trans ( mul_le_mul_of_nonneg_left ( show ( ∑ n ∈ Finset.range ( X + 1 ), if error_term n ≠ 0 then 1 else 0 ) ≤ C₁ * Real.sqrt X from ?_ ) ( by positivity ) ) ?_;
      · simpa [ Finset.sum_ite ] using hC₁_bound X a;
      · nlinarith [ show 0 ≤ C₁ * C₂ * Real.sqrt X by positivity ];
    obtain ⟨ C, hC₀, hC ⟩ := h_error_bound;
    refine' Asymptotics.isBigO_iff.mpr ⟨ C, _ ⟩;
    norm_num +zetaDelta at *;
    exact ⟨ 6, fun X hX => by simpa only [ ← mul_assoc, abs_of_nonneg ( Real.sqrt_nonneg _ ) ] using hC X hX |> le_trans ( by simp +decide [ Finset.sum_add_distrib, T_χ, S₂ ] ) ⟩

/-
The Twin Prime Conjecture: there are infinitely many twin primes.
-/
def TPC : Prop := {p : ℕ | p.Prime ∧ (p + 2).Prime}.Infinite

/-
Defining S2_good (twin prime contribution) and S2_bad (proper prime power contribution).
-/
noncomputable def S2_good (X : ℕ) : ℝ := ∑ n ∈ Finset.range (X + 1), if n.Prime ∧ (n + 2).Prime then Λ n * Λ (n + 2) else 0

noncomputable def S2_bad (X : ℕ) : ℝ := ∑ n ∈ Finset.range (X + 1), if IsProperPrimePow n ∨ IsProperPrimePow (n + 2) then Λ n * Λ (n + 2) else 0

/-
S₂ is the sum of the twin prime part and the proper prime power part.
-/
theorem S2_decomposition (X : ℕ) : S₂ X = S2_good X + S2_bad X := by
  -- By definition of $S₂$, we can write it as the sum of $S2_good$ and $S2_bad$.
  have h_def : ∀ n ∈ Finset.range (X + 1), Λ n * Λ (n + 2) = (if n.Prime ∧ (n + 2).Prime then Λ n * Λ (n + 2) else 0) + (if IsProperPrimePow n ∨ IsProperPrimePow (n + 2) then Λ n * Λ (n + 2) else 0) := by
    intro n hn; split_ifs <;> ring;
    · unfold IsProperPrimePow at * ; aesop;
    · rw [ Nat.add_comm, ArithmeticFunction.vonMangoldt_apply, ArithmeticFunction.vonMangoldt_apply ] ; aesop;
      unfold IsProperPrimePow at *; aesop;
  simpa only [ Finset.sum_add_distrib ] using Finset.sum_congr rfl h_def

/-
S2_bad is O(√X log²X).
-/
theorem S2_bad_bound :
  S2_bad =O[Filter.atTop] (fun (X : ℕ) => Real.sqrt X * (Real.log X)^2) := by
    -- The number of terms in S2_bad is bounded by 2 * proper_prime_powers_count(X+2), and each term is bounded by log(X)^2.
    have h_bound : ∀ X : ℕ, S2_bad X ≤ 2 * (proper_prime_powers_count (X + 2)) * (Real.log (X + 2)) ^ 2 := by
      intro X
      have h_count : (Finset.filter (fun n => IsProperPrimePow n ∨ IsProperPrimePow (n + 2)) (Finset.range (X + 1))).card ≤ 2 * (proper_prime_powers_count (X + 2)) := by
        have h_count : (Finset.filter (fun n => IsProperPrimePow n ∨ IsProperPrimePow (n + 2)) (Finset.range (X + 1))).card ≤ (Finset.filter (fun n => IsProperPrimePow n) (Finset.range (X + 1))).card + (Finset.filter (fun n => IsProperPrimePow n) (Finset.range (X + 3))).card := by
          have h_card : (Finset.filter (fun n => IsProperPrimePow n ∨ IsProperPrimePow (n + 2)) (Finset.range (X + 1))) ⊆ (Finset.filter (fun n => IsProperPrimePow n) (Finset.range (X + 1))) ∪ (Finset.image (fun n => n - 2) (Finset.filter (fun n => IsProperPrimePow n) (Finset.range (X + 3)))) := by
            intro n hn; aesop;
          exact le_trans ( Finset.card_le_card h_card ) ( Finset.card_union_le _ _ ) |> le_trans <| add_le_add_left ( Finset.card_image_le ) _;
        refine le_trans h_count ?_;
        rw [ two_mul ];
        exact add_le_add ( Finset.card_mono <| Finset.filter_subset_filter _ <| Finset.range_mono <| by linarith ) ( Finset.card_mono <| Finset.filter_subset_filter _ <| Finset.range_mono <| by linarith );
      -- Each term in S2_bad is bounded by log(X)^2.
      have h_term_bound : ∀ n ∈ Finset.filter (fun n => IsProperPrimePow n ∨ IsProperPrimePow (n + 2)) (Finset.range (X + 1)), Λ n * Λ (n + 2) ≤ (Real.log (X + 2)) ^ 2 := by
        bound;
        -- Since $\Lambda(n) \leq \log(X+2)$ and $\Lambda(n+2) \leq \log(X+2)$ for all $n \leq X$, we have $\Lambda(n) \Lambda(n+2) \leq (\log(X+2))^2$.
        have h_lambda_bound : ∀ n ≤ X, Λ n ≤ Real.log (X + 2) ∧ Λ (n + 2) ≤ Real.log (X + 2) := by
          intro n hn; constructor <;> refine' le_trans _ ( Real.log_le_log _ _ ) <;> norm_cast <;> norm_num;
          · by_cases hn' : n = 0 <;> simp_all +decide [ ArithmeticFunction.vonMangoldt ];
            · exact Real.log_nonneg ( by linarith );
            · split_ifs;
              · exact Real.log_le_log ( Nat.cast_pos.mpr ( Nat.minFac_pos _ ) ) ( mod_cast Nat.le_trans ( Nat.minFac_le ( Nat.pos_of_ne_zero hn' ) ) ( by linarith ) );
              · exact Real.log_nonneg ( by linarith );
          · positivity;
          · unfold ArithmeticFunction.vonMangoldt; aesop;
            · exact Real.log_le_log ( Nat.cast_pos.mpr ( Nat.minFac_pos _ ) ) ( mod_cast Nat.le_trans ( Nat.minFac_le ( by linarith ) ) ( by linarith ) );
            · exact Real.log_nonneg ( by linarith );
            · exact Real.log_le_log ( Nat.cast_pos.mpr ( Nat.minFac_pos _ ) ) ( mod_cast Nat.le_trans ( Nat.minFac_le ( by linarith ) ) ( by linarith ) );
            · exact Real.log_nonneg ( by linarith );
          · positivity;
        nlinarith only [ h_lambda_bound n ( Finset.mem_range_succ_iff.mp ( Finset.mem_filter.mp a |>.1 ) ), show 0 ≤ Λ n from by exact_mod_cast ArithmeticFunction.vonMangoldt_nonneg, show 0 ≤ Λ ( n + 2 ) from by exact_mod_cast ArithmeticFunction.vonMangoldt_nonneg ];
      convert Finset.sum_le_sum h_term_bound |> le_trans <| ?_ using 1;
      · unfold S2_bad; aesop;
        rw [ Finset.sum_filter ];
      · aesop;
        exact mul_le_mul_of_nonneg_right ( mod_cast h_count ) ( sq_nonneg _ );
    -- Since proper_prime_powers_count is O(√X), we can substitute this into the bound.
    have h_substitute : (fun X : ℕ => 2 * (proper_prime_powers_count (X + 2)) * (Real.log (X + 2)) ^ 2) =O[Filter.atTop] (fun X : ℕ => Real.sqrt (X + 2) * (Real.log (X + 2)) ^ 2) := by
      have h_substitute : (fun X : ℕ => (proper_prime_powers_count (X + 2) : ℝ)) =O[Filter.atTop] (fun X : ℕ => Real.sqrt (X + 2)) := by
        have h_O : (fun X : ℕ => (proper_prime_powers_count X : ℝ)) =O[Filter.atTop] fun X : ℕ => Real.sqrt X := by
          exact?;
        norm_num [ Asymptotics.isBigO_iff ] at *;
        obtain ⟨ c, a, h ⟩ := h_O; exact ⟨ c, a, fun b hb => mod_cast h ( b + 2 ) ( by linarith ) ⟩ ;
      rw [ Asymptotics.isBigO_iff ] at * ; aesop;
      exact ⟨ 2 * w, w_1, fun n hn => by nlinarith [ h n hn, show 0 ≤ Real.log ( n + 2 ) ^ 2 * |Real.sqrt ( n + 2 )| by positivity ] ⟩;
    refine' Asymptotics.IsBigO.trans _ ( h_substitute.trans _ );
    · refine' Asymptotics.IsBigO.of_bound 1 _;
      aesop;
      exact ⟨ 0, fun X _ => by rw [ abs_of_nonneg ( show 0 ≤ S2_bad X from Finset.sum_nonneg fun _ _ => by split_ifs <;> first | positivity | exact mul_nonneg ( by exact ( by rw [ ArithmeticFunction.vonMangoldt_apply ] ; positivity ) ) ( by exact ( by rw [ ArithmeticFunction.vonMangoldt_apply ] ; positivity ) ) ) ] ; exact h_bound X ⟩;
    · -- To show that the function is O(√X * log²X), we can use the fact that for large X, √(X + 2) is approximately √X and log(X + 2) is approximately log X.
      have h_approx : Filter.Tendsto (fun X : ℕ => Real.sqrt (X + 2) * (Real.log (X + 2))^2 / (Real.sqrt X * (Real.log X)^2)) Filter.atTop (nhds 1) := by
        -- We can simplify the expression inside the limit.
        suffices h_simplify : Filter.Tendsto (fun X : ℕ => Real.sqrt (1 + 2 / (X : ℝ)) * (Real.log (X + 2) / Real.log X)^2) Filter.atTop (nhds 1) by
          refine h_simplify.congr' ?_;
          filter_upwards [ Filter.eventually_gt_atTop 0 ] with X hX using by rw [ one_add_div ( by positivity ), Real.sqrt_div ( by positivity ) ] ; rw [ div_pow ] ; ring;
        -- We'll use the fact that $\frac{\log(X+2)}{\log X}$ tends to $1$ as $X$ tends to infinity.
        have h_log : Filter.Tendsto (fun X : ℕ => Real.log (X + 2) / Real.log X) Filter.atTop (nhds 1) := by
          -- We can use the fact that $\log(X+2) = \log X + \log\left(1 + \frac{2}{X}\right)$ to simplify the expression.
          suffices h_log_simplified : Filter.Tendsto (fun X : ℕ => (Real.log X + Real.log (1 + 2 / (X : ℝ))) / Real.log X) Filter.atTop (nhds 1) by
            refine h_log_simplified.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with X hX using by rw [ ← Real.log_mul ( by positivity ) ( by positivity ), mul_add, mul_div_cancel₀ _ ( by positivity ), mul_one ] );
          ring_nf;
          exact le_trans ( Filter.Tendsto.add ( tendsto_const_nhds.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 1 ] with x hx; rw [ mul_inv_cancel₀ ( ne_of_gt ( Real.log_pos ( mod_cast hx ) ) ) ] ) ) ( Filter.Tendsto.mul ( Filter.Tendsto.log ( tendsto_const_nhds.add ( tendsto_inverse_atTop_nhds_zero_nat.mul_const _ ) ) ( by norm_num ) ) ( tendsto_inv_atTop_zero.comp ( Real.tendsto_log_atTop.comp tendsto_natCast_atTop_atTop ) ) ) ) ( by norm_num );
        convert Filter.Tendsto.mul ( Filter.Tendsto.sqrt ( tendsto_const_nhds.add ( tendsto_const_nhds.div_atTop tendsto_natCast_atTop_atTop ) ) ) ( h_log.pow 2 ) using 2 ; norm_num;
      rw [ Asymptotics.isBigO_iff ];
      have := h_approx.eventually ( Metric.ball_mem_nhds _ zero_lt_one ) ; aesop;
      exact ⟨ 2, w + 2, fun n hn => by rw [ abs_of_nonneg ( Real.sqrt_nonneg _ ), abs_of_nonneg ( Real.sqrt_nonneg _ ) ] ; have := abs_lt.mp ( h n ( by linarith ) ) ; rw [ div_eq_mul_inv ] at this; nlinarith [ inv_pos.mpr ( show 0 < Real.sqrt n * Real.log n ^ 2 by exact mul_pos ( Real.sqrt_pos.mpr ( Nat.cast_pos.mpr ( by linarith ) ) ) ( sq_pos_of_pos ( Real.log_pos ( Nat.one_lt_cast.mpr ( by linarith ) ) ) ) ), mul_inv_cancel₀ ( ne_of_gt ( show 0 < Real.sqrt n * Real.log n ^ 2 by exact mul_pos ( Real.sqrt_pos.mpr ( Nat.cast_pos.mpr ( by linarith ) ) ) ( sq_pos_of_pos ( Real.log_pos ( Nat.one_lt_cast.mpr ( by linarith ) ) ) ) ) ) ] ⟩

/-
If S2_good is unbounded, there are infinitely many twin primes.
-/
theorem tpc_of_S2_good_unbounded (h : ¬ BddAbove (Set.range S2_good)) : TPC := by
  -- Suppose, for contradiction, there are only finitely many twin primes.
  by_contra h_finite;
  -- Then there are finitely many twin primes.
  obtain ⟨P, hP⟩ : ∃ P : Finset ℕ, {p : ℕ | p.Prime ∧ (p + 2).Prime} ⊆ P := by
    exact Set.Finite.bddAbove ( Classical.not_not.mp h_finite ) |> fun ⟨ N, hN ⟩ => ⟨ Finset.Iic N, fun P hP => Finset.mem_Iic.2 ( hN hP ) ⟩;
  -- Since P is finite, the sum of log(p)log(p+2) over all p in P is finite.
  have h_sum_finite : ∃ M : ℝ, ∀ X, S2_good X ≤ M := by
    use ∑ p ∈ P, Λ p * Λ ( p + 2 );
    intro X; rw [ S2_good ] ; refine' le_trans _ ( Finset.sum_le_sum_of_subset_of_nonneg _ _ );
    rotate_left;
    exact Finset.filter ( fun p => Nat.Prime p ∧ Nat.Prime ( p + 2 ) ) ( Finset.range ( X + 1 ) );
    · exact fun p hp => hP <| Finset.mem_filter.mp hp |>.2;
    · exact fun _ _ _ => mul_nonneg ( by exact? ) ( by exact? );
    · rw [ Finset.sum_filter ];
  exact h ⟨ h_sum_finite.choose, Set.forall_mem_range.mpr h_sum_finite.choose_spec ⟩

/-
S2_bad is o(X).
-/
open Asymptotics Filter

theorem S2_bad_is_little_o_X : S2_bad =o[atTop] (fun (X : ℕ) => (X : ℝ)) := by
  have h_S2_bad_bound : S2_bad =O[Filter.atTop] (fun X => Real.sqrt X * (Real.log X)^2) := by
    exact?;
  -- Since $\sqrt{X} \cdot \log^2(X)$ grows slower than $X$, we can conclude that $S2\_bad$ is $o(X)$.
  have h_sqrt_log2X_o_X : (fun X : ℕ => Real.sqrt X * (Real.log X)^2) =o[Filter.atTop] (fun X : ℕ => (X : ℝ)) := by
    -- We can divide both sides by $X$ and show that the resulting expression tends to zero.
    have h_div : Filter.Tendsto (fun X : ℕ => (Real.log X)^2 / Real.sqrt X) Filter.atTop (nhds 0) := by
      -- Let $y = \log X$, therefore the expression becomes $\frac{y^2}{e^{y/2}}$.
      suffices h_log : Filter.Tendsto (fun y : ℝ => y^2 / Real.exp (y / 2)) Filter.atTop (nhds 0) by
        have h_log : Filter.Tendsto (fun X : ℕ => (Real.log X)^2 / Real.exp (Real.log X / 2)) Filter.atTop (nhds 0) := by
          exact h_log.comp ( Real.tendsto_log_atTop.comp tendsto_natCast_atTop_atTop );
        refine h_log.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with X hX using by rw [ Real.sqrt_eq_rpow, Real.rpow_def_of_pos ( Nat.cast_pos.mpr hX ) ] ; ring );
      -- Let $z = \frac{y}{2}$, therefore the expression becomes $\frac{(2z)^2}{e^z} = \frac{4z^2}{e^z}$.
      suffices h_z : Filter.Tendsto (fun z : ℝ => 4 * z^2 / Real.exp z) Filter.atTop (nhds 0) by
        convert h_z.comp ( Filter.tendsto_id.atTop_mul_const ( by norm_num : 0 < ( 2⁻¹ : ℝ ) ) ) using 2 ; norm_num ; ring;
      simpa [ Real.exp_neg, mul_div_assoc ] using Real.tendsto_pow_mul_exp_neg_atTop_nhds_zero 2 |> Filter.Tendsto.const_mul 4;
    rw [ Asymptotics.isLittleO_iff_tendsto' ];
    · refine h_div.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with x hx using by rw [ div_eq_div_iff ] <;> first | positivity | ring_nf ; norm_num [ hx.ne', le_of_lt hx ] );
    · aesop;
  exact h_S2_bad_bound.trans_isLittleO h_sqrt_log2X_o_X

/-
The error term T_χ - (-S₂) is o(X).
-/
open Asymptotics Filter

theorem error_is_little_o_X : (fun (X : ℕ) => T_χ X - (-S₂ X)) =o[atTop] (fun (X : ℕ) => (X : ℝ)) := by
  -- We know T_χ X - (-S₂ X) = O(√X log²X) from identity_a_twin_sum_relation.
  have h_error_term : (fun (X : ℕ) => T_χ X - (-S₂ X)) =O[Filter.atTop] (fun (X : ℕ) => Real.sqrt X * (Real.log X)^2) := by
    exact?;
  refine' h_error_term.trans_isLittleO _;
  -- We can divide both sides by $X$ to get $\frac{\log^2 X}{\sqrt{X}}$.
  suffices h_div : (fun X : ℕ => (Real.log X)^2 / Real.sqrt X) =o[Filter.atTop] (fun _ : ℕ => 1 : ℕ → ℝ) by
    rw [ Asymptotics.isLittleO_iff_tendsto' ] at * <;> aesop;
    grind;
  -- Let $y = \log X$, therefore the expression becomes $\frac{y^2}{e^{y/2}}$.
  suffices h_log : (fun y : ℝ => y^2 / Real.exp (y / 2)) =o[Filter.atTop] (fun _ : ℝ => 1 : ℝ → ℝ) by
    have h_subst : (fun X : ℕ => (Real.log X)^2 / Real.exp (Real.log X / 2)) =o[Filter.atTop] (fun _ : ℕ => 1 : ℕ → ℝ) := by
      exact h_log.comp_tendsto ( Real.tendsto_log_atTop.comp tendsto_natCast_atTop_atTop );
    refine h_subst.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with X hX using by rw [ Real.sqrt_eq_rpow, Real.rpow_def_of_pos ( Nat.cast_pos.mpr hX ) ] ; ring ) ( by norm_num );
  -- Let $z = \frac{y}{2}$, therefore the expression becomes $\frac{(2z)^2}{e^z} = \frac{4z^2}{e^z}$.
  suffices h_z : (fun z : ℝ => 4 * z^2 / Real.exp z) =o[Filter.atTop] (fun _ : ℝ => 1 : ℝ → ℝ) by
    rw [ Asymptotics.isLittleO_iff_tendsto' ] at * <;> aesop;
    convert h_z.comp ( Filter.tendsto_id.atTop_mul_const ( by norm_num : 0 < ( 2⁻¹ : ℝ ) ) ) using 2 ; norm_num ; ring;
  simpa [ Real.exp_neg, mul_div_assoc ] using Real.tendsto_pow_mul_exp_neg_atTop_nhds_zero 2 |> Filter.Tendsto.const_mul 4

/-
If limsup |T_χ(X)|/X > 0, then TPC is true.
-/
open Asymptotics Filter

theorem tpc_of_limsup_pos (h : Filter.limsup (fun X => abs (T_χ X) / X) Filter.atTop > 0) : TPC := by
  -- By definition of limsup, there exists a constant $c > 0$ such that for infinitely many $X$, $|T_{\chi}(X)| \geq cX$.
  obtain ⟨c, hc_pos, hc⟩ : ∃ c > 0, ∀ N : ℕ, ∃ X ≥ N, |T_χ X| ≥ c * (X : ℝ) := by
    contrapose! h;
    refine' le_of_forall_pos_le_add fun ε ε_pos => _;
    refine' csInf_le _ _ <;> aesop;
    · exact ⟨ 0, by rintro x ⟨ N, hN ⟩ ; exact le_trans ( by positivity ) ( hN _ le_rfl ) ⟩;
    · exact Exists.elim ( h ε ε_pos ) fun N hN => ⟨ N + 1, fun n hn => by rw [ div_le_iff₀ ( by norm_cast; linarith ) ] ; linarith [ hN n ( by linarith ) ] ⟩;
  -- For such $X$, we have $S₂(X) \geq |T_{\chi}(X)| - |error(X)| \geq cX - o(X)$.
  have h_bound : ∀ N : ℕ, ∃ X ≥ N, S₂ X ≥ (c / 2) * (X : ℝ) := by
    -- Since $|error(X)| = o(X)$, there exists $N'$ such that for all $X \geq N'$, $|error(X)| \leq \frac{c}{2}X$.
    obtain ⟨N', hN'⟩ : ∃ N', ∀ X ≥ N', |T_χ X - (-S₂ X)| ≤ (c / 2) * (X : ℝ) := by
      have := error_is_little_o_X;
      rw [ Asymptotics.isLittleO_iff ] at this;
      aesop;
    intro N; obtain ⟨ X, hX₁, hX₂ ⟩ := hc ( Max.max N' N ) ; use X; aesop;
    cases abs_cases ( T_χ X ) <;> cases abs_cases ( T_χ X + S₂ X ) <;> linarith [ hN' X left, show ( 0 : ℝ ) ≤ S₂ X from Finset.sum_nonneg fun _ _ => mul_nonneg ( by exact? ) ( by exact? ) ];
  -- Since $S₂(X) = S2_good(X) + S2_bad(X)$ and $S2_bad(X) = o(X)$, it follows that $S2_good(X)$ must be unbounded.
  have h_S2_good_unbounded : ¬ BddAbove (Set.range S2_good) := by
    -- By definition of $S2_bad$, we know that $S2_bad(X) = o(X)$, which implies that for any $\epsilon > 0$, there exists an $N$ such that for all $X \geq N$, $|S2_bad(X)| < \epsilon X$.
    have h_S2_bad_small : ∀ ε > 0, ∃ N : ℕ, ∀ X ≥ N, |S2_bad X| < ε * (X : ℝ) := by
      have := S2_bad_is_little_o_X; rw [ Asymptotics.isLittleO_iff ] at this; aesop;
      exact Exists.elim ( this ( half_pos a ) ) fun N hN => ⟨ N + 1, fun X hX => lt_of_le_of_lt ( hN X ( by linarith ) ) ( mul_lt_mul_of_pos_right ( half_lt_self a ) ( Nat.cast_pos.mpr ( by linarith ) ) ) ⟩;
    contrapose! h_bound;
    obtain ⟨ M, hM ⟩ := h_bound; obtain ⟨ N, hN ⟩ := h_S2_bad_small ( c / 4 ) ( by positivity ) ; use N + ⌈M / ( c / 4 ) ⌉₊ + 1; intros x hx; have := hN x ( by linarith ) ; rw [ S2_decomposition ] ; nlinarith [ Nat.le_ceil ( M / ( c / 4 ) ), mul_div_cancel₀ M ( by positivity : ( c / 4 ) ≠ 0 ), abs_lt.mp this, show ( x : ℝ ) ≥ N + ⌈M / ( c / 4 ) ⌉₊ + 1 by exact_mod_cast hx, hM <| Set.mem_range_self x ] ;
  exact?

/-
Defining the complex-valued Dirichlet character χ₄.
-/
noncomputable def χ₄_complex : DirichletCharacter ℂ 4 :=
  MulChar.ringHomComp ZMod.χ₄ (Int.castRingHom ℂ)

/-
Theorem 6: Σ f(n)/n^s = -L'(s, χ₄)/L(s, χ₄).
-/
theorem l_function_connection (s : ℂ) (hs : 1 < s.re) :
  ∑' n : ℕ, f n / (n : ℂ) ^ s = - (deriv (DirichletCharacter.LFunction χ₄_complex) s) / (DirichletCharacter.LFunction χ₄_complex s) := by
    convert DirichletCharacter.LSeries_twist_vonMangoldt_eq χ₄_complex hs using 1;
    · refine' tsum_congr fun n => _;
      unfold f; unfold LSeries.term; norm_num [ mul_comm ];
      rcases n with ( _ | _ | _ | _ | n ) <;> norm_num [ ZMod, χ₄_complex ];
    · congr! 1;
      · congr! 1;
        exact?;
      · exact?

/-
Defining the partial sums of the Leibniz series.
-/
open Finset BigOperators Filter Topology

noncomputable def leibniz_partial_sum (k : ℕ) : ℝ := ∑ i ∈ range k, (-1 : ℝ) ^ i / (2 * i + 1)

/-
Defining the partial sums of the Dirichlet series for χ₄.
-/
noncomputable def chi4_partial_sum (k : ℕ) : ℂ := ∑ i ∈ range k, (χ₄_complex i : ℂ) / (i : ℂ)

/-
The partial sums of the χ₄ series match the Leibniz series.
-/
theorem chi4_sum_eq_leibniz_sum (k : ℕ) :
  chi4_partial_sum (4 * k) = (leibniz_partial_sum (2 * k) : ℂ) := by
    -- Let's simplify the expression for $\chi_4(i)$.
    have h_chi4 (i : ℕ) : (χ₄_complex i : ℂ) = if i % 4 = 1 then 1 else if i % 4 = 3 then -1 else 0 := by
      rcases Nat.even_or_odd' i with ⟨ k, rfl | rfl ⟩ <;> norm_num [ Nat.add_mod, Nat.mul_mod ];
      · norm_num [ χ₄_complex ];
        rcases Nat.even_or_odd' k with ⟨ k, rfl | rfl ⟩ <;> ring_nf <;> norm_num;
        · exact Or.inl rfl;
        · exact Or.inl rfl;
      · norm_num [ χ₄_complex, ZMod.χ₄ ];
        rcases Nat.even_or_odd' k with ⟨ k, rfl | rfl ⟩ <;> ring_nf <;> norm_cast;
        · ring_nf; aesop;
        · ring_nf; aesop;
    -- Let's rewrite the sum over i from 0 to 4k-1 by separating it into the sum over even i and the sum over odd i.
    have h_split_sum : ∑ i ∈ Finset.range (4 * k), (χ₄_complex i : ℂ) / (i : ℂ) = ∑ i ∈ Finset.range (2 * k), (if i % 2 = 0 then 1 else -1 : ℂ) / (2 * i + 1) := by
      induction' k with k ih;
      · norm_num;
      · simp_all +decide [ Nat.mul_succ, Finset.sum_range_succ ];
        ring;
    convert h_split_sum using 2 ; norm_num [ leibniz_partial_sum ];
    exact Finset.sum_congr rfl fun x hx => by rcases Nat.even_or_odd' x with ⟨ c, rfl | rfl ⟩ <;> norm_num [ pow_add, pow_mul ] ;

/-
The terms of the Dirichlet series for χ₄ tend to 0.
-/
theorem chi4_terms_tendsto_zero :
  Tendsto (fun n : ℕ => (χ₄_complex n : ℂ) / (n : ℂ)) atTop (nhds 0) := by
    refine' squeeze_zero_norm _ tendsto_inverse_atTop_nhds_zero_nat;
    unfold χ₄_complex; aesop

/-
The Dirichlet series for χ₄ converges to π/4.
-/
theorem chi4_series_limit_pi_div_four :
  Tendsto chi4_partial_sum atTop (nhds ((Real.pi / 4) : ℂ)) := by
    -- The partial sums of the Leibniz series converge to π/4.
    have h_leibniz : Filter.Tendsto (fun k : ℕ => leibniz_partial_sum (2 * k)) Filter.atTop (nhds (Real.pi / 4)) := by
      have := @Real.tendsto_sum_pi_div_four;
      exact this.comp <| Filter.tendsto_id.nsmul_atTop two_pos;
    -- The terms of the Dirichlet series $\sum_{n=1}^{\infty} \frac{\chi_4(n)}{n}$ tend to 0.
    have h_terms_zero : Filter.Tendsto (fun n : ℕ => (χ₄_complex n) / (n : ℂ)) Filter.atTop (nhds 0) := by
      exact?;
    -- For any $n$, let $k = n / 4$. Then $4k \leq n < 4(k + 1)$.
    have h_partition : ∀ n : ℕ, chi4_partial_sum n = chi4_partial_sum (4 * (n / 4)) + ∑ i ∈ Finset.Ico (4 * (n / 4)) n, (χ₄_complex i : ℂ) / (i : ℂ) := by
      intro n; unfold chi4_partial_sum; rw [ Finset.sum_range_add_sum_Ico _ ( by linarith [ Nat.div_mul_le_self n 4 ] ) ] ;
    -- Since the terms of the Dirichlet series tend to 0, the difference between the partial sums and the limit tends to 0.
    have h_diff_zero : Filter.Tendsto (fun n : ℕ => ∑ i ∈ Finset.Ico (4 * (n / 4)) n, (χ₄_complex i : ℂ) / (i : ℂ)) Filter.atTop (nhds 0) := by
      have h_diff_zero : ∀ ε > 0, ∃ N : ℕ, ∀ n ≥ N, ∀ i ∈ Finset.Ico (4 * (n / 4)) n, ‖(χ₄_complex i : ℂ) / (i : ℂ)‖ < ε := by
        intro ε hε; have := Metric.tendsto_atTop.mp h_terms_zero ε hε; aesop;
        exact ⟨ w + 4, fun n hn i hi₁ hi₂ => h i ( by omega ) ⟩;
      rw [ Metric.tendsto_nhds ];
      intro ε hε; obtain ⟨ N, hN ⟩ := h_diff_zero ( ε / 4 ) ( by positivity ) ; refine' Filter.eventually_atTop.mpr ⟨ N + 4, fun n hn => _ ⟩ ; norm_num [ dist_eq_norm ];
      refine' lt_of_le_of_lt ( norm_sum_le _ _ ) _;
      refine' lt_of_le_of_lt ( Finset.sum_le_sum fun i hi => le_of_lt ( hN n ( by linarith ) i hi ) ) _ ; norm_num;
      exact lt_of_le_of_lt ( mul_le_mul_of_nonneg_right ( Nat.cast_le.mpr ( show n - 4 * ( n / 4 ) ≤ 3 by omega ) ) ( by positivity ) ) ( by norm_num; linarith );
    -- Since the partial sums of the Leibniz series converge to π/4, and the difference between the partial sums and the limit tends to 0, the partial sums of the Dirichlet series also converge to π/4.
    have h_converge : Filter.Tendsto (fun n : ℕ => chi4_partial_sum (4 * (n / 4))) Filter.atTop (nhds (Real.pi / 4)) := by
      have h_converge : Filter.Tendsto (fun k : ℕ => chi4_partial_sum (4 * k)) Filter.atTop (nhds (Real.pi / 4)) := by
        convert Complex.continuous_ofReal.continuousAt.tendsto.comp h_leibniz using 2 ; norm_num [ chi4_sum_eq_leibniz_sum ];
        norm_num;
      exact h_converge.comp <| Filter.tendsto_atTop_atTop.mpr fun k => ⟨ 4 * k, fun n hn => by linarith [ Nat.div_add_mod n 4, Nat.mod_lt n zero_lt_four ] ⟩;
    rw [ Filter.tendsto_congr h_partition ] ; simpa using h_converge.add h_diff_zero;