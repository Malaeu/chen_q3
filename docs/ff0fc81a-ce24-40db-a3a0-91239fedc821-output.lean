/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ff0fc81a-ce24-40db-a3a0-91239fedc821

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open BigOperators
open Finset

-- Dirichlet character mod 4
def χ₄ (n : ℤ) : ℤ :=
  if n % 2 = 0 then 0
  else if n % 4 = 1 then 1
  else -1

-- Exponential e(x) = exp(2πix)
noncomputable def e (x : ℝ) : ℂ := Complex.exp (2 * Real.pi * Complex.I * x)

-- Von Mangoldt
noncomputable def Λ : ℕ → ℝ := ArithmeticFunction.vonMangoldt

open scoped BigOperators



-- The weighted exponential sum
noncomputable def F (X : ℝ) (α : ℝ) : ℂ :=
  ∑ n ∈ Finset.range ⌊X⌋₊, (Λ n : ℂ) * (χ₄ n : ℂ) * e (n * α)

-- Dirichlet approximation: for any α, ∃ a/q with |α - a/q| < 1/(qQ)
def has_dirichlet_approx (α : ℝ) (Q : ℝ) (a q : ℕ) : Prop :=
  q ≤ Q ∧ Nat.Coprime a q ∧ |α - a/q| < 1/(q * Q)

-- Minor arc condition: α not close to simple rationals
def is_minor (α : ℝ) (X : ℝ) : Prop :=
  ∀ a q : ℕ, q ≤ Real.log X → |α - a/q| > 1/(q * X)

lemma minor_arc_large_q (X : ℝ) (α : ℝ) (hX : X > 100) (h_minor : is_minor α X) :
  ∀ a q : ℕ, has_dirichlet_approx α X a q → q > Real.log X := by
  -- By definition of `has_dirichlet_approx`, we know that $q \leq X$ and $|α - a/q| < 1/(qX)$. However, since $α$ is in the minor arc, we also have $|α - a/q| > 1/(q \log X)$ for all $a$ and $q$ with $q \leq \log X$. Therefore, $q$ must be greater than $\log X$ to avoid contradicting the minor arc condition.
  intros a q h_approx
  by_contra hq_le_logX;
  -- Apply the minor arc condition to the approximation given by h_approx.
  have h_contradiction : |α - a / q| > 1 / (q * X) := by
    -- Apply the minor arc condition with $q \leq \log X$ and $|α - a/q| < 1/(qX)$ to derive a contradiction.
    apply h_minor a q;
    linarith;
  exact h_contradiction.not_le h_approx.2.2.le

lemma chi4_bounded (n : ℕ) : |χ₄ n| ≤ 1 := by
  -- By definition of $χ₄$, we know that $|χ₄(n)| = 1$ for all $n$.
  simp [χ₄];
  -- By definition of absolute value, we know that |0| = 0, |1| = 1, and |-1| = 1.
  split_ifs <;> norm_num

def VinogradovEstimateProp : Prop :=
  ∀ (X : ℝ) (α : ℝ) (a q : ℕ) (β : ℝ),
    X > 100 → q ≥ 1 → Nat.Coprime a q → α = a/q + β → |β| < 1/(q * X) →
    ‖∑ p ∈ (Finset.filter Nat.Prime (Finset.range ⌊X⌋₊)), (Real.log p : ℂ) * e (p * α)‖ 
    ≤ X * (Real.log X)^4 * (1/Real.sqrt q + 1/Real.sqrt X + Real.sqrt q / X)

def VinogradovEstimateTwistedProp : Prop :=
  ∀ (X : ℝ) (α : ℝ) (a q : ℕ) (β : ℝ),
    X > 100 → q ≥ 1 → Nat.Coprime a q → α = a/q + β → |β| < 1/(q * X) →
    ‖∑ p ∈ (Finset.filter Nat.Prime (Finset.range ⌊X⌋₊)), (χ₄ p : ℂ) * (Real.log p : ℂ) * e (p * α)‖ 
    ≤ X * (Real.log X)^4 * (1/Real.sqrt q + 1/Real.sqrt X + Real.sqrt q / X)

lemma F_approx_sum_primes (X : ℝ) (α : ℝ) (hX : X > 100) :
  ‖F X α - ∑ p ∈ (Finset.filter Nat.Prime (Finset.range ⌊X⌋₊)), (χ₄ p : ℂ) * (Real.log p : ℂ) * e (p * α)‖
  ≤ 2 * Real.sqrt X * Real.log X := by
  -- The sum over non-primes is bounded by the sum of the von Mangoldt function over non-primes.
  have h_non_primes : ‖∑ n ∈ Finset.range ⌊X⌋₊ \ Finset.filter Nat.Prime (Finset.range ⌊X⌋₊), (χ₄ n : ℂ) * (Λ n) * e (n * α)‖ ≤ 2 * Real.sqrt X * Real.log X := by
    refine' le_trans ( norm_sum_le _ _ ) _;
    -- Since $\Lambda(n) \neq 0$ implies $n$ is a prime power, we can bound the sum by considering only prime powers.
    have h_prime_powers : ∑ n ∈ Finset.range ⌊X⌋₊ \ Finset.filter Nat.Prime (Finset.range ⌊X⌋₊), ‖(χ₄ n : ℂ) * (Λ n) * e (n * α)‖ ≤ ∑ p ∈ Finset.filter (fun p => Nat.Prime p ∧ ∃ k : ℕ, k ≥ 2 ∧ p^k < ⌊X⌋₊) (Finset.range ⌊X⌋₊), ∑ k ∈ Finset.Ico 2 (Nat.log p ⌊X⌋₊ + 1), Real.log p := by
      have h_prime_powers : Finset.filter (fun n => Λ n ≠ 0) (Finset.range ⌊X⌋₊ \ Finset.filter Nat.Prime (Finset.range ⌊X⌋₊)) ⊆ Finset.biUnion (Finset.filter (fun p => Nat.Prime p ∧ ∃ k : ℕ, k ≥ 2 ∧ p^k < ⌊X⌋₊) (Finset.range ⌊X⌋₊)) (fun p => Finset.image (fun k => p^k) (Finset.Ico 2 (Nat.log p ⌊X⌋₊ + 1))) := by
        intro n hn; simp_all +decide [ Finset.subset_iff ];
        -- Since $\Lambda(n) \neq 0$, $n$ must be a prime power.
        obtain ⟨p, k, hp, hk, rfl⟩ : ∃ p k : ℕ, Nat.Prime p ∧ k ≥ 1 ∧ n = p^k := by
          unfold Λ at hn; aesop;
          rw [ ArithmeticFunction.vonMangoldt ] at right ; aesop;
          rw [ isPrimePow_nat_iff ] at * ; aesop;
        refine' ⟨ p, ⟨ _, hp, k, _, _ ⟩, k, ⟨ _, _ ⟩, rfl ⟩ <;> aesop;
        · exact lt_of_le_of_lt ( Nat.le_self_pow ( by linarith ) _ ) left;
        · exact le_of_not_gt fun h => right_1 <| by interval_cases k ; aesop;
        · exact le_of_not_gt fun h => right_1 <| by interval_cases k ; aesop;
        · exact Nat.lt_succ_of_le ( Nat.le_log_of_pow_le hp.one_lt left.le );
      have h_prime_powers_sum : ∑ n ∈ Finset.filter (fun n => Λ n ≠ 0) (Finset.range ⌊X⌋₊ \ Finset.filter Nat.Prime (Finset.range ⌊X⌋₊)), ‖(χ₄ n : ℂ) * (Λ n) * e (n * α)‖ ≤ ∑ p ∈ Finset.filter (fun p => Nat.Prime p ∧ ∃ k : ℕ, k ≥ 2 ∧ p^k < ⌊X⌋₊) (Finset.range ⌊X⌋₊), ∑ k ∈ Finset.Ico 2 (Nat.log p ⌊X⌋₊ + 1), ‖(χ₄ (p^k) : ℂ) * (Λ (p^k)) * e ((p^k) * α)‖ := by
        refine' le_trans ( Finset.sum_le_sum_of_subset_of_nonneg h_prime_powers fun _ _ _ => norm_nonneg _ ) _;
        rw [ Finset.sum_biUnion ];
        · gcongr ; aesop;
          rw [ Finset.sum_image ] <;> aesop;
          exact fun a ha b hb hab => Nat.pow_right_injective left_1.one_lt hab;
        · intros p hp q hq hpq; simp_all +decide [ Finset.disjoint_left ];
          intro a x hx₁ hx₂ hx₃ y hy₁ hy₂ hy₃; subst_vars; have := Nat.Prime.dvd_of_dvd_pow hp.2.1 ( hy₃.symm ▸ dvd_pow_self _ ( by linarith ) ) ; simp_all +decide [ Nat.prime_dvd_prime_iff_eq ] ;
      refine le_trans ?_ ( h_prime_powers_sum.trans ?_ );
      · rw [ Finset.sum_filter_of_ne ] ; aesop;
      · gcongr ; aesop;
        -- Since $i$ is prime, we have $\Lambda(i^{i_1}) = \log(i)$.
        have h_lambda_prime_power : Λ (i ^ i_1) = Real.log i := by
          -- Since $i$ is prime, we have $\Lambda(i^{i_1}) = \log(i)$ by definition of the von Mangoldt function.
          have h_lambda_prime_power : ∀ p : ℕ, Nat.Prime p → ∀ k : ℕ, k ≥ 1 → Λ (p ^ k) = Real.log p := by
            intro p hp k hk; unfold Λ; aesop;
            rw [ ArithmeticFunction.vonMangoldt_apply ];
            rw [ if_pos ];
            · rw [ Nat.pow_minFac ] ; aesop;
              linarith;
            · exact hp.isPrimePow.pow ( by linarith );
          exact h_lambda_prime_power i left_2 i_1 ( by linarith );
        unfold e; norm_num [ Complex.norm_exp ] ; aesop;
        norm_cast ; aesop;
        rw [ abs_of_nonneg ( Real.log_nonneg ( mod_cast left_2.one_lt.le ) ) ];
        exact mul_le_of_le_one_left ( Real.log_nonneg ( mod_cast left_2.pos ) ) ( mod_cast abs_le.mpr ⟨ by unfold χ₄; split_ifs <;> norm_num, by unfold χ₄; split_ifs <;> norm_num ⟩ );
    -- The number of primes $p$ such that $p^2 \leq X$ is at most $\sqrt{X}$.
    have h_prime_count : Finset.card (Finset.filter (fun p => Nat.Prime p ∧ ∃ k : ℕ, k ≥ 2 ∧ p^k < ⌊X⌋₊) (Finset.range ⌊X⌋₊)) ≤ Real.sqrt X := by
      have h_prime_count : Finset.card (Finset.filter (fun p => Nat.Prime p ∧ ∃ k : ℕ, k ≥ 2 ∧ p^k < ⌊X⌋₊) (Finset.range ⌊X⌋₊)) ≤ Finset.card (Finset.filter (fun p => Nat.Prime p ∧ p^2 ≤ ⌊X⌋₊) (Finset.range ⌊X⌋₊)) := by
        refine Finset.card_mono ?_;
        intro p hp; aesop;
        exact le_trans ( pow_le_pow_right₀ left_1.one_lt.le left_2 ) right.le;
      have h_prime_count : Finset.card (Finset.filter (fun p => Nat.Prime p ∧ p^2 ≤ ⌊X⌋₊) (Finset.range ⌊X⌋₊)) ≤ Nat.sqrt ⌊X⌋₊ := by
        exact le_trans ( Finset.card_le_card <| show Finset.filter ( fun p => Nat.Prime p ∧ p ^ 2 ≤ ⌊X⌋₊ ) ( Finset.range ⌊X⌋₊ ) ⊆ Finset.Icc 1 ( Nat.sqrt ⌊X⌋₊ ) from fun p hp => Finset.mem_Icc.mpr ⟨ Nat.Prime.pos <| Finset.mem_filter.mp hp |>.2.1, by nlinarith only [ Finset.mem_filter.mp hp |>.2.2, Nat.lt_succ_sqrt ⌊X⌋₊ ] ⟩ ) <| by simp +decide ;
      refine le_trans ( Nat.cast_le.mpr <| le_trans ‹_› h_prime_count ) ?_;
      exact Real.le_sqrt_of_sq_le ( le_trans ( mod_cast Nat.sqrt_le' _ ) ( Nat.floor_le ( by positivity ) ) );
    -- The sum of the logarithms of the prime powers is at most $\sqrt{X} \cdot \log X$.
    have h_log_sum : ∑ p ∈ Finset.filter (fun p => Nat.Prime p ∧ ∃ k : ℕ, k ≥ 2 ∧ p^k < ⌊X⌋₊) (Finset.range ⌊X⌋₊), ∑ k ∈ Finset.Ico 2 (Nat.log p ⌊X⌋₊ + 1), Real.log p ≤ Real.sqrt X * Real.log X := by
      -- Since each term in the sum over primes is at most log X, and there are at most sqrt(X) primes, the total sum is at most sqrt(X) log X.
      have h_log_sum : ∀ p ∈ Finset.filter (fun p => Nat.Prime p ∧ ∃ k : ℕ, k ≥ 2 ∧ p^k < ⌊X⌋₊) (Finset.range ⌊X⌋₊), ∑ k ∈ Finset.Ico 2 (Nat.log p ⌊X⌋₊ + 1), Real.log p ≤ Real.log X := by
        aesop;
        rw [ ← Real.log_rpow ( Nat.cast_pos.mpr left_1.pos ) ];
        gcongr;
        · exact_mod_cast pow_pos left_1.pos _;
        · exact le_trans ( mod_cast Nat.pow_le_of_le_log ( by linarith ) ( Nat.sub_le _ _ ) ) ( Nat.floor_le ( by positivity ) );
      exact le_trans ( Finset.sum_le_sum h_log_sum ) ( by simpa [ mul_comm ] using mul_le_mul_of_nonneg_right h_prime_count <| Real.log_nonneg <| show 1 ≤ X by linarith );
    exact h_prime_powers.trans ( h_log_sum.trans ( mul_le_mul_of_nonneg_right ( le_mul_of_one_le_left ( Real.sqrt_nonneg _ ) ( by norm_num ) ) ( Real.log_nonneg ( by linarith ) ) ) );
  convert h_non_primes using 2;
  unfold F; rw [ ← Finset.sum_sdiff ( Finset.filter_subset Nat.Prime ( Finset.range ⌊X⌋₊ ) ) ] ; aesop;
  congr! 2;
  · ring;
  · unfold Λ; aesop;
    simp +decide [ right, ArithmeticFunction.vonMangoldt_apply_prime ]