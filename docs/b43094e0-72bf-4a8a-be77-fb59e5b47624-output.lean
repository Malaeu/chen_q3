/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b43094e0-72bf-4a8a-be77-fb59e5b47624
-/

/-
We have formalized and proved the Resonance Identity, Peak Value Formula, Peak Magnitude (conditional on PNT), Phase at Œ± = 1/4, and the Main Term Sign Corollary for the œá‚ÇÑ Circle Method.

The main results are:
- `resonance_identity`: œá‚ÇÑ(n) ¬∑ e(n/4) = i for odd n.
- `peak_value_formula_exact`: F(1/4) = i ¬∑ (Œ∏(X) - log 2).
- `peak_magnitude`: |F(1/4)| = X + O(X/log X) (assuming PNT).
- `phase_at_quarter`: e(-1/2) = -1.
- `main_term_sign`: The contribution from Œ± = 1/4 is negative.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions of e(x), œá‚ÇÑ(n), F(Œ±), and Theorem 1 (Resonance Identity).
-/
open Real Complex BigOperators Nat
open scoped Real BigOperators

noncomputable def e (x : ‚Ñù) : ‚ÑÇ := exp (2 * œÄ * I * x)

noncomputable def chi4 (n : ‚Ñï) : ‚ÑÇ := (ZMod.œá‚ÇÑ (n : ZMod 4) : ‚Ñ§)

noncomputable def F (X : ‚Ñï) (Œ± : ‚Ñù) : ‚ÑÇ :=
  ‚àë p ‚àà (Finset.range (X + 1)).filter (fun n => n.Prime ‚àß Odd n),
    (Real.log p : ‚ÑÇ) * chi4 p * e (p * Œ±)

theorem resonance_identity (n : ‚Ñï) (h : Odd n) : chi4 n * e (n / 4) = I := by
  obtain ‚ü® k, rfl ‚ü© : ‚àÉ k, n = 2 * k + 1 := h;
  unfold chi4 e;
  rcases Nat.even_or_odd' k with ‚ü® k, rfl | rfl ‚ü© <;> norm_num [ Nat.add_mod, Nat.mul_mod, ZMod.œá‚ÇÑ ] <;> ring_nf <;> norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im ] at *;
  ¬∑ norm_num [ mul_assoc, mul_comm Real.pi _, mul_div ];
    norm_num [ show 1 / 2 * Real.pi = Real.pi / 2 by ring ];
    bound;
  ¬∑ erw [ show Real.pi * ( 3 / 2 ) = Real.pi / 2 + Real.pi by ring ] ; norm_num [ mul_assoc, mul_comm Real.pi ];
    norm_cast;
    aesop

/-
Definition of Chebyshev functions Œ∏(X) and œà(X), and the exact formula for F(1/4) in terms of Œ∏(X).
-/
noncomputable def theta (X : ‚Ñï) : ‚Ñù :=
  ‚àë p ‚àà (Finset.range (X + 1)).filter (fun n => n.Prime), Real.log p

noncomputable def psi (X : ‚Ñï) : ‚Ñù :=
  ‚àë n ‚àà Finset.range (X + 1), ArithmeticFunction.vonMangoldt n

theorem peak_value_formula_exact (X : ‚Ñï) (hX : X ‚â• 2) :
  F X (1/4) = I * (theta X - Real.log 2) := by
  -- Applying the resonance identity to each term in the sum, we get:
  have h_sum_res : ‚àë p ‚àà Finset.filter (fun n => n.Prime ‚àß Odd n) (Finset.range (X + 1)), (Real.log p) * chi4 p * (e (p / 4)) = ‚àë p ‚àà Finset.filter (fun n => n.Prime ‚àß n > 2) (Finset.range (X + 1)), (Real.log p) * Complex.I := by
    refine' Finset.sum_bij ( fun p hp => p ) _ _ _ _ <;> aesop;
    ¬∑ exact lt_of_le_of_ne left_1.two_le ( by rintro rfl; contradiction );
    ¬∑ exact left_1.odd_of_ne_two right.ne';
    ¬∑ have := resonance_identity a right; simp_all +decide [ mul_assoc, mul_left_comm ] ;
  unfold F theta; convert h_sum_res using 1;
  ¬∑ norm_num [ div_eq_mul_inv ];
  ¬∑ rw [ show ( Finset.filter ( fun p => Nat.Prime p ‚àß p > 2 ) ( Finset.range ( X + 1 ) ) ) = Finset.filter ( fun p => Nat.Prime p ) ( Finset.range ( X + 1 ) ) \ { 2 } from ?_ ];
    ¬∑ rw [ Finset.sum_eq_sum_diff_singleton_add <| show 2 ‚àà Finset.filter ( fun p => Nat.Prime p ) ( Finset.range ( X + 1 ) ) from Finset.mem_filter.mpr ‚ü® Finset.mem_range.mpr <| by linarith, by norm_num ‚ü© ] ; norm_num [ mul_comm, Finset.sum_mul _ _ _ ];
      rw [ Finset.mul_sum _ _ _ ];
    ¬∑ ext; aesop;
      exact lt_of_le_of_ne right_1.two_le ( Ne.symm right )

/-
Theorem 4: Phase at Œ± = 1/4.
-/
theorem phase_at_quarter : e (-1/2) = -1 := by
  unfold e;
  norm_num [ mul_div, Complex.ext_iff, Complex.exp_re, Complex.exp_im ]

/-
Corollary: Main Term Sign. The contribution from Œ± = 1/4 is negative.
-/
theorem main_term_sign (X : ‚Ñï) :
  Complex.normSq (F X (1/4)) * e (-1/2) = - (Complex.normSq (F X (1/4))) := by
  rw [ phase_at_quarter ] ; norm_num [ Complex.ext_iff ]

/-
Weak bound on the difference between Chebyshev functions: œà(n) - Œ∏(n) = O(‚àön log n).
-/
open Filter Asymptotics Topology Nat

lemma psi_sub_theta_bound_weak : (fun n => psi n - theta n) =O[atTop] (fun n => Real.sqrt n * Real.log n) := by
  -- We will show that the difference œà(n) - Œ∏(n) is bounded above by a constant multiple of ‚àön log n.
  have h_bound : ‚àÄ n : ‚Ñï, n ‚â• 1 ‚Üí psi n - theta n ‚â§ Real.sqrt n * Real.log n := by
    -- We'll use that œà(n) - Œ∏(n) is equal to the sum of log p over primes p such that p^k ‚â§ n for some k ‚â• 2.
    have h_sum : ‚àÄ n : ‚Ñï, n ‚â• 1 ‚Üí psi n - theta n = ‚àë p ‚àà Finset.filter (fun p => Nat.Prime p) (Finset.range (n + 1)), (‚àë k ‚àà Finset.Ico 2 (Nat.log p n + 1), Real.log p) := by
      intro n hn
      have h_split : psi n = ‚àë p ‚àà Finset.filter (fun p => Nat.Prime p) (Finset.range (n + 1)), (‚àë k ‚àà Finset.Ico 1 (Nat.log p n + 1), Real.log p) := by
        unfold psi;
        -- By definition of von Mangoldt function, we can rewrite the sum as a double sum over primes and their powers.
        have h_double_sum : ‚àë n ‚àà Finset.range (n + 1), (ArithmeticFunction.vonMangoldt n) = ‚àë p ‚àà Finset.filter (fun p => Nat.Prime p) (Finset.range (n + 1)), ‚àë k ‚àà Finset.Ico 1 (Nat.log p n + 1), (ArithmeticFunction.vonMangoldt (p ^ k)) := by
          have h_double_sum : Finset.filter (fun n => ‚àÉ p k, Nat.Prime p ‚àß k ‚â• 1 ‚àß n = p ^ k ‚àß n ‚â§ n) (Finset.range (n + 1)) = Finset.biUnion (Finset.filter (fun p => Nat.Prime p) (Finset.range (n + 1))) (fun p => Finset.image (fun k => p ^ k) (Finset.Ico 1 (Nat.log p n + 1))) := by
            ext; aesop;
            ¬∑ exact ‚ü® w, ‚ü® by linarith [ Nat.le_self_pow ( by linarith ) w ], left_1 ‚ü©, w_1, ‚ü® left_2, Nat.lt_succ_of_le ( Nat.le_log_of_pow_le left_1.one_lt ( by linarith ) ) ‚ü©, rfl ‚ü©;
            ¬∑ exact Nat.lt_succ_of_le ( Nat.pow_le_of_le_log ( by linarith ) ( by linarith ) );
            ¬∑ exact ‚ü® w, right_1, w_1, left_1, rfl ‚ü©;
          have h_double_sum : ‚àë n ‚àà Finset.range (n + 1), (ArithmeticFunction.vonMangoldt n) = ‚àë n ‚àà Finset.filter (fun n => ‚àÉ p k, Nat.Prime p ‚àß k ‚â• 1 ‚àß n = p ^ k ‚àß n ‚â§ n) (Finset.range (n + 1)), (ArithmeticFunction.vonMangoldt n) := by
            rw [ Finset.sum_filter_of_ne ] ; aesop;
            rw [ ArithmeticFunction.vonMangoldt ] at a_1 ; aesop;
            rw [ isPrimePow_nat_iff ] at left ; aesop;
          aesop;
          rw [ Finset.sum_biUnion ];
          ¬∑ exact Finset.sum_congr rfl fun p hp => Finset.sum_image <| fun a ha b hb h => Nat.pow_right_injective ( Nat.Prime.one_lt <| Finset.mem_filter.mp hp |>.2 ) h;
          ¬∑ intros p hp q hq hpq; simp_all +decide [ Finset.disjoint_left ];
            intro a x hx‚ÇÅ hx‚ÇÇ hx‚ÇÉ y hy‚ÇÅ hy‚ÇÇ hy‚ÇÉ; subst_vars; have := Nat.Prime.dvd_of_dvd_pow hp.2 ( hy‚ÇÉ.symm ‚ñ∏ dvd_pow_self _ ( by linarith ) ) ; simp_all +decide [ Nat.prime_dvd_prime_iff_eq ] ;
        simp_all +decide [ ArithmeticFunction.vonMangoldt ];
        rw [ Finset.sum_congr rfl ] ; aesop;
        rw [ Finset.sum_congr rfl fun i hi => if_pos <| ?_ ];
        ¬∑ rw [ Finset.sum_congr rfl fun i hi => by rw [ Nat.pow_minFac ] ; aesop ] ; aesop;
        ¬∑ exact right.isPrimePow.pow ( by linarith [ Finset.mem_Ico.mp hi ] );
      unfold theta; aesop;
      rw [ ‚Üê Finset.sum_sub_distrib ] ; refine' Finset.sum_congr rfl fun x hx => _ ; rw [ Nat.cast_sub <| Nat.succ_le_of_lt <| Nat.log_pos ( Nat.Prime.one_lt <| Finset.mem_filter.mp hx |>.2 ) <| by linarith [ Finset.mem_range.mp <| Finset.mem_filter.mp hx |>.1 ] ] ; simp +decide [ sub_mul ] ;
    -- Let's simplify the expression inside the sum.
    suffices h_inner : ‚àÄ n : ‚Ñï, n ‚â• 1 ‚Üí ‚àë p ‚àà Finset.filter (fun p => Nat.Prime p) (Finset.range (n + 1)), (‚àë k ‚àà Finset.Ico 2 (Nat.log p n + 1), Real.log p) ‚â§ ‚àë p ‚àà Finset.filter (fun p => Nat.Prime p) (Finset.range (Nat.sqrt n + 1)), (Real.log n) by
      intro n hn; rw [ h_sum n hn ] ; specialize h_inner n hn; aesop;
      refine le_trans h_inner ?_;
      gcongr;
      refine' le_trans ( Nat.cast_le.mpr <| Finset.card_le_card <| show Finset.filter ( fun p => Nat.Prime p ) ( Finset.range ( Nat.sqrt n + 1 ) ) ‚äÜ Finset.Icc 1 ( Nat.sqrt n ) from fun p hp => Finset.mem_Icc.mpr ‚ü® Nat.pos_of_ne_zero <| Nat.Prime.ne_zero <| Finset.mem_filter.mp hp |>.2, Nat.le_of_lt_succ <| Finset.mem_range.mp <| Finset.mem_filter.mp hp |>.1 ‚ü© ) _ ; norm_num;
      exact Real.le_sqrt_of_sq_le ( mod_cast Nat.sqrt_le' _ );
    intros n hn
    have h_inner : ‚àÄ p ‚àà Finset.filter (fun p => Nat.Prime p) (Finset.range (n + 1)), (‚àë k ‚àà Finset.Ico 2 (Nat.log p n + 1), Real.log p) ‚â§ if p ‚â§ Nat.sqrt n then Real.log n else 0 := by
      intro p hp; split_ifs <;> simp_all +decide [ Nat.le_sqrt ];
      ¬∑ rw [ ‚Üê Real.log_pow ];
        exact Real.log_le_log ( pow_pos ( Nat.cast_pos.mpr hp.2.pos ) _ ) ( mod_cast Nat.pow_le_of_le_log ( by linarith ) ( by omega ) );
      ¬∑ rw [ Nat.sub_eq_zero_of_le ( Nat.le_of_lt_succ <| Nat.log_lt_of_lt_pow ( by linarith ) <| by nlinarith ) ] ; norm_num;
    refine le_trans ( Finset.sum_le_sum h_inner ) ?_ ; aesop;
    norm_num [ Finset.sum_ite ];
    exact mul_le_mul_of_nonneg_right ( mod_cast Finset.card_mono <| fun x hx => by aesop ; nlinarith [ Nat.sqrt_le n ] ) <| Real.log_nonneg <| mod_cast hn;
  rw [ Asymptotics.isBigO_iff ];
  use 1; refine' Filter.eventually_atTop.mpr ‚ü® 1, fun n hn => _ ‚ü© ; aesop;
  rw [ abs_of_nonneg ( Real.sqrt_nonneg _ ), abs_of_nonneg ( Real.log_nonneg ( by norm_cast ) ) ];
  rw [ abs_of_nonneg ] <;> norm_num [ psi, theta ];
  ¬∑ convert h_bound n hn using 1;
  ¬∑ rw [ Finset.sum_filter ];
    gcongr ; aesop;
    rw [ ArithmeticFunction.vonMangoldt_apply_prime h ]

/-
Lemma: ‚àön log n = O(n / log n).
-/
open Filter Asymptotics Topology

lemma sqrt_mul_log_isBigO_div_log : (fun n => Real.sqrt n * Real.log n) =O[atTop] (fun n => n / Real.log n) := by
  -- We show that $(\log n)^2 = O(\sqrt{n})$ by using the fact that $\log n = o(\sqrt{n})$.
  have h_log_sqrt : (fun n => (Real.log n)^2) =o[Filter.atTop] (fun n => Real.sqrt n) := by
    -- Let $y = \log n$, therefore the expression becomes $y^2 = o(e^{y/2})$.
    suffices h_log : (fun y => y^2) =o[Filter.atTop] (fun y => Real.exp (y / 2)) by
      have := h_log.comp_tendsto ( Real.tendsto_log_atTop );
      refine' this.congr' _ _ <;> norm_num [ Function.comp, Real.sqrt_eq_rpow, Real.rpow_def_of_pos ];
      ¬∑ filter_upwards [ Filter.eventually_gt_atTop 0 ] with n hn using rfl;
      ¬∑ filter_upwards [ Filter.eventually_gt_atTop 0 ] with x hx using by rw [ Function.comp_apply, Real.rpow_def_of_pos hx ] ; ring;
    rw [ Asymptotics.isLittleO_iff_tendsto' ] <;> norm_num;
    -- Let $y = \frac{x}{2}$, therefore the expression becomes $\frac{(2y)^2}{e^y} = \frac{4y^2}{e^y}$.
    suffices h_y : Filter.Tendsto (fun y => 4 * y^2 / Real.exp y) Filter.atTop (ùìù 0) by
      convert h_y.comp ( Filter.tendsto_id.atTop_mul_const ( by norm_num : 0 < ( 2‚Åª¬π : ‚Ñù ) ) ) using 2 ; norm_num ; ring;
    simpa [ Real.exp_neg, mul_div_assoc ] using Real.tendsto_pow_mul_exp_neg_atTop_nhds_zero 2 |> Filter.Tendsto.const_mul 4;
  rw [ Asymptotics.isLittleO_iff ] at h_log_sqrt;
  rw [ Asymptotics.isBigO_iff' ];
  refine' ‚ü® 1, by norm_num, _ ‚ü© ; filter_upwards [ h_log_sqrt zero_lt_one, Filter.eventually_gt_atTop 1 ] with x hx‚ÇÅ hx‚ÇÇ ; norm_num [ abs_of_pos, hx‚ÇÇ.le, Real.sqrt_nonneg ] at *;
  rw [ le_div_iff‚ÇÄ ( abs_pos.mpr ( ne_of_gt ( Real.log_pos hx‚ÇÇ ) ) ) ];
  rw [ abs_of_nonneg ( Real.sqrt_nonneg x ), abs_of_nonneg ( Real.log_nonneg hx‚ÇÇ.le ), abs_of_nonneg ( by positivity : 0 ‚â§ x ) ] at * ; nlinarith [ Real.mul_self_sqrt ( show 0 ‚â§ x by positivity ), Real.log_nonneg hx‚ÇÇ.le ]

/-
Nat version of sqrt_mul_log_isBigO_div_log.
-/
open Filter Asymptotics Topology

lemma sqrt_mul_log_isBigO_div_log_nat : (fun n : ‚Ñï => Real.sqrt n * Real.log n) =O[atTop] (fun n => (n : ‚Ñù) / Real.log n) := by
  exact ( sqrt_mul_log_isBigO_div_log.comp_tendsto tendsto_natCast_atTop_atTop )

/-
Lemma: log 2 = O(X / log X).
-/
open Filter Asymptotics Topology

lemma log_two_isBigO : (fun X : ‚Ñï => Real.log 2) =O[atTop] (fun X => (X : ‚Ñù) / Real.log X) := by
  -- Since $X / \log X$ tends to infinity as $X$ goes to infinity, we can find an $N$ such that for all $X \geq N$, $X / \log X > \log 2$.
  have h_inf : Filter.Tendsto (fun X : ‚Ñï => (X : ‚Ñù) / Real.log X) Filter.atTop Filter.atTop := by
    -- We can use the change of variables $u = \log X$ to transform the limit expression.
    suffices h_log : Filter.Tendsto (fun u : ‚Ñù => Real.exp u / u) Filter.atTop Filter.atTop by
      have := h_log.comp Real.tendsto_log_atTop;
      exact this.comp tendsto_natCast_atTop_atTop |> Filter.Tendsto.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with x hx using by simp +decide [ Real.exp_log ( Nat.cast_pos.mpr hx ) ] );
    simpa using Real.tendsto_exp_div_pow_atTop 1;
  rw [ Asymptotics.isBigO_iff ];
  exact ‚ü® 1, by filter_upwards [ h_inf.eventually_gt_atTop ( Real.log 2 ) ] with x hx using by rw [ Real.norm_of_nonneg ( Real.log_nonneg one_le_two ) ] ; rw [ Real.norm_of_nonneg ( by positivity ) ] ; linarith ‚ü©

/-
Lemma: The norm of a real number viewed as a complex number is its absolute value.
-/
open Filter Asymptotics Topology Complex

lemma norm_of_real (r : ‚Ñù) : ‚Äñ(r : ‚ÑÇ)‚Äñ = |r| := by
  bound

/-
Theorem 3: Peak Magnitude (conditional on PNT). Assuming œà(X) - X = O(X/log X), then |F(1/4)| - X = O(X/log X).
-/
open Filter Asymptotics Topology Complex

theorem peak_magnitude (hPNT : (fun n => psi n - n) =O[atTop] (fun n => (n : ‚Ñù) / Real.log n)) :
  (fun X => ‚ÄñF X (1/4)‚Äñ - (X : ‚Ñù)) =O[atTop] (fun X => (X : ‚Ñù) / Real.log X) := by
  have h_theta_psi : (fun n => theta n - psi n) =O[atTop] (fun n => (n : ‚Ñù) / Real.log n) := by
    have h_bound : (fun n => psi n - theta n) =O[Filter.atTop] (fun n => (n : ‚Ñù) / Real.log n) := by
      -- By transitivity of the big O notation, if $f = O(g)$ and $g = O(h)$, then $f = O(h)$.
      apply Asymptotics.IsBigO.trans (psi_sub_theta_bound_weak) (sqrt_mul_log_isBigO_div_log_nat);
    exact?
  have h_theta_sub_id : (fun n => theta n - n) =O[atTop] (fun n => (n : ‚Ñù) / Real.log n) := by
    simpa using h_theta_psi.add hPNT
  have h_F_abs : (fun X => ‚ÄñF X (1/4)‚Äñ - (X : ‚Ñù)) =·∂†[atTop] (fun X => theta X - Real.log 2 - X) := by
    -- By Theorem 1, we know that for $X \geq 2$, $F_X(1/4) = i \cdot (\theta(X) - \ln 2)$.
    have h_F_eq : ‚àÄ X : ‚Ñï, X ‚â• 2 ‚Üí F X (1 / 4) = Complex.I * (theta X - Real.log 2) := by
      exact?;
    filter_upwards [ Filter.eventually_ge_atTop 2 ] with X hX ; aesop;
    norm_num [ Complex.normSq, Complex.norm_def, Complex.log_re, Complex.log_im ];
    rw [ Real.sqrt_mul_self ( sub_nonneg.mpr _ ) ];
    exact le_trans ( by norm_num [ Real.log_le_iff_le_exp ] ) ( Finset.single_le_sum ( fun x _ => Real.log_nonneg <| Nat.one_le_cast.2 <| Nat.Prime.pos <| by aesop ) <| show 2 ‚àà Finset.filter ( fun n => n.Prime ) ( Finset.range ( X + 1 ) ) from Finset.mem_filter.2 ‚ü® Finset.mem_range.2 <| by linarith, by norm_num ‚ü© )
  refine (isBigO_congr h_F_abs EventuallyEq.rfl).mpr ?_
  rw [show (fun X => theta X - Real.log 2 - X) = (fun X => (theta X - X) - Real.log 2) by ext; ring]
  apply IsBigO.sub
  ¬∑ exact h_theta_sub_id
  ¬∑ exact log_two_isBigO