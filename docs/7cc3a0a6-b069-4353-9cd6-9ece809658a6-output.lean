/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7cc3a0a6-b069-4353-9cd6-9ece809658a6

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions of the character œá‚ÇÑ and the exponential function e(x).
-/
open Complex Real

noncomputable def œá‚ÇÑ (n : ‚Ñ§) : ‚ÑÇ := ZMod.œá‚ÇÑ (n : ZMod 4)

noncomputable def e (x : ‚Ñù) : ‚ÑÇ := cexp (2 * œÄ * I * x)

/-
Definition of l2 space and ket vectors.
-/
open Complex Real ENNReal

abbrev l2 := lp (fun _ : ‚Ñï => ‚ÑÇ) 2

def ket (n : ‚Ñï) : l2 := lp.single 2 n 1

/-
The underlying function of the Fourier operator.
-/
def F_fun (Œ± : ‚Ñù) (f : l2) : ‚Ñï ‚Üí ‚ÑÇ := fun n => e (n * Œ±) * f n

/-
Proof that the Fourier transformed sequence is in l2.
-/
theorem F_mem_l2 (Œ± : ‚Ñù) (f : l2) : Mem‚Ñìp (F_fun Œ± f) 2 := by
  unfold F_fun;
  have h_abs : ‚àÄ n : ‚Ñï, ‚Äñe (n * Œ±) * f.val n‚Äñ = ‚Äñf.val n‚Äñ := by
    norm_num [ e, Complex.norm_exp ];
  simp_all +decide [ Mem‚Ñìp ];
  have := f.2.summable;
  aesop

/-
Linear map corresponding to the Fourier operator.
-/
def F_lin (Œ± : ‚Ñù) : l2 ‚Üí‚Çó[‚ÑÇ] l2 where
  toFun f := ‚ü®F_fun Œ± f, F_mem_l2 Œ± f‚ü©
  map_add' f g := by
    ext n; unfold F_fun; simp +decide ; ring;
  map_smul' c f := by
    ext
    generalize_proofs at *;
    unfold F_fun; norm_num; ring

/-
Definition of Fourier operator F_op as a continuous linear map.
-/
def F_op (Œ± : ‚Ñù) : l2 ‚ÜíL[‚ÑÇ] l2 :=
  LinearMap.mkContinuous
    (F_lin Œ±)
    1
    (by
    simp [F_lin, F_fun];
    simp [F_fun, lp.norm_eq_tsum_rpow];
    norm_num [ e, Complex.norm_exp ])

/-
The underlying function of the Shift operator.
-/
def U_fun (h : ‚Ñï) (f : l2) : ‚Ñï ‚Üí ‚ÑÇ := fun n => if n < h then 0 else f (n - h)

/-
Proof that the shifted sequence is in l2.
-/
theorem U_mem_l2 (h : ‚Ñï) (f : l2) : Mem‚Ñìp (U_fun h f) 2 := by
  have h_summable : Summable (fun n => ‚Äñ(U_fun h f) n‚Äñ ^ 2) := by
    have h_summable : Summable (fun n => ‚Äñf n‚Äñ ^ 2) := by
      simpa using f.2.summable;
    rw [ ‚Üê summable_nat_add_iff h ];
    unfold U_fun; aesop;
  simp_all +decide [ Mem‚Ñìp ]

/-
Linear map corresponding to the Shift operator.
-/
def U_lin (h : ‚Ñï) : l2 ‚Üí‚Çó[‚ÑÇ] l2 where
  toFun f := ‚ü®U_fun h f, U_mem_l2 h f‚ü©
  map_add' f g := by
    ext n ; aesop;
    unfold U_fun;
    aesop
  map_smul' c f := by
    ext1; aesop;
    -- By definition of $U_fun$, we can expand both sides.
    funext n; simp [U_fun]

/-
Definition of Shift operator U_op as a continuous linear map.
-/
def U_op (h : ‚Ñï) : l2 ‚ÜíL[‚ÑÇ] l2 :=
  LinearMap.mkContinuous
    (U_lin h)
    1
    (by
    intro x;
    simp +decide [U_lin, U_fun, lp.norm_eq_tsum_rpow];
    rw [ ‚Üê Summable.sum_add_tsum_nat_add h ];
    ¬∑ norm_num [ Finset.sum_range, Nat.lt_succ_iff ];
    ¬∑ have := x.2.summable;
      rw [ ‚Üê summable_nat_add_iff h ] ; aesop)

/-
Check if ContinuousLinearMap has a LieRing instance.
-/
#synth LieRing (l2 ‚ÜíL[‚ÑÇ] l2)

/-
Check if commutator is already defined.
-/
#check commutator

/-
Definition of the commutator of two operators.
-/
def op_commutator (A B : l2 ‚ÜíL[‚ÑÇ] l2) : l2 ‚ÜíL[‚ÑÇ] l2 := A * B - B * A

/-
Check the type of the von Mangoldt function.
-/
#check ArithmeticFunction.vonMangoldt

/-
Definition of the heavy vector g_œá.
-/
open ArithmeticFunction

noncomputable def g_œá (N : ‚Ñï) : l2 :=
  ‚àë n ‚àà Finset.range (N + 1), (vonMangoldt n : ‚ÑÇ) ‚Ä¢ œá‚ÇÑ n ‚Ä¢ ket n

/-
Definitions of the twin sum S‚ÇÇ and the character twisted sum T_œá.
-/
noncomputable def S‚ÇÇ (X : ‚Ñï) : ‚Ñù :=
  ‚àë n ‚àà Finset.range (X + 1), vonMangoldt n * vonMangoldt (n + 2)

noncomputable def T_œá (X : ‚Ñï) : ‚ÑÇ :=
  ‚àë n ‚àà Finset.range (X + 1), (vonMangoldt n : ‚ÑÇ) * œá‚ÇÑ n * (vonMangoldt (n + 2) : ‚ÑÇ) * œá‚ÇÑ (n + 2)

/-
Theorem 1: Golden Bridge Identity. For all odd integers n, œá‚ÇÑ(n) ¬∑ e(n/4) = i.
-/
theorem golden_bridge_identity (n : ‚Ñ§) (h : n % 2 ‚â† 0) :
    œá‚ÇÑ n * e (n / 4) = I := by
      -- Since $n$ is odd, we can write $n = 4k + 1$ or $n = 4k + 3$ for some integer $k$.
      obtain ‚ü®k, rfl | rfl‚ü© : ‚àÉ k : ‚Ñ§, n = 4 * k + 1 ‚à® n = 4 * k + 3 := by
        exact ‚ü® n / 4, by omega ‚ü©;
      ¬∑ unfold œá‚ÇÑ e;
        norm_num [ ZMod.œá‚ÇÑ, mul_add, add_div, mul_div_cancel_left‚ÇÄ ];
        erw [ show ( 4 : ZMod 4 ) = 0 by rfl ] ; norm_num ; ring_nf ; norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im, mul_div ] ;
        norm_num [ mul_assoc, mul_comm Real.pi ];
      ¬∑ unfold œá‚ÇÑ e; norm_num [ Int.add_emod, Int.mul_emod ];
        erw [ show ( 4 : ZMod 4 ) = 0 by rfl ] ; ring_nf ; norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im ];
        norm_num [ mul_assoc, mul_comm Real.pi _, mul_div ];
        norm_num [ show 3 / 2 * Real.pi = Real.pi + Real.pi / 2 by ring, Real.cos_add, Real.sin_add ];
        norm_cast

/-
Theorem 2: AFM Structure (Protection). For all twin primes (p, p+2) with p > 2, œá‚ÇÑ(p) ¬∑ œá‚ÇÑ(p+2) = -1.
-/
theorem afm_structure (p : ‚Ñï) (hp : p.Prime) (hp2 : (p + 2).Prime) (h_gt_2 : p > 2) :
    œá‚ÇÑ p * œá‚ÇÑ (p + 2) = -1 := by
      cases Nat.Prime.eq_two_or_odd hp <;> simp_all ( config := { decide := Bool.true } ) [ Nat.add_mod ];
      unfold œá‚ÇÑ; norm_cast; aesop;
      ¬∑ rw [ ZMod.natCast_zmod_eq_zero_iff_dvd ] at heq ; have := Nat.dvd_trans ( by decide : 2 ‚à£ 4 ) heq ; simp_all ( config := { decide := Bool.true } ) [ Nat.prime_dvd_prime_iff_eq ];
      ¬∑ erw [ ZMod.eq_iff_modEq_nat ] at heq ; norm_num [ Nat.ModEq, Nat.add_mod ] at heq ; omega

/-
Cancellation lemma: for twin primes > 2, the terms in T_œá and S‚ÇÇ cancel out.
-/
theorem cancellation_on_twins (n : ‚Ñï) (h_gt_2 : 2 < n) (hp : n.Prime) (hp2 : (n + 2).Prime) :
    (vonMangoldt n : ‚ÑÇ) * œá‚ÇÑ n * (vonMangoldt (n + 2) : ‚ÑÇ) * œá‚ÇÑ (n + 2) +
    (vonMangoldt n : ‚ÑÇ) * (vonMangoldt (n + 2) : ‚ÑÇ) = 0 := by
      have h_term : œá‚ÇÑ n * œá‚ÇÑ (n + 2) = -1 := by
        exact?;
      linear_combination' h_term * ( Œõ n : ‚ÑÇ ) * ( Œõ ( n + 2 ) : ‚ÑÇ )

/-
A number is a proper prime power if it is a prime power but not prime (i.e., exponent >= 2).
-/
def is_proper_prime_power (n : ‚Ñï) : Prop := IsPrimePow n ‚àß ¬¨ n.Prime

/-
Characterization of proper prime powers.
-/
lemma proper_prime_power_iff (n : ‚Ñï) :
    is_proper_prime_power n ‚Üî ‚àÉ p k, Nat.Prime p ‚àß 2 ‚â§ k ‚àß n = p ^ k := by
      bound;
      ¬∑ rcases a with ‚ü® h‚ÇÅ, h‚ÇÇ ‚ü©;
        rw [ isPrimePow_nat_iff ] at h‚ÇÅ ; aesop;
        exact ‚ü® w, left, w_1, Nat.one_lt_iff_ne_zero_and_ne_one.mpr ‚ü® left_1.ne', by aesop_cat ‚ü©, rfl ‚ü©;
      ¬∑ unfold is_proper_prime_power; aesop;
        ¬∑ exact left.isPrimePow.pow ( by linarith );
        ¬∑ rw [ Nat.prime_iff ] at a ; aesop

/-
The number of proper prime powers up to X is O(‚àöX).
-/
open Asymptotics Filter

theorem count_proper_prime_powers_bound :
    (fun X => (((Finset.range (X + 1)).filter is_proper_prime_power).card : ‚Ñù)) =O[atTop] (fun X => Real.sqrt (X : ‚Ñù)) := by
      refine' Asymptotics.isBigO_iff.mpr _;
      use 2 * Real.sqrt 2 + 1;
      -- We'll use that the number of proper prime powers up to $X$ is bounded by the sum of $X^{1/k}$ for $k \geq 2$.
      have h_bound : ‚àÄ X : ‚Ñï, (Finset.filter is_proper_prime_power (Finset.range (X + 1))).card ‚â§ ‚àë k ‚àà Finset.Icc 2 (Nat.log 2 X + 1), Nat.floor (Real.rpow X (1 / k : ‚Ñù)) := by
        -- Each proper prime power $n$ up to $X$ can be written as $p^k$ for some prime $p$ and integer $k \geq 2$.
        intro X
        have h_count : Finset.filter is_proper_prime_power (Finset.range (X + 1)) ‚äÜ Finset.biUnion (Finset.Icc 2 (Nat.log 2 X + 1)) (fun k => Finset.image (fun p => p^k) (Finset.filter Nat.Prime (Finset.range (Nat.floor (Real.rpow X (1 / k : ‚Ñù)) + 1)))) := by
          intro n hn; aesop;
          obtain ‚ü® p, k, hp, hk, rfl ‚ü© := proper_prime_power_iff n |>.1 right;
          refine' ‚ü® k, ‚ü® hk, _ ‚ü©, p, ‚ü® _, hp ‚ü©, rfl ‚ü©;
          ¬∑ exact Nat.le_succ_of_le ( Nat.le_log_of_pow_le ( by norm_num ) ( by linarith [ Nat.pow_le_pow_left hp.two_le k ] ) );
          ¬∑ refine' Nat.lt_succ_of_le ( Nat.le_floor _ );
            rw [ Real.le_rpow_inv_iff_of_pos ] <;> norm_cast <;> linarith [ pow_pos hp.pos k ];
        refine le_trans ( Finset.card_le_card h_count ) ?_;
        refine' le_trans ( Finset.card_biUnion_le ) _;
        exact Finset.sum_le_sum fun k hk => le_trans ( Finset.card_image_le ) ( by simpa using Finset.card_le_card ( show Finset.filter Nat.Prime ( Finset.range ( ‚åä ( X : ‚Ñù ) ^ ( k : ‚Ñù ) ‚Åª¬π‚åã‚Çä + 1 ) ) ‚äÜ Finset.Ico 2 ( ‚åä ( X : ‚Ñù ) ^ ( k : ‚Ñù ) ‚Åª¬π‚åã‚Çä + 1 ) from fun p hp => Finset.mem_Ico.mpr ‚ü® Nat.Prime.two_le ( Finset.mem_filter.mp hp |>.2 ), Finset.mem_range.mp ( Finset.mem_filter.mp hp |>.1 ) ‚ü© ) |> le_trans <| by simp +arith +decide ) ;
      -- We'll use that $\sum_{k=2}^{\infty} X^{1/k} \leq \sqrt{X} + (\log_2 X) X^{1/3}$.
      have h_sum_bound : ‚àÄ X : ‚Ñï, X ‚â• 2 ‚Üí ‚àë k ‚àà Finset.Icc 2 (Nat.log 2 X + 1), Nat.floor (Real.rpow X (1 / k : ‚Ñù)) ‚â§ Real.sqrt X + (Real.logb 2 X) * Real.rpow X (1 / 3 : ‚Ñù) := by
        intros X hX
        have h_split : ‚àë k ‚àà Finset.Icc 2 (Nat.log 2 X + 1), Nat.floor (Real.rpow X (1 / k : ‚Ñù)) ‚â§ Real.sqrt X + ‚àë k ‚àà Finset.Icc 3 (Nat.log 2 X + 1), Nat.floor (Real.rpow X (1 / k : ‚Ñù)) := by
          rw [ Finset.Icc_eq_cons_Ioc, Finset.sum_cons ] <;> norm_num;
          ¬∑ norm_num [ ‚Üê Real.sqrt_eq_rpow ];
            exact add_le_add ( Real.le_sqrt_of_sq_le ( mod_cast Nat.sqrt_le' _ ) ) le_rfl;
          ¬∑ exact Nat.succ_le_succ ( Nat.log_pos ( by norm_num ) hX );
        -- We'll use that $\sum_{k=3}^{\infty} X^{1/k} \leq (\log_2 X) X^{1/3}$.
        have h_sum_bound : ‚àë k ‚àà Finset.Icc 3 (Nat.log 2 X + 1), Nat.floor (Real.rpow X (1 / k : ‚Ñù)) ‚â§ (Nat.log 2 X) * Real.rpow X (1 / 3 : ‚Ñù) := by
          norm_num +zetaDelta at *;
          refine' le_trans ( Finset.sum_le_sum fun i hi => Nat.floor_le <| by positivity ) _;
          refine' le_trans ( Finset.sum_le_sum fun i hi => Real.rpow_le_rpow_of_exponent_le ( mod_cast by linarith ) <| inv_anti‚ÇÄ ( by positivity ) <| show ( i : ‚Ñù ) ‚â• 3 by norm_cast; linarith [ Finset.mem_Icc.mp hi ] ) _ ; norm_num;
          exact mul_le_mul_of_nonneg_right ( mod_cast Nat.sub_le_of_le_add <| by linarith ) <| by positivity;
        refine le_trans h_split <| add_le_add_left ( h_sum_bound.trans ?_ ) _;
        gcongr;
        ¬∑ exact Real.rpow_nonneg ( Nat.cast_nonneg _ ) _;
        ¬∑ rw [ Real.le_logb_iff_rpow_le ] <;> norm_cast <;> linarith [ Nat.pow_log_le_self 2 ( by linarith : X ‚â† 0 ) ];
      -- We'll use that $\log_2 X \cdot X^{1/3} \leq \sqrt{X}$ for sufficiently large $X$.
      have h_log_bound : ‚àÄ·∂† X in Filter.atTop, Real.logb 2 X * Real.rpow X (1 / 3 : ‚Ñù) ‚â§ Real.sqrt X := by
        -- We can divide both sides by $X^{1/3}$ to get $\log_2 X \leq X^{1/6}$.
        suffices h_div : ‚àÄ·∂† X in Filter.atTop, Real.logb 2 X ‚â§ Real.rpow X (1 / 6 : ‚Ñù) by
          filter_upwards [ h_div, Filter.eventually_gt_atTop 0 ] with X hX‚ÇÅ hX‚ÇÇ;
          convert mul_le_mul_of_nonneg_right hX‚ÇÅ ( Real.rpow_nonneg hX‚ÇÇ.le ( 1 / 3 : ‚Ñù ) ) using 1 ; norm_num [ Real.sqrt_eq_rpow, ‚Üê Real.rpow_add hX‚ÇÇ ];
        -- We can use the fact that $\log_2 X$ grows slower than any polynomial function, in particular $X^{1/6}$.
        have h_log_growth : Filter.Tendsto (fun X : ‚Ñù => Real.logb 2 X / X ^ (1 / 6 : ‚Ñù)) Filter.atTop (nhds 0) := by
          -- Let $y = \log_2 X$, therefore the expression becomes $\frac{y}{2^{y/6}}$.
          suffices h_log : Filter.Tendsto (fun y : ‚Ñù => y / Real.exp (y * Real.log 2 / 6)) Filter.atTop (nhds 0) by
            have h_log : Filter.Tendsto (fun X : ‚Ñù => Real.logb 2 X / Real.exp (Real.logb 2 X * Real.log 2 / 6)) Filter.atTop (nhds 0) := by
              exact h_log.comp ( Real.tendsto_logb_atTop ( by norm_num ) );
            refine h_log.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with X hX using by rw [ Real.rpow_def_of_pos hX ] ; norm_num [ Real.logb, mul_div ] );
          -- Let $z = \frac{y \log 2}{6}$, therefore the expression becomes $\frac{6z}{e^z}$.
          suffices h_z : Filter.Tendsto (fun z : ‚Ñù => 6 * z / Real.exp z) Filter.atTop (nhds 0) by
            have := h_z.comp ( Filter.tendsto_id.atTop_mul_const ( show 0 < Real.log 2 / 6 by positivity ) );
            convert this.div_const ( Real.log 2 ) using 2 <;> norm_num ; ring;
            norm_num [ mul_assoc, mul_comm, mul_left_comm ];
          simpa [ mul_div_assoc, Real.exp_neg ] using Real.tendsto_pow_mul_exp_neg_atTop_nhds_zero 1 |> Filter.Tendsto.const_mul 6;
        have := h_log_growth.eventually ( gt_mem_nhds zero_lt_one ) ; aesop;
        exact ‚ü® Max.max w 1, fun x hx => by have := h x ( le_trans ( le_max_left _ _ ) hx ) ; rw [ div_lt_one ( Real.rpow_pos_of_pos ( by linarith [ le_max_right w 1 ] ) _ ) ] at this; linarith ‚ü©;
      filter_upwards [ Filter.eventually_ge_atTop 2, h_log_bound.natCast_atTop ] with X hX‚ÇÅ hX‚ÇÇ ; aesop;
      refine' le_trans ( Nat.cast_le.mpr ( h_bound X ) ) _;
      rw [ abs_of_nonneg ( Real.sqrt_nonneg _ ) ] ; push_cast ; nlinarith [ h_sum_bound X hX‚ÇÅ, Real.sqrt_nonneg X, Real.sq_sqrt ( Nat.cast_nonneg X ), Real.sqrt_nonneg 2, Real.sq_sqrt zero_le_two ]

/-
Theorem 3: Character Identity (T_œá = -S‚ÇÇ). T_œá(X) = -S‚ÇÇ(X) + O(‚àöX log¬≤X).
-/
open Asymptotics Filter

theorem character_identity :
    (fun X => T_œá X + S‚ÇÇ X) =O[atTop] (fun X => Real.sqrt X * (Real.log X)^2) := by
      -- We want to bound $D(X) = T_\chi(X) + S_2(X) = \sum_{n \le X} \Lambda(n)\Lambda(n+2) (\chi_4(n)\chi_4(n+2) + 1)$.
      set D := fun X : ‚Ñï => ‚àë n ‚àà Finset.range (X + 1), (Œõ n : ‚ÑÇ) * (Œõ (n + 2) : ‚ÑÇ) * (œá‚ÇÑ n * œá‚ÇÑ (n + 2) + 1);
      -- We want to show that $D(X) = O(\sqrt{X} \log^2 X)$.
      have hD : D =O[atTop] (fun X : ‚Ñï => Real.sqrt (X : ‚Ñù) * (Real.log (X : ‚Ñù)) ^ 2) := by
        -- The term for $n$ is zero if $\Lambda(n)=0$ or $\Lambda(n+2)=0$.
        -- If both are non-zero, $n$ and $n+2$ are prime powers.
        -- If $n > 2$ and both are prime, then by `cancellation_on_twins`, the term is 0.
        -- So non-zero terms occur only when (at least one of $n, n+2$ is a proper prime power) or ($n \le 2$).
        have h_nonzero_terms : ‚àÄ X : ‚Ñï, D X = ‚àë n ‚àà Finset.range (X + 1), if is_proper_prime_power n ‚à® is_proper_prime_power (n + 2) ‚à® n ‚â§ 2 then (vonMangoldt n : ‚ÑÇ) * (vonMangoldt (n + 2) : ‚ÑÇ) * (œá‚ÇÑ n * œá‚ÇÑ (n + 2) + 1) else 0 := by
          intro X;
          refine' Finset.sum_congr rfl fun n hn => _;
          split_ifs <;> simp_all +decide [ ArithmeticFunction.vonMangoldt ];
          by_cases h : Nat.Prime n <;> by_cases h' : Nat.Prime ( n + 2 ) <;> simp_all +decide [ is_proper_prime_power ];
          have := afm_structure n h h' ( by linarith ) ; aesop;
        -- The number of $n \le X$ such that $n$ is a proper prime power is $O(\sqrt{X})$ by `count_proper_prime_powers_bound`.
        have h_proper_prime_powers : (fun X : ‚Ñï => (((Finset.range (X + 1)).filter (fun n => is_proper_prime_power n ‚à® is_proper_prime_power (n + 2) ‚à® n ‚â§ 2)).card : ‚Ñù)) =O[atTop] (fun X : ‚Ñï => Real.sqrt (X : ‚Ñù)) := by
          -- The number of $n \le X$ such that $n$ is a proper prime power is $O(\sqrt{X})$ by `count_proper_prime_powers_bound`. Similarly for $n+2$.
          have h_proper_prime_powers_count : (fun X : ‚Ñï => (((Finset.range (X + 1)).filter is_proper_prime_power).card : ‚Ñù)) =O[atTop] (fun X : ‚Ñï => Real.sqrt (X : ‚Ñù)) ‚àß (fun X : ‚Ñï => (((Finset.range (X + 1)).filter (fun n => is_proper_prime_power (n + 2))).card : ‚Ñù)) =O[atTop] (fun X : ‚Ñï => Real.sqrt (X : ‚Ñù)) := by
            have h_proper_prime_powers_count : (fun X : ‚Ñï => (((Finset.range (X + 1)).filter is_proper_prime_power).card : ‚Ñù)) =O[atTop] (fun X : ‚Ñï => Real.sqrt (X : ‚Ñù)) := by
              exact?;
            refine ‚ü® h_proper_prime_powers_count, ?_ ‚ü©;
            have h_proper_prime_powers_count : (fun X : ‚Ñï => (((Finset.Ico 2 (X + 3)).filter is_proper_prime_power).card : ‚Ñù)) =O[atTop] (fun X : ‚Ñï => Real.sqrt (X : ‚Ñù)) := by
              have h_proper_prime_powers_count : (fun X : ‚Ñï => (((Finset.range (X + 3)).filter is_proper_prime_power).card : ‚Ñù)) =O[atTop] (fun X : ‚Ñï => Real.sqrt (X : ‚Ñù)) := by
                rw [ Asymptotics.isBigO_iff ] at *;
                aesop;
                use w * 2, w_1 + 3;
                intro b hb; have := h ( b + 2 ) ( by linarith ) ; norm_num [ Finset.sum_range_succ ] at *;
                refine le_trans this ?_;
                rw [ mul_assoc ];
                exact mul_le_mul_of_nonneg_left ( by rw [ abs_of_nonneg ( Real.sqrt_nonneg _ ), abs_of_nonneg ( Real.sqrt_nonneg _ ) ] ; nlinarith only [ Real.sqrt_nonneg b, Real.sqrt_nonneg ( b + 2 ), Real.mul_self_sqrt ( show ( b:‚Ñù ) ‚â• 0 by positivity ), Real.mul_self_sqrt ( show ( b + 2:‚Ñù ) ‚â• 0 by positivity ), show ( b:‚Ñù ) ‚â• 3 by norm_cast; linarith ] ) ( show 0 ‚â§ w by have := h ( w_1 + 3 ) ( by linarith ) ; exact le_of_not_gt fun hw => by { exact absurd this ( by { exact not_le_of_gt ( by { exact lt_of_lt_of_le ( mul_neg_of_neg_of_pos hw ( abs_pos.mpr ( ne_of_gt ( Real.sqrt_pos.mpr ( Nat.cast_pos.mpr ( by linarith ) ) ) ) ) ) ( Nat.cast_nonneg _ ) } ) } ) } );
              refine' Asymptotics.IsBigO.trans _ h_proper_prime_powers_count;
              refine' Asymptotics.isBigO_iff.mpr _;
              norm_num +zetaDelta at *;
              exact ‚ü® 1, 0, fun n hn => by rw [ one_mul ] ; exact_mod_cast Finset.card_mono <| Finset.filter_subset_filter _ <| Finset.subset_iff.mpr fun x hx => Finset.mem_range.mpr <| by linarith [ Finset.mem_Ico.mp hx ] ‚ü©;
            convert h_proper_prime_powers_count using 2;
            rw [ Finset.card_filter, Finset.card_filter ];
            rw [ Finset.sum_Ico_eq_sum_range ] ; norm_num [ add_comm, add_left_comm, add_assoc ];
            rfl;
          -- The number of $n \le X$ such that $n \le 2$ is $O(1)$.
          have h_small_n : (fun X : ‚Ñï => (((Finset.range (X + 1)).filter (fun n => n ‚â§ 2)).card : ‚Ñù)) =O[atTop] (fun X : ‚Ñï => Real.sqrt (X : ‚Ñù)) := by
            norm_num [ Asymptotics.isBigO_iff ];
            use 3, 9; intros b hb; rw [ abs_of_nonneg ( Real.sqrt_nonneg _ ) ] ; norm_cast; aesop;
            rw [ show ( Finset.filter ( fun n => n ‚â§ 2 ) ( Finset.range ( b + 1 ) ) ) = Finset.Icc 0 2 by ext n; aesop ; linarith ] ; norm_num ; nlinarith [ Real.sqrt_nonneg b, Real.sq_sqrt <| Nat.cast_nonneg b, ( by norm_cast : ( 9 :‚Ñù ) ‚â§ b ) ];
          have h_union : (fun X : ‚Ñï => (((Finset.range (X + 1)).filter (fun n => is_proper_prime_power n ‚à® is_proper_prime_power (n + 2) ‚à® n ‚â§ 2)).card : ‚Ñù)) ‚â§ (fun X : ‚Ñï => (((Finset.range (X + 1)).filter is_proper_prime_power).card : ‚Ñù)) + (fun X : ‚Ñï => (((Finset.range (X + 1)).filter (fun n => is_proper_prime_power (n + 2))).card : ‚Ñù)) + (fun X : ‚Ñï => (((Finset.range (X + 1)).filter (fun n => n ‚â§ 2)).card : ‚Ñù)) := by
            intro X;
            simp;
            exact mod_cast le_trans ( Finset.card_mono <| by aesop_cat ) ( Finset.card_union_le _ _ |> le_trans <| add_le_add_right ( Finset.card_union_le _ _ ) _ );
          refine' Asymptotics.IsBigO.trans _ ( Asymptotics.IsBigO.add ( Asymptotics.IsBigO.add h_proper_prime_powers_count.1 h_proper_prime_powers_count.2 ) h_small_n );
          rw [ Asymptotics.isBigO_iff ];
          exact ‚ü® 1, Filter.Eventually.of_forall fun x => by rw [ Real.norm_of_nonneg ( Nat.cast_nonneg _ ), Real.norm_of_nonneg ( by positivity ) ] ; simpa using h_union x ‚ü©;
        -- Each term is bounded by $2 \Lambda(n) \Lambda(n+2) \le 2 \log n \log(n+2) \le 2 \log^2(X+2)$.
        have h_term_bound : ‚àÄ X : ‚Ñï, ‚àÄ n ‚àà Finset.range (X + 1), ‚Äñ(vonMangoldt n : ‚ÑÇ) * (vonMangoldt (n + 2) : ‚ÑÇ) * (œá‚ÇÑ n * œá‚ÇÑ (n + 2) + 1)‚Äñ ‚â§ 2 * (Real.log (X + 2)) ^ 2 := by
          -- Each term is bounded by $2 \Lambda(n) \Lambda(n+2) \le 2 \log n \log(n+2) \le 2 \log^2(X+2)$ because $\Lambda(n) \le \log n$ and $\Lambda(n+2) \le \log(n+2)$.
          intros X n hn
          have h_term_bound : ‚Äñ(vonMangoldt n : ‚ÑÇ) * (vonMangoldt (n + 2) : ‚ÑÇ)‚Äñ ‚â§ (Real.log (X + 2)) ^ 2 := by
            have h_term_bound : ‚àÄ n : ‚Ñï, n ‚â§ X ‚Üí ‚Äñ(vonMangoldt n : ‚ÑÇ)‚Äñ ‚â§ Real.log (X + 2) ‚àß ‚Äñ(vonMangoldt (n + 2) : ‚ÑÇ)‚Äñ ‚â§ Real.log (X + 2) := by
              intros n hn
              have h_term_bound : ‚àÄ m : ‚Ñï, m ‚â§ X + 2 ‚Üí ‚Äñ(vonMangoldt m : ‚ÑÇ)‚Äñ ‚â§ Real.log (X + 2) := by
                intros m hm
                have h_term_bound : ‚Äñ(vonMangoldt m : ‚ÑÇ)‚Äñ ‚â§ Real.log m := by
                  norm_num +zetaDelta at *;
                  rw [ abs_of_nonneg ( by exact? ) ] ; exact?;
                rcases m with ( _ | _ | m ) <;> norm_num at *;
                ¬∑ exact Real.log_nonneg ( by linarith );
                ¬∑ exact Real.log_nonneg ( by linarith );
                ¬∑ exact h_term_bound.trans ( Real.log_le_log ( by positivity ) ( by norm_cast; linarith ) );
              exact ‚ü® h_term_bound n ( by linarith ), h_term_bound ( n + 2 ) ( by linarith ) ‚ü©;
            simpa only [ sq, norm_mul ] using mul_le_mul ( h_term_bound n ( Finset.mem_range_succ_iff.mp hn ) |>.1 ) ( h_term_bound n ( Finset.mem_range_succ_iff.mp hn ) |>.2 ) ( by positivity ) ( by exact Real.log_nonneg ( by linarith ) );
          -- Since $|\chi_4(n)\chi_4(n+2) + 1| \leq 2$, we have:
          have h_char_bound : ‚Äñ(œá‚ÇÑ n * œá‚ÇÑ (n + 2) + 1 : ‚ÑÇ)‚Äñ ‚â§ 2 := by
            have h_char_bound : ‚àÄ n : ‚Ñ§, ‚Äñ(œá‚ÇÑ n : ‚ÑÇ)‚Äñ ‚â§ 1 := by
              unfold œá‚ÇÑ; aesop;
            exact le_trans ( norm_add_le _ _ ) ( by exact le_trans ( add_le_add ( norm_mul_le _ _ ) le_rfl ) ( by exact le_trans ( add_le_add ( mul_le_mul ( h_char_bound _ ) ( h_char_bound _ ) ( by positivity ) ( by positivity ) ) le_rfl ) ( by norm_num ) ) );
          simpa only [ mul_comm, norm_mul ] using mul_le_mul h_char_bound h_term_bound ( by positivity ) ( by positivity );
        -- Therefore, $D(X) = O(\sqrt{X} \log^2 X)$.
        have hD_bound : ‚àÄ X : ‚Ñï, ‚ÄñD X‚Äñ ‚â§ 2 * (Real.log (X + 2)) ^ 2 * (((Finset.range (X + 1)).filter (fun n => is_proper_prime_power n ‚à® is_proper_prime_power (n + 2) ‚à® n ‚â§ 2)).card : ‚Ñù) := by
          intros X
          rw [h_nonzero_terms X];
          refine' le_trans ( norm_sum_le _ _ ) _;
          refine' le_trans ( Finset.sum_le_sum fun i hi => _ ) _;
          use fun i => if is_proper_prime_power i ‚à® is_proper_prime_power ( i + 2 ) ‚à® i ‚â§ 2 then 2 * Real.log ( X + 2 ) ^ 2 else 0;
          ¬∑ split_ifs <;> [ exact h_term_bound X i hi; exact by norm_num ];
          ¬∑ norm_num [ mul_comm, Finset.sum_ite ];
        -- Since $\log(X+2) = O(\log X)$, we can replace $\log(X+2)$ with $\log X$ in the bound.
        have h_log_bound : (fun X : ‚Ñï => (Real.log (X + 2)) ^ 2) =O[atTop] (fun X : ‚Ñï => (Real.log X) ^ 2) := by
          rw [ Asymptotics.isBigO_iff ];
          use 4;
          norm_num;
          refine' ‚ü® 8, fun n hn => _ ‚ü© ; rw [ show ( n + 2 : ‚Ñù ) = n * ( 1 + 2 / n ) by rw [ mul_add, mul_div_cancel‚ÇÄ _ ( by positivity ) ] ; ring ] ; rw [ Real.log_mul ( by positivity ) ( by positivity ) ];
          nlinarith only [ show 0 ‚â§ Real.log n by positivity, show Real.log ( 1 + 2 / ( n : ‚Ñù ) ) ‚â§ Real.log n by exact Real.log_le_log ( by positivity ) ( by nlinarith [ show ( n : ‚Ñù ) ‚â• 8 by norm_cast, div_mul_cancel‚ÇÄ ( 2 : ‚Ñù ) ( by positivity : ( n : ‚Ñù ) ‚â† 0 ) ] ), show Real.log ( 1 + 2 / ( n : ‚Ñù ) ) ‚â• 0 by exact Real.log_nonneg ( by norm_num; positivity ) ];
        have := h_proper_prime_powers.mul h_log_bound;
        rw [ Asymptotics.isBigO_iff ] at *;
        obtain ‚ü® c, hc ‚ü© := this; use 2 * c; filter_upwards [ hc ] with x hx; specialize hD_bound x; norm_num [ mul_assoc, mul_comm, mul_left_comm ] at *; nlinarith;
      convert hD using 2 ; norm_num [ D, T_œá, S‚ÇÇ ];
      rw [ ‚Üê Finset.sum_add_distrib ] ; congr ; ext ; ring;

/-
Check if vonMangoldt_le_log is available.
-/
#check ArithmeticFunction.vonMangoldt_le_log

/-
Definitions of the term in the sum and the set of exceptional indices.
-/
open Asymptotics Filter

noncomputable def term (n : ‚Ñï) : ‚ÑÇ :=
  (vonMangoldt n : ‚ÑÇ) * œá‚ÇÑ n * (vonMangoldt (n + 2) : ‚ÑÇ) * œá‚ÇÑ (n + 2) +
  (vonMangoldt n : ‚ÑÇ) * (vonMangoldt (n + 2) : ‚ÑÇ)

def exceptional_set (X : ‚Ñï) : Finset ‚Ñï :=
  (Finset.range (X + 1)).filter (fun n => n ‚â§ 2 ‚à® is_proper_prime_power n ‚à® is_proper_prime_power (n + 2))

/-
Corrected Theorem 4: [F_{1/4}, U_2] = -2 ¬∑ U_2 ¬∑ F_{1/4}.
-/
theorem non_commutativity_corrected :
    op_commutator (F_op (1/4)) (U_op 2) = -2 ‚Ä¢ (U_op 2 * F_op (1/4)) := by
      have h_def : ‚àÄ f : l2, (F_op (1 / 4)) (U_op 2 f) = (U_op 2 ((-1 : ‚ÑÇ) ‚Ä¢ (F_op (1 / 4)) f)) := by
        intros f
        ext n
        simp [F_op, U_op];
        unfold F_lin U_lin; aesop;
        unfold F_fun U_fun; norm_num [ Real.pi_pos.ne.symm, mul_div, Complex.ext_iff ];
        unfold e; split_ifs <;> norm_num [ Complex.exp_re, Complex.exp_im ] ; ring;
        rw [ Nat.cast_sub ( by linarith ) ] ; ring ; norm_num [ mul_assoc, mul_comm Real.pi _, mul_div ] ;
        norm_num [ Real.cos_add, Real.sin_add ] ; ring ; norm_num;
      ext a; specialize h_def a; norm_num at * ; aesop;
      simp_all +decide [ two_mul, add_mul, sub_eq_add_neg ];
      erw [ ContinuousLinearMap.sub_apply ] ; aesop

/-
Definition of exceptional indices and proof that non-exceptional terms vanish.
-/
def is_exceptional (n : ‚Ñï) : Prop := n ‚â§ 2 ‚à® is_proper_prime_power n ‚à® is_proper_prime_power (n + 2)

theorem term_eq_zero_of_not_exceptional (n : ‚Ñï) (h : ¬¨ is_exceptional n) : term n = 0 := by
  unfold is_exceptional at h; contrapose! h; aesop;
  unfold term at h;
  -- By the cancellation lemma, if the term is non-zero, then n must be a twin prime or a proper prime power.
  have h_cancel : ¬¨(is_proper_prime_power n ‚à® is_proper_prime_power (n + 2)) ‚Üí (Œõ n) * œá‚ÇÑ n * (Œõ (n + 2)) * œá‚ÇÑ (n + 2) + (Œõ n) * (Œõ (n + 2)) = 0 := by
    by_cases h_prime : Nat.Prime n ‚àß Nat.Prime ( n + 2 ) <;> simp_all +decide [ ArithmeticFunction.vonMangoldt ];
    ¬∑ have := afm_structure n h_prime.1 h_prime.2 ( by rcases n with ( _ | _ | _ | n ) <;> simp_all +arith +decide ) ; aesop;
      exact False.elim <| h <| by linear_combination' this * Complex.log n * Real.log ( n + 2 ) ;
    ¬∑ unfold is_proper_prime_power at *; aesop;
  grind

/-
Theorem 5: Commutator Norm. ‚Äñ[F_{1/4}, U_2]‚Äñ = 2.
-/
theorem commutator_norm :
    ‚Äñop_commutator (F_op (1/4)) (U_op 2)‚Äñ = 2 := by
      -- Since F_op (1/4) is unitary and U_op 2 is an isometry, their product has norm 1.
      have h_norm_prod : ‚ÄñU_op 2 * F_op (1 / 4)‚Äñ = 1 := by
        refine' le_antisymm _ _;
        ¬∑ refine' le_trans ( ContinuousLinearMap.opNorm_comp_le _ _ ) _;
          refine' le_trans ( mul_le_mul ( LinearMap.mkContinuous_norm_le _ _ _ ) ( LinearMap.mkContinuous_norm_le _ _ _ ) _ _ ) _ <;> norm_num;
        ¬∑ refine' le_csInf _ _;
          ¬∑ use ‚ÄñU_op 2 * F_op (1 / 4)‚Äñ;
            exact ‚ü® norm_nonneg _, fun x => ContinuousLinearMap.le_opNorm _ _ ‚ü©;
          ¬∑ bound;
            have := a.2 ( ‚ü® ket 0, by exact? ‚ü© : l2 ) ; norm_num [ F_op, U_op ] at this;
            unfold U_lin F_lin ket at this ; norm_num at this;
            unfold U_fun F_fun at this ; norm_num at this;
            erw [ lp.norm_eq_tsum_rpow ] at this ; norm_num at this;
            ¬∑ rw [ tsum_eq_single 2 ] at this <;> norm_num at this ‚ä¢;
              ¬∑ unfold e at this ; norm_num at this ; aesop;
              ¬∑ intro n hn hn'; rw [ Pi.single_eq_of_ne ( by omega ) ] ; norm_num;
            ¬∑ norm_num;
      have h_norm : ‚Äñop_commutator (F_op (1/4)) (U_op 2)‚Äñ = ‚Äñ-2 ‚Ä¢ (U_op 2 * F_op (1/4))‚Äñ := by
        exact non_commutativity_corrected ‚ñ∏ rfl;
      norm_num [ h_norm, h_norm_prod, norm_smul ];
      convert congr_arg ( fun x : ‚Ñù => 2 * x ) h_norm_prod using 1 ; norm_num [ two_mul ];
      ¬∑ rw [ ‚Üê two_smul ‚ÑÇ, norm_smul, h_norm_prod ] ; norm_num;
      ¬∑ norm_num

/-
Definitions of Psi_prime_sum (Chebyshev theta) and F_sum (Fourier sum at 1/4).
-/
noncomputable def Psi_prime_sum (X : ‚Ñï) : ‚Ñù :=
  ‚àë p ‚àà (Finset.range (X + 1)).filter Nat.Prime, Real.log p

noncomputable def F_sum (X : ‚Ñï) : ‚ÑÇ :=
  ‚àë p ‚àà (Finset.range (X + 1)).filter (fun n => n.Prime ‚àß n > 2), (Real.log p : ‚ÑÇ) * œá‚ÇÑ p * e (p / 4)

/-
Theorem 6: Peak Value via Golden Bridge. F(1/4) = i¬∑œà(X) + O(1).
-/
open Asymptotics Filter

theorem peak_value_via_golden_bridge :
    (fun X => F_sum X - I * (Psi_prime_sum X : ‚ÑÇ)) =O[atTop] (fun X => (1 : ‚Ñù)) := by
      refine' Asymptotics.isBigO_iff.mpr ‚ü® 2, Filter.eventually_atTop.mpr ‚ü® 0, fun n hn => _ ‚ü© ‚ü©;
      -- We'll use that $F_sum n$ is the sum of $i \log p$ over primes $p \leq n$ greater than 2.
      have hF_sum : F_sum n = Complex.I * (‚àë p ‚àà (Finset.range (n + 1)).filter (fun p => p.Prime ‚àß p > 2), Real.log p) := by
        -- We'll use that $F_sum n$ is the sum of $i \log p$ over primes $p \leq n$ greater than 2, and that $\chi_4(p) = i$ for primes $p \equiv 3 \mod 4$.
        have hF_sum : ‚àÄ p : ‚Ñï, p.Prime ‚Üí p > 2 ‚Üí (Real.log p : ‚ÑÇ) * œá‚ÇÑ p * e (p / 4) = Complex.I * Real.log p := by
          intro p hp hp2; rw [ mul_comm ] ; convert congr_arg ( fun x : ‚ÑÇ => x * Real.log p ) ( golden_bridge_identity p _ ) using 1 <;> norm_num [ hp, hp2 ] ;
          ¬∑ ring;
          ¬∑ exact mod_cast hp.eq_two_or_odd.resolve_left hp2.ne';
        push_cast [ Finset.mul_sum _ _ _ ];
        exact Finset.sum_congr rfl fun x hx => by aesop;
      unfold Psi_prime_sum; aesop;
      rw [ show ( Finset.filter ( fun p => Nat.Prime p ‚àß 2 < p ) ( Finset.range ( n + 1 ) ) ) = Finset.filter ( fun p => Nat.Prime p ) ( Finset.range ( n + 1 ) ) \ { 2 } from ?_ ];
      ¬∑ by_cases h : 2 ‚àà Finset.range ( n + 1 ) <;> simp_all +decide [ Finset.sum_eq_zero_iff_of_nonneg, Complex.normSq, Complex.norm_def ];
        ¬∑ norm_num [ Complex.log_re, Complex.log_im ];
          rw [ Real.sqrt_mul_self ( Real.log_nonneg ( by norm_num ) ) ] ; linarith [ Real.log_le_sub_one_of_pos zero_lt_two ];
        ¬∑ interval_cases n <;> norm_num [ Finset.sum ];
      ¬∑ ext ( _ | _ | _ | p ) <;> simp +arith +decide

/-
Check for InnerProductSpace instance.
-/
#synth InnerProductSpace ‚ÑÇ l2

/-
Definition of the Bell functional.
-/
noncomputable def Bell (X : ‚Ñï) : ‚ÑÇ :=
  inner (ùïú := ‚ÑÇ) (g_œá X) (op_commutator (F_op (1/4)) (U_op 2) (g_œá X))

/-
The shift operator U_op is an isometry.
-/
theorem U_isometry (h : ‚Ñï) : Isometry (U_op h) := by
  -- The norm of U_op h f is equal to the norm of f, since shifting doesn't change the norm.
  have h_norm : ‚àÄ f : l2, ‚Äñ(U_op h) f‚Äñ = ‚Äñf‚Äñ := by
    -- The norm of the shifted sequence is the same as the norm of the original sequence because shifting doesn't change the values, just their positions.
    have h_norm_shift : ‚àÄ f : l2, ‚Äñ(U_op h f)‚Äñ = ‚Äñf‚Äñ := by
      intro f
      have h_shift : ‚àÄ n, (U_op h f) n = if n < h then 0 else f (n - h) := by
        aesop
      have h_shift : ‚àë' n, ‚Äñ(U_op h f) n‚Äñ ^ 2 = ‚àë' n, ‚Äñf n‚Äñ ^ 2 := by
        rw [ ‚Üê Summable.sum_add_tsum_nat_add h ];
        ¬∑ rw [ Finset.sum_eq_zero ] <;> aesop;
        ¬∑ have := f.2.summable;
          rw [ ‚Üê summable_nat_add_iff h ] ; aesop;
      norm_num [ Norm.norm, lp.norm_eq_tsum_rpow ] at * ; aesop;
      convert congr_arg ( ¬∑ ^ ( 2‚Åª¬π : ‚Ñù ) ) h_shift using 1;
    assumption;
  refine' Isometry.of_dist_eq fun f g => _;
  simp +decide [ dist_eq_norm, h_norm ];
  rw [ ‚Üê map_sub, h_norm ]

/-
If TPC is false, then for large n, non-zero terms in S‚ÇÇ imply proper prime powers.
-/
def TPC : Prop := Set.Infinite {p : ‚Ñï | p.Prime ‚àß (p + 2).Prime}

lemma S2_support_bound (h : ¬¨ TPC) :
    ‚àÉ N, ‚àÄ n > N, vonMangoldt n * vonMangoldt (n + 2) ‚â† 0 ‚Üí is_proper_prime_power n ‚à® is_proper_prime_power (n + 2) := by
      simp +zetaDelta at *;
      -- If there are no twin primes beyond a certain point, then for any $n > N$, if $\Lambda(n) \neq 0$ and $\Lambda(n+2) \neq 0$, then $n$ and $n+2$ must be proper prime powers.
      obtain ‚ü®N, hN‚ü© : ‚àÉ N, ‚àÄ n > N, ¬¨(Nat.Prime n ‚àß Nat.Prime (n + 2)) := by
        exact Set.Finite.bddAbove ( Classical.not_not.mp h ) |> fun ‚ü® N, hN ‚ü© => ‚ü® N, fun n hn h => hn.not_le ( hN h ) ‚ü©;
      use N;
      intro n hn hn' hn''; contrapose! hN;
      simp_all +decide [ ArithmeticFunction.vonMangoldt ];
      unfold is_proper_prime_power at hN; aesop;

/-
If Twin Prime Conjecture is false, S‚ÇÇ(X) is O(‚àöX log¬≤ X).
-/
theorem S2_bound_of_finite_twins (h : ¬¨ TPC) :
    (fun X => S‚ÇÇ X) =O[atTop] (fun X => Real.sqrt X * (Real.log X)^2) := by
  obtain ‚ü®N, hN‚ü© := S2_support_bound h
  -- We split the sum S‚ÇÇ X into n ‚â§ N and n > N.
  -- The part n ‚â§ N is eventually constant, so it is O(1), which is O(‚àöX log¬≤ X).
  -- The part n > N is supported on proper prime powers.
  -- Let A be the set of n ‚àà range(X+1) such that n > N and Œõ(n)Œõ(n+2) ‚â† 0.
  -- For n ‚àà A, n or n+2 is a proper prime power.
  -- So |A| ‚â§ |{n ‚â§ X | is_proper_prime_power n}| + |{n ‚â§ X | is_proper_prime_power (n+2)}|.
  -- Both are O(‚àöX).
  -- Each term is bounded by log¬≤(X+2).
  -- So the sum is O(‚àöX log¬≤ X).
  -- The number of proper prime powers up to X is O(‚àöX).
  have hProperPrimePowers : (fun X => (((Finset.range (X + 1)).filter is_proper_prime_power).card : ‚Ñù)) =O[atTop] (fun X => Real.sqrt (X : ‚Ñù)) := by
    exact?;
  -- Each term in S‚ÇÇ(X) is bounded by log¬≤(X+2).
  have hTermBound : ‚àÄ X, S‚ÇÇ X ‚â§ ‚àë n ‚àà ((Finset.range (X + 1)).filter (fun n => n ‚â§ N)) ‚à™ ((Finset.range (X + 1)).filter is_proper_prime_power) ‚à™ ((Finset.range (X + 1)).filter (fun n => is_proper_prime_power (n + 2))), (Real.log (X + 2 : ‚Ñù)) ^ 2 := by
    intro X
    have hTermBound : ‚àÄ n ‚àà Finset.range (X + 1), vonMangoldt n * vonMangoldt (n + 2) ‚â§ (Real.log (X + 2 : ‚Ñù)) ^ 2 * (if n ‚â§ N ‚à® is_proper_prime_power n ‚à® is_proper_prime_power (n + 2) then 1 else 0) := by
      intro n hn; split_ifs <;> simp_all +decide [ sq ] ;
      ¬∑ refine' mul_le_mul _ _ _ _;
        ¬∑ refine' le_trans _ ( Real.log_le_log ( by norm_cast; linarith ) ( show ( X : ‚Ñù ) + 2 ‚â• n + 1 by norm_cast; linarith ) );
          rcases n with ( _ | _ | n ) <;> norm_num [ ArithmeticFunction.vonMangoldt ];
          ¬∑ positivity;
          ¬∑ split_ifs <;> norm_cast;
            ¬∑ exact Real.log_le_log ( Nat.cast_pos.mpr ( Nat.minFac_pos _ ) ) ( mod_cast Nat.le_trans ( Nat.minFac_le ( by linarith ) ) ( by linarith ) );
            ¬∑ positivity;
        ¬∑ -- Since $n + 2 \leq X + 2$, we have $\log(n + 2) \leq \log(X + 2)$.
          have h_log_le : Real.log (n + 2) ‚â§ Real.log (X + 2) := by
            exact Real.log_le_log ( by positivity ) ( by norm_cast; linarith );
          exact le_trans ( vonMangoldt_le_log ) ( mod_cast h_log_le );
        ¬∑ exact?;
        ¬∑ exact Real.log_nonneg ( by linarith );
      ¬∑ contrapose! hN; aesop;
    refine' le_trans ( Finset.sum_le_sum hTermBound ) _;
    simp +decide [ Finset.sum_ite ];
    exact mul_le_mul_of_nonneg_right ( mod_cast Finset.card_mono <| by aesop_cat ) <| sq_nonneg _;
  -- The number of terms in the union is O(‚àöX).
  have hUnionCard : (fun X => (((Finset.range (X + 1)).filter (fun n => n ‚â§ N)) ‚à™ ((Finset.range (X + 1)).filter is_proper_prime_power) ‚à™ ((Finset.range (X + 1)).filter (fun n => is_proper_prime_power (n + 2)))).card : ‚Ñï ‚Üí ‚Ñù) =O[atTop] (fun X => Real.sqrt (X : ‚Ñù)) := by
    -- The number of proper prime powers up to X+2 is also O(‚àöX).
    have hProperPrimePowersUpToX2 : (fun X => (((Finset.range (X + 1)).filter (fun n => is_proper_prime_power (n + 2))).card : ‚Ñù)) =O[atTop] (fun X => Real.sqrt (X : ‚Ñù)) := by
      have hProperPrimePowersUpToX2 : (fun X => (((Finset.range (X + 1)).filter (fun n => is_proper_prime_power (n + 2))).card : ‚Ñù)) =O[atTop] (fun X => (((Finset.range (X + 3)).filter is_proper_prime_power).card : ‚Ñù)) := by
        refine' Asymptotics.isBigO_of_le Filter.atTop ( fun X => _ );
        rw [ show Finset.filter is_proper_prime_power ( Finset.range ( X + 3 ) ) = Finset.image ( fun n => n + 2 ) ( Finset.filter ( fun n => is_proper_prime_power ( n + 2 ) ) ( Finset.range ( X + 1 ) ) ) ‚à™ Finset.filter is_proper_prime_power ( Finset.range 2 ) from ?_ ];
        ¬∑ norm_num [ Finset.card_image_of_injective, Function.Injective ];
          exact le_trans ( by rw [ Finset.card_image_of_injective _ fun x y hxy => by linarith ] ) ( Finset.card_mono <| Finset.subset_union_left );
        ¬∑ ext ( _ | _ | n ) <;> simp +arith +decide [ Finset.mem_union, Finset.mem_image ];
      refine' hProperPrimePowersUpToX2.trans _;
      refine' hProperPrimePowers.comp_tendsto ( Filter.tendsto_add_atTop_nat 2 ) |> fun h => h.trans _;
      rw [ Asymptotics.isBigO_iff ];
      simp +zetaDelta at *;
      exact ‚ü® 2, 4, fun n hn => by rw [ abs_of_nonneg ( Real.sqrt_nonneg _ ), abs_of_nonneg ( Real.sqrt_nonneg _ ) ] ; nlinarith [ Real.sqrt_nonneg ( n + 2 : ‚Ñù ), Real.sqrt_nonneg ( n : ‚Ñù ), Real.mul_self_sqrt ( show ( n : ‚Ñù ) + 2 ‚â• 0 by positivity ), Real.mul_self_sqrt ( show ( n : ‚Ñù ) ‚â• 0 by positivity ), show ( n : ‚Ñù ) ‚â• 4 by norm_cast ] ‚ü©;
    have hUnionCard : (fun X => (((Finset.range (X + 1)).filter (fun n => n ‚â§ N)).card : ‚Ñù)) =O[atTop] (fun X => Real.sqrt (X : ‚Ñù)) := by
      norm_num [ Asymptotics.isBigO_iff ];
      refine' ‚ü® N + 1, N + 1, fun n hn => _ ‚ü© ; rw [ abs_of_nonneg ( Real.sqrt_nonneg _ ) ];
      exact le_trans ( Nat.cast_le.mpr <| Finset.card_le_card <| show Finset.filter ( fun n => n ‚â§ N ) ( Finset.range ( n + 1 ) ) ‚äÜ Finset.Icc 0 N from fun x hx => Finset.mem_Icc.mpr ‚ü® Nat.zero_le _, Finset.mem_filter.mp hx |>.2 ‚ü© ) <| by norm_num; nlinarith [ Real.sqrt_nonneg n, Real.sq_sqrt <| Nat.cast_nonneg n, show ( n : ‚Ñù ) ‚â• N + 1 by norm_cast ] ;
    refine' Asymptotics.IsBigO.trans _ ( hUnionCard.add ( hProperPrimePowers.add hProperPrimePowersUpToX2 ) );
    refine' Asymptotics.IsBigO.of_bound 1 _;
    norm_num;
    exact ‚ü® 0, fun n hn => by rw [ abs_of_nonneg ( by positivity ) ] ; exact mod_cast le_trans ( Finset.card_union_le _ _ ) ( add_le_add_left ( Finset.card_union_le _ _ ) _ ) ‚ü©;
  -- Using the bounds on the number of terms and the size of each term, we can conclude the proof.
  have hFinalBound : (fun X => (((Finset.range (X + 1)).filter (fun n => n ‚â§ N)) ‚à™ ((Finset.range (X + 1)).filter is_proper_prime_power) ‚à™ ((Finset.range (X + 1)).filter (fun n => is_proper_prime_power (n + 2)))).card * (Real.log (X + 2 : ‚Ñù)) ^ 2 : ‚Ñï ‚Üí ‚Ñù) =O[atTop] (fun X => Real.sqrt (X : ‚Ñù) * (Real.log (X : ‚Ñù)) ^ 2) := by
    -- Since $\log(X+2)$ is asymptotically equivalent to $\log(X)$, we can replace $\log(X+2)$ with $\log(X)$ in the bound.
    have hLogEquivalence : (fun X : ‚Ñï => Real.log (X + 2 : ‚Ñù)) =O[atTop] (fun X : ‚Ñï => Real.log (X : ‚Ñù)) := by
      refine' Asymptotics.IsBigO.of_bound 2 _;
      norm_num;
      refine' ‚ü® 2, fun n hn => _ ‚ü© ; rw [ abs_of_nonneg ( Real.log_nonneg <| by linarith ), abs_of_nonneg ( Real.log_nonneg <| by norm_cast; linarith ) ] ; rw [ two_mul ] ; rw [ ‚Üê Real.log_mul ( by positivity ) ( by positivity ) ] ; gcongr ; norm_cast ; nlinarith;
    apply_rules [ Asymptotics.IsBigO.mul, hUnionCard, hLogEquivalence.pow ];
  refine' Asymptotics.IsBigO.trans _ hFinalBound;
  rw [ Asymptotics.isBigO_iff ];
  exact ‚ü® 1, Filter.eventually_atTop.mpr ‚ü® 0, fun X hX => by rw [ Real.norm_of_nonneg ( show 0 ‚â§ S‚ÇÇ X from Finset.sum_nonneg fun _ _ => mul_nonneg ( by exact ( show 0 ‚â§ ArithmeticFunction.vonMangoldt _ from by exact? ) ) ( by exact ( show 0 ‚â§ ArithmeticFunction.vonMangoldt _ from by exact? ) ) ) ] ; rw [ Real.norm_of_nonneg ( show 0 ‚â§ ( _ : ‚Ñù ) * Real.log ( X + 2 ) ^ 2 from mul_nonneg ( Nat.cast_nonneg _ ) ( sq_nonneg _ ) ) ] ; simpa using hTermBound X ‚ü© ‚ü©

/-
Bound on the cardinality of the support of S2 under negation of TPC.
-/
open Asymptotics Filter

lemma card_S2_support_bound (N : ‚Ñï) :
    (fun X => (((Finset.range (X + 1)).filter (fun n => n ‚â§ N ‚à® is_proper_prime_power n ‚à® is_proper_prime_power (n + 2))).card : ‚Ñù)) =O[atTop] (fun X => Real.sqrt (X : ‚Ñù)) := by
      have h_card_support : (fun X => ((Finset.range (X + 1)).filter (fun n => n ‚â§ N ‚à® is_proper_prime_power n ‚à® is_proper_prime_power (n + 2))).card : ‚Ñï ‚Üí ‚Ñù) =O[Filter.atTop] (fun X => Real.sqrt (X : ‚Ñù)) := by
        have h_card_support_aux : (fun X => (((Finset.range (X + 1)).filter is_proper_prime_power).card : ‚Ñù)) =O[Filter.atTop] (fun X => Real.sqrt (X : ‚Ñù)) := by
          exact?
        -- The cardinality of the set of numbers up to X that are proper prime powers or their successors is bounded by $O(\sqrt{X})$.
        have h_card_support_aux2 : (fun X => (((Finset.range (X + 1)).filter (fun n => is_proper_prime_power (n + 2))).card : ‚Ñù)) =O[Filter.atTop] (fun X => Real.sqrt (X : ‚Ñù)) := by
          have h_card_support_aux2 : (fun X => (((Finset.range (X + 3)).filter is_proper_prime_power).card : ‚Ñù)) =O[Filter.atTop] (fun X => Real.sqrt (X : ‚Ñù)) := by
            rw [ Asymptotics.isBigO_iff ] at *;
            aesop;
            use w * 3;
            refine' ‚ü® w_1 + 3, fun b hb => le_trans ( mod_cast h ( b + 2 ) ( by linarith ) ) _ ‚ü© ; norm_num ; ring;
            rw [ abs_of_nonneg ( Real.sqrt_nonneg _ ), abs_of_nonneg ( Real.sqrt_nonneg _ ) ];
            rw [ mul_assoc ];
            exact mul_le_mul_of_nonneg_left ( Real.sqrt_le_iff.mpr ‚ü® by positivity, by nlinarith [ Real.sqrt_nonneg b, Real.sq_sqrt ( Nat.cast_nonneg b ), ( by norm_cast : ( w_1:‚Ñù ) + 3 ‚â§ b ) ] ‚ü© ) ( show 0 ‚â§ w by specialize h ( w_1 + 3 ) ( by linarith ) ; exact le_of_not_gt fun hw => by { exact absurd h ( by { exact not_le_of_gt ( by { exact lt_of_lt_of_le ( mul_neg_of_neg_of_pos hw ( abs_pos.mpr ( ne_of_gt ( Real.sqrt_pos.mpr ( by norm_cast; linarith ) ) ) ) ) ( Nat.cast_nonneg _ ) } ) } ) } );
          refine' h_card_support_aux2.congr' _ _;
          ¬∑ filter_upwards [ Filter.eventually_gt_atTop 0 ] with X hX;
            rw [ show ( Finset.filter is_proper_prime_power ( Finset.range ( X + 3 ) ) ) = Finset.image ( fun n => n + 2 ) ( Finset.filter ( fun n => is_proper_prime_power ( n + 2 ) ) ( Finset.range ( X + 1 ) ) ) from ?_, Finset.card_image_of_injective _ ( add_left_injective 2 ) ];
            ext ( _ | _ | n ) <;> simp +arith +decide;
            ¬∑ rintro ‚ü® h‚ÇÅ, h‚ÇÇ ‚ü©;
              simp_all +decide [ IsPrimePow ];
              aesop;
            ¬∑ simp +decide [ is_proper_prime_power ];
              native_decide +revert;
          ¬∑ rfl;
        -- The cardinality of the set of numbers up to X that are ‚â§ N is bounded by $O(\sqrt{X})$.
        have h_card_support_aux3 : (fun X => (((Finset.range (X + 1)).filter (fun n => n ‚â§ N)).card : ‚Ñù)) =O[Filter.atTop] (fun X => Real.sqrt (X : ‚Ñù)) := by
          refine' Asymptotics.isBigO_iff.mpr ‚ü® N + 1, _ ‚ü©;
          norm_num;
          exact ‚ü® N + 1, fun n hn => le_trans ( Nat.cast_le.mpr <| Finset.card_le_card <| show Finset.filter ( fun x => x ‚â§ N ) ( Finset.range ( n + 1 ) ) ‚äÜ Finset.Icc 0 N from fun x hx => Finset.mem_Icc.mpr ‚ü® Nat.zero_le _, Finset.mem_filter.mp hx |>.2 ‚ü© ) <| by norm_num; rw [ abs_of_nonneg <| Real.sqrt_nonneg _ ] ; nlinarith [ Real.sqrt_nonneg n, Real.sq_sqrt <| Nat.cast_nonneg n, ( by norm_cast : ( N:‚Ñù ) + 1 ‚â§ n ) ] ‚ü©;
        refine' Asymptotics.IsBigO.trans _ ( h_card_support_aux3.add ( h_card_support_aux.add h_card_support_aux2 ) );
        refine' Asymptotics.IsBigO.of_bound 1 _;
        norm_num [ Finset.filter_or ];
        exact ‚ü® 0, fun n hn => by rw [ abs_of_nonneg ( by positivity ) ] ; exact_mod_cast le_trans ( Finset.card_union_le _ _ ) ( add_le_add_left ( Finset.card_union_le _ _ ) _ ) ‚ü©;
      convert h_card_support using 1

/-
Bound on the number of shifted proper prime powers.
-/
open Asymptotics Filter

lemma count_shifted_proper_prime_powers_bound (k : ‚Ñï) :
    (fun X => (((Finset.range (X + 1)).filter (fun n => is_proper_prime_power (n + k))).card : ‚Ñù)) =O[atTop] (fun X => Real.sqrt (X : ‚Ñù)) := by
      -- The set of proper prime powers up to X is a subset of the set of proper prime powers up to X + k.
      have h_subset : ‚àÄ X, (Finset.filter (fun n => is_proper_prime_power (n + k)) (Finset.range (X + 1))).card ‚â§ (Finset.filter is_proper_prime_power (Finset.range (X + k + 1))).card := by
        intro X;
        have h_subset : Finset.filter (fun n => is_proper_prime_power (n + k)) (Finset.range (X + 1)) ‚äÜ Finset.image (fun m => m - k) (Finset.filter is_proper_prime_power (Finset.range (X + k + 1))) := by
          intro n hn; aesop;
          grind;
        exact le_trans ( Finset.card_le_card h_subset ) ( Finset.card_image_le );
      -- The number of proper prime powers up to X + k is bounded by O(‚àö(X + k)).
      have h_card_bound : (fun X : ‚Ñï => (Finset.filter is_proper_prime_power (Finset.range (X + k + 1))).card : ‚Ñï ‚Üí ‚Ñù) =O[atTop] fun X : ‚Ñï => Real.sqrt (X + k) := by
        have h_card_bound : (fun X : ‚Ñï => (Finset.filter is_proper_prime_power (Finset.range (X + 1))).card : ‚Ñï ‚Üí ‚Ñù) =O[atTop] fun X : ‚Ñï => Real.sqrt X := by
          exact?;
        have := h_card_bound.comp_tendsto ( show Filter.Tendsto ( fun X : ‚Ñï => X + k ) Filter.atTop Filter.atTop from Filter.tendsto_add_atTop_nat k );
        convert this using 1;
        exact funext fun X => by rw [ Function.comp_apply ] ; norm_cast;
      refine' Asymptotics.IsBigO.trans _ ( h_card_bound.trans _ );
      ¬∑ norm_num [ Asymptotics.isBigO_iff ];
        exact ‚ü® 1, 0, fun n hn => by simpa using mod_cast h_subset n ‚ü©;
      ¬∑ refine' Asymptotics.IsBigO.of_bound 2 _;
        simp +zetaDelta at *;
        exact ‚ü® k + 1, fun n hn => by rw [ abs_of_nonneg ( Real.sqrt_nonneg _ ), abs_of_nonneg ( Real.sqrt_nonneg _ ) ] ; exact Real.sqrt_le_iff.mpr ‚ü® by positivity, by nlinarith [ Real.mul_self_sqrt ( show ( 0:‚Ñù ) ‚â§ n by positivity ), Real.sqrt_nonneg n, show ( n:‚Ñù ) ‚â• k + 1 by norm_cast ] ‚ü© ‚ü©

/-
Explicit summation formula for Bell(X).
-/
open ArithmeticFunction

theorem Bell_eq_sum (X : ‚Ñï) :
    Bell X = -2 * Finset.sum (Finset.range (X - 1)) (fun n => (vonMangoldt n : ‚ÑÇ) * (vonMangoldt (n + 2) : ‚ÑÇ) * œá‚ÇÑ n * œá‚ÇÑ (n + 2) * e (n / 4)) := by
      unfold Bell; norm_num [ div_eq_mul_inv ] ; ring; aesop;
      -- By definition of $g_œá$, we can expand the inner product.
      have h_expand : inner ‚ÑÇ (g_œá X) ((op_commutator (F_op (1 / 4)) (U_op 2)) (g_œá X)) = ‚àë n ‚àà Finset.range (X + 1), ‚àë m ‚àà Finset.range (X + 1), (vonMangoldt n : ‚ÑÇ) * (œá‚ÇÑ n : ‚ÑÇ) * (vonMangoldt m : ‚ÑÇ) * (œá‚ÇÑ m : ‚ÑÇ) * inner ‚ÑÇ (ket n) ((op_commutator (F_op (1 / 4)) (U_op 2)) (ket m)) := by
        have h_expand : g_œá X = ‚àë n ‚àà Finset.range (X + 1), (vonMangoldt n : ‚ÑÇ) ‚Ä¢ (œá‚ÇÑ n : ‚ÑÇ) ‚Ä¢ ket n := by
          exact?;
        simp +decide [ h_expand, inner_sum, inner_smul_left ];
        simp +decide [ mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _, Finset.sum_mul ];
        rw [ Finset.sum_comm ] ; congr ; ext ; congr ; ext ; ring;
        unfold œá‚ÇÑ; norm_num ; ring;
      -- By definition of $F_op$ and $U_op$, we can simplify the inner product.
      have h_inner : ‚àÄ n m : ‚Ñï, inner ‚ÑÇ (ket n) ((op_commutator (F_op (1 / 4)) (U_op 2)) (ket m)) = -2 * (if n = m + 2 then (e (m / 4) : ‚ÑÇ) else 0) := by
        unfold op_commutator; aesop;
        ¬∑ unfold F_op U_op; aesop; ring;
          unfold F_lin U_lin; norm_num [ ket ] ; ring;
          unfold F_fun U_fun; norm_num [ inner ] ; ring;
          rw [ tsum_eq_single ( 2 + m ), tsum_eq_single ( 2 + m ) ] <;> aesop;
          norm_num [ add_comm, Pi.single_apply ] ; ring;
          unfold e; ring; norm_num [ mul_div, Complex.ext_iff, Complex.exp_re, Complex.exp_im ] ; ring;
          norm_num [ Real.cos_add, Real.sin_add, mul_div ] ; ring ; norm_num;
        ¬∑ unfold F_op U_op; norm_num [ inner ] ; ring;
          unfold F_lin U_lin ket; aesop;
          rw [ tsum_eq_single n, tsum_eq_single n ] <;> aesop;
          unfold F_fun U_fun; aesop;
          rw [ Pi.single_apply ] ; aesop;
      simp_all +decide [ mul_assoc, mul_comm, mul_left_comm, Finset.sum_ite ];
      norm_num [ Finset.sum_filter, add_comm ];
      rw [ Finset.sum_comm ] ; norm_num [ Finset.sum_ite, Finset.filter_eq', Finset.filter_ne' ] ; ring;
      rw [ Finset.sum_mul ] ; rw [ show ( Finset.filter ( fun x => 2 + x < 1 + X ) ( Finset.range ( 1 + X ) ) ) = Finset.range ( X - 1 ) from Finset.ext fun x => by aesop <;> omega ] ;