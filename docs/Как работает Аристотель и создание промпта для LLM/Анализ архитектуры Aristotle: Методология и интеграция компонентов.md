# Анализ архитектуры Aristotle: Методология и интеграция компонентов

## 1. Общая архитектура системы

Aristotle функционирует как интегрированная система с тремя основными компонентами, работающими в синергии:

```
┌─────────────────────────────────────────────────────────────────┐
│                    ВХОДНАЯ ЗАДАЧА                              │
│              (Формальная или неформальная)                      │
└────────────────────────┬────────────────────────────────────────┘
                         │
         ┌───────────────┴───────────────┐
         │                               │
         ▼                               ▼
    ┌─────────────┐           ┌──────────────────┐
    │ Geometry?   │           │ Algebra/Logic?   │
    └─────────────┘           └──────────────────┘
         │ Да                        │ Да
         ▼                           ▼
    ┌─────────────────────┐    ┌──────────────────────────┐
    │  Yuclid (Geometry   │    │ Lemma-Based Informal     │
    │  Solver)            │    │ Reasoning System         │
    │                     │    │                          │
    │ • Diagram parsing   │    │ • Generate informal proof│
    │ • Algebraic rules   │    │ • Decompose into lemmas  │
    │ • Deductive DB      │    │ • Create aux definitions │
    └─────────────────────┘    └──────────────────────────┘
         │                            │
         └─────────────┬──────────────┘
                       │
                       ▼
         ┌──────────────────────────┐
         │ Autoformalization        │
         │ Pipeline                 │
         │                          │
         │ • Convert to Lean        │
         │ • Iterative refinement   │
         │ • Error feedback loop    │
         └──────────────┬───────────┘
                        │
                        ▼
         ┌──────────────────────────────────┐
         │ Lean Proof Search (MCGS)         │
         │                                  │
         │ • Monte Carlo Graph Search       │
         │ • Transformer policy/value       │
         │ • Parallel tactic exploration    │
         │ • Lean kernel verification      │
         └──────────────┬───────────────────┘
                        │
                        ▼
         ┌──────────────────────────┐
         │ ПОЛНОЕ ДОКАЗАТЕЛЬСТВО    │
         │ (Lean 4 + Mathlib)       │
         │ Без пропусков (sorry)    │
         └──────────────────────────┘
```

---

## 2. Детальное описание каждого компонента

### 2.1 Lean Proof Search Algorithm (Основной движок)

#### Входные данные:
- Блок кода Lean с пропусками (`sorry` утверждения)
- Опционально: неформальное доказательство
- Proof state (текущее состояние доказательства)

#### Процесс работы:

**Шаг 1: Инициализация MCGS**
- Создаётся граф состояний, где каждый узел — это proof state
- Начальное состояние — исходная цель с `sorry`
- Рёбра — применения Lean тактик

**Шаг 2: Генеративная политика (Policy)**
```
Input: [proof_state, proof_history, informal_proof]
↓
Transformer Model (200B+ параметров)
↓
Output: Вероятностное распределение над тактиками Lean
Примеры тактик: intro, cases, simp, rw, apply, exact, ...
```

**Шаг 3: Выборка тактик**
- Используется progressively widened sampling
- Выбираются несколько наиболее перспективных тактик
- Каждая тактика может создавать несколько подцелей

**Шаг 4: Оценка состояния (Value function)**
```
Input: proof_state
↓
Transformer Model (тот же, что и для policy)
↓
Output: Скалярная оценка вероятности успешного доказательства
```

**Шаг 5: PUCT-выбор (Predictor Upper Confidence Bound)**
- Балансирует исследование (exploration) и эксплуатацию (exploitation)
- Приоритизирует действия с высокой оценкой и хорошим балансом

**Шаг 6: Параллельное исследование**
- Множественные экземпляры поиска работают параллельно
- Каждый исследует разные ветви
- Результаты агрегируются

**Шаг 7: Верификация Lean**
- Lean kernel проверяет корректность каждого шага
- Только верифицированные шаги добавляются в граф
- Неверные тактики отбрасываются

#### Выходные данные:
- Полное доказательство (все `sorry` заменены на тактики)
- Или частичное доказательство (для интеграции с другими компонентами)

#### Ключевые параметры:
- **Глубина поиска:** сколько шагов вперёд смотреть
- **Ширина поиска:** сколько тактик рассматривать на каждом шаге
- **Время вычисления:** бюджет для параллельного поиска
- **Температура sampling:** контролирует разнообразие выбираемых тактик

---

### 2.2 Lemma-Based Informal Reasoning System

#### Входные данные:
- Математическая задача (естественный язык)
- Опционально: формальное утверждение

#### Процесс работы:

**Фаза 1: Proof Narrative Elicitation**
```
Задача: "Доказать, что для всех натуральных n > 1, 
         сумма делителей n больше n"

LLM генерирует нарратив:
"Пусть n > 1. Рассмотрим делители n.
1 всегда делит n, и 1 < n.
Если n > 1, то n также делит n.
Поэтому сумма делителей ≥ 1 + n > n."
```

**Фаза 2: Decomposition into Lemmas**
```
Из нарратива извлекаются леммы:

Лемма 1: 1 делит любое натуральное число
Лемма 2: n делит n для любого n
Лемма 3: Если n > 1, то 1 + n > n
Лемма 4: Сумма делителей включает 1 и n
```

**Фаза 3: Auxiliary Definitions**
```
Создаются вспомогательные определения:

def divisors (n : ℕ) : Set ℕ := {d | d ∣ n}

def sum_of_divisors (n : ℕ) : ℕ := 
  ∑ d in (divisors n), d

def is_abundant (n : ℕ) : Prop :=
  sum_of_divisors n > n
```

**Фаза 4: Autoformalization Pipeline**
```
Неформальная лемма:
"1 делит любое натуральное число"
        ↓
Попытка формализации:
lemma one_divides_all (n : ℕ) : 1 ∣ n := by
  sorry
        ↓
Lean пытается верифицировать
        ↓
Если ошибка, парсится и возвращается в неформальный слой:
"Ошибка: нужно использовать Nat.one_dvd вместо 1 ∣ n"
        ↓
Исправление и повторная попытка:
lemma one_divides_all (n : ℕ) : 1 ∣ n :=
  Nat.one_dvd n
        ↓
Успех! Лемма добавлена в базу
```

**Фаза 5: Iterative Refinement**
- Если доказательство леммы не удаётся, система возвращается на Фазу 1
- Генерируется альтернативный нарратив
- Процесс повторяется до успеха

#### Выходные данные:
- Набор неформальных лемм
- Набор формализованных лемм в Lean
- Вспомогательные определения
- Sketch доказательства (основная структура)

#### Ключевые параметры:
- **Максимальное количество лемм:** сколько подзадач разложить
- **Глубина разложения:** насколько детально разбивать
- **Количество итераций:** сколько раз пытаться переформулировать
- **Творческость:** насколько необычные определения создавать

---

### 2.3 Geometry Solver (Yuclid)

#### Входные данные:
- Диаграмма (координаты точек, отношения)
- Геометрическая задача

#### Процесс работы:

**Шаг 1: Diagram Preprocessing**
```
Входная диаграмма:
Points: A(0,0), B(1,0), C(0.5, √3/2)
Relations: AB = BC = CA (равносторонний треугольник)

Парсинг и нормализация:
- Идентификация стандартных конфигураций
- Поиск середин, биссектрис, перпендикуляров
- Численное сопоставление правил
```

**Шаг 2: Configuration Recognition**
```
Обнаруженные конфигурации:
- Равносторонний треугольник ABC
- Все углы = 60°
- Все стороны равны
```

**Шаг 3: Algebraic Encoding**
```
Конфигурации кодируются в уравнения:

Для перпендикулярности:
AB ⊥ CD ⟺ AC² + BD² = AD² + BC²

Для подобия:
△ABC ~ △DEF ⟺ AB/DE = BC/EF = CA/FD

Для параллельности:
AB ∥ CD ⟺ (slope AB) = (slope CD)
```

**Шаг 4: Gaussian Elimination**
```
Система уравнений решается методом Гаусса:
- Исключение переменных
- Упрощение выражений
- Получение численных или символических результатов
```

**Шаг 5: Deductive Database Query**
```
Запрос в дедуктивную базу:
"Какие свойства следуют из равностороннего треугольника?"

Ответ из БД:
- Все углы = 60°
- Все стороны равны
- Центр совпадает с центроидом
- Высота = (√3/2) * сторона
```

**Шаг 6: Lean Codification**
```
Результаты кодифицируются как Lean факты:

lemma equilateral_triangle_angles (A B C : Point) :
  (AB = BC) ∧ (BC = CA) → 
  (∠ABC = 60°) ∧ (∠BCA = 60°) ∧ (∠CAB = 60°) := by
  sorry  -- заполняется Yuclid

lemma equilateral_triangle_height (A B C : Point) :
  (AB = BC) ∧ (BC = CA) →
  height = (Real.sqrt 3 / 2) * AB := by
  sorry  -- заполняется Yuclid
```

#### Выходные данные:
- Набор Lean фактов о геометрической конфигурации
- Численные значения (если применимо)
- Символические выражения

#### Ключевые параметры:
- **Точность численных вычислений:** сколько знаков сохранять
- **Размер дедуктивной БД:** количество известных правил
- **Максимальное количество фактов:** сколько свойств извлечь

---

## 3. Интеграция компонентов

### 3.1 Общий workflow

```
ВХОДНАЯ ЗАДАЧА
      ↓
┌─────────────────────────────────────────┐
│ Классификация задачи                    │
│ - Геометрия?                            │
│ - Алгебра/логика?                       │
│ - Комбинаторика?                        │
└─────────────────────────────────────────┘
      ↓
      ├─→ ГЕОМЕТРИЯ
      │   ├─→ Yuclid (параллельно)
      │   └─→ Результаты → Lean факты
      │
      └─→ ОСТАЛЬНОЕ
          ├─→ Informal Reasoning (параллельно)
          │   ├─→ Генерация нарратива
          │   ├─→ Разложение на леммы
          │   └─→ Autoformalization
          │
          └─→ Lean Proof Search (параллельно)
              ├─→ MCGS с трансформером
              ├─→ Параллельное исследование
              └─→ Lean верификация
      ↓
┌─────────────────────────────────────────┐
│ Агрегация результатов                   │
│ - Объединение фактов от Yuclid          │
│ - Объединение лемм от Informal         │
│ - Объединение доказательств от Search  │
└─────────────────────────────────────────┘
      ↓
┌─────────────────────────────────────────┐
│ Финальная верификация                   │
│ - Lean kernel проверка                  │
│ - Нет пропусков (sorry)?                │
│ - Нет неправильных аксиом?              │
└─────────────────────────────────────────┘
      ↓
ПОЛНОЕ ДОКАЗАТЕЛЬСТВО (или НЕУДАЧА)
```

### 3.2 Параллелизм и асинхронность

Aristotle использует масштабное параллелизм:

1. **Параллельный поиск тактик** (Lean Proof Search)
   - Множество экземпляров MCGS работают одновременно
   - Каждый исследует разные ветви
   - Результаты объединяются

2. **Параллельная генерация лемм** (Informal Reasoning)
   - Несколько лемм формализуются одновременно
   - Независимые леммы обрабатываются в параллель

3. **Параллельная обработка Yuclid**
   - Несколько геометрических фактов извлекаются одновременно

4. **Test-Time Training**
   - Во время инференса модель обучается на собственных следах поиска
   - Улучшает выбор тактик для текущей задачи

### 3.3 Обратная связь и итерация

```
ПОПЫТКА ДОКАЗАТЕЛЬСТВА
      ↓
Lean верификация
      ↓
УСПЕХ? ──→ ДА ──→ ВЫХОД
      │
      └─→ НЕТ
          ↓
    Парсинг ошибки
          ↓
    Тип ошибки?
          ├─→ Синтаксическая ошибка
          │   └─→ Исправить формализацию
          │
          ├─→ Логическая ошибка
          │   └─→ Переформулировать лемму
          │
          └─→ Недостаточно информации
              └─→ Добавить вспомогательные факты
          ↓
    ПОВТОРНАЯ ПОПЫТКА
```

---

## 4. Ключевые механизмы успеха

### 4.1 Комбинация формального и неформального

- **Неформальное рассуждение** обеспечивает гибкость, творчество, интуицию
- **Формальная верификация** обеспечивает надёжность, корректность, проверяемость
- **Вместе** они позволяют решать сложные задачи эффективнее, чем каждый подход отдельно

### 4.2 Модульность и разложение

- Сложные задачи разлагаются на управляемые подзадачи (леммы)
- Каждая подзадача решается независимо
- Результаты объединяются в финальное доказательство

### 4.3 Обучение и адаптация

- **Expert Iteration:** успешные пути поиска используются для переобучения модели
- **Test-Time Training:** модель адаптируется к структуре текущей задачи
- **Feedback Loop:** ошибки используются для улучшения будущих попыток

### 4.4 Масштабируемость

- **Параллелизм:** множество вычислений работают одновременно
- **Большая модель:** 200B+ параметров обеспечивают выразительность
- **Специализированные компоненты:** Yuclid для геометрии, Informal для разложения

---

## 5. Примеры работы

### Пример 1: Алгебраическая задача

```
ЗАДАЧА: Доказать, что для всех натуральных n,
        (n+1)² - n² = 2n + 1

INFORMAL REASONING:
Нарратив: "Раскроем скобки: (n+1)² = n² + 2n + 1
          Вычтем n²: (n+1)² - n² = 2n + 1"

Леммы:
1. (n+1)² = n² + 2n + 1  (раскрытие скобок)
2. (n² + 2n + 1) - n² = 2n + 1  (вычитание)

AUTOFORMALIZATION:
lemma expand_square (n : ℕ) : (n + 1) ^ 2 = n ^ 2 + 2 * n + 1 := by
  ring

lemma subtract_squares (n : ℕ) : (n + 1) ^ 2 - n ^ 2 = 2 * n + 1 := by
  rw [expand_square]
  ring

LEAN PROOF SEARCH:
theorem difference_of_squares (n : ℕ) : (n + 1) ^ 2 - n ^ 2 = 2 * n + 1 := by
  exact subtract_squares n

РЕЗУЛЬТАТ: ✓ Доказано
```

### Пример 2: Геометрическая задача

```
ЗАДАЧА: В равностороннем треугольнике ABC, 
        доказать, что все углы равны 60°

YUCLID:
Диаграмма: A(0,0), B(1,0), C(0.5, √3/2)
Конфигурация: AB = BC = CA (равносторонний)

Алгебраическое кодирование:
- Вычислить углы через скалярное произведение
- ∠ABC = arccos((BA·BC)/(|BA||BC|)) = 60°
- ∠BCA = 60°, ∠CAB = 60°

Lean факты:
lemma equilateral_angles (A B C : Point) :
  (dist A B = dist B C) ∧ (dist B C = dist C A) →
  (angle A B C = 60°) ∧ (angle B C A = 60°) ∧ (angle C A B = 60°) := by
  sorry  -- заполняется Yuclid

LEAN PROOF SEARCH:
theorem triangle_angles_sum (A B C : Point) :
  (dist A B = dist B C) ∧ (dist B C = dist C A) →
  angle A B C + angle B C A + angle C A B = 180° := by
  intro h
  have h1 := equilateral_angles A B C h
  linarith

РЕЗУЛЬТАТ: ✓ Доказано
```

---

## 6. Масштабирование и производительность

### Масштабирование компонентов:

| Компонент | Масштабирование | Результат |
|-----------|-----------------|-----------|
| Lean Search | Больше параллельных потоков | Более глубокий поиск |
| Informal Reasoning | Больше лемм | Более детальное разложение |
| Yuclid | Больше правил в БД | Больше геометрических конфигураций |
| Transformer | Больше параметров | Лучшие предсказания |

### Производительность:

- **IMO 2025:** 5 из 6 задач (золотая медаль)
- **Erdős #124:** решена за 6 часов
- **Масштабирование:** благоприятные свойства при увеличении вычислительных ресурсов

---

## 7. Ограничения и вызовы

1. **Вычислительная сложность:** MCGS может быть дорогостоящей для больших пространств действий
2. **Формализация:** преобразование неформального рассуждения в формальное может быть сложным
3. **Геометрия:** некоторые геометрические конфигурации могут быть не в дедуктивной БД
4. **Масштабируемость:** очень сложные задачи могут требовать экспоненциального времени

---

## 8. Выводы

Aristotle демонстрирует, что **комбинация формального и неформального рассуждения**, поддерживаемая **мощными трансформер-моделями** и **специализированными компонентами**, может достичь человеко-конкурентной производительности на сложных математических задачах.

Ключ к успеху:
- **Модульность** (разложение на леммы)
- **Параллелизм** (одновременное исследование)
- **Обратная связь** (итеративное улучшение)
- **Верификация** (Lean kernel гарантирует корректность)
