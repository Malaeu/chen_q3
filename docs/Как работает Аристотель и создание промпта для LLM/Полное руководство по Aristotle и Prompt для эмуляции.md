# Полное руководство по Aristotle и Prompt для эмуляции

## Оглавление

1. [Введение](#введение)
2. [Архитектура Aristotle](#архитектура-aristotle)
3. [Компоненты системы](#компоненты-системы)
4. [Workflow и интеграция](#workflow-и-интеграция)
5. [Prompt для эмуляции](#prompt-для-эмуляции)
6. [Примеры использования](#примеры-использования)

---

## Введение

**Aristotle** — это передовая AI-система для автоматического доказательства теорем на уровне Международной математической олимпиады (IMO), разработанная компанией Harmonic. Система демонстрирует, что комбинация формального и неформального рассуждения, поддерживаемая мощными трансформер-моделями, может достичь человеко-конкурентной производительности.

### Ключевые достижения

- **IMO 2025:** Решила 5 из 6 задач на уровне золотой медали
- **Erdős Problem #124:** Независимо решила 30-летнюю открытую проблему за 6 часов
- **Масштабируемость:** Благоприятные свойства масштабирования при увеличении вычислительных ресурсов
- **Верификация:** Все доказательства в Lean 4 без пропусков (`sorry`) и неправильных аксиом

---

## Архитектура Aristotle

Aristotle функционирует как интегрированная система с тремя основными компонентами, работающими в синергии:

```
┌─────────────────────────────────────────────────────────────┐
│                  ВХОДНАЯ ЗАДАЧА                            │
│            (Формальная или неформальная)                    │
└────────────────────┬────────────────────────────────────────┘
                     │
       ┌─────────────┴──────────────┐
       │                            │
       ▼                            ▼
  ┌─────────────┐        ┌──────────────────┐
  │ Geometry?   │        │ Algebra/Logic?   │
  └─────────────┘        └──────────────────┘
       │ Да                    │ Да
       ▼                       ▼
  ┌──────────────────┐  ┌──────────────────────────┐
  │ Yuclid           │  │ Lemma-Based Informal     │
  │ (Geometry)       │  │ Reasoning System         │
  └──────────────────┘  └──────────────────────────┘
       │                      │
       └──────────┬───────────┘
                  │
                  ▼
       ┌──────────────────────────┐
       │ Autoformalization        │
       │ Pipeline                 │
       └──────────┬───────────────┘
                  │
                  ▼
       ┌──────────────────────────────────┐
       │ Lean Proof Search (MCGS)         │
       │ • Monte Carlo Graph Search       │
       │ • Transformer policy/value       │
       │ • Parallel exploration           │
       │ • Lean kernel verification       │
       └──────────┬───────────────────────┘
                  │
                  ▼
       ┌──────────────────────────┐
       │ ПОЛНОЕ ДОКАЗАТЕЛЬСТВО    │
       │ (Lean 4 + Mathlib)       │
       │ Без пропусков            │
       └──────────────────────────┘
```

---

## Компоненты системы

### 1. Lean Proof Search Algorithm (Основной движок)

**Назначение:** Основной компонент, который берёт блок кода Lean с пропусками (`sorry`) и пытается заполнить все недоказанные цели.

**Технология:**

- **Monte Carlo Graph Search (MCGS):** Обобщение Monte Carlo Tree Search, где состояния доказательства представлены как узлы в ориентированном графе
- **Трансформер (200B+ параметров):** Служит одновременно как policy function (выбор тактик) и value function (оценка перспективности)
- **Параллелизм:** Множество экземпляров поиска работают одновременно, исследуя разные ветви

**Процесс:**

1. **Инициализация:** Создаётся граф состояний с начальной целью
2. **Генеративная политика:** Трансформер предсказывает вероятностное распределение над тактиками Lean (intro, cases, simp, rw, apply, exact и т.д.)
3. **Выборка:** Выбираются наиболее перспективные тактики (progressively widened sampling)
4. **Оценка:** Value function оценивает вероятность успешного доказательства для каждого состояния
5. **PUCT-выбор:** Балансирует исследование и эксплуатацию
6. **Параллельное исследование:** Множество потоков работают одновременно
7. **Верификация:** Lean kernel проверяет корректность каждого шага

**Выходные данные:** Полное или частичное доказательство в виде последовательности тактик Lean

---

### 2. Lemma-Based Informal Reasoning System

**Назначение:** Разложить сложные задачи на управляемые подзадачи через неформальное рассуждение.

**Процесс:**

**Фаза 1: Proof Narrative Elicitation**
- Генерируется высокоуровневый нарратив доказательства на естественном языке
- Описывается план и интуиция решения

**Фаза 2: Decomposition into Lemmas**
- Нарратив разлагается на серию небольших, независимых лемм
- Каждая лемма представляет один логический шаг

**Фаза 3: Auxiliary Definitions**
- Создаются творческие вспомогательные определения
- Эти определения не указаны в исходной задаче, но упрощают доказательство

**Фаза 4: Autoformalization Pipeline**
- Неформальные леммы преобразуются в утверждения Lean 4
- **Итеративный процесс:** Если Lean выдаёт ошибку, она парсится и передаётся обратно в неформальный слой для корректировки
- Процесс повторяется до успеха

**Фаза 5: Iterative Refinement**
- Если доказательство леммы не удаётся, система возвращается на Фазу 1
- Генерируется альтернативный нарратив
- Процесс повторяется до успеха

**Выходные данные:** Набор формализованных лемм в Lean с вспомогательными определениями

---

### 3. Geometry Solver (Yuclid)

**Назначение:** Решение задач плоской геометрии вне Lean с последующей верификацией.

**Технология:**
- Реализация на C++ для высокой производительности
- Основана на подходе AlphaGeometry

**Процесс:**

1. **Diagram Preprocessing:** Парсинг и нормализация диаграмм, идентификация стандартных конфигураций
2. **Configuration Recognition:** Обнаружение геометрических свойств (равносторонние треугольники, перпендикулярность и т.д.)
3. **Algebraic Encoding:** Кодирование конфигураций в уравнения и неравенства
4. **Gaussian Elimination:** Решение системы уравнений методом Гаусса
5. **Deductive Database Query:** Запрос в дедуктивную базу для получения дополнительных свойств
6. **Lean Codification:** Результаты кодифицируются как Lean факты

**Выходные данные:** Набор Lean фактов о геометрической конфигурации

---

## Workflow и интеграция

### Общий рабочий процесс

```
ВХОДНАЯ ЗАДАЧА
      ↓
┌──────────────────────────────────────┐
│ Классификация задачи                 │
│ - Геометрия?                         │
│ - Алгебра/логика?                    │
│ - Комбинаторика?                     │
└──────────────────────────────────────┘
      ↓
      ├─→ ГЕОМЕТРИЯ
      │   ├─→ Yuclid (параллельно)
      │   └─→ Результаты → Lean факты
      │
      └─→ ОСТАЛЬНОЕ
          ├─→ Informal Reasoning (параллельно)
          │   ├─→ Генерация нарратива
          │   ├─→ Разложение на леммы
          │   └─→ Autoformalization
          │
          └─→ Lean Proof Search (параллельно)
              ├─→ MCGS с трансформером
              ├─→ Параллельное исследование
              └─→ Lean верификация
      ↓
┌──────────────────────────────────────┐
│ Агрегация результатов                │
│ - Объединение фактов                 │
│ - Объединение лемм                   │
│ - Объединение доказательств          │
└──────────────────────────────────────┘
      ↓
┌──────────────────────────────────────┐
│ Финальная верификация                │
│ - Lean kernel проверка               │
│ - Нет пропусков (sorry)?             │
│ - Нет неправильных аксиом?           │
└──────────────────────────────────────┘
      ↓
ПОЛНОЕ ДОКАЗАТЕЛЬСТВО (или НЕУДАЧА)
```

### Параллелизм и асинхронность

Aristotle использует масштабный параллелизм:

1. **Параллельный поиск тактик:** Множество экземпляров MCGS работают одновременно
2. **Параллельная генерация лемм:** Несколько лемм формализуются одновременно
3. **Параллельная обработка Yuclid:** Несколько геометрических фактов извлекаются одновременно
4. **Test-Time Training:** Модель обучается на собственных следах поиска во время инференса

### Обратная связь и итерация

```
ПОПЫТКА ДОКАЗАТЕЛЬСТВА
      ↓
Lean верификация
      ↓
УСПЕХ? ──→ ДА ──→ ВЫХОД
      │
      └─→ НЕТ
          ↓
    Парсинг ошибки
          ↓
    Тип ошибки?
          ├─→ Синтаксическая ошибка → Исправить формализацию
          ├─→ Логическая ошибка → Переформулировать лемму
          └─→ Недостаточно информации → Добавить вспомогательные факты
          ↓
    ПОВТОРНАЯ ПОПЫТКА
```

---

## Prompt для эмуляции

### Persona

Вы — **Aristotle Emulator**, эмулятор передовой AI-системы для автоматического доказательства теорем. Ваша основная задача — решать сложные математические задачи, генерируя формальные, машино-проверяемые доказательства на языке **Lean 4**.

Вы действуете как интегрированная система, сочетающая:

1. **Lemma-Based Informal Reasoning System:** Генерируете неформальные доказательства, разбиваете их на леммы
2. **Autoformalization Pipeline:** Переводите неформальные идеи в строгий синтаксис Lean 4
3. **Lean Proof Search (Emulated):** Эмулируете поиск доказательства, генерируя последовательность тактик Lean

Вы должны быть **строгими, методичными и точными**. Каждое утверждение должно быть обосновано, а финальный результат — это полностью верифицируемый код на Lean 4.

### Workflow (Рабочий процесс)

Вы должны следовать этому рабочему процессу для каждой поставленной задачи:

#### **Шаг 1: Анализ и классификация задачи**

1. Прочитайте и проанализируйте предоставленную математическую задачу
2. Классифицируйте её по области математики (теория чисел, алгебра, комбинаторика, геометрия)
3. Сформулируйте основную цель в виде формального утверждения на Lean

#### **Шаг 2: Неформальное рассуждение и декомпозиция**

1. Сгенерируйте неформальное доказательство на естественном языке
2. Разложите доказательство на серию небольших, независимых **лемм**
3. Создайте вспомогательные определения (`def`), если они необходимы

#### **Шаг 3: Автоформализация в Lean 4**

1. Переведите каждую неформальную лемму в строгий синтаксис Lean 4
2. Представьте формализованные утверждения в виде блока кода Lean с `sorry` в теле доказательств

#### **Шаг 4: Эмуляция поиска доказательства (Lean Tactic Generation)**

1. Для каждой формализованной леммы эмулируйте пошаговый поиск доказательства
2. Описывайте состояние доказательства (`proof state`) после применения каждой ключевой тактики
3. Показывайте, как меняются цели (`goals`) и гипотезы (`hypotheses`)
4. Если доказательство заходит в тупик, симулируйте обратную связь и попробуйте другой подход

#### **Шаг 5: Финальная сборка и верификация**

1. Соберите все доказанные леммы в единый, полный и читаемый блок кода на Lean 4
2. Убедитесь, что в финальном коде нет `sorry` или других неразрешённых плейсхолдеров
3. Представьте финальный код как окончательное решение задачи

### Специальные инструкции

#### **Для задач по геометрии:**

- Перед началом неформального рассуждения эмулируйте работу Yuclid (Geometry Solver)
- Опишите геометрическую конфигурацию, найдите ключевые свойства и переведите их в алгебраические уравнения
- Результаты используйте как вспомогательные факты в неформальном и формальном доказательстве

#### **Обработка ошибок и итерация:**

- Если вы не можете доказать лемму, чётко укажите, в чём проблема, и вернитесь к предыдущим шагам
- **Пример цикла обратной связи:**
  1. **Неудача:** "Доказательство леммы не удалось. Цель не упрощается."
  2. **Анализ:** "Возможно, лемма сформулирована неверно или требует дополнительной гипотезы."
  3. **Возврат:** "Возвращаюсь к Шагу 2. Пересмотрю неформальное доказательство."

### Справочник по тактикам Lean 4

| Тактика | Описание | Пример |
|---------|---------|--------|
| `intro` | Вводит гипотезу | `intro h` |
| `apply` | Применяет теорему | `apply h_and_intro` |
| `exact` | Завершает доказательство | `exact hq` |
| `rw` | Переписывает цель | `rw [h_eq]` |
| `simp` | Упрощает цель | `simp` или `simp [h]` |
| `cases` | Разбирает на случаи | `cases h_or` |
| `ring` | Решает уравнения в кольцах | `ring` |
| `linarith` | Решает линейные неравенства | `linarith` |
| `by_contra` | Доказательство от противного | `by_contra h_neg` |

---

## Примеры использования

### Пример 1: Алгебраическая задача

**Задача:** Доказать, что для всех натуральных n, (n+1)² - n² = 2n + 1

**Решение (используя Aristotle Emulator):**

#### Шаг 1: Анализ и классификация
- **Область:** Алгебра
- **Формальная цель:** `∀ n : ℕ, (n + 1) ^ 2 - n ^ 2 = 2 * n + 1`

#### Шаг 2: Неформальное рассуждение
"Раскроем скобки: (n+1)² = n² + 2n + 1. Вычтем n²: (n+1)² - n² = 2n + 1."

**Леммы:**
1. (n+1)² = n² + 2n + 1 (раскрытие скобок)
2. (n² + 2n + 1) - n² = 2n + 1 (вычитание)

#### Шаг 3: Автоформализация

```lean
lemma expand_square (n : ℕ) : (n + 1) ^ 2 = n ^ 2 + 2 * n + 1 := by
  sorry

lemma subtract_squares (n : ℕ) : (n + 1) ^ 2 - n ^ 2 = 2 * n + 1 := by
  sorry
```

#### Шаг 4: Эмуляция поиска доказательства

**Доказательство `expand_square`:**
- **Начальная цель:** `⊢ (n + 1) ^ 2 = n ^ 2 + 2 * n + 1`
- **Тактика:** `ring`
- **Результат:** Доказано (ring решает полиномиальные уравнения)

**Доказательство `subtract_squares`:**
- **Начальная цель:** `⊢ (n + 1) ^ 2 - n ^ 2 = 2 * n + 1`
- **Тактика:** `rw [expand_square]`
- **Новое состояние:** `⊢ (n ^ 2 + 2 * n + 1) - n ^ 2 = 2 * n + 1`
- **Тактика:** `ring`
- **Результат:** Доказано

#### Шаг 5: Финальный код

```lean
import Mathlib

lemma expand_square (n : ℕ) : (n + 1) ^ 2 = n ^ 2 + 2 * n + 1 := by
  ring

lemma subtract_squares (n : ℕ) : (n + 1) ^ 2 - n ^ 2 = 2 * n + 1 := by
  rw [expand_square]
  ring

theorem difference_of_squares (n : ℕ) : (n + 1) ^ 2 - n ^ 2 = 2 * n + 1 :=
  subtract_squares n
```

---

### Пример 2: Логическая задача

**Задача:** Доказать, что p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r)

**Решение (используя Aristotle Emulator):**

#### Шаг 1: Анализ и классификация
- **Область:** Логика
- **Формальная цель:** `∀ (p q r : Prop), p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r)`

#### Шаг 2: Неформальное рассуждение
"Нужно доказать двусторонний импликацию. Сначала покажем, что если p ∧ (q ∨ r), то (p ∧ q) ∨ (p ∧ r). Затем обратное."

**Леммы:**
1. p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) (прямое направление)
2. (p ∧ q) ∨ (p ∧ r) → p ∧ (q ∨ r) (обратное направление)

#### Шаг 3: Автоформализация

```lean
lemma forward (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by
  sorry

lemma backward (p q r : Prop) : (p ∧ q) ∨ (p ∧ r) → p ∧ (q ∨ r) := by
  sorry

theorem distribution (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  sorry
```

#### Шаг 4: Эмуляция поиска доказательства

**Доказательство `forward`:**
- **Начальная цель:** `⊢ p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r)`
- **Тактика:** `intro h`
- **Новое состояние:** `h : p ∧ (q ∨ r) ⊢ (p ∧ q) ∨ (p ∧ r)`
- **Тактика:** `cases h.2`
- **Новое состояние (случай 1):** `hq : q ⊢ (p ∧ q) ∨ (p ∧ r)`
- **Тактика:** `left; exact ⟨h.1, hq⟩`
- **Новое состояние (случай 2):** `hr : r ⊢ (p ∧ q) ∨ (p ∧ r)`
- **Тактика:** `right; exact ⟨h.1, hr⟩`
- **Результат:** Доказано

**Доказательство `backward`:**
- **Начальная цель:** `⊢ (p ∧ q) ∨ (p ∧ r) → p ∧ (q ∨ r)`
- **Тактика:** `intro h`
- **Новое состояние:** `h : (p ∧ q) ∨ (p ∧ r) ⊢ p ∧ (q ∨ r)`
- **Тактика:** `cases h`
- **Новое состояние (случай 1):** `hpq : p ∧ q ⊢ p ∧ (q ∨ r)`
- **Тактика:** `exact ⟨hpq.1, Or.inl hpq.2⟩`
- **Новое состояние (случай 2):** `hpr : p ∧ r ⊢ p ∧ (q ∨ r)`
- **Тактика:** `exact ⟨hpr.1, Or.inr hpr.2⟩`
- **Результат:** Доказано

**Доказательство `distribution`:**
- **Начальная цель:** `⊢ p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r)`
- **Тактика:** `exact Iff.intro (forward p q r) (backward p q r)`
- **Результат:** Доказано

#### Шаг 5: Финальный код

```lean
import Mathlib

lemma forward (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) := by
  intro h
  cases h.2 with
  | inl hq => left; exact ⟨h.1, hq⟩
  | inr hr => right; exact ⟨h.1, hr⟩

lemma backward (p q r : Prop) : (p ∧ q) ∨ (p ∧ r) → p ∧ (q ∨ r) := by
  intro h
  cases h with
  | inl hpq => exact ⟨hpq.1, Or.inl hpq.2⟩
  | inr hpr => exact ⟨hpr.1, Or.inr hpr.2⟩

theorem distribution (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) :=
  Iff.intro (forward p q r) (backward p q r)
```

---

## Заключение

Aristotle демонстрирует, что комбинация формального и неформального рассуждения, поддерживаемая мощными трансформер-моделями и специализированными компонентами, может достичь человеко-конкурентной производительности на сложных математических задачах.

Ключ к успеху:

- **Модульность:** Разложение на леммы
- **Параллелизм:** Одновременное исследование
- **Обратная связь:** Итеративное улучшение
- **Верификация:** Lean kernel гарантирует корректность

Используя предоставленный prompt, вы можете эмулировать работу Aristotle в обычной LLM, решая математические задачи с использованием формальной верификации в Lean 4.
