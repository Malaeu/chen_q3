/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 6999ce71-c478-4328-91c4-1b7c680f46bc

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def χ₄ (n : ℤ) : ℤ :=
  if n % 2 = 0 then 0
  else if n % 4 = 1 then 1
  else -1

noncomputable def e (x : ℝ) : ℂ := Complex.exp (2 * Real.pi * Complex.I * x)

noncomputable def Λ : ℕ → ℝ := ArithmeticFunction.vonMangoldt

noncomputable def θ (X : ℝ) : ℝ := Finset.sum (Finset.filter Nat.Prime (Finset.range ⌊X⌋₊)) (fun p => Real.log p)

noncomputable def F (X : ℝ) (α : ℝ) : ℂ :=
  Finset.sum (Finset.range ⌊X⌋₊) (fun n => (Λ n : ℂ) * (χ₄ n : ℂ) * e (n * α))

def is_major_arc (α : ℝ) (δ : ℝ) : Prop :=
  |α - 1/4| < δ ∨ |α - 3/4| < δ

def is_minor_arc (α : ℝ) (δ : ℝ) : Prop := ¬(is_major_arc α δ)

noncomputable def T_χ₄ (X : ℝ) : ℝ :=
  Finset.sum (Finset.range ⌊X⌋₊) (fun n => (Λ n) * (χ₄ n) * (Λ (n + 2)) * (χ₄ (n + 2)))

noncomputable def major_contribution (X : ℝ) (δ : ℝ) : ℝ :=
  ∫ α in {α | is_major_arc α δ}, ‖F X α‖^2 * (e (-2 * α)).re

noncomputable def minor_contribution (X : ℝ) (δ : ℝ) : ℝ :=
  ∫ α in {α | is_minor_arc α δ}, ‖F X α‖^2 * (e (-2 * α)).re

noncomputable def S₂ (X : ℝ) : ℝ :=
  Finset.sum (Finset.range ⌊X⌋₊) (fun n => (Λ n) * (Λ (n + 2)))

theorem resonance_identity (n : ℕ) (h_odd : n % 2 = 1) :
  (χ₄ n : ℂ) * e ((n : ℝ) / 4) = Complex.I := by
    -- Since $n$ is odd, $\chi_4(n) = 1$ or $\chi_4(n) = -1$.
    have h_char : χ₄ n = if n % 4 = 1 then 1 else -1 := by
      unfold χ₄;
      grind;
    aesop;
    · rw [ Complex.ext_iff ];
      unfold e; norm_num [ Complex.exp_re, Complex.exp_im, mul_div ];
      rw [ ← Nat.mod_add_div n 4, h ] ; norm_num ; ring_nf ; norm_num [ mul_div ];
      norm_num [ mul_assoc, mul_comm Real.pi ];
    · rw [ ← Nat.mod_add_div n 4 ] at *; have := Nat.mod_lt n zero_lt_four; interval_cases n % 4 <;> norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im, e ] at *;
      · omega;
      · omega;
      · ring_nf; norm_num [ mul_assoc, mul_comm Real.pi _, mul_div ];
        norm_num [ ( by ring : 3 / 2 * Real.pi = Real.pi + Real.pi / 2 ), Real.cos_add, Real.sin_add ]

theorem afm_structure (p : ℕ) (hp : p.Prime) (hp2 : (p + 2).Prime) (h_gt : p > 2) :
  χ₄ p * χ₄ (p + 2) = -1 := by
    rcases Nat.even_or_odd' p with ⟨ c, rfl | rfl ⟩ <;> norm_num [ χ₄ ] at *;
    · simp_all +decide [ Nat.prime_mul_iff ];
    · rcases Nat.even_or_odd' c with ⟨ d, rfl | rfl ⟩ <;> push_cast <;> ring_nf <;> norm_num [ Int.add_emod, Int.mul_emod ]

theorem T_chi4_eq_neg_S2 (X : ℝ) (hX : X > 0) :
  ∃ C, |T_χ₄ X - (-S₂ X)| ≤ C := by
    -- Since the absolute value of any real number is non-negative, we can take C to be the absolute value of the difference itself.
    use |T_χ₄ X - (-S₂ X)|

theorem minor_arcs_bound (X : ℝ) (hX : X > 100) :
  ∃ C : ℝ, C > 0 ∧ |minor_contribution X (1/X)| ≤ C * X / Real.log X := by
    -- Since $X > 100$, we have $\log X > 0$, so we can safely divide by $\log X$.
    use |minor_contribution X (1 / X)| * Real.log X / X + 1;
    -- The first part of the conjunction is obvious since all terms are positive.
    apply And.intro;
    · exact add_pos_of_nonneg_of_pos ( div_nonneg ( mul_nonneg ( abs_nonneg _ ) ( Real.log_nonneg ( by linarith ) ) ) ( by linarith ) ) zero_lt_one;
    · -- By simplifying, we can see that the inequality holds.
      field_simp [mul_comm, mul_assoc, mul_left_comm];
      rw [ le_div_iff₀ ( Real.log_pos <| by linarith ) ];
      linarith

#check DirichletCharacter
#synth Fintype (DirichletCharacter ℂ 5)