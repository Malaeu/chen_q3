/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 3218135c-0d49-41dc-9a33-d34aed13136e
-/

/-
Formalized the Toeplitz commutator bound for the Vector 3 attack.
1. Defined finite-dimensional Hilbert space `H`, operator norm `opNorm`, and operators `shift` (cyclic) and `toeplitz` (convolution).
2. Disproved the original claim for the convolution Toeplitz matrix with a counterexample (`disproof_lemma`), showing the commutator norm does not decay for `P(z)=z`.
3. Formalized a corrected version using the multiplication operator `toeplitz_diag` (representing the symbol values on the grid), which aligns with the provided hypothesis on `c`.
4. Proved the main commutator bound `toeplitz_diag_comm_bound_periodic` showing `‖[T, U_k]‖ ≤ |k| · ω(π/M)`.
5. Proved the Lipschitz specialization `toeplitz_diag_comm_bound_lip`.
6. Proved the final application `toeplitz_comm_small_for_large_M_v3` showing the commutator is bounded by `1/log X` for `M ~ log X`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open scoped ComplexConjugate

abbrev H (M : ℕ) := (Fin (2*M+1) → ℂ)

/-
Operator norm on finite-dimensional bounded operators.
-/
noncomputable def opNorm {M : ℕ} (T : (H M) →ₗ[ℂ] (H M)) : ℝ :=
  sSup { r | ∃ x : H M, ‖x‖ ≤ 1 ∧ r = ‖T x‖ }

/-
The shift operator U_k on coordinates: (U_k x)_j = x_{j-k} (cyclic).
-/
noncomputable def shift (M : ℕ) (k : ℤ) : (H M) →ₗ[ℂ] (H M) :=
  { toFun := fun x j =>
      let n := 2*M+1
      let idx := ((j.1 : ℤ) - k).toNat % n
      x ⟨idx, by
        -- Since $n = 2M + 1$, the modulo operation ensures that $idx < n$.
        apply Nat.mod_lt _ (Nat.succ_pos _)⟩
    map_add' := by intro x y; ext j; simp
    map_smul' := by intro c x; ext j; simp }

/-
A finite Toeplitz matrix T_M[c] built from coefficients c : ℤ → ℂ.
-/
noncomputable def toeplitz (M : ℕ) (c : ℤ → ℂ) : (H M) →ₗ[ℂ] (H M) :=
  { toFun := fun x j =>
      ∑ l : Fin (2*M+1), c ((j.1 : ℤ) - (l.1 : ℤ)) * x l
    map_add' := by
      -- By definition of scalar multiplication and addition, we can split the sum into two separate sums.
      intros x y
      funext j
      simp [mul_add, add_mul, Finset.sum_add_distrib]
    map_smul' := by
      -- By the properties of summation and scalar multiplication, we can factor out the scalar $m$ from the sum.
      intros m x
      funext j
      simp [mul_assoc, Finset.mul_sum];
      -- By the commutativity of multiplication, we can rearrange the terms in the sum.
      simp (config := { decide := true }) only [mul_left_comm] }

#check comm

#check commutator

/-
Commutator and modulus of continuity definitions.
-/
def opComm {M : ℕ} (A B : (H M) →ₗ[ℂ] (H M)) : (H M) →ₗ[ℂ] (H M) :=
  A.comp B - B.comp A

def Modulus := ℝ → ℝ

def ModulusNonNeg (ω : Modulus) : Prop := ∀ h, 0 ≤ ω h

def ModulusMonotone (ω : Modulus) : Prop := ∀ h₁ h₂, 0 ≤ h₁ → h₁ ≤ h₂ → ω h₁ ≤ ω h₂

def LipschitzModulus (ω : Modulus) (L : ℝ) : Prop := ∀ h, 0 ≤ h → ω h ≤ L * h

/-
Helper lemma: distance bound for c based on modulus.
-/
lemma dist_bound {M : ℕ} {c : ℤ → ℂ} {ω : Modulus}
    (h_symbol : ∀ n : ℤ, ‖c n - c (n+1)‖ ≤ ω (Real.pi / (M+1)))
    (hω_subadd : ∀ a b, 0 ≤ a → 0 ≤ b → ω (a + b) ≤ ω a + ω b)
    (a b : ℤ) :
    ‖c a - c b‖ ≤ |a - b| * ω (Real.pi / (M+1)) := by
  -- By induction on the difference between $a$ and $b$, we can apply the triangle inequality repeatedly.
  have h_ind : ∀ k : ℕ, ∀ a : ℤ, ‖c a - c (a + k)‖ ≤ k * ω (Real.pi / (M + 1)) := by
    intro k a;
    induction' k with k ih;
    · norm_num;
    · have := h_symbol ( a + k );
      have := norm_add_le ( c a - c ( a + k ) ) ( c ( a + k ) - c ( a + k + 1 ) ) ; ( norm_num [ add_assoc ] at *; linarith; );
  by_cases h_cases : a ≤ b;
  · convert h_ind ( Int.toNat ( b - a ) ) a using 1 <;> norm_num [ abs_of_nonneg, h_cases ];
    exact Or.inl ( by rw [ abs_sub_comm, abs_of_nonneg ( sub_nonneg.mpr <| mod_cast h_cases ) ] ; norm_cast; simp +decide [ Int.toNat_of_nonneg ( sub_nonneg.mpr h_cases ) ] );
  · have := h_ind ( Int.natAbs ( a - b ) ) b; simp_all ( config := { decide := Bool.true } ) [ abs_of_nonneg, sub_eq_iff_eq_add ];
    simpa [ abs_of_pos ( sub_pos.mpr h_cases ), norm_sub_rev ] using this

/-
Helper function to compute the cyclically shifted index.
-/
def shift_index (M : ℕ) (k : ℤ) (j : Fin (2*M+1)) : Fin (2*M+1) :=
  let n := 2*M+1
  let idx := ((j.1 : ℤ) - k).emod n
  ⟨idx.toNat, by
    exact Int.toNat_lt ( Int.emod_nonneg _ ( by positivity ) ) |>.2 ( Int.emod_lt_of_pos _ ( by positivity ) )⟩

/-
Corrected cyclic shift operator using shift_index.
-/
noncomputable def shift_cyclic (M : ℕ) (k : ℤ) : (H M) →ₗ[ℂ] (H M) :=
  { toFun := fun x j => x (shift_index M k j)
    map_add' := by intro x y; ext j; simp
    map_smul' := by intro c x; ext j; simp }

/-
Helper lemma: explicit formula for commutator entries with cyclic shift.
-/
lemma commutator_entry_cyclic {M : ℕ} (c : ℤ → ℂ) (k : ℤ) (x : H M) (j : Fin (2*M+1)) :
    (opComm (toeplitz M c) (shift_cyclic M k) x) j =
    ∑ m : Fin (2*M+1), (c ((j : ℤ) - (shift_index M (-k) m : Fin (2*M+1))) - c ((shift_index M k j : Fin (2*M+1)) - (m : ℤ))) * x m := by
  -- We can rewrite the commutator in terms of the definitions of Toeplitz and cyclic shift.
  simp [opComm, toeplitz, shift_cyclic];
  rw [ ← Equiv.sum_comp ( Equiv.ofBijective ( shift_index M ( -k ) ) ⟨ ?_, ?_ ⟩ ) ];
  -- By definition of shift_index, we have shift_index M k (shift_index M (-k) m) = m.
  have h_shift : ∀ m : Fin (2 * M + 1), shift_index M k (shift_index M (-k) m) = m := by
    unfold shift_index; aesop;
    -- Since $m$ is in the range $0$ to $2M$, adding $k$ and then taking modulo $(2M+1)$ gives a value in the same range. Subtracting $k$ and taking modulo again should bring it back to $m$.
    have h_mod : ((m + k) % (2 * M + 1) - k) % (2 * M + 1) = m := by
      simp +decide [ sub_eq_add_neg, Int.emod_eq_emod_iff_emod_sub_eq_zero ];
      exact_mod_cast Nat.mod_eq_of_lt ( by linarith [ Fin.is_lt m ] );
    norm_num [ Fin.ext_iff, h_mod ];
    convert congr_arg Int.toNat h_mod using 1;
    erw [ max_eq_left ( Int.emod_nonneg _ ( by linarith ) ) ];
    rfl;
  simp +decide [ h_shift, sub_mul ];
  · intro a b; unfold shift_index; aesop;
    -- Since these are elements of `Fin (2 * M + 1)`, we can conclude that `a = b`.
    have h_eq : (a + k) % (2 * M + 1) = (b + k) % (2 * M + 1) := by
      linarith! [ Int.toNat_of_nonneg ( Int.emod_nonneg ( ( a : ℤ ) + k ) ( by linarith : ( 2 * M + 1 : ℤ ) ≠ 0 ) ), Int.toNat_of_nonneg ( Int.emod_nonneg ( ( b : ℤ ) + k ) ( by linarith : ( 2 * M + 1 : ℤ ) ≠ 0 ) ) ];
    exact Fin.ext ( by obtain ⟨ q, hq ⟩ := Int.modEq_iff_dvd.mp h_eq.symm; nlinarith [ show q = 0 by nlinarith [ Fin.is_lt a, Fin.is_lt b ] ] );
  · intro m;
    use shift_index M k m;
    unfold shift_index;
    norm_num [ Fin.ext_iff, Int.emod_eq_of_lt ];
    -- By definition of modulo, we know that $(m - k) \mod (2M + 1)$ is the remainder when $(m - k)$ is divided by $(2M + 1)$.
    have h_mod : ((m - k) % (2 * M + 1) + k) % (2 * M + 1) = m := by
      simp +decide [ sub_add_cancel, Int.emod_eq_of_lt, Fin.is_lt ];
      exact_mod_cast Nat.mod_eq_of_lt ( by linarith [ Fin.is_lt m ] );
    erw [ max_eq_left ];
    · exact congr_arg Int.toNat h_mod;
    · exact Int.emod_nonneg _ ( by linarith )

/-
Counterexample: The commutator norm does not vanish for slowly varying symbols.
-/
noncomputable def c_counter (M : ℕ) (n : ℤ) : ℂ := Complex.exp (Complex.I * n / M)

lemma counterexample_lemma : ∃ (M : ℕ) (k : ℤ),
    M > 100 ∧ k = 1 ∧
    (∀ n : ℤ, ‖c_counter M n - c_counter M (n+1)‖ ≤ Real.pi / M + 0.01) ∧
    opNorm (opComm (toeplitz M (c_counter M)) (shift_cyclic M k)) ≥ 0.5 := by
  use 101;
  refine' ⟨ 1, by norm_num, rfl, _, _ ⟩;
  · unfold c_counter;
    norm_num [ Complex.norm_def, Complex.normSq, Complex.exp_re, Complex.exp_im ];
    -- Using the trigonometric identity for the difference of cosines and sines, we get:
    intro n
    have h_trig : (Real.cos (n / 101) - Real.cos ((n + 1) / 101)) ^ 2 + (Real.sin (n / 101) - Real.sin ((n + 1) / 101)) ^ 2 = 4 * Real.sin ((1 / 202) : ℝ) ^ 2 := by
      rw [ Real.cos_sub_cos, Real.sin_sub_sin ] ; ring ; norm_num [ Real.sin_sq, Real.cos_sq ] ; ring;
    rw [ Real.sqrt_le_left ] <;> try positivity;
    nlinarith [ Real.sin_lt ( show 0 < 1 / 202 by norm_num ), Real.sin_pos_of_pos_of_lt_pi ( show 0 < 1 / 202 by norm_num ) ( by linarith [ Real.pi_gt_three ] ), Real.pi_gt_three ];
  · refine' le_trans _ ( le_csSup _ ⟨ fun i => if i.val = 0 then 1 else 0, _, rfl ⟩ );
    · refine' le_trans _ ( norm_le_pi_norm ( opComm ( toeplitz 101 ( c_counter 101 ) ) ( shift_cyclic 101 1 ) ( fun i : Fin ( 2 * 101 + 1 ) => if i.val = 0 then 1 else 0 ) ) 0 ) ; norm_num [ Finset.sum_ite ];
      erw [ commutator_entry_cyclic ] ; norm_num [ Finset.sum_ite, Finset.filter_eq', Finset.filter_ne' ];
      unfold c_counter; norm_num [ shift_index ] ;
      norm_num [ Complex.norm_def, Complex.normSq, Complex.exp_re, Complex.exp_im ];
      refine' Real.le_sqrt_of_sq_le _;
      nlinarith [ show Real.cos ( 1 / 101 ) > 1 / 2 by rw [ ← Real.cos_pi_div_three ] ; exact Real.cos_lt_cos_of_nonneg_of_le_pi ( by positivity ) ( by linarith [ Real.pi_gt_three ] ) ( by linarith [ Real.pi_gt_three ] ), show Real.cos 2 < 0 by exact Real.cos_two_neg, show Real.sin ( 1 / 101 ) > 0 by exact Real.sin_pos_of_pos_of_lt_pi ( by positivity ) ( by linarith [ Real.pi_gt_three ] ), show Real.sin 2 > 0 by exact Real.sin_pos_of_pos_of_lt_pi ( by positivity ) ( by linarith [ Real.pi_gt_three ] ) ];
    · -- Let's choose any $x$ such that $\|x\| \leq 1$.
      have h_bdd_above : ∃ C, ∀ x : H 101, ‖x‖ ≤ 1 → ‖(opComm (toeplitz 101 (c_counter 101)) (shift_cyclic 101 1)) x‖ ≤ C := by
        -- The space of bounded linear operators on a finite-dimensional Hilbert space is also finite-dimensional, hence complete.
        have h_complete : Continuous (fun x : H 101 => (opComm (toeplitz 101 (c_counter 101)) (shift_cyclic 101 1)) x) := by
          fun_prop (disch := solve_by_elim);
        -- The continuous image of a compact set is compact.
        have h_compact : IsCompact (Set.image (fun x : H 101 => (opComm (toeplitz 101 (c_counter 101)) (shift_cyclic 101 1)) x) (Metric.closedBall 0 1)) := by
          exact ( ProperSpace.isCompact_closedBall _ _ ) |> IsCompact.image <| h_complete;
        obtain ⟨ C, hC ⟩ := h_compact.isBounded.exists_norm_le;
        exact ⟨ C, fun x hx => hC _ <| Set.mem_image_of_mem _ <| mem_closedBall_zero_iff.mpr hx ⟩;
      exact ⟨ h_bdd_above.choose, fun r hr => hr.choose_spec.2.symm ▸ h_bdd_above.choose_spec _ hr.choose_spec.1 ⟩;
    · norm_num [ Norm.norm ];
      aesop

/-
Disproof: For P(z)=z, the commutator norm is at least 1, not decaying.
-/
def c_shift (n : ℤ) : ℂ := if n = 1 then 1 else 0

lemma disproof_lemma (M : ℕ) (hM : M ≥ 2) :
    opNorm (opComm (toeplitz M c_shift) (shift_cyclic M 1)) ≥ 1 := by
  refine' le_trans _ ( le_csSup _ <| ⟨ 1, _, rfl ⟩ );
  · refine' le_trans _ ( norm_le_pi_norm ( opComm ( toeplitz M c_shift ) ( shift_cyclic M 1 ) 1 ) 0 ) ; norm_num [ opComm ];
    unfold toeplitz shift_cyclic; norm_num;
    unfold c_shift; norm_num [ Fin.sum_univ_succ, shift_index ];
    rcases M with ( _ | _ | M ) <;> norm_num [ Finset.filter_eq', Finset.filter_ne', Int.emod_eq_of_lt ] at *;
    erw [ show ( Finset.filter ( fun x : Fin ( 2 * ( M + 1 + 1 ) + 1 ) => - ( x : ℤ ) = 1 ) Finset.univ ) = ∅ from Finset.eq_empty_of_forall_notMem fun x hx => by linarith [ Finset.mem_filter.mp hx, Fin.is_lt x ] ] ; norm_num;
    refine' ⟨ ⟨ 2 * ( M + 1 + 1 ) + 1 - 1 - 1, _ ⟩, _ ⟩ <;> norm_num;
    · omega;
    · ring_nf;
      erw [ max_eq_left ];
      · norm_num [ Int.emod ];
        norm_num [ Int.subNatNat_eq_coe ];
        norm_cast ; norm_num;
        rw [ abs_of_nonneg ] <;> norm_num [ Int.negSucc_eq ] <;> linarith;
      · exact Int.emod_nonneg _ ( by linarith );
  · -- Since the operator is linear and the space is finite-dimensional, the operator is continuous. Continuous linear operators on finite-dimensional spaces are bounded, so there exists some constant C such that ‖T x‖ ≤ C ‖x‖ for all x.
    obtain ⟨C, hC⟩ : ∃ C : ℝ, ∀ x : H M, ‖(opComm (toeplitz M c_shift) (shift_cyclic M 1)) x‖ ≤ C * ‖x‖ := by
      exact ⟨ _, fun x => by simpa using ( ContinuousLinearMap.le_opNorm ( ContinuousLinearMap.mk ( opComm ( toeplitz M c_shift ) ( shift_cyclic M 1 ) ) ) x ) ⟩;
    exact ⟨ C, by rintro _ ⟨ x, hx, rfl ⟩ ; exact le_trans ( hC x ) ( mul_le_of_le_one_right ( by exact le_trans ( by norm_num ) ( show 0 ≤ C by exact le_of_not_gt fun hC' => by have := hC 1; norm_num at this; linarith [ norm_nonneg ( ( opComm ( toeplitz M c_shift ) ( shift_cyclic M 1 ) ) 1 ) ] ) ) hx ) ⟩;
  · norm_num [ Norm.norm ]

/-
Diagonal operator (multiplication by c).
-/
noncomputable def toeplitz_diag (M : ℕ) (c : ℤ → ℂ) : (H M) →ₗ[ℂ] (H M) :=
  { toFun := fun x j => c j * x j
    map_add' := by
      -- By the properties of multiplication and addition, we can rearrange the terms to show that the two functions are equal.
      intros x y
      funext j
      simp [mul_add, add_mul]
    map_smul' := by
      -- By the associativity of multiplication, we can rearrange the terms to show that the two functions are equal.
      intros m x
      funext j
      simp [mul_assoc, mul_comm, mul_left_comm] }

#synth Norm (H 10)

/-
Helper lemma: Explicit formula for the commutator of the diagonal Toeplitz operator and the cyclic shift.
-/
lemma toeplitz_diag_comm_entry (M : ℕ) (c : ℤ → ℂ) (k : ℤ) (x : H M) (j : Fin (2*M+1)) :
    (opComm (toeplitz_diag M c) (shift_cyclic M k) x) j = (c j - c (shift_index M k j)) * x (shift_index M k j) := by
  unfold opComm;
  unfold toeplitz_diag; aesop; ring;
  unfold shift_cyclic; aesop;

/-
Diagonal operator from a vector.
-/
noncomputable def diag_op (M : ℕ) (d : H M) : (H M) →ₗ[ℂ] (H M) :=
  { toFun := fun x j => d j * x j
    map_add' := by intro x y; ext j; simp [mul_add]
    map_smul' := by intro r x; ext j; simp [mul_assoc, mul_left_comm] }

/-
Corrected Theorem: Commutator bound for periodic symbol (multiplication operator).
-/
theorem toeplitz_diag_comm_bound_periodic
    (M : ℕ) (hM : 0 < M)
    (c : ℤ → ℂ) (ω : Modulus) (hω : ModulusNonNeg ω)
    (C : ℝ) (hC : 0 < C)
    (h_symbol : ∀ n : ℤ, ‖c n - c (n+1)‖ ≤ ω (Real.pi / (M+1)))
    (hω_subadd : ∀ a b, 0 ≤ a → 0 ≤ b → ω (a + b) ≤ ω a + ω b)
    (h_per : ∀ n : ℤ, c (n + (2*M+1)) = c n)
    (k : ℤ) :
    opNorm (opComm (toeplitz_diag M c) (shift_cyclic M k)) ≤ |k| * ω (Real.pi / (M+1)) := by
  simp +zetaDelta at *;
  -- By definition of the operator norm, we need to show that for any vector `x`, the norm of `opComm (toeplitz_diag M c) (shift_cyclic M k) x` is bounded by `|k| * ω (Real.pi / (M + 1))`.
  have h_op_norm : ∀ x : H M, ‖opComm (toeplitz_diag M c) (shift_cyclic M k) x‖ ≤ abs k * ω (Real.pi / (M + 1)) * ‖x‖ := by
    intro x
    have h_comm : ∀ j : Fin (2 * M + 1), ‖(opComm (toeplitz_diag M c) (shift_cyclic M k) x) j‖ ≤ abs k * ω (Real.pi / (M + 1)) * ‖x‖ := by
      intros j
      have h_comm_j : ‖c j - c (shift_index M k j)‖ ≤ abs k * ω (Real.pi / (M + 1)) := by
        have h_comm_j : ∀ n : ℤ, ‖c n - c (n + k)‖ ≤ abs k * ω (Real.pi / (M + 1)) := by
          intro n;
          induction' k using Int.induction_on with k ih k ih;
          · norm_num;
          · have := h_symbol ( n + k );
            have := norm_add_le ( c n - c ( n + k ) ) ( c ( n + k ) - c ( n + k + 1 ) ) ; simp_all +decide [ add_assoc ];
            rw [ abs_of_nonneg ( by positivity ) ] ; nlinarith [ hω ( Real.pi / ( M + 1 ) ) ];
          · have := h_symbol ( n + ( -k - 1 ) );
            norm_num [ abs_of_nonpos, add_assoc ] at *;
            have := norm_sub_le ( c n - c ( n + -↑k ) ) ( c ( n + ( -↑k - 1 ) ) - c ( n + -↑k ) ) ; ring_nf at *; linarith;
        convert h_comm_j ( j - k ) using 1;
        unfold shift_index; aesop;
        rw [ max_eq_left ];
        · rw [ ← norm_sub_rev ];
          -- By periodicity, we have $c(n) = c(n \mod (2M+1))$ for any integer $n$.
          have h_periodic : ∀ n : ℤ, c n = c (n % (2 * M + 1)) := by
            intro n; conv_lhs => rw [ ← Int.emod_add_ediv n ( 2 * M + 1 ) ];
            simpa [ mul_comm ] using Function.Periodic.int_mul h_per ( n / ( 2 * M + 1 ) ) ( n % ( 2 * M + 1 ) );
          exact h_periodic _ ▸ rfl;
        · exact Int.emod_nonneg _ ( by linarith );
      have h_comm_j : ‖(opComm (toeplitz_diag M c) (shift_cyclic M k) x) j‖ = ‖(c j - c (shift_index M k j)) * x (shift_index M k j)‖ := by
        rw [ toeplitz_diag_comm_entry ];
      aesop;
      exact mul_le_mul h_comm_j_1 ( norm_le_pi_norm x _ ) ( by positivity ) ( by exact mul_nonneg ( abs_nonneg _ ) ( hω _ ) );
    refine' pi_norm_le_iff_of_nonneg _ |>.2 h_comm;
    exact mul_nonneg ( mul_nonneg ( by positivity ) ( hω _ ) ) ( norm_nonneg _ );
  refine' csSup_le _ _ <;> aesop;
  · exact ⟨ _, ⟨ 0, by norm_num, rfl ⟩ ⟩;
  · exact le_trans ( h_op_norm w ) ( mul_le_of_le_one_right ( mul_nonneg ( abs_nonneg _ ) ( hω _ ) ) left )

/-
Lipschitz specialization: If ω(h) ≤ L·h, then the commutator norm is bounded by L·π·|k|/(M+1).
-/
theorem toeplitz_diag_comm_bound_lip
    (M : ℕ) (hM : 0 < M)
    (c : ℤ → ℂ) (ω : Modulus)
    (C L : ℝ) (hC : 0 < C) (hL : 0 ≤ L)
    (hLip : LipschitzModulus ω L)
    (h_symbol : ∀ n : ℤ, ‖c n - c (n+1)‖ ≤ ω (Real.pi / (M+1)))
    (hω_subadd : ∀ a b, 0 ≤ a → 0 ≤ b → ω (a + b) ≤ ω a + ω b)
    (h_per : ∀ n : ℤ, c (n + (2*M+1)) = c n)
    (k : ℤ) :
    opNorm (opComm (toeplitz_diag M c) (shift_cyclic M k)) ≤ L * Real.pi * |k| / (M+1) := by
  have := hLip ( Real.pi / ( M + 1 ) ) ( div_nonneg Real.pi_pos.le ( by positivity ) ) ; ring_nf at *; aesop;
  -- Apply the bound from the theorem to the commutator.
  have h_comm_bound : ∀ x : H M, ‖(opComm (toeplitz_diag M c) (shift_cyclic M k)) x‖ ≤ ‖x‖ * |k| * L * Real.pi * (1 + M : ℝ)⁻¹ := by
    -- Applying the triangle inequality and the Lipschitz condition, we get:
    have h_triangle : ∀ x : H M, ∀ j : Fin (2*M+1), ‖(opComm (toeplitz_diag M c) (shift_cyclic M k) x) j‖ ≤ ‖x‖ * |k| * L * Real.pi * (1 + M : ℝ)⁻¹ := by
      intros x j
      have h_triangle_step : ‖c j - c (shift_index M k j)‖ ≤ |k| * L * Real.pi * (1 + M : ℝ)⁻¹ := by
        have h_triangle_step : ∀ n : ℤ, ‖c n - c (n + k)‖ ≤ |k| * L * Real.pi * (1 + M : ℝ)⁻¹ := by
          -- By induction on $k$, we can show that the norm of the difference between $c(n)$ and $c(n+k)$ is bounded by $|k| \cdot L \cdot \pi \cdot (1 + M)^{-1}$.
          have h_induction : ∀ k : ℤ, ∀ n : ℤ, ‖c n - c (n + k)‖ ≤ |k| * L * Real.pi * (1 + M : ℝ)⁻¹ := by
            intro k n; induction' k using Int.induction_on with k ih k ih ; aesop;
            · have := h_symbol ( n + k ) ; simp_all +decide [ ← add_assoc ];
              rw [ abs_of_nonneg ( by positivity ) ];
              have := norm_add_le ( c n - c ( n + k ) ) ( c ( n + k ) - c ( 1 + n + k ) ) ; ring_nf at *; linarith;
            · field_simp;
              have := h_symbol ( n + ( -k - 1 ) ) ; ring_nf at *; aesop;
              rw [ abs_of_nonpos ] <;> try linarith;
              have := norm_sub_le ( c n - c ( n - k ) ) ( c ( -1 + ( n - k ) ) - c ( n - k ) ) ; ring_nf at *; nlinarith [ Real.pi_pos, mul_inv_cancel_left₀ ( by positivity : ( 1 + M : ℝ ) ≠ 0 ) ( L * Real.pi ) ] ;
          exact fun n => h_induction k n;
        convert h_triangle_step ( j - k ) using 1 ; norm_num [ shift_index ];
        -- By periodicity, we have $c (j - k) = c ((j - k) \mod (2M + 1))$.
        have h_periodic : c (j - k) = c ((j - k) % (2 * M + 1)) := by
          rw [ ← Int.emod_add_mul_ediv ( ( j : ℤ ) - k ) ( 2 * M + 1 ) ] ; induction' ( ( j : ℤ ) - k ) / ( 2 * M + 1 ) using Int.induction_on with n ihn n ihn <;> aesop;
          · have := h_per ( ( ( j : ℤ ) - k ) % ( 2 * M + 1 ) + ( 2 * M + 1 ) * n ) ; ring_nf at *; aesop;
          · have := h_per ( ( ( j : ℤ ) - k ) % ( 2 * M + 1 ) + ( 2 * M + 1 ) * ( -n - 1 ) ) ; ring_nf at *; aesop;
        erw [ max_eq_left ( Int.emod_nonneg _ ( by positivity ) ) ] ; aesop;
        rw [ norm_sub_rev ];
      -- Apply the triangle inequality and the Lipschitz condition to bound the norm of the commutator entry.
      have h_triangle_step : ‖(opComm (toeplitz_diag M c) (shift_cyclic M k) x) j‖ ≤ ‖x (shift_index M k j)‖ * |k| * L * Real.pi * (1 + M : ℝ)⁻¹ := by
        convert mul_le_mul_of_nonneg_left h_triangle_step ( norm_nonneg ( x ( shift_index M k j ) ) ) using 1 ; ring;
        · rw [ ← norm_mul ] ; rw [ toeplitz_diag_comm_entry ] ; ring;
        · ring;
      exact h_triangle_step.trans ( mul_le_mul_of_nonneg_right ( mul_le_mul_of_nonneg_right ( mul_le_mul_of_nonneg_right ( mul_le_mul_of_nonneg_right ( norm_le_pi_norm x _ ) ( by positivity ) ) ( by positivity ) ) ( by positivity ) ) ( by positivity ) );
    exact fun x => pi_norm_le_iff_of_nonneg ( by positivity ) |>.2 fun j => h_triangle x j;
  refine' csSup_le _ _ <;> aesop;
  · exact ⟨ _, ⟨ 0, by norm_num, rfl ⟩ ⟩;
  · exact le_trans ( h_comm_bound w ) ( by nlinarith [ show 0 ≤ L * Real.pi * |( k : ℝ )| * ( 1 + M : ℝ ) ⁻¹ by positivity ] )

/-
Application: For large M, the commutator is small (suppressing minor arcs).
-/
theorem toeplitz_comm_small_for_large_M
    (X : ℕ) (hX : 2 ≤ X)
    (c : ℤ → ℂ) (ω : Modulus)
    (C L : ℝ) (hC : 1 ≤ C) (hL : 0 < L)
    (hLip : LipschitzModulus ω L)
    (hω_subadd : ∀ a b, 0 ≤ a → 0 ≤ b → ω (a + b) ≤ ω a + ω b)
    (M : ℕ) (hM_pos : 0 < M)
    (h_symbol : ∀ n : ℤ, ‖c n - c (n+1)‖ ≤ ω (Real.pi / (M+1)))
    (h_per : ∀ n : ℤ, c (n + (2*M+1)) = c n)
    (hM : M ≥ 2 * C * L * Real.pi * Real.log X) :
    opNorm (opComm (toeplitz_diag M c) (shift_cyclic M 2)) ≤ 1 / Real.log X := by
      refine' le_trans ( toeplitz_diag_comm_bound_lip M hM_pos c ω C L ( by positivity ) hL.le hLip h_symbol hω_subadd h_per 2 ) _;
      norm_num +zetaDelta at *;
      field_simp;
      rw [ le_div_iff₀ ( Real.log_pos ( by norm_cast ) ) ] ; nlinarith [ Real.pi_gt_three, Real.log_pos ( by norm_cast : ( 1 :ℝ ) < X ) ]

/-
Application: For large M, the commutator is small (suppressing minor arcs).
-/
theorem toeplitz_comm_small_for_large_M_v2
    (X : ℕ) (hX : 2 ≤ X)
    (c : ℤ → ℂ) (ω : Modulus)
    (C L : ℝ) (hC : 1 ≤ C) (hL : 0 < L)
    (hLip : LipschitzModulus ω L)
    (hω_subadd : ∀ a b, 0 ≤ a → 0 ≤ b → ω (a + b) ≤ ω a + ω b)
    (M : ℕ) (hM_pos : 0 < M)
    (h_symbol : ∀ m : ℕ, 0 < m → ∀ n : ℤ, ‖c n - c (n+1)‖ ≤ ω (Real.pi / (m+1)))
    (h_per : ∀ n : ℤ, c (n + (2*M+1)) = c n)
    (hM : M ≥ 2 * C * L * Real.pi * Real.log X) :
    opNorm (opComm (toeplitz_diag M c) (shift_cyclic M 2)) ≤ 1 / Real.log X := by
      apply_rules [ toeplitz_comm_small_for_large_M ]

/-
Application: For large M, the commutator is small (suppressing minor arcs).
-/
theorem toeplitz_comm_small_for_large_M_v3
    (X : ℕ) (hX : 2 ≤ X)
    (c : ℤ → ℂ) (ω : Modulus)
    (C L : ℝ) (hC : 1 ≤ C) (hL : 0 < L)
    (hLip : LipschitzModulus ω L)
    (hω_subadd : ∀ a b, 0 ≤ a → 0 ≤ b → ω (a + b) ≤ ω a + ω b)
    (M : ℕ) (hM_pos : 0 < M)
    (h_symbol : ∀ n : ℤ, ‖c n - c (n+1)‖ ≤ ω (Real.pi / (M+1)))
    (h_per : ∀ n : ℤ, c (n + (2*M+1)) = c n)
    (hM : M ≥ 2 * C * L * Real.pi * Real.log X) :
    opNorm (opComm (toeplitz_diag M c) (shift_cyclic M 2)) ≤ 1 / Real.log X := by
      have := @toeplitz_comm_small_for_large_M;
      exact this X hX c ω C L hC hL hLip hω_subadd M hM_pos h_symbol h_per hM