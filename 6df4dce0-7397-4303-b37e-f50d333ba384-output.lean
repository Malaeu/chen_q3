/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 6df4dce0-7397-4303-b37e-f50d333ba384

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The magnitude of the sum of 5 complex exponentials with phase multiples of 2π * log(9) is strictly less than 5.
-/
lemma five_fold_cancellation :
  ‖∑ j ∈ Finset.range 5, Complex.exp (2 * Real.pi * Complex.I * j * Real.log 9)‖ < 5 := by
    norm_num [ Finset.sum_range_succ, Complex.norm_def, Complex.normSq ];
    norm_num [ Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im ] ; ring_nf;
    rw [ show Real.pi * Real.log 9 * 8 = 2 * ( Real.pi * Real.log 9 * 4 ) by ring, show Real.pi * Real.log 9 * 6 = 3 * ( Real.pi * Real.log 9 * 2 ) by ring, show Real.pi * Real.log 9 * 4 = 2 * ( Real.pi * Real.log 9 * 2 ) by ring, show Real.pi * Real.log 9 * 2 = 2 * ( Real.pi * Real.log 9 ) by ring ] ; norm_num [ Real.sin_two_mul, Real.sin_three_mul, Real.cos_two_mul, Real.cos_three_mul ] ; ring_nf;
    rw [ show Real.sin _ ^ 4 = ( Real.sin _ ^ 2 ) ^ 2 by ring, show Real.sin _ ^ 6 = ( Real.sin _ ^ 2 ) ^ 3 by ring, Real.sin_sq ] ; ring_nf;
    rw [ Real.sqrt_lt' ] <;> norm_num;
    -- Let's simplify the expression. Since we know that $\cos(\pi \log 9)$ is not equal to $\pm 1$, we can use the fact that $\cos^2(\pi \log 9) < 1$.
    have h_cos_sq_lt_1 : Real.cos (Real.pi * Real.log 9) ^ 2 < 1 := by
      rw [ Real.cos_sq' ] ; norm_num;
      refine' sq_pos_of_ne_zero _;
      norm_num [ Real.sin_eq_zero_iff ];
      intro x hx; rw [ mul_comm ] at hx; norm_num [ Real.pi_ne_zero ] at hx;
      rw [ show ( 9 : ℝ ) = 3 ^ 2 by norm_num, Real.log_pow ] at hx ; norm_num at hx;
      rcases x with ⟨ _ | _ | _ | _ | _ | _ | x ⟩ <;> norm_num at * <;> try nlinarith [ Real.log_pos ( by norm_num : ( 3 : ℝ ) > 1 ), Real.log_lt_sub_one_of_pos ( by norm_num : ( 0 : ℝ ) < 3 ) ( by norm_num ) ];
      · linarith [ show 1 < Real.log 3 by rw [ Real.lt_log_iff_exp_lt ( by norm_num ) ] ; exact Real.exp_one_lt_d9.trans_le ( by norm_num ) ];
      · apply_fun Real.exp at hx ; norm_num [ Real.exp_log ] at hx;
        exact absurd ( hx.symm ▸ Real.exp_one_lt_d9 ) ( by norm_num );
      · have := Real.log_two_lt_d9 ; norm_num at * ; rw [ show ( 3 : ℝ ) = 2 * 1.5 by norm_num, Real.log_mul ] at hx <;> norm_num at *;
        linarith [ Real.log_le_sub_one_of_pos ( show 0 < 3 / 2 by norm_num ) ];
    nlinarith [ pow_nonneg ( sq_nonneg ( Real.cos ( Real.pi * Real.log 9 ) ) ) 2, pow_nonneg ( sq_nonneg ( Real.cos ( Real.pi * Real.log 9 ) ) ) 3, pow_nonneg ( sq_nonneg ( Real.cos ( Real.pi * Real.log 9 ) ) ) 4, pow_nonneg ( sq_nonneg ( Real.cos ( Real.pi * Real.log 9 ) ) ) 5, pow_nonneg ( sq_nonneg ( Real.cos ( Real.pi * Real.log 9 ) ) ) 6 ]

/-
For any real θ that is not an integer, the geometric sum has magnitude < k
-/
/-- For any real θ that is not an integer, the geometric sum has magnitude < k -/
lemma k_fold_cancellation_general (k : ℕ) (hk : k ≥ 2) (θ : ℝ) (hθ : ∀ m : ℤ, θ ≠ m) :
  ‖∑ j ∈ Finset.range k, Complex.exp (2 * Real.pi * Complex.I * j * θ)‖ < k := by
  by_contra h_contra;
  -- The magnitude of the sum is strictly less than k because the terms are all of unit magnitude and not aligned.
  have h_mag : ‖∑ j ∈ Finset.range k, Complex.exp (2 * Real.pi * Complex.I * j * θ)‖ ^ 2 < k ^ 2 := by
    -- The magnitude squared of the sum is given by the sum of the squares of the magnitudes plus twice the sum of the products of the magnitudes.
    have h_mag_sq : ‖∑ j ∈ Finset.range k, Complex.exp (2 * Real.pi * Complex.I * j * θ)‖ ^ 2 = ∑ j ∈ Finset.range k, ∑ l ∈ Finset.range k, Complex.re (Complex.exp (2 * Real.pi * Complex.I * (j - l) * θ)) := by
      norm_num [ Complex.normSq, Complex.sq_norm, Complex.exp_re, Complex.exp_im ];
      norm_num [ sub_mul, mul_sub, Real.cos_sub, Real.sin_sub ];
      simp +decide only [mul_comm, Finset.sum_add_distrib, ← Finset.mul_sum _ _ _, ← Finset.sum_mul];
    -- Since $\cos(2\pi(j-l)\theta) \leq 1$ for all $j, l$, and $\cos(2\pi(j-l)\theta) < 1$ for some $j, l$, the sum is strictly less than $k^2$.
    have h_cos_lt_one : ∃ j l : ℕ, j ∈ Finset.range k ∧ l ∈ Finset.range k ∧ j ≠ l ∧ Real.cos (2 * Real.pi * (j - l) * θ) < 1 := by
      refine' ⟨ 0, 1, _, _, _, _ ⟩ <;> norm_num <;> try linarith;
      refine' lt_of_le_of_ne ( Real.cos_le_one _ ) fun h => _;
      rw [ Real.cos_eq_one_iff ] at h; obtain ⟨ m, hm ⟩ := h; exact hθ ( m : ℤ ) ( by nlinarith [ Real.pi_pos ] ) ;
    obtain ⟨ j, l, hj, hl, hne, hlt ⟩ := h_cos_lt_one; simp_all +decide [ Complex.exp_re ];
    have h_sum_lt_k2 : ∑ x ∈ Finset.range k, ∑ x_1 ∈ Finset.range k, Real.cos (2 * Real.pi * (x - x_1) * θ) < ∑ x ∈ Finset.range k, ∑ x_1 ∈ Finset.range k, 1 := by
      apply Finset.sum_lt_sum;
      · exact fun i hi => Finset.sum_le_sum fun j hj => Real.cos_le_one _;
      · exact ⟨ j, Finset.mem_range.mpr hj, Finset.sum_lt_sum ( fun i _ => Real.cos_le_one _ ) ⟨ l, Finset.mem_range.mpr hl, hlt ⟩ ⟩;
    simpa [ sq ] using h_sum_lt_k2;
  exact h_contra <| by nlinarith [ show 0 ≤ ‖∑ j ∈ Finset.range k, Complex.exp ( 2 * Real.pi * Complex.I * j * θ )‖ by positivity ] ;

/-
The magnitude of the sum of 6 complex exponentials with phase multiples of 2π * log(6) is strictly less than 6.
-/
lemma six_fold_cancellation_6 :
  ‖∑ j ∈ Finset.range 6, Complex.exp (2 * Real.pi * Complex.I * j * Real.log 6)‖ < 6 := by
    -- We use the fact that $\log(6)$ is not an integer.
    have h_log_6_not_int : ¬∃ m : ℤ, Real.log 6 = m := by
      -- Show that $\log(6)$ is not an integer by noting that $1 < \log(6) < 2$.
      have h_log_6_bounds : 1 < Real.log 6 ∧ Real.log 6 < 2 := by
        rw [ Real.lt_log_iff_exp_lt, Real.log_lt_iff_lt_exp ] <;> norm_num;
        exact ⟨ Real.exp_one_lt_d9.trans_le <| by norm_num, by have := Real.exp_one_gt_d9; norm_num1 at *; rw [ show ( 2 : ℝ ) = 1 + 1 by norm_num, Real.exp_add ] ; nlinarith [ Real.add_one_le_exp 1 ] ⟩;
      exact fun ⟨ m, hm ⟩ => by rcases m with ⟨ _ | _ | m ⟩ <;> norm_num at hm <;> linarith;
    exact k_fold_cancellation_general 6 ( by norm_num ) ( Real.log 6 ) ( by aesop )

/-
The magnitude of the sum of 4 complex exponentials with phase multiples of 2π * log(16) is strictly less than 4.
-/
lemma four_fold_cancellation_16 :
  ‖∑ j ∈ Finset.range 4, Complex.exp (2 * Real.pi * Complex.I * j * Real.log 16)‖ < 4 := by
    convert k_fold_cancellation_general 4 ( by decide ) ( Real.log 16 ) _ using 1;
    rw [ show ( 16 : ℝ ) = 2 ^ 4 by norm_num, Real.log_pow ] ; norm_num;
    intro m hm; have := Real.log_two_lt_d9; norm_num at *;
    rcases m with ⟨ _ | _ | _ | _ | _ | _ | m ⟩ <;> norm_num at hm <;> linarith [ Real.log_two_gt_d9 ]

/-
The magnitude of the sum of 3 complex exponentials with phase multiples of 2π * log(27) is strictly less than 3.
-/
lemma three_fold_cancellation_27 :
  ‖∑ j ∈ Finset.range 3, Complex.exp (2 * Real.pi * Complex.I * j * Real.log 27)‖ < 3 := by
    convert k_fold_cancellation_general 3 _ _ _ using 2 <;> norm_num;
    intro m hm; rw [ show ( 27 : ℝ ) = 3 ^ 3 by norm_num, Real.log_pow ] at hm; norm_num at hm;
    -- We'll use that $3 \log 3$ is approximately $3.2958$, which is not an integer.
    have h_approx : 3 < 3 * Real.log 3 ∧ 3 * Real.log 3 < 4 := by
      rw [ ← Real.log_rpow, Real.lt_log_iff_exp_lt, Real.log_lt_iff_lt_exp ] <;> norm_num;
      exact ⟨ by have := Real.exp_one_lt_d9.le; norm_num1 at *; rw [ show ( 3 : ℝ ) = 1 + 1 + 1 by norm_num, Real.exp_add, Real.exp_add ] ; nlinarith [ Real.add_one_le_exp 1 ], by have := Real.exp_one_gt_d9.le; norm_num1 at *; rw [ show ( 4 : ℝ ) = 1 + 1 + 1 + 1 by norm_num, Real.exp_add, Real.exp_add, Real.exp_add ] ; nlinarith [ Real.add_one_le_exp 1, pow_pos ( Real.exp_pos 1 ) 2, pow_pos ( Real.exp_pos 1 ) 3 ] ⟩;
    rcases m with ⟨ _ | _ | _ | _ | m ⟩ <;> norm_num at hm <;> linarith

/-
Quantitative cancellation bound using geometric series and sine lower bound.
-/
/-- Quantitative cancellation bound -/
lemma k_fold_cancellation_quantitative (k : ℕ) (hk : k ≥ 2) (θ : ℝ) (ε : ℝ)
    (hθ : ∀ m : ℤ, |θ - m| ≥ ε) (hε : ε > 0) :
  ‖∑ j ∈ Finset.range k, Complex.exp (2 * Real.pi * Complex.I * j * θ)‖
    ≤ 1 / Real.sin (Real.pi * ε) := by
  -- Use the geometric sum formula:
  have h_geo_sum_formula : ‖∑ j ∈ Finset.range k, Complex.exp (2 * Real.pi * Complex.I * j * θ)‖ ≤ 1 / |Real.sin (Real.pi * θ)| := by
    -- Use the formula for the sum of a geometric series.
    have h_geo_series : ∑ j ∈ Finset.range k, Complex.exp (2 * Real.pi * Complex.I * j * θ) = (1 - Complex.exp (2 * Real.pi * Complex.I * k * θ)) / (1 - Complex.exp (2 * Real.pi * Complex.I * θ)) := by
      rw [ eq_div_iff ];
      · exact Nat.recOn k ( by norm_num ) fun n ih => by norm_num [ Finset.sum_range_succ, Complex.exp_add, mul_add, add_mul ] at * ; linear_combination ih;
      · norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im ];
        contrapose! hθ;
        rw [ sub_eq_zero, eq_comm ] at hθ; ( ( erw [ Real.cos_eq_one_iff ] at hθ; obtain ⟨ m, hm ⟩ := hθ.1; use m; exact abs_lt.2 ⟨ by nlinarith [ Real.pi_pos ], by nlinarith [ Real.pi_pos ] ⟩ ; ) );
    -- Use the fact that $|1 - e^{2\pi i k \theta}| \leq 2$ and $|1 - e^{2\pi i \theta}| = 2 |\sin(\pi \theta)|$.
    have h_norms : ‖1 - Complex.exp (2 * Real.pi * Complex.I * k * θ)‖ ≤ 2 ∧ ‖1 - Complex.exp (2 * Real.pi * Complex.I * θ)‖ = 2 * |Real.sin (Real.pi * θ)| := by
      norm_num [ Complex.norm_def, Complex.normSq, Complex.exp_re, Complex.exp_im ];
      norm_num [ Real.sqrt_le_iff, ← sq ];
      exact ⟨ by nlinarith only [ Real.cos_sq' ( 2 * Real.pi * k * θ ) ], by rw [ Real.sqrt_eq_iff_mul_self_eq ] <;> norm_num <;> cases abs_cases ( Real.sin ( Real.pi * θ ) ) <;> nlinarith [ Real.sin_sq ( 2 * Real.pi * θ ), Real.sin_sq ( Real.pi * θ ), Real.cos_sq ( 2 * Real.pi * θ ), Real.cos_sq ( Real.pi * θ ), show Real.cos ( 2 * Real.pi * θ ) = 1 - 2 * Real.sin ( Real.pi * θ ) ^ 2 by rw [ Real.sin_sq, Real.cos_sq ] ; ring ] ⟩;
    by_cases h : Real.sin ( Real.pi * θ ) = 0 <;> simp_all +decide [ div_eq_mul_inv ];
    nlinarith [ inv_pos.mpr ( abs_pos.mpr h ), mul_inv_cancel₀ ( ne_of_gt ( abs_pos.mpr h ) ) ];
  -- We are given |θ - m| ≥ ε for all integers m, which implies the distance from θ to the nearest integer is ≥ ε.
  have h_dist : ∃ m : ℤ, |θ - m| ≤ 1 / 2 ∧ 0 ≤ Real.sin (Real.pi * |θ - m|) ∧ Real.sin (Real.pi * |θ - m|) ≥ Real.sin (Real.pi * ε) := by
    -- Since ε is the minimum distance from θ to any integer, there must exist an integer m such that |θ - m| ≤ 1 / 2.
    obtain ⟨m, hm⟩ : ∃ m : ℤ, |θ - m| ≤ 1 / 2 := by
      exact ⟨ ⌊θ + 1 / 2⌋, abs_le.mpr ⟨ by linarith [ Int.floor_le ( θ + 1 / 2 ) ], by linarith [ Int.lt_floor_add_one ( θ + 1 / 2 ) ] ⟩ ⟩;
    exact ⟨ m, hm, Real.sin_nonneg_of_nonneg_of_le_pi ( by positivity ) ( by nlinarith [ Real.pi_pos, abs_nonneg ( θ - m ) ] ), by rw [ ← Real.cos_pi_div_two_sub ] ; rw [ ← Real.cos_pi_div_two_sub ] ; exact Real.cos_le_cos_of_nonneg_of_le_pi ( by nlinarith [ Real.pi_pos, abs_nonneg ( θ - m ) ] ) ( by nlinarith [ Real.pi_pos, abs_nonneg ( θ - m ) ] ) ( by nlinarith [ Real.pi_pos, abs_nonneg ( θ - m ), hθ m ] ) ⟩;
  -- Since $| \sin(\pi \theta) | = \sin(\pi \cdot \text{dist}(\theta, \mathbb{Z}))$, we can conclude.
  obtain ⟨m, hm⟩ := h_dist
  have h_sin_eq : |Real.sin (Real.pi * θ)| = Real.sin (Real.pi * |θ - m|) := by
    -- Since $|θ - m| ≤ 1 / 2$, we have $|sin(πθ)| = sin(π|θ - m|)$.
    have h_sin_eq : Real.sin (Real.pi * θ) = Real.sin (Real.pi * |θ - m|) ∨ Real.sin (Real.pi * θ) = -Real.sin (Real.pi * |θ - m|) := by
      cases abs_cases ( θ - m ) <;> simp +decide [ *, mul_sub, mul_add ];
      · norm_num [ mul_comm Real.pi, Real.sin_sub ];
        have := Real.cos_sq' ( m * Real.pi ) ; aesop;
      · norm_num [ mul_comm Real.pi, Real.sin_sub ];
        have := Real.cos_sq' ( m * Real.pi ) ; aesop;
    cases h_sin_eq <;> simp +decide [ * ];
  simp +zetaDelta at *;
  exact h_geo_sum_formula.trans ( inv_anti₀ ( Real.sin_pos_of_pos_of_lt_pi ( by positivity ) ( by nlinarith [ Real.pi_pos, show ε < 1 by have := hθ m; norm_num at *; linarith ] ) ) ( by linarith ) )

/-
The natural logarithm of an integer n > 1 is not a non-positive integer.
-/
lemma log_nat_ne_int_nonpos (n : ℕ) (hn : n > 1) (m : ℤ) (hm : m ≤ 0) : Real.log n ≠ m := by
  intro h
  have h_pos : Real.log n > 0 := Real.log_pos (Nat.one_lt_cast.mpr hn)
  have h_le : (m : ℝ) ≤ 0 := Int.cast_nonpos.mpr hm
  linarith