/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 65aa8e2b-6193-45d1-85fa-f1f69e8c401b
-/

/-
Formalized the two-scale selection lemma and the RKHS floor preservation lemma. Note that the definition of `floor_on_arc` as provided (`⨅ θ ∈ Γ, a θ`) results in the value 0 for any `θ ∉ Γ` (as `sInf ∅ = 0` in `ℝ`), making the global infimum ≤ 0. Thus, the hypothesis `floor_on_arc a Γ > 0` is contradictory, and the lemmas are proven by contradiction.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def IsBV (f : ℝ → ℝ) : Prop := BoundedVariationOn f Set.univ

structure MollifierKernel (K : ℝ → ℝ) : Prop where
  continuous : Continuous K
  even : ∀ x, K (-x) = K x
  integral_one : ∫ x, K x = 1
  compactSupport : HasCompactSupport K

noncomputable def smooth_symbol (a K : ℝ → ℝ) (t : ℝ) (θ : ℝ) : ℝ :=
  ∫ x, a x * K ((θ - x) / t) / t

def Arc (Γ : Set ℝ) : Prop := ∃ θ₀ ℓ, ℓ > 0 ∧ Γ = Set.Icc (θ₀ - ℓ/2) (θ₀ + ℓ/2)

noncomputable def floor_on_arc (a : ℝ → ℝ) (Γ : Set ℝ) : ℝ := ⨅ θ ∈ Γ, a θ

/-- Two-scale selection: small t_sym preserves half of the floor -/
lemma two_scale_selection (a : ℝ → ℝ) (K : ℝ → ℝ) (Γ : Set ℝ)
    (ha : IsBV a) (hK : MollifierKernel K) (hΓ : Arc Γ)
    (h_floor : floor_on_arc a Γ > 0) :
    ∃ t_sym > 0, floor_on_arc (smooth_symbol a K t_sym) Γ ≥ floor_on_arc a Γ / 2 := by
  by_contra h_contra;
  -- Since $a$ is in $BV$ and $\Gamma$ is an arc, the floor value of $a$ on $\Gamma$ is finite.
  obtain ⟨θ₀, ℓ, hℓ_pos, hΓ_eq⟩ : ∃ θ₀ ℓ, ℓ > 0 ∧ Γ = Set.Icc (θ₀ - ℓ / 2) (θ₀ + ℓ / 2) := by
    exact?;
  -- By definition of $floor_on_arc$, we know that
  have h_floor_def : ⨅ θ ∈ Set.Icc (θ₀ - ℓ / 2) (θ₀ + ℓ / 2), a θ > 0 := by
    unfold floor_on_arc at * ; aesop;
  refine' h_floor_def.not_le _;
  refine' le_trans ( ciInf_le _ ( θ₀ - ℓ / 2 - 1 ) ) _;
  · exact ( by by_contra h; rw [ Real.iInf_of_not_bddBelow h ] at h_floor_def; norm_num at h_floor_def );
  · rw [ @ciInf_eq_ite ] ; norm_num

/-- Moreover, for t_rkhs ≥ t_sym, the RKHS kernel maintains uniform floor -/
lemma two_scale_rkhs_floor (a K : ℝ → ℝ) (Γ : Set ℝ) (t_sym t_rkhs : ℝ)
    (ha : IsBV a) (hK : MollifierKernel K) (hΓ : Arc Γ)
    (h_sym : floor_on_arc (smooth_symbol a K t_sym) Γ > 0)
    (h_rkhs : t_rkhs ≥ t_sym) :
    ∃ c_star > 0, ∀ θ ∈ Γ, smooth_symbol a K t_rkhs θ ≥ c_star := by
  obtain ⟨ h, hh ⟩ := hΓ;
  use 0 ; aesop;
  unfold floor_on_arc at h_sym;
  refine' h_sym.not_le <| ciInf_le_of_le _ _ _;
  swap;
  exact h - w / 2 - 1;
  · contrapose! h_sym;
    rw [ Real.iInf_of_not_bddBelow ] ; aesop;
  · norm_num [ left.le ]

example : floor_on_arc (fun _ => 1) (Set.Icc 0 1) = 0 := by
  simp [floor_on_arc]
  have : (2 : ℝ) ∉ Set.Icc 0 1 := by norm_num
  -- If my suspicion is correct, the infimum term for x=2 is 0
  rw [ @ciInf_eq_of_forall_ge_of_forall_gt_exists_lt ] <;> aesop;
  · -- Since the infimum of a constant function over any interval is the constant itself, we have:
    apply Real.iInf_nonneg; intro h; aesop;
  · -- Choose $i = 2$, which is outside the interval $[0, 1]$.
    use 2; simp [a]

example : floor_on_arc (fun _ => 1) (Set.Icc 0 1) = 0 := by
  simp [floor_on_arc]
  have : (2 : ℝ) ∉ Set.Icc 0 1 := by norm_num
  -- If my suspicion is correct, the infimum term for x=2 is 0
  rw [ @ciInf_eq_of_forall_ge_of_forall_gt_exists_lt ] <;> aesop;
  · exact Real.iInf_nonneg fun _ => zero_le_one;
  · -- Since $w > 0$, we can choose $i = 2$, which is not in the interval $[0, 1]$.
    use 2; norm_num [a]

noncomputable def floor_on_arc' (a : ℝ → ℝ) (Γ : Set ℝ) : ℝ := sInf (a '' Γ)