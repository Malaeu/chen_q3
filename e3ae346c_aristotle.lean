/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e3ae346c-ed26-47c4-b4b0-df229881b1a3

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

-- Fixed parameters
def B_min : ℝ := 3
def t_sym : ℝ := 3 / 50  -- = 0.06

-- Uniform floor constant
def c_star : ℝ := 1.5

open Real Complex MeasureTheory Set
open scoped BigOperators

-- Digamma function
def digamma (z : ℂ) : ℂ := (deriv Complex.Gamma z) / (Complex.Gamma z)

def a (ξ : ℝ) : ℝ := Real.log Real.pi - (digamma (1/4 + Complex.I * Real.pi * ξ)).re

def w (B t ξ : ℝ) : ℝ :=
  max 0 (1 - |ξ| / B) * Real.exp (-4 * Real.pi^2 * t * ξ^2)

def g (B t ξ : ℝ) : ℝ := a ξ * w B t ξ

def P_A (B t θ : ℝ) : ℝ :=
  2 * Real.pi * ∑' (m : ℤ), g B t (θ + m)

def trigamma (z : ℂ) : ℂ := ∑' n : ℕ, 1 / (z + n)^2

/-
If Re(z) > 0 and Im(z) > 0, then Im(trigamma(z)) < 0.
-/
lemma im_trigamma_neg {z : ℂ} (hz : 0 < z.re) (hzi : 0 < z.im) : (trigamma z).im < 0 := by
  -- Applying the formula for the imaginary part of a sum, we get:
  have h_im_sum : (trigamma z).im = ∑' n : ℕ, -2 * z.im * (z.re + n) / ((z.re + n)^2 + z.im^2)^2 := by
    rw [ ← tsum_congr fun n : ℕ => ?_ ];
    convert Complex.im_tsum _;
    · exact?;
    · have h_summable : Summable (fun n : ℕ => (1 / (n + z.re)^2 : ℝ)) := by
        have h_summable : Summable (fun n : ℕ => (1 / (n : ℝ)^2 : ℝ)) := by
          exact Real.summable_one_div_nat_pow.2 one_lt_two;
        rw [ ← summable_nat_add_iff ⌈z.re⌉₊ ] at *;
        exact Summable.of_nonneg_of_le ( fun n => by positivity ) ( fun n => by gcongr ; linarith [ Nat.le_ceil z.re ] ) h_summable;
      rw [ ← summable_norm_iff ] at *;
      refine' .of_nonneg_of_le ( fun n => norm_nonneg _ ) ( fun n => _ ) h_summable;
      norm_num [ Complex.normSq, Complex.norm_def ];
      exact inv_anti₀ ( by positivity ) ( by rw [ Real.sq_sqrt ( by positivity ) ] ; nlinarith );
    · norm_num [ sq, Complex.normSq, Complex.div_im ];
      ring;
      rw [ inv_pow ] ; ring;
  rw [ h_im_sum ];
  norm_num [ div_eq_mul_inv, tsum_neg ];
  refine' Summable.tsum_pos ..;
  -- We'll use the fact that if the denominator grows faster than the numerator, the series converges.
  have h_summable : Summable (fun n : ℕ => (z.re + n) / ((z.re + n)^2 + z.im^2)^2) := by
    -- We can bound the terms of the series by comparing them to a convergent p-series.
    have h_bound : ∀ n : ℕ, (z.re + n) / ((z.re + n)^2 + z.im^2)^2 ≤ 1 / (z.re + n)^3 := by
      field_simp;
      exact fun n => by nlinarith only [ show 0 ≤ z.re * n by positivity, show 0 ≤ z.re ^ 2 by positivity, show 0 ≤ z.im ^ 2 by positivity ] ;
    refine Summable.of_nonneg_of_le ( fun n => div_nonneg ( by positivity ) ( by positivity ) ) ( fun n => h_bound n ) ?_;
    have h_pseries : Summable (fun n : ℕ => (1 : ℝ) / (n : ℝ)^3) := by
      exact Real.summable_one_div_nat_pow.2 ( by norm_num );
    rw [ ← summable_nat_add_iff ⌈z.re⁻¹⌉₊ ];
    exact Summable.of_nonneg_of_le ( fun n => by positivity ) ( fun n => by simpa using inv_anti₀ ( by positivity ) ( pow_le_pow_left₀ ( by positivity ) ( show ( z.re + ( n + ⌈z.re⁻¹⌉₊ ) : ℝ ) ≥ n + ⌈z.re⁻¹⌉₊ by linarith ) 3 ) ) ( h_pseries.comp_injective ( add_left_injective _ ) );
  exacts [ by convert h_summable.mul_left ( 2 * z.im ) using 2; ring, fun n => by positivity, 0, by positivity ]

/-
If f has derivative f' at A + iBx, then the derivative of Re(f(A + iBt)) at x is -B * Im(f'(A + iBx)).
-/
lemma deriv_re_comp_linear_imag (f : ℂ → ℂ) (f' : ℂ → ℂ) (A B : ℝ) (x : ℝ)
    (hf : HasDerivAt f (f' (A + Complex.I * B * x)) (A + Complex.I * B * x)) :
    deriv (fun t : ℝ => (f (A + Complex.I * B * t)).re) x = -B * (f' (A + Complex.I * B * x)).im := by
      refine' HasDerivAt.deriv _;
      have h_chain : HasDerivAt (fun t : ℝ => f (A + Complex.I * B * t)) (f' (A + Complex.I * B * x) * (Complex.I * B)) x := by
        convert HasDerivAt.comp x ( hf ) ( HasDerivAt.add ( hasDerivAt_const _ _ ) ( HasDerivAt.mul ( hasDerivAt_const _ _ ) ( hasDerivAt_id _ |> HasDerivAt.ofReal_comp ) ) ) using 1 ; norm_num;
      rw [ hasDerivAt_iff_tendsto_slope_zero ] at *;
      convert Complex.continuous_re.continuousAt.tendsto.comp h_chain using 2 ; norm_num ; ring;
      norm_num [ Complex.ext_iff ]